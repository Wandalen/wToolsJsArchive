
/* */  /* begin of library Main_s */ ( function _library_() {

/* */  /* begin of predefined */ ( function _predefined_() {



  'use strict';

  /* */

  let _global = get();
  if( !_global._globals_ )
  {
    _global._globals_ = Object.create( null );
    _global._globals_.real = _global._realGlobal_ || _global;
    _global._realGlobal_ = _global;
    _global._global_ = _global;
  }

  /* */

  function get()
  {
    let _global = undefined;
    if( typeof _global_ !== 'undefined' && _global_._global_ === _global_ )
    _global = _global_;
    else if( typeof globalThis !== 'undefined' && globalThis.globalThis === globalThis )
    _global = globalThis;
    else if( typeof Global !== 'undefined' && Global.Global === Global )
    _global = Global;
    else if( typeof global !== 'undefined' && global.global === global )
    _global = global;
    else if( typeof window !== 'undefined' && window.window === window )
    _global = window;
    else if( typeof self !== 'undefined' && self.self === self )
    _global = self;
    return _global;
  }

  /* */

  if( !_global_.Config )
  _global_.Config = Object.create( null );
  if( _global_.Config.interpreter === undefined )
  _global_.Config.interpreter = ( ( typeof module !== 'undefined' ) && ( typeof process !== 'undefined' ) ) ? 'njs' : 'browser';
  if( _global_.Config.isWorker === undefined )
  _global_.Config.isWorker = !!( typeof self !== 'undefined' && self.self === self && typeof importScripts !== 'undefined' );

  /* */

  if( _global._starter_ && _global._starter_._inited )
  return;

  let _starter_ = _global._starter_ = _global._starter_ || Object.create( null );
  let _ = _starter_;
  const Self = _starter_;

  _realGlobal_.HashMap = Map;
  _realGlobal_.HashMapWeak = WeakMap;

  // special tokens

  Self.def = Symbol.for( 'def' );
  Self.null = Symbol.for( 'null' );
  Self.undefined = Symbol.for( 'undefined' );
  Self.nothing = Symbol.for( 'nothing' );
  Self.anything = Symbol.for( 'anything' );
  Self.maybe = Symbol.for( 'maybe' );
  Self.unknown = Symbol.for( 'unknown' );
  Self.dont = Symbol.for( 'dont' );
  Self.self = Symbol.for( 'self' );
  Self.optional = Symbol.for( 'optional' );

  _realGlobal_.unrollSymbol = Symbol.for( 'unroll' );

;

/* */  _global_._starter_.debug = 1;
/* */  _global_._starter_.interpreter = 'njs';
/* */  _global_._starter_.proceduring = 0;
/* */  _global_._starter_.globing = 1;
/* */  _global_._starter_.catchingUncaughtErrors = 1;
/* */  _global_._starter_.loggingApplication = 0;
/* */  _global_._starter_.loggingSourceFiles = 0;
/* */  _global_._starter_.withServer = 0;
/* */  _global_._starter_.redirectingConsole = 1;
/* */  _global_._starter_.loggingPath = 'ws://127.0.0.1:15000/.log/';

/* */  _global_.Config.debug = 1;



;

/* */  /* end of predefined */ })();


/* */  /* begin of early */ ( function _early_() {



  'use strict';

  const _global = _global_;
  let _starter_ = _global._starter_ = _global._starter_ || Object.create( null );
  let _ = _starter_;

  let str = _starter_.str = _starter_.str || Object.create( null );
  let date = _starter_.date = _starter_.date || Object.create( null );
  let entity = _starter_.entity = _starter_.entity || Object.create( null );
  let _class = _starter_.class = _starter_.class || Object.create( null );
  let path = _starter_.path = _starter_.path || Object.create( null );
  let uri = _starter_.uri = _starter_.uri || Object.create( null );
  let property = _starter_.props = _starter_.props || Object.create( null );
  _starter_.uri.path = _starter_.path;
  let introspector = _starter_.introspector = _starter_.introspector || Object.create( null );
  let error = _starter_.error = _starter_.error || Object.create( null );
  let setup = _starter_.setup = _starter_.setup || Object.create( null );
  let event = _starter_.event = _starter_.event || Object.create( null );
  let sourcesMap = _starter_.sourcesMap = _starter_.sourcesMap || Object.create( null );
  let requireCache = _starter_.requireCache = _starter_.requireCache || Object.create( null );
  let moduleMainFilesMap = _starter_.moduleMainFilesMap = _starter_.moduleMainFilesMap || Object.create( null );
  let color = _starter_.color = _starter_.color || Object.create( null );
  let colorRgba = _starter_.color.rgba = _starter_.color.rgba || Object.create( null );
  let Logger = _starter_.Logger = _starter_.Logger || Object.create( null );

  let long = _starter_.long = _starter_.long || Object.create( null );
  let argumentsArray = _starter_.argumentsArray = _starter_.argumentsArray || Object.create( null );
  let array = _starter_.array = _starter_.array || Object.create( null );
  let unroll = _starter_.unroll = _starter_.unroll || Object.create( null );
  let buffer = _starter_.buffer = _starter_.buffer || Object.create( null );
  let bufferRaw = _starter_.bufferRaw = _starter_.bufferRaw || Object.create( null );
  let bufferTyped = _starter_.bufferTyped = _starter_.bufferTyped || Object.create( null );
  let bufferNode = _starter_.bufferNode = _starter_.bufferNode || Object.create( null );
  let vector = _starter_.vector = _starter_.vector || Object.create( null );

  let primitive = _starter_.primitive = _starter_.primitive || Object.create( null );
  let number = _starter_.number = _starter_.number || Object.create( null );
  let symbol = _starter_.symbol = _starter_.symbol || Object.create( null );
  let bool = _starter_.bool = _starter_.bool || Object.create( null );

  let countable = _starter_.countable = _starter_.countable || Object.create( null );
  let constructible = _starter_.constructible = _starter_.constructible || Object.create( null );
  let aux = _starter_.aux = _starter_.aux || Object.create( null );
  let object = _starter_.object = _starter_.object || Object.create( null );
  let map = _starter_.map = _starter_.map || Object.create( null );
  let hashMap = _starter_.hashMap = _starter_.hashMap || Object.create( null );
  let props = _starter_.props = _starter_.props || Object.create( null );
  let set = _starter_.set = _starter_.set || Object.create( null );

  let routine = _starter_.routine = _starter_.routine || Object.create( null );
  let routines = _starter_.routine.s = _starter_.routine.s || Object.create( null );
  let regexp = _starter_.regexp = _starter_.regexp || Object.create( null );

  let container = _starter_.container = _starter_.container || Object.create( null );

  //

  function assert( good )
  {
    if( !good )
    {
      throw new Error( 'Something wrong!' );
      return false;
    }
    return true;
  }

  //

  function assertRoutineOptions()
  {
    return arguments[ 0 ];
  }

  //

  function assertMapHasOnly()
  {
  }

  //

  function assertMapHasNoUndefine()
  {
  }

  //

  function dir( filePath )
  {
    let canonized = this.canonize( filePath );
    let splits = canonized.split( '/' );
    if( splits[ splits.length-1 ] )
    splits.pop();
    return splits.join( '/' );
  }

  //

  function nativize()
  {
    if( _global.process && _global.process.platform === 'win32' )
    this.nativize = this._nativizeWindows;
    else
    this.nativize = this._nativizePosix;
    return this.nativize.apply( this, arguments );
  }

  //

  function toStr( src )
  {
    try
    {
      return String( src );
    }
    catch( err )
    {
      return '{- UNKNOWN DATA TYPE -}';
    }
  }

  //

  function mapFields( src )
  {
    let result = Object.create( null );
    if( !src )
    return result;
    for( let s in src )
    result[ s ] = src[ s ];
    return result;
  }
  //
  // //
  //
  // ProcedureInit = function init( o )
  // {
  //   let procedure = this;
  //
  //   // _.workpiece.initFields( procedure );
  //   // Object.preventExtensions( procedure );
  //   // procedure.copy( o );
  //   _.props.extend( procedure, o );
  //
  //   _.assert( _.strIs( procedure._stack ) );
  //   // _.assert( procedure._sourcePath === null );
  //
  //   procedure._sourcePath = procedure._stack.split( '\n' )[ 0 ];
  //
  //   procedure._longNameMake();
  //
  //   _.arrayAppendOnceStrictly( _.Procedure.InstancesArray, procedure );
  //
  //   _.assert( _.strIs( procedure._sourcePath ) );
  //   _.assert( arguments.length === 1 );
  //   // _.assert( _.Procedure.NamesMap[ procedure._longName ] === procedure, () => `${procedure._longName} not found` );
  //
  //   return procedure;
  // };

;


  let StarterExtension =
  {

    assert,
    assertRoutineOptions,
    assertMapHasOnly,
    assertMapHasNoUndefine,
    toStr,
    mapFields,

    path,

  }

  Object.assign( _starter_, StarterExtension );

  let PathExtension =
  {

    dir,
    nativize,

  }

  Object.assign( _starter_.path, PathExtension );

  // let ProcedureExtension =
  // {
  //
  //   ProcedureInit
  //
  // }
  //
  // Object.assign( _starter_.Procedure.prototype, PathExtension );

;

/* */  /* end of early */ })();


/* */  /* begin of extract */ ( function _extract_() {



  'use strict';

  const _global = _global_;
  let _starter_ = _global_._starter_;
  let _ = _starter_;

  let stackSymbol = Symbol.for( 'stack' );
  let _diagnosticCodeExecuting = 0;
  // let notLongSymbol = Symbol.for( 'notLong' );
  let iteratorSymbol = Symbol.iterator;

  // let _errorCounter = 0;
  // let _errorMaking = false;
  let _ArrayIndexOf = Array.prototype.indexOf;
  let _ArrayIncludes = Array.prototype.includes;
  if( !_ArrayIncludes )
  _ArrayIncludes = function( e ){ _ArrayIndexOf.call( this, e ) }

;


  _.strQuote = function quote( o )
{

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ], quote : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  if( o.quote === undefined || o.quote === null )
  o.quote = quote.defaults.quote;
  _.map.assertHasOnly( o, quote.defaults );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( _.arrayIs( o.src ) )
  {
    let result = [];
    for( let s = 0 ; s < o.src.length ; s++ )
    result.push( _.strQuote({ src : o.src[ s ], quote : o.quote }) );
    return result;
  }

  let src = o.src;

  if( !_.primitive.is( src ) )
  src = _.entity.exportString( src );

  _.assert( _.primitive.is( src ) );

  let result = o.quote + String( src ) + o.quote;

  return result;
}
_.strQuote.defaults =
{ "src" : null, "quote" : `"` }

//


  _.err = function err()
{
  return _._err
  ({
    args : arguments,
    level : 2,
  });
}

//


  _._err = function _err( o )
{
  const exportString = _.entity.exportString ? _.entity.exportString.bind( _.entity ) : String;
  let error;

  if( arguments.length !== 1 )
  throw Error( '_err : Expects single argument : options map' );

  if( !_.mapIs( o ) )
  throw Error( '_err : Expects single argument : options map' );

  if( !_.longIs( o.args ) )
  throw Error( '_err : Expects Long option::args' );

  for( let e in o )
  {
    if( _err.defaults[ e ] === undefined )
    {
      debugger;
      throw Error( `Unknown option::${e}` );
    }
  }

  for( let e in _err.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = _err.defaults[ e ];
  }

  if( _.error._errorMaking )
  {
    throw Error( 'Recursive dead lock because of error inside of routine _err()!' );
  }
  _.error._errorMaking = true;

  if( o.level === undefined || o.level === null )
  o.level = null;

  /* let */

  if( !o.message )
  o.message = '';
  let fallBackMessage = '';
  let errors = [];
  let combinedStack = '';

  /* algorithm */

  try
  {

    argumentsPreprocessArguments();
    argumentsPreprocessErrors();
    locationForm();
    stackAndErrorForm();
    attributesForm();
    catchesForm();
    sourceCodeForm();
    originalMessageForm();

    error = _.error._make
    ({
      error,
      throwLocation : o.throwLocation,
      sections : o.sections,
      concealed : o.concealed,
      exposed : o.exposed,

      attended : o.attended,
      logged : o.logged,
      brief : o.brief,
      stackCondensing : o.stackCondensing,

      originalMessage : o.message,
      combinedStack,
      throwCallsStack : o.throwCallsStack,
      throwsStack : o.throwsStack,
      asyncCallsStack : o.asyncCallsStack,
      sourceCode : o.sourceCode,
      reason : o.reason,
    });

  }
  catch( err2 )
  {
    _.error._errorMaking = false;
    console.log( err2.message );
    console.log( err2.stack );
  }
  _.error._errorMaking = false;

  return error;

  /* */

  function argumentsPreprocessArguments()
  {

    for( let a = 0 ; a < o.args.length ; a++ )
    {
      let arg = o.args[ a ];

      if( !_.error.is( arg ) && _.routine.is( arg ) )
      {
        if( arg.length === 0 )
        {
          try
          {
            arg = o.args[ a ] = arg();
          }
          catch( err )
          {
            let original = arg;
            arg = o.args[ a ] = 'Error throwen by callback for formatting of error string';
            console.error( String( err ) );
            if( _.strLinesSelect ) /* aaa : for Dmytro : make sure it works and cover */ /* Dmytro : works, covered. Test routine `_errWithArgsIncludedRoutine` */
            console.error( _.strLinesSelect
            ({
              src : original.toString(),
              line : 0,
              nearestLines : 5,
              numbering : 1,
            }));
            else
            console.error( original.toString() );
          }
        }
        if( _.unrollIs( arg ) )
        {
          debugger;
          o.args = [ ... Array.prototype.slice.call( o.args, 0, a ), ... arg, ... Array.prototype.slice.call( o.args, a+1, o.args.length ) ];
          // o.args = _.longBut_( null, o.args, [ a, a ], arg );
          // o.args = _.longBut( o.args, [ a, a+1 ], arg );
          a -= 1;
          continue;
        }
      }

    }

  }

  /* */

  function argumentsPreprocessErrors()
  {

    for( let a = 0 ; a < o.args.length ; a++ )
    {
      let arg = o.args[ a ];

      if( _.error.is( arg ) )
      {

        errProcess( arg );
        o.args[ a ] = _.error.originalMessage( arg )

      }
      else if( _.strIs( arg ) && _.error._inStr( arg ) )
      {

        let err = _.error.fromStr( arg );
        errProcess( err );
        o.args[ a ] = _.error.originalMessage( err );

      }

    }

  }

  /* */

  function errProcess( arg )
  {

    if( !error )
    {
      error = arg;
      if( !o.sourceCode )
      o.sourceCode = arg.sourceCode || null;
      if( o.attended === null )
      o.attended = arg.attended || false;
      if( o.logged === null )
      o.logged = arg.logged || false;
    }

    if( arg.throwCallsStack )
    if( !o.throwCallsStack )
    o.throwCallsStack = arg.throwCallsStack;

    // if( arg.asyncCallsStack )
    // if( !o.asyncCallsStack )
    // o.asyncCallsStack = arg.asyncCallsStack;

    if( arg.throwsStack )
    if( o.throwsStack )
    o.throwsStack += '\n' + arg.throwsStack;
    else
    o.throwsStack = arg.throwsStack;

    if( arg.constructor )
    fallBackMessage = fallBackMessage || arg.constructor.name;
    errors.push( arg );

  }

  /* */

  function locationForm()
  {

    if( !error )
    for( let a = 0 ; a < o.args.length ; a++ )
    {
      let arg = o.args[ a ];
      if( !_.primitive.is( arg ) && _.object.like( arg ) )
      try
      {
        o.throwLocation = _.introspector.location
        ({
          error : arg,
          location : o.throwLocation,
        });
      }
      catch( err2 )
      {
        console.error( err2 );
      }
    }

    o.throwLocation = o.throwLocation || Object.create( null );
    o.catchLocation = o.catchLocation || Object.create( null );

  }

  /* */

  function stackAndErrorForm()
  {

    if( error )
    {

      /* qqq : cover each if-branch. ask how to. *difficult problem* */

      if( !o.throwCallsStack )
      if( o.throwLocation )
      o.throwCallsStack = _.introspector.locationToStack( o.throwLocation );
      if( !o.throwCallsStack )
      o.throwCallsStack = _.error.originalStack( error );
      if( !o.throwCallsStack )
      o.throwCallsStack = _.introspector.stack([ ( o.level || 0 ) + 1, Infinity ]);

      if( !o.catchCallsStack && o.catchLocation )
      o.catchCallsStack = _.introspector.locationToStack( o.catchLocation );
      if( !o.catchCallsStack )
      o.catchCallsStack = _.introspector.stack( o.catchCallsStack, [ ( o.level || 0 ) + 1, Infinity ] );

      if( !o.throwCallsStack && o.catchCallsStack )
      o.throwCallsStack = o.catchCallsStack;
      if( !o.throwCallsStack )
      o.throwCallsStack = _.introspector.stack( error, [ ( o.level || 0 ) + 1, Infinity ] );

      o.level = 0;

    }
    else
    {

      error = new Error( o.message + '\n' );
      if( o.throwCallsStack )
      {
        error.stack = o.throwCallsStack;
        o.catchCallsStack = _.introspector.stack( o.catchCallsStack, [ o.level + 1, Infinity ] );
        o.level = 0;
      }
      else
      {
        if( o.catchCallsStack )
        {
          o.throwCallsStack = error.stack = o.catchCallsStack;
        }
        else
        {
          if( o.level === undefined || o.level === null )
          o.level = 1;
          o.level += 1;
          o.throwCallsStack = error.stack = _.introspector.stack( error.stack, [ o.level, Infinity ] );
        }
        o.level = 0;
        if( !o.catchCallsStack )
        o.catchCallsStack = o.throwCallsStack;
      }

    }

    _.assert( o.level === 0 );

    if( ( o.stackRemovingBeginIncluding || o.stackRemovingBeginExcluding ) && o.throwCallsStack )
    o.throwCallsStack = _.introspector.stackRemoveLeft
    (
      o.throwCallsStack, o.stackRemovingBeginIncluding || null, o.stackRemovingBeginExcluding || null
    );

    if( !o.throwCallsStack )
    o.throwCallsStack = error.stack = o.fallBackStack;

    combinedStack = o.throwCallsStack;

    _.assert
    (
      error.asyncCallsStack === undefined
      || error.asyncCallsStack === null
      || error.asyncCallsStack === ''
      || _.arrayIs( error.asyncCallsStack )
    );
    if( error.asyncCallsStack && error.asyncCallsStack.length )
    {
      o.asyncCallsStack = o.asyncCallsStack || [];
      o.asyncCallsStack.push( ... error.asyncCallsStack );
      // _.arrayAppendArray( o.asyncCallsStack, error.asyncCallsStack );
    }

    if( o.asyncCallsStack === null || o.asyncCallsStack === undefined )
    if( _.Procedure && _.Procedure.ActiveProcedure )
    o.asyncCallsStack = [ _.Procedure.ActiveProcedure.stack() ];

    _.assert( o.asyncCallsStack === null || _.arrayIs( o.asyncCallsStack ) );
    if( o.asyncCallsStack && o.asyncCallsStack.length )
    {
      combinedStack += '\n\n' + o.asyncCallsStack.join( '\n\n' );
    }

    _.assert( _.strIs( combinedStack ) );
    if( o.stackCondensing )
    combinedStack = _.introspector.stackCondense( combinedStack );

  }

  /* */

  function attributesForm()
  {

    try
    {
      o.catchLocation = _.introspector.location
      ({
        stack : o.catchCallsStack,
        location : o.catchLocation,
      });
    }
    catch( err2 )
    {
      console.error( err2 );
    }

    try
    {
      o.throwLocation = _.introspector.location
      ({
        error : error,
        stack : o.throwCallsStack,
        location : o.throwLocation,
      });
    }
    catch( err2 )
    {
      console.error( err2 );
    }

  }

  /* */

  function catchesForm()
  {

    if( o.throws )
    {
      _.assert( _.arrayIs( o.throws ) );
      o.throws.forEach( ( c ) =>
      {
        c = _.introspector.locationFromStackFrame( c ).routineFilePathLineCol;
        if( o.throwsStack )
        o.throwsStack += `\nthrown at ${c}`;
        else
        o.throwsStack = `thrown at ${c}`;
      });
    }

    _.assert( _.number.is( o.catchLocation.abstraction ) );
    if( !o.catchLocation.abstraction || o.catchLocation.abstraction === 1 )
    {
      if( o.throwsStack )
      o.throwsStack += `\nthrown at ${o.catchLocation.routineFilePathLineCol}`;
      else
      o.throwsStack = `thrown at ${o.catchLocation.routineFilePathLineCol}`;
    }

  }

  /* */

  function sourceCodeForm()
  {

    if( !o.usingSourceCode )
    return;

    if( o.sourceCode )
    return;

    if( error.sourceCode === undefined )
    {
      let c = _.introspector.code
      ({
        location : o.throwLocation,
        sourceCode : o.sourceCode,
        asMap : 1,
      });
      if( c && c.code && c.code.length < 400 )
      {
        o.sourceCode = c;
      }
    }

  }

  /* */

  function originalMessageForm()
  {
    let result = [];

    if( o.message )
    return;

    for( let a = 0 ; a < o.args.length ; a++ )
    {
      let arg = o.args[ a ];
      let str;

      if( arg && !_.primitive.is( arg ) )
      {

        if( _.routine.is( arg.toStr ) )
        {
          str = arg.toStr();
        }
        else if( _.error.is( arg ) && _.strIs( arg.originalMessage ) )
        {
          str = arg.originalMessage;
        }
        else if( _.error.is( arg ) )
        {
          if( _.strIs( arg.message ) )
          str = arg.message;
          else
          str = exportString( arg );
        }
        else
        {
          str = exportString( arg, { levels : 2 } );
        }
      }
      else if( arg === undefined )
      {
        str = '\n' + String( arg ) + '\n';
      }
      else
      {
        str = String( arg );
      }

      result[ a ] = str;

    }

    let o2 =
    {
      onToStr : eachMessageFormat,
      onPairWithDelimeter : strConcatenateCounting
    };
    o.message = _.strConcat( result, o2 );

    /*
      remove redundant spaces at the begin and the end of lines
    */

    o.message = o.message || fallBackMessage || 'UnknownError';
    o.message = o.message.replace( /^\s*/, '' );
    o.message = o.message.replace( /\x20*$/gm, '' );
    o.message = o.message.replace( /\s*$/, '' );

  }

  /* */

  function eachMessageFormat( str )
  {
    let strBeginsWithRegular = _.strBegins( str, /\S/ );
    let strEndsWithRegular = _.strEnds( str, /\S/ );

    if( !strBeginsWithRegular )
    {
      let notSpaceLikeSymbol = /\S/.exec( str );

      if( notSpaceLikeSymbol === null )
      {
        str = str.replace( /\x20+/g, '' );
        strEndsWithRegular = true;
      }
      else
      {
        let before = str.substring( 0, notSpaceLikeSymbol.index );
        let spaces = /(?<=\n)\x20+$/.exec( before );
        before = before.replace( /\x20+/g, '' );
        before += spaces ? spaces[ 0 ] : '';

        str = before + str.substring( notSpaceLikeSymbol.index );
      }
    }

    if( str && !strEndsWithRegular )
    {
      let notSpaceLikeSymbol = /\S\s*$/.exec( str );

      let after = str.substring( notSpaceLikeSymbol.index + 1 );
      let spaces = /^\x20+(?=\n)/.exec( after );
      after = after.replace( /\x20+/g, '' );
      after += spaces ? spaces[ 0 ] : '';

      str = str.substring( 0, notSpaceLikeSymbol.index + 1 ) + after;
    }

    return str;
  }

  /* */

  function strConcatenateCounting( src1, src2 )
  {
    let result;
    if( _.strEnds( src1, '\n' ) && _.strBegins( src2, '\n' ) )
    {
      let right = /\n+$/.exec( src1 );
      let left = /^\n+/.exec( src2 );

      result = src1.substring( 0, right.index );
      result += right[ 0 ].length > left[ 0 ].length ? right[ 0 ] : left[ 0 ];
      result += src2.substring( left[ 0 ].length );
    }
    else
    {
      result = src1 + src2;
    }
    return result;
  }
}
_._err.defaults =
{
  "args" : null,
  "sections" : null,
  "concealed" : null,
  "exposed" : null,
  "level" : 1,
  "message" : null,
  "reason" : null,
  "sourceCode" : null,
  "stackRemovingBeginIncluding" : 0,
  "stackRemovingBeginExcluding" : 0,
  "usingSourceCode" : 1,
  "stackCondensing" : 1,
  "attended" : null,
  "logged" : null,
  "brief" : null,
  "throwLocation" : null,
  "catchLocation" : null,
  "asyncCallsStack" : null,
  "throwCallsStack" : null,
  "catchCallsStack" : null,
  "fallBackStack" : null,
  "throwsStack" : ``,
  "throws" : null
}

//


  _._errMake = function _make( o )
{
  const logger = _global_.logger || _global_.console;

  if( arguments.length !== 1 )
  throw Error( 'Expects single argument : options map' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects single argument : options map' );

  for( let k in o )
  {
    if( _make.defaults[ k ] === undefined )
    throw Error( `Unknown option::${k}` );
  }

  for( let k in _.error._make.defaults )
  {
    if( o[ k ] === undefined )
    o[ k ] = _.error._make.defaults[ k ];
  }

  if( !_.error.is( o.error ) )
  throw Error( 'Expects option.error:Error' );

  if( !_.strIs( o.originalMessage ) )
  throw Error( 'Expects option.originalMessage:String' );

  if( !_.strIs( o.combinedStack ) )
  throw Error( 'Expects option.combinedStack:String' );

  if( !_.strIs( o.throwCallsStack ) )
  throw Error( 'Expects option.throwCallsStack:String' );

  if( !_.strIs( o.throwsStack ) )
  throw Error( 'Expects option.throwsStack:String' );

  if( !o.throwLocation )
  throw Error( 'Expects option.throwLocation:Location' );

  attributesForm();
  exposedForm();
  sectionsForm();
  _.error._messageForm( o );
  form();

  return o.error;

  /* */

  function attributesForm()
  {

    if( o.attended === null || o.attended === undefined )
    o.attended = o.error.attended;
    o.attended = !!o.attended;

    if( o.logged === null || o.logged === undefined )
    o.logged = o.error.logged;
    o.logged = !!o.logged;

    if( o.brief === null || o.brief === undefined )
    o.brief = o.error.brief;
    o.brief = !!o.brief;

    if( o.reason === null || o.reason === undefined )
    o.reason = o.error.reason;

    o.sections = o.sections || Object.create( null );
    if( o.error.section )
    _.props.supplement( o.sections, o.error.section );

    o.id = o.error.id;
    if( !o.id )
    {
      _.error._errorCounter += 1;
      o.id = _.error._errorCounter;
    }

  }

  /* */

  function exposedForm()
  {
    var has = false;
    for( let k in o.error )
    {
      has = true;
      break;
    }
    if( has )
    {
      if( o.exposed )
      {
        for( let k in o.error )
        if( !Reflect.has( o.exposed, k ) )
        o.exposed[ k ] = o.error[ k ];
      }
      else
      {
        o.exposed = Object.create( null );
        for( let k in o.error )
        o.exposed[ k ] = o.error[ k ];
      }
    }
  }

  /* */

  function sectionsForm()
  {
    let result = '';

    // sectionAdd( 'message', `Message of Error#${o.id}`, o.originalMessage );
    sectionAdd( 'message', `Message of ${o.error.name || 'error'}#${o.id}`, o.originalMessage );
    sectionAdd( 'combinedStack', o.stackCondensing ? 'Beautified calls stack' : 'Calls stack', o.combinedStack );
    sectionAdd( 'throwsStack', `Throws stack`, o.throwsStack );

    /* xxx : postpone */
    if( o.sourceCode )
    if( _.strIs( o.sourceCode ) )
    sectionAdd( 'sourceCode', `Source code`, o.sourceCode );
    else if( _.routine.is( o.sourceCode.read ) )
    sectionAdd( 'sourceCode', `Source code from ${o.sourceCode.path}`, o.sourceCode.read );
    else if( _.strIs( o.sourceCode.code ) )
    sectionAdd( 'sourceCode', `Source code from ${o.sourceCode.path}`, o.sourceCode.code );
    else
    console.error( 'Unknown format of {- o.sourceCode -}' );

    if( o.exposed && Object.keys( o.exposed ).length > 0 )
    _.error._sectionExposedAdd( o );

    for( let s in o.sections )
    {
      let section = o.sections[ s ];
      if( !_.strIs( section.head ) )
      {
        logger.error
        (
          `Each section of an error should have head, but head of section::${s} is ${_.entity.strType(section.head)}`
        );
        delete o.sections[ s ];
      }
      if( !_.strIs( section.body ) )
      {
        logger.error
        (
          `Each section of an error should have body, but body of section::${s} is ${_.entity.strType(section.body)}`
        );
        delete o.sections[ s ];
      }
    }

    return result;
  }

  /* */

  function sectionAdd( name, head, body )
  {
    _.error._sectionAdd({ name, head, body, sections : o.sections });
  }

  /* */

  function form()
  {

    nonenumerable( 'originalMessage', o.originalMessage );
    logging( 'stack' );
    nonenumerable( 'reason', o.reason );

    nonenumerable( 'combinedStack', o.combinedStack );
    nonenumerable( 'throwCallsStack', o.throwCallsStack );
    nonenumerable( 'asyncCallsStack', o.asyncCallsStack );
    nonenumerable( 'throwsStack', o.throwsStack );
    nonenumerable( 'catchCounter', o.error.catchCounter ? o.error.catchCounter+1 : 1 );

    nonenumerable( 'attended', o.attended );
    nonenumerable( 'logged', o.logged );
    nonenumerable( 'brief', o.brief );

    if( o.throwLocation.line !== undefined )
    nonenumerable( 'lineNumber', o.throwLocation.line );
    if( o.error.throwLocation === undefined )
    nonenumerable( 'location', o.throwLocation );
    nonenumerable( 'sourceCode', o.sourceCode || null );
    nonenumerable( 'id', o.id );

    nonenumerable( 'toString', function() { return this.stack } );
    nonenumerable( 'sections', o.sections );

    getter( 'name', function() { return this.constructor.name } );

    o.error[ Symbol.for( 'nodejs.util.inspect.custom' ) ] = o.error.toString;

    if( o.concealed )
    {
      for( let k in o.concealed )
      nonenumerable( k, o.concealed[ k ] );
    }

  }

  /* */

  function nonenumerable( propName, value )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        writable : true,
        value,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
  }

  /* */

  function getter( propName, get )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        get,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
  }

  /* */

  function logging( propName )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        get,
        set,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
    function get()
    {
      /*
      workaround to avoid Njs issue: Njs stingify inherited error
      */
      /* zzz : qqq : find better solution */
      if( ( new Error().stack ).split( '\n' ).length !== 3 )
      {
        _.error.logged( this );
        _.error.attend( this );
      }
      return this.message;
    }
    function set( src )
    {
      this.message = src;
      return src;
    }
  }

}
_._errMake.defaults =
{
  "error" : null,
  "id" : null,
  "throwLocation" : null,
  "sections" : null,
  "concealed" : null,
  "exposed" : null,
  "attended" : null,
  "logged" : null,
  "brief" : null,
  "stackCondensing" : null,
  "originalMessage" : null,
  "combinedStack" : ``,
  "throwCallsStack" : ``,
  "throwsStack" : ``,
  "asyncCallsStack" : ``,
  "sourceCode" : null,
  "reason" : null
}

//


  _.errLogged = function logged( err, value )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( value === undefined )
  value = Config.debug ? _.introspector.stack([ 0, Infinity ]) : true;
  // console.log( `logged ${value}` );
  return _.error.concealedSet( err, { logged : value } );
}

//


  _.errAttend = function attend( err, value )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( value === undefined )
  value = Config.debug ? _.introspector.stack([ 0, Infinity ]) : true;
  let result = _.error.concealedSet( err, { attended : value } );
  return result;
}

//


  _.errProcess = function process( err )
{

  if( arguments.length !== 1 || !_.error.isFormed( err ) )
  err = _.err( ... arguments );

  if( _.process && _.process.entryPointInfo )
  _.error.sectionAdd( err, { name : 'process', body : _.process.entryPointInfo() });

  return err;
}

//


  _.assert = function assert( condition, ... args )
{

  if( Config.debug === false )
  return true;

  if( condition !== true )
  {
    _assertDebugger( condition, arguments );
    if( !_._err )
    throw Error( ... args );
    if( arguments.length === 1 )
    throw _._err
    ({
      args : [ 'Assertion fails' ],
      level : 2,
    });
    else if( arguments.length === 2 )
    throw _._err
    ({
      args : [ arguments[ 1 ] ],
      level : 2,
    });
    else
    throw _._err
    ({
      args : Array.prototype.slice.call( arguments, 1 ),
      level : 2,
    });
  }

  return true;

  function _assertDebugger( condition, args )
  {
    if( !_.error.breakpointOnAssertEnabled )
    return;
    debugger; /* eslint-disable-line no-debugger */
  }

}

//



  _.error.isFormed = function isFormed( src )
{
  if( !_.error.is( src ) )
  return false;
  return src.originalMessage !== undefined;
}

//


  _.error.isAttended = function isAttended( src )
{
  if( !_.error.is( src ) )
  return false;
  return !!src.attended;
}

//


  _.error.originalMessage = function originalMessage( err )
{

  if( arguments.length !== 1 )
  throw Error( 'error.originalMessage : Expects single argument' );

  if( _.strIs( err ) )
  return err;

  if( !err )
  return;

  if( err.originalMessage )
  return err.originalMessage;

  let message = err.message;

  if( !message && message !== '' )
  message = err.msg;
  if( !message && message !== '' )
  message = err.name;

  return message;
}

//


  _.error.originalStack = function originalStack( err )
{

  if( arguments.length !== 1 )
  throw Error( 'error.originalStack : Expects single argument' );

  if( !_.error.is( err ) )
  throw Error( 'error.originalStack : Expects error' );

  if( err.throwCallsStack )
  return err.throwCallsStack;

  if( err.combinedStack )
  return err.combinedStack;

  if( err[ stackSymbol ] )
  return err[ stackSymbol ];

  if( err.stack )
  return _.introspector.stack( err.stack );

  /* should return null if nothing found */
  return null;
}

//


  /* _.error.set = undefined;

//

 // Dmytro : routine does not exist exposedSet and concealedSet are used instead */
  _.error.is = function is( src )
{
  return src instanceof Error || Object.prototype.toString.call( src ) === '[object Error]';
}

//


  _.error._make = function _make( o )
{
  const logger = _global_.logger || _global_.console;

  if( arguments.length !== 1 )
  throw Error( 'Expects single argument : options map' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects single argument : options map' );

  for( let k in o )
  {
    if( _make.defaults[ k ] === undefined )
    throw Error( `Unknown option::${k}` );
  }

  for( let k in _.error._make.defaults )
  {
    if( o[ k ] === undefined )
    o[ k ] = _.error._make.defaults[ k ];
  }

  if( !_.error.is( o.error ) )
  throw Error( 'Expects option.error:Error' );

  if( !_.strIs( o.originalMessage ) )
  throw Error( 'Expects option.originalMessage:String' );

  if( !_.strIs( o.combinedStack ) )
  throw Error( 'Expects option.combinedStack:String' );

  if( !_.strIs( o.throwCallsStack ) )
  throw Error( 'Expects option.throwCallsStack:String' );

  if( !_.strIs( o.throwsStack ) )
  throw Error( 'Expects option.throwsStack:String' );

  if( !o.throwLocation )
  throw Error( 'Expects option.throwLocation:Location' );

  attributesForm();
  exposedForm();
  sectionsForm();
  _.error._messageForm( o );
  form();

  return o.error;

  /* */

  function attributesForm()
  {

    if( o.attended === null || o.attended === undefined )
    o.attended = o.error.attended;
    o.attended = !!o.attended;

    if( o.logged === null || o.logged === undefined )
    o.logged = o.error.logged;
    o.logged = !!o.logged;

    if( o.brief === null || o.brief === undefined )
    o.brief = o.error.brief;
    o.brief = !!o.brief;

    if( o.reason === null || o.reason === undefined )
    o.reason = o.error.reason;

    o.sections = o.sections || Object.create( null );
    if( o.error.section )
    _.props.supplement( o.sections, o.error.section );

    o.id = o.error.id;
    if( !o.id )
    {
      _.error._errorCounter += 1;
      o.id = _.error._errorCounter;
    }

  }

  /* */

  function exposedForm()
  {
    var has = false;
    for( let k in o.error )
    {
      has = true;
      break;
    }
    if( has )
    {
      if( o.exposed )
      {
        for( let k in o.error )
        if( !Reflect.has( o.exposed, k ) )
        o.exposed[ k ] = o.error[ k ];
      }
      else
      {
        o.exposed = Object.create( null );
        for( let k in o.error )
        o.exposed[ k ] = o.error[ k ];
      }
    }
  }

  /* */

  function sectionsForm()
  {
    let result = '';

    // sectionAdd( 'message', `Message of Error#${o.id}`, o.originalMessage );
    sectionAdd( 'message', `Message of ${o.error.name || 'error'}#${o.id}`, o.originalMessage );
    sectionAdd( 'combinedStack', o.stackCondensing ? 'Beautified calls stack' : 'Calls stack', o.combinedStack );
    sectionAdd( 'throwsStack', `Throws stack`, o.throwsStack );

    /* xxx : postpone */
    if( o.sourceCode )
    if( _.strIs( o.sourceCode ) )
    sectionAdd( 'sourceCode', `Source code`, o.sourceCode );
    else if( _.routine.is( o.sourceCode.read ) )
    sectionAdd( 'sourceCode', `Source code from ${o.sourceCode.path}`, o.sourceCode.read );
    else if( _.strIs( o.sourceCode.code ) )
    sectionAdd( 'sourceCode', `Source code from ${o.sourceCode.path}`, o.sourceCode.code );
    else
    console.error( 'Unknown format of {- o.sourceCode -}' );

    if( o.exposed && Object.keys( o.exposed ).length > 0 )
    _.error._sectionExposedAdd( o );

    for( let s in o.sections )
    {
      let section = o.sections[ s ];
      if( !_.strIs( section.head ) )
      {
        logger.error
        (
          `Each section of an error should have head, but head of section::${s} is ${_.entity.strType(section.head)}`
        );
        delete o.sections[ s ];
      }
      if( !_.strIs( section.body ) )
      {
        logger.error
        (
          `Each section of an error should have body, but body of section::${s} is ${_.entity.strType(section.body)}`
        );
        delete o.sections[ s ];
      }
    }

    return result;
  }

  /* */

  function sectionAdd( name, head, body )
  {
    _.error._sectionAdd({ name, head, body, sections : o.sections });
  }

  /* */

  function form()
  {

    nonenumerable( 'originalMessage', o.originalMessage );
    logging( 'stack' );
    nonenumerable( 'reason', o.reason );

    nonenumerable( 'combinedStack', o.combinedStack );
    nonenumerable( 'throwCallsStack', o.throwCallsStack );
    nonenumerable( 'asyncCallsStack', o.asyncCallsStack );
    nonenumerable( 'throwsStack', o.throwsStack );
    nonenumerable( 'catchCounter', o.error.catchCounter ? o.error.catchCounter+1 : 1 );

    nonenumerable( 'attended', o.attended );
    nonenumerable( 'logged', o.logged );
    nonenumerable( 'brief', o.brief );

    if( o.throwLocation.line !== undefined )
    nonenumerable( 'lineNumber', o.throwLocation.line );
    if( o.error.throwLocation === undefined )
    nonenumerable( 'location', o.throwLocation );
    nonenumerable( 'sourceCode', o.sourceCode || null );
    nonenumerable( 'id', o.id );

    nonenumerable( 'toString', function() { return this.stack } );
    nonenumerable( 'sections', o.sections );

    getter( 'name', function() { return this.constructor.name } );

    o.error[ Symbol.for( 'nodejs.util.inspect.custom' ) ] = o.error.toString;

    if( o.concealed )
    {
      for( let k in o.concealed )
      nonenumerable( k, o.concealed[ k ] );
    }

  }

  /* */

  function nonenumerable( propName, value )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        writable : true,
        value,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
  }

  /* */

  function getter( propName, get )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        get,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
  }

  /* */

  function logging( propName )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        get,
        set,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
    function get()
    {
      /*
      workaround to avoid Njs issue: Njs stingify inherited error
      */
      /* zzz : qqq : find better solution */
      if( ( new Error().stack ).split( '\n' ).length !== 3 )
      {
        _.error.logged( this );
        _.error.attend( this );
      }
      return this.message;
    }
    function set( src )
    {
      this.message = src;
      return src;
    }
  }

}
_.error._make.defaults =
{
  "error" : null,
  "id" : null,
  "throwLocation" : null,
  "sections" : null,
  "concealed" : null,
  "exposed" : null,
  "attended" : null,
  "logged" : null,
  "brief" : null,
  "stackCondensing" : null,
  "originalMessage" : null,
  "combinedStack" : ``,
  "throwCallsStack" : ``,
  "throwsStack" : ``,
  "asyncCallsStack" : ``,
  "sourceCode" : null,
  "reason" : null
}

//


  _.error._sectionAdd = function _sectionAdd( o )
{

  if( Config.debug )
  for( let k in _sectionAdd.defaults )
  {
    if( o[ k ] === undefined )
    throw Error( `Expects defined option::${k}` );
  }

  let section = Object.create( null );
  section.name = o.name;
  section.head = o.head;
  section.body = o.body;
  o.sections[ o.name ] = section;
  return section;
}
_.error._sectionAdd.defaults =
{
  "sections" : null,
  "name" : null,
  "head" : null,
  "body" : null
}

//


  _.error._sectionExposedAdd = function _sectionExposedAdd( o )
{
  const exportString = _.entity.exportString ? _.entity.exportString.bind( _.entity ) : String;

  if( Config.debug )
  for( let k in _sectionExposedAdd.defaults )
  {
    if( o[ k ] === undefined )
    throw Error( `Expects defined option::${k}` );
  }

  let i = 0;
  let body = '';
  for( let k in o.exposed )
  {
    if( i > 0 )
    body += `\n`;
    body += `${k} : ${exportString( o.exposed[ k ] )}`;
    i += 1;
  }

  _.error._sectionAdd
  ({
    sections : o.sections,
    name : 'exposed',
    head : 'Exposed',
    body,
  });
}
_.error._sectionExposedAdd.defaults =
{ "sections" : null, "exposed" : null }

//


  _.error._messageForm = function _messageForm( o )
{

  o.message = o.message || '';

  if( !_.strIs( o.originalMessage ) )
  throw 'Expects string {- o.originalMessage -}';

  // _.map.assertHasAll( o, _messageForm.defaults );

  if( Config.debug )
  for( let k in _messageForm.defaults )
  {
    if( o[ k ] === undefined )
    throw Error( `Expects defined option::${k}` );
  }

  if( o.brief )
  {
    o.message += o.originalMessage;
  }
  else
  {
    o.message = _.error._sectionsJoin( o );
  }

  if( o.error )
  nonenumerable( 'message', o.message );

  return o.message;

  /* */

  function nonenumerable( propName, value )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        writable : true,
        value,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
  }

}
_.error._messageForm.defaults =
{
  "error" : null,
  "sections" : null,
  "brief" : false,
  "message" : ``
}

//


  _.error._sectionsJoin = function _sectionsJoin( o )
{
  o.message = o.message || '';

  // _.map.assertHasAll( o, _sectionsJoin.defaults );

  if( Config.debug )
  for( let k in _sectionsJoin.defaults )
  {
    if( o[ k ] === undefined )
    throw Error( `Expects defined option::${k}` );
  }

  for( let s in o.sections )
  {
    let section = o.sections[ s ];
    let head = section.head || '';
    let body = strLinesIndentation( section.body, '    ' );
    if( !body.trim().length )
    continue;
    o.message += ` = ${head}\n${body}\n\n`;
  }

  return o.message;

  function strLinesIndentation( str, indentation )
  {
    if( _.strLinesIndentation )
    return indentation + _.strLinesIndentation( str, indentation );
    else
    return str;
  }

}
_.error._sectionsJoin.defaults =
{ "sections" : null, "message" : `` }

//


  _.error._inStr = function _inStr( errStr )
{
  _.assert( _.strIs( errStr ) );

  if( !_.strHas( errStr, /\=\s+Message of/m ) )
  return false;

  if( !_.strHas( errStr, /(^|\n)\s*=\s+Beautified calls stack/m ) )
  return false;

  return true;
}

//


  _.error.fromStr = function fromStr( errStr )
{

  try
  {

    errStr = _.str.lines.strip( errStr );

    let sectionBeginRegexp = /[=]\s+(.*?)\s*\n/mg;
    let splits = _.strSplitFast
    ({
      src : errStr,
      delimeter : sectionBeginRegexp,
    });

    let sectionName;
    let throwCallsStack = '';
    let throwsStack = '';
    let stackCondensing = true;
    let messages = [];
    for( let s = 0 ; s < splits.length ; s++ )
    {
      let split = splits[ s ];
      let sectionNameParsed = sectionBeginRegexp.exec( split + '\n' );
      if( sectionNameParsed )
      {
        sectionName = sectionNameParsed[ 1 ];
        continue;
      }

      if( !sectionName )
      messages.push( split );
      else if( !sectionName || _.strBegins( sectionName, 'Message of' ) )
      messages.push( split );
      else if( _.strBegins( sectionName, 'Beautified calls stack' ) )
      throwCallsStack = split;
      else if( _.strBegins( sectionName, 'Throws stack' ) )
      throwsStack = split;

    }

    let error = new Error();

    let throwLocation = _.introspector.locationFromStackFrame( throwCallsStack || error.stack );

    let originalMessage = messages.join( '\n' );

    let result = _.error._make
    ({
      error,
      throwLocation,
      stackCondensing,
      originalMessage,
      combinedStack : throwCallsStack,
      throwCallsStack,
      throwsStack,
    });

    return result;
  }
  catch( err2 )
  {
    console.error( err2 );
    return Error( errStr );
  }
}

//


  _.error.logged = function logged( err, value )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( value === undefined )
  value = Config.debug ? _.introspector.stack([ 0, Infinity ]) : true;
  // console.log( `logged ${value}` );
  return _.error.concealedSet( err, { logged : value } );
}

//


  _.error.attend = function attend( err, value )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( value === undefined )
  value = Config.debug ? _.introspector.stack([ 0, Infinity ]) : true;
  let result = _.error.concealedSet( err, { attended : value } );
  return result;
}

//


  _.error.exposedSet = function exposedSet( args, props )
{

  _.assert( arguments.length === 2 );
  _.assert( _.mapIs( props ) )

  if( !_.longIs( args ) )
  args = [ args ];

  let err = args[ 0 ];

  if( _.symbol.is( err ) )
  {
    _.assert( args.length === 1 );
    return err;
  }

  if( args.length !== 1 || !_.error.isFormed( err ) )
  err = _._err
  ({
    args,
    level : 2,
  });

  /* */

  try
  {

    for( let f in props )
    {
      err[ f ] = props[ f ];
    }

  }
  catch( err )
  {
    if( Config.debug )
    console.error( `Cant assign "${f}" property to error\n${err.toString()}` );
  }

  /* */

  return err;
}

//


  _.error.concealedSet = function concealedSet( args, props )
{

  _.assert( arguments.length === 2 );
  _.assert( _.mapIs( props ) )

  if( !_.longIs( args ) )
  args = [ args ];

  let err = args[ 0 ];

  if( _.symbol.is( err ) )
  {
    _.assert( args.length === 1 );
    return err;
  }

  if( args.length !== 1 || !_.error.isFormed( err ) )
  err = _._err
  ({
    args,
    level : 2,
  });

  /* */

  try
  {

    for( let f in props )
    {
      let o =
      {
        enumerable : false,
        configurable : true,
        writable : true,
        value : props[ f ],
      };
      Object.defineProperty( err, f, o );
    }

  }
  catch( err )
  {
    if( Config.debug )
    console.error( `Cant assign "${f}" property to error\n${err.toString()}` );
  }

  /* */

  return err;
}

//


  _.error.process = function process( err )
{

  if( arguments.length !== 1 || !_.error.isFormed( err ) )
  err = _.err( ... arguments );

  if( _.process && _.process.entryPointInfo )
  _.error.sectionAdd( err, { name : 'process', body : _.process.entryPointInfo() });

  return err;
}

//





  _.date.is = function is( src )
{
  return Object.prototype.toString.call( src ) === '[object Date]';
}

//



  _.introspector.code = function code( o )
{

  _.routine.options( code, o );
  _.assert( arguments.length === 0 || arguments.length === 1 );

  if( _diagnosticCodeExecuting )
  return;
  _diagnosticCodeExecuting += 1;

  try
  {

    if( !o.location )
    {
      if( o.error )
      o.location = _.introspector.location({ error : o.error, level : o.level });
      else
      o.location = _.introspector.location({ stack : o.stack, level : o.stack ? o.level : o.level+1 });
    }

    if( !_.number.is( o.location.line ) )
    return end();

    /* */

    if( !o.sourceCode )
    {

      if( !o.location.filePath )
      return end();

      let codeProvider = _.codeProvider || _.fileProvider;
      if( !codeProvider && _globals_.testing && _globals_.testing.wTools )
      codeProvider = _globals_.testing.wTools.codeProvider || _globals_.testing.wTools.fileProvider;

      if( !codeProvider )
      return end();

      try
      {

        let filePath = codeProvider.path.normalizeTolerant( o.location.filePath );
        if( codeProvider.path.isAbsolute( filePath ) )
        o.sourceCode = read( codeProvider, filePath );

      }
      catch( err )
      {
        o.sourceCode = ` ! Cant load source code of "${ o.location.filePath }"`;
      }

      if( !o.sourceCode )
      return end();

    }

    /* */

    let code = _.strLinesSelect
    ({
      src : o.sourceCode,
      line : o.location.line,
      nearestLines : o.nearestLines,
      selectMode : o.selectMode,
      zeroLine : 1,
      numbering : 1,
    });

    if( code && _.strLinesIndentation && o.identation )
    code = o.identation + _.strLinesIndentation( code, o.identation );

    let result = code;
    if( o.withPath )
    {
      if( o.asMap )
      result = { path : o.location.filePathLineCol, code };
      else
      result = o.location.filePathLineCol + '\n' + code;
    }

    return end( result );
  }
  catch( err )
  {
    console.log( err.toString() );
    return;
  }

  /* */

  function end( result )
  {
    _diagnosticCodeExecuting -= 1;
    return result;
  }

  /* */

  function read( codeProvider, filePath )
  {
    let result = codeProvider.fileRead
    ({
      filePath,
      sync : 1,
      throwing : 0,
    });
    return result;
  }

  /* */

}
_.introspector.code.defaults =
{
  "level" : 0,
  "nearestLines" : 5,
  "withPath" : 1,
  "asMap" : 0,
  "selectMode" : `center`,
  "identation" : null,
  "stack" : null,
  "error" : null,
  "location" : null,
  "sourceCode" : null
}

//


  _.introspector.stack = function stack( stack, range )
{

  if( arguments.length === 1 )
  {
    if( !_.error.is( stack ) )
    if( !_.strIs( stack ) )
    {
      range = arguments[ 0 ];
      stack = undefined;
    }
  }

  if( stack === undefined || stack === null )
  {
    stack = new Error();
    if( range === undefined )
    {
      range = [ 1, Infinity ];
    }
    else
    {
      if( _.number.is( range[ 0 ] ) ) /* Dmytro : previous implementation affects range - not a number value + number => NaN, so assertion does not word properly */
      range[ 0 ] += 1;
      if( _.number.is( range[ 1 ] ) && range[ 1 ] >= 0 )
      range[ 1 ] += 1;
    }
  }

  if( range === undefined )
  range = [ 0, Infinity ];

  if( arguments.length !== 0 && arguments.length !== 1 && arguments.length !== 2 )
  {
    debugger;
    throw Error( 'stack : expects one or two or none arguments' );
  }

  if( !_.intervalIs( range ) )
  {
    debugger;
    throw Error( 'stack : expects range but, got ' + _.entity.strType( range ) );
  }

  let first = range[ 0 ];
  let last = range[ 1 ];

  // if( !_.number.is( first ) ) // Dmytro : it's unnecessary assertions, _.intervalIs checks number value in passed array
  // {
  //   debugger;
  //   throw Error( 'stack : expects number range[ 0 ], but got ' + _.entity.strType( first ) );
  // }
  //
  // if( !_.number.is( last ) )
  // {
  //   debugger;
  //   throw Error( 'stack : expects number range[ 0 ], but got ' + _.entity.strType( last ) );
  // }

  let errIs = 0;
  if( _.error.is( stack ) )
  {
    stack = _.error.originalStack( stack );
    errIs = 1;
  }

  if( !stack )
  return '';

  if( !_.arrayIs( stack ) && !_.strIs( stack ) )
  return;

  // if( !_.arrayIs( stack ) && !_.strIs( stack ) ) // Dmytro : previous condition is almost identical
  // {
  //   debugger;
  //   throw Error( 'stack expects array or string' );
  // }

  if( !_.arrayIs( stack ) )
  stack = stack.split( '\n' );

  // debugger;

  /* remove redundant lines */

  while( stack.length )
  {
    let splice = 0;
    splice |= ( _.strHas( stack[ 0 ], /(^| )at / ) === false && stack[ 0 ].indexOf( '@' ) === -1 );
    splice |= stack[ 0 ].indexOf( '(vm.js:' ) !== -1;
    splice |= stack[ 0 ].indexOf( '(module.js:' ) !== -1;
    splice |= stack[ 0 ].indexOf( '(internal/module.js:' ) !== -1;
    if( splice )
    stack.splice( 0, 1 );
    else break;
  }

  if( stack[ 0 ] )
  if( stack[ 0 ].indexOf( 'at ' ) === -1 && stack[ 0 ].indexOf( '@' ) === -1 ) // Dmytro : it's dubious - while loop removes all strings if stack[ 0 ] has not 'at ' or '@'
  {
    console.error( 'stack : failed to parse stack' );
    debugger;
  }

  stack = stack.map( ( line ) => line.trim() );
  stack = stack.filter( ( line ) => line );

  /* */

  first = first === undefined ? 0 : first;
  last = last === undefined ? stack.length : last;

  // if( _.number.is( first ) ) // Dmytro : first and last - is always some numbers, see above about assertions
  if( first < 0 )
  first = stack.length + first;

  // if( _.number.is( last ) )
  if( last < 0 )
  last = stack.length + last + 1;

  /* */

  if( first !== 0 || last !== stack.length )
  {
    stack = stack.slice( first || 0, last );
  }

  /* */

  stack = String( stack.join( '\n' ) );

  return stack;
}

//


  _.introspector.stackCondense = function stackCondense( stack )
{

  if( arguments.length !== 1 )
  throw Error( 'Expects single arguments' );

  if( !_.strIs( stack ) )
  {
    debugger;
    throw Error( 'Expects string' );
  }

  stack = stack.split( '\n' );

  for( let s = stack.length-1 ; s >= 0 ; s-- )
  {
    let line = stack[ s ];
    if( s > 0 )
    if( /(\W|^)__\w+/.test( line ) )
    {
      stack.splice( s, 1 );
      continue;
    }
    if( _.strHas( line, '.test.' ) )
    line += ' *';
    stack[ s ] = line;
  }

  return stack.join( '\n' );
}

//


  _.introspector.location = function location( o )
{
  if( _.number.is( o ) )
  o = { level : o }
  else if( _.strIs( o ) )
  o = { stack : o, level : 0 }
  else if( _.error.is( o ) )
  o = { error : o, level : 0 }
  else if( o === undefined )
  o = { stack : _.introspector.stack([ 1, Infinity ]) };

  /* */

  if( location.defaults )
  for( let e in o )
  {
    if( location.defaults[ e ] === undefined )
    throw Error( 'Unknown option ' + e );
  }

  if( location.defaults )
  for( let e in location.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = location.defaults[ e ];
  }

  if( !( arguments.length === 0 || arguments.length === 1 ) )
  throw Error( 'Expects single argument or none' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  if( !o.level )
  o.level = 0;

  /* */

  if( !o.location )
  o.location = Object.create( null );

  /* */

  if( o.error )
  {
    let location2 = o.error.location || Object.create( null );

    var args0 =
    [
      location2.filePath,
      o.location.filePath,
      o.error.filename,
      o.error.fileName
    ];
    o.location.filePath = _.longLeftDefined( args0 ).element;

    var args1 =
    [
      location2.line,
      o.location.line,
      o.error.line,
      o.error.linenumber,
      o.error.lineNumber,
      o.error.lineNo,
      o.error.lineno
    ];
    o.location.line = _.longLeftDefined( args1 ).element;

    var args2 =
    [
      location2.col,
      o.location.col,
      o.error.col,
      o.error.colnumber,
      o.error.colNumber,
      o.error.colNo,
      o.error.colno
    ];
    o.location.col = _.longLeftDefined( args2 ).element;

  }

  /* */

  if( !o.stack )
  {
    if( o.error )
    {
      o.stack = _.introspector.stack( o.error, undefined );
    }
    else
    {
      o.stack = _.introspector.stack();
      o.level += 1;
    }
  }

  if( o.stack === null || o.stack === undefined )
  return o.location;

  _.assert( _.strIs( o.stack ) || _.arrayIs( o.stack ) );

  let stack = o.stack;
  if( _.strIs( stack ) )
  stack = stack.split( '\n' );
  let stackFrame = stack[ o.level ];

  return _.introspector.locationFromStackFrame({ stackFrame, location : o.location });
}
_.introspector.location.defaults =
{
  "level" : 0,
  "stack" : null,
  "error" : null,
  "location" : null
}

//


  _.introspector.locationFromStackFrame = function locationFromStackFrame( o )
{

  if( _.strIs( o ) )
  o = { stackFrame : o };

  if( !( arguments.length === 1 ) )
  throw Error( 'Expects single argument' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  /* */

  if( locationFromStackFrame.defaults ) /* Dmytro : maybe it is the redundant condition, the routine has defaults */
  for( let e in o )
  {
    if( locationFromStackFrame.defaults[ e ] === undefined )
    throw Error( 'Unknown option : ' + e );
  }

  if( locationFromStackFrame.defaults ) /* Dmytro : maybe it is the redundant condition, the routine has defaults */
  for( let e in locationFromStackFrame.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = locationFromStackFrame.defaults[ e ];
  }

  /* */

  if( !( _.strIs( o.stackFrame ) ) )
  throw Error( `Expects string {- stackFrame -}, but fot ${_.entity.strType( o.stackFrame )}` );

  if( o.location && !_.mapIs( o.location ) )
  throw Error( 'Expects map option::location' );

  /* */

  if( !o.location )
  o.location = Object.create( null );
  o.location.original = o.stackFrame;
  _.introspector.locationNormalize( o.location );
  return o.location;
}
_.introspector.locationFromStackFrame.defaults =
{ "stackFrame" : null, "location" : null }

//


  _.introspector.locationToStack = function locationToStack( o )
{
  if( !( arguments.length === 1 ) )
  throw Error( 'Expects single argument' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  /* */

  // _.map.assertHasOnly( o, locationToStack.defaults );
  if( Config.debug )
  {
    let extraKeys = mapButKeys( o, locationToStack.defaults );
    _.assert( extraKeys.length === 0, () => `Routine "locationToStack" does not expect options: ${ keysQuote( extraKeys ) }` );
  }

  _.introspector.locationNormalize( o );

  if( !o.filePathLineCol )
  return null;

  // if( o.routineFilePathLineCol )
  // {
  //   _.assert( 0, 'not tested' );
  // }

  if( o.routineName )
  return `at ${o.routineName} (${o.filePathLineCol})`;
  else
  return `at (${o.filePathLineCol})`;

  /*
    at Object.locationToStack (http://127.0.0.1:5000//builder/include/wtools/abase/l0/l3/Introspector.s:723:10)
  */

  /* */

  function mapButKeys( srcMap, butMap )
  {
    let result = [];

    for( let s in srcMap )
    if( !( s in butMap ) )
    result.push( s );

    return result;
  }

  /* */

  function keysQuote( keys )
  {
    let result = `"${ keys[ 0 ] }"`;
    for( let i = 1 ; i < keys.length ; i++ )
    result += `, "${ keys[ i ] }"`;
    return result.trim();
  }
}
_.introspector.locationToStack.defaults =
{
  "original" : null,
  "filePath" : null,
  "routineName" : null,
  "routineAlias" : null,
  "internal" : null,
  "abstraction" : null,
  "line" : null,
  "col" : null,
  "filePathLineCol" : null,
  "routineFilePathLineCol" : null,
  "fileName" : null,
  "fileNameLineCol" : null
}

//


  _.introspector.locationNormalize = function locationNormalize( o )
{

  if( !( arguments.length === 1 ) )
  throw Error( 'Expects single argument' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  /* */

  if( locationNormalize.defaults )
  for( let e in o )
  {
    if( locationNormalize.defaults[ e ] === undefined )
    throw Error( 'Unknown option ' + e );
  }

  if( locationNormalize.defaults )
  for( let e in locationNormalize.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = locationNormalize.defaults[ e ];
  }

  /* */

  let hadPath = !!o.filePath;
  if( !o.filePath )
  o.filePath = pathFromStack();

  pathCanonize();
  routineFromStack();
  routineAliasFromStack();
  internalForm();
  abstractionForm();

  // if( !_.strIs( o.filePath ) )
  // return end();

  if( !_.number.defined( o.line ) || !_.number.defined( o.col ) )
  o.filePath = lineColFromPath( o.filePath );

  if( !_.number.is( o.line ) && hadPath )
  {
    let path = pathFromStack();
    if( path )
    lineColFromPath( path );
  }

  return end();

  /* */

  function end()
  {
    let path = o.filePath;

    /* filePathLineCol */

    o.filePathLineCol = path || '';
    if( _.number.defined( o.line ) )
    {
      o.filePathLineCol += ':' + o.line;
      if( _.number.defined( o.col ) )
      o.filePathLineCol += ':' + o.col;
    }

    /* routineFilePathLineCol */

    if( o.routineName )
    o.routineFilePathLineCol = o.routineName + ' @ ' + o.filePathLineCol;

    /* fileName */

    if( path )
    {
      let fileName = path;
      _.assert( _.routine.is( fileName.lastIndexOf ) );
      let i1 = fileName.lastIndexOf( '/' );
      let i2 = fileName.lastIndexOf( '\\' );
      let i = Math.max( i1, i2 );
      if( i !== -1 )
      fileName = fileName.substr( i+1 );
      o.fileName = fileName;
    }

    /* fileNameLineCol */

    o.fileNameLineCol = o.fileName || '';
    if( _.number.defined( o.line ) )
    {
      o.fileNameLineCol += ':' + o.line;
      if( _.number.defined( o.col ) )
      o.fileNameLineCol += ':' + o.col;
    }

    return o;
  }

  /* */

  function pathCanonize()
  {
    if( !o.filePath )
    return;

    if( _.path && _.path.canonize )
    o.filePath = _.path.canonize( o.filePath );
  }

  /* */

  function routineFromStack()
  {
    let routineName;

    if( o.routineName )
    return o.routineName;
    if( !o.original )
    return o.routineName;

    routineName = o.original;

    // if( !_.strIs( routineName ) ) // xxx /* Dmytro : deprecated comment, delete with label, please */
    // return '{-anonymous-}';
    if( !_.strIs( routineName ) ) // xxx /* Dmytro : deprecated comment, delete with label, please */
    {
      routineName = '{-anonymous-}';
    }
    else
    {
      routineName = routineName.replace( /at eval \(eval at/, '' );
      let t = /^\s*(?:at\s+)?([\w.<>]+)\s*.+/;
      let executed = t.exec( routineName );
      if( executed )
      routineName = executed[ 1 ] || '';

      routineName = routineName.replace( /<anonymous>/gm, '{-anonymous-}' );

      if( _.strEnds( routineName, '.' ) )
      routineName += '{-anonymous-}';
    }

    o.routineName = routineName;
    return o.routineName;
  }

  /* */

  function routineAliasFromStack()
  {
    let routineAlias;

    if( o.routineAlias )
    return o.routineAlias;
    if( !o.original )
    return o.routineAlias;

    routineAlias = null;

    let t = /\[as ([^\]]*)\]/;
    let executed = t.exec( o.original );
    if( executed )
    routineAlias = executed[ 1 ] || null;

    if( routineAlias )
    routineAlias = routineAlias.replace( /<anonymous>/gm, '{-anonymous-}' );

    o.routineAlias = routineAlias;
    return o.routineAlias;
  }

  /* */

  function internalForm()
  {

    if( _.number.defined( o.internal ) )
    return;

    o.internal = 0;

    if( o.filePath )
    {
      if( o.internal < 2 )
      if( _.strBegins( o.filePath, 'internal/' ) )
      o.internal = 2;

      if( o.internal < 2 )
      if( _.strBegins( o.filePath, 'node:internal/' ) )
      o.internal = 2;

    }

  }

  /* */

  function abstractionForm()
  {

    if( _.number.defined( o.abstraction ) )
    return;

    o.abstraction = 0;

    if( o.routineName )
    {
      if( o.abstraction < 2 )
      if( _.strBegins( o.routineName, '__' ) || o.routineName.indexOf( '.__' ) !== -1 )
      o.abstraction = 2;
      if( o.abstraction < 1 )
      if( _.strBegins( o.routineName, '_' ) || o.routineName.indexOf( '._' ) !== -1 )
      o.abstraction = 1;
    }

    if( o.routineAlias )
    {
      if( o.abstraction < 2 )
      if( _.strBegins( o.routineAlias, '__' ) || o.routineAlias.indexOf( '.__' ) !== -1 )
      o.abstraction = 2;
      if( o.abstraction < 1 )
      if( _.strBegins( o.routineAlias, '_' ) || o.routineAlias.indexOf( '._' ) !== -1 )
      o.abstraction = 1;
    }

  }

  /* */

  function pathFromStack()
  {
    let path = o.original;

    if( !_.strIs( path ) )
    return;

    path = path.replace( /^\s+/, '' );
    path = path.replace( /^\w+@/, '' );
    path = path.replace( /^at/, '' );
    path = path.replace( /^\s+/, '' );
    path = path.replace( /\s+$/, '' );

    let regexp = /^.*\(([^)]*)\).*$/;
    var parsed = regexp.exec( path );
    if( parsed )
    path = parsed[ 1 ];

    return path;
  }

  /* line / col number from path */

  function lineColFromPath( path )
  {
    if( !path )
    {
      if( o.line )
      o.line = numberFromToInt( o.line );
      if( o.col )
      o.col = numberFromToInt( o.col )
    }
    else
    {
      let lineNumber, colNumber;
      let postfix = /(.+?):(\d+)(?::(\d+))?[^:/]*$/;
      let parsed = postfix.exec( path );

      if( parsed )
      {
        path = parsed[ 1 ];
        lineNumber = parsed[ 2 ];
        colNumber = parsed[ 3 ];
      }

      lineNumber = numberFromToInt( lineNumber );
      colNumber = numberFromToInt( colNumber );

      if( !_.number.defined( o.line ) )
      if( _.number.defined( lineNumber ) )
      o.line = lineNumber;

      if( !_.number.defined( o.col ) )
      if( _.number.defined( colNumber ) )
      o.col = colNumber;
    }

    if( !_.number.defined( o.line ) )
    o.line = null;
    if( !_.number.defined( o.col ) )
    o.col = null;

    return path;
  }

  /* */

  function numberFromToInt( src )
  {
    if( _.strIs( src ) )
    src = parseInt( src );
    else
    src = Math.floor( Number( src ) );

    return src;
  }

}
_.introspector.locationNormalize.defaults =
{
  "original" : null,
  "filePath" : null,
  "routineName" : null,
  "routineAlias" : null,
  "internal" : null,
  "abstraction" : null,
  "line" : null,
  "col" : null,
  "filePathLineCol" : null,
  "routineFilePathLineCol" : null,
  "fileName" : null,
  "fileNameLineCol" : null
}

//



  _.long._functor_functor = function _functor_functor( methodName, typer, which )
{
  _.assert( !!( methodName ) );
  if( !typer )
  typer = 'namespaceOf';
  if( !which )
  which = 0;
  if( which === 0 )
  return end( _functor0 );
  if( which === 1 )
  return end( _functor1 );
  _.assert( 0 );

  function _functor0( container )
  {
    _.assert( arguments.length === 1 );
    _.assert( _.routine.is( this[ typer ] ), () => `No routine::${typer} in the namesapce::${this.NamespaceName}` );
    const namespace = this[ typer ]( container );
    _.assert( _.routine.is( namespace[ methodName ] ), `No routine::${methodName} in the namesapce::${namespace.NamespaceName}` );
    return namespace[ methodName ].bind( namespace, container );
  }

  function _functor1( container )
  {
    _.assert( arguments.length === 1 );
    _.assert( _.routine.is( this[ typer ] ), () => `No routine::${typer} in the namesapce::${this.NamespaceName}` );
    const namespace = this[ typer ]( container );
    _.assert( _.routine.is( namespace[ methodName ] ), `No routine::${methodName} in the namesapce::${namespace.NamespaceName}` );
    const routine0 = namespace[ methodName ];
    return routine1.bind( namespace );
    function routine1( arg1, ... args )
    {
      return routine0.call( this, arg1, container, ... args );
    }
  }

  function end( result )
  {
    result.functor = new Function( `return _.long._functor_functor( '${methodName}', '${typer}', ${which} )` );
    return result;
  }

}

//



  _.entity.strType = function strTypeWithTraits( src )
{

  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.aux.is( src ) )
  {

    if( _.mapIsPure( src ) )
    return end( 'Map.pure' );
    else if( _.mapIsPolluted( src ) )
    return end( 'Map.polluted' );
    else if( _.aux.isPure( src ) && _.aux.isPrototyped( src ) )
    return end( 'Aux.pure.prototyped' );
    else if( _.aux.isPolluted( src ) && _.aux.isPrototyped( src ) )
    return end( 'Aux.polluted.prototyped' );
    else _.assert( 0, 'undexpected' );

  }

  if( _.primitive.is( src ) )
  return end( _.entity.strTypeSecondary( src ) );

  let proto = Object.getPrototypeOf( src );
  if( proto && proto.constructor && proto.constructor !== Object && proto.constructor.name )
  return end( proto.constructor.name );

  return end( _.entity.strTypeSecondary( src ) );

  function end( result )
  {
    let translated = _.entity.TranslatedTypeMap[ result ];
    if( translated )
    result = translated;

    if( !_.entity.StandardTypeSet.has( result ) )
    {
      if( _.countableIs( src ) )
      result += '.countable';
      if( _.constructibleIs( src ) )
      result += '.constructible';
    }

    return result;
  }

}

//


  _.entity.strTypeSecondary = function strTypeSecondary( src )
{

  let name = Object.prototype.toString.call( src );
  let result = /\[(\w+) (\w+)\]/.exec( name );
  _.assert( !!result, 'unknown type', name );
  return result[ 2 ];
}

//


  _.entity.namespaceOf = function namespaceForIterating( src ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 );

  if( src === undefined )
  return _.blank;
  if( _.primitive.is( src ) )
  return _.itself;
  if( _.hashMap.like( src ) )
  return _.hashMap;
  if( _.set.like( src ) )
  return _.set;
  if( _.long.is( src ) )
  return _.long;
  if( _.buffer.like( src ) )
  return _.buffer;
  if( _.countable.is( src ) )
  return _.object;
  if( _.aux.is( src ) )
  return _.aux;
  if( _.object.is( src ) )
  return _.object;

  return _.props;
}

//


  _.entity.lengthOf = ( function()
{
  const lengthOf = function lengthOf( src ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 );
  return lengthOf.functor.call( this, src )();
};
  lengthOf.functor = ( function anonymous(
) {
return _.long._functor_functor( 'lengthOf', 'namespaceOf', 0 )
} )();;
  return lengthOf;
})();

//


  _.lengthOf = _.entity.lengthOf.bind( _.entity )
  _.strType = _.entity.strType.bind( _.entity )
  _.entity.makeUndefined = ( function()
{
  const makeUndefined = function makeUndefined( container, ... args ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return makeUndefined.functor.call( this, container )( ... args );
};
  makeUndefined.functor = ( function anonymous(
) {
return _.long._functor_functor( 'makeUndefined', 'namespaceOf', 0 )
} )();;
  return makeUndefined;
})();

//


  _.entity.TranslatedTypeMap = {
  "BigUint64Array" : `U64x`,
  "Uint32Array" : `U32x`,
  "Uint16Array" : `U16x`,
  "Uint8Array" : `U8x`,
  "Uint8ClampedArray" : `U8xClamped`,
  "BigInt64Array" : `I64x`,
  "Int32Array" : `I32x`,
  "Int16Array" : `I16x`,
  "Int8Array" : `I8x`,
  "Float64Array" : `F64x`,
  "Float32Array" : `F32x`,
  "Buffer" : `BufferNode`,
  "ArrayBuffer" : `BufferRaw`,
  "SharedArrayBuffer" : `BufferRawShared`,
  "Map" : `HashMap`,
  "WeakMap" : `HashMapWeak`,
  "Function" : `Routine`,
  "Arguments" : `ArgumentsArray`
};

//


  _.entity.StandardTypeSet = new Set([
  `U64x`,
  `U32x`,
  `U16x`,
  `U8x`,
  `U8xClamped`,
  `I64x`,
  `I32x`,
  `I16x`,
  `I8x`,
  `F64x`,
  `F32x`,
  `BufferNode`,
  `BufferRaw`,
  `BufferRawShared`,
  `HashMap`,
  `HashMapWeak`,
  `ArgumentsArray`,
  `Array`,
  `Set`,
  `Routine`,
  `Global`
]);

//



  _.class.methodIteratorOf = function methodIteratorOf( src )
{
  if( !src )
  return;
  if( _.routine.like( src[ iteratorSymbol ] ) )
  return src[ iteratorSymbol ];
  return;
}

//



  _.path.refine = function refine( src )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) );

  let result = src;

  if( result[ 1 ] === ':' )
  {
    if( result[ 2 ] === '\\' || result[ 2 ] === '/' )
    {
      if( result.length > 3 )
      result = '/' + result[ 0 ] + '/' + result.substring( 3 );
      else
      result = '/' + result[ 0 ]
    }
    else if( result.length === 2 )
    {
      result = '/' + result[ 0 ];
    }
  }

  result = result.replace( /\\/g, '/' );

  return result;
}

//


  _.path._normalize = function _normalize( o )
{
  // let debug = 0;
  // if( 0 )
  // debug = 1;

  _.routine.assertOptions( _normalize, arguments );
  _.assert( _.strIs( o.src ), 'Expects string' );

  if( !o.src.length )
  return '';

  let result = o.src;

  result = this.refine( result );

  // if( debug )
  // console.log( 'normalize.refined : ' + result );

  /* detrailing */

  if( o.tolerant )
  {
    /* remove "/" duplicates */
    result = result.replace( this._delUpDupRegexp, this.upToken );
  }

  let endsWithUp = false;
  let beginsWithHere = false;

  /* remove right "/" */

  if( result !== this.upToken && !_.strEnds( result, this.upToken + this.upToken ) && _.strEnds( result, this.upToken ) )
  {
    endsWithUp = true;
    result = _.strRemoveEnd( result, this.upToken );
  }

  /* undoting */

  while( !_.strBegins( result, this.hereUpToken + this.upToken ) && _.strBegins( result, this.hereUpToken ) )
  {
    beginsWithHere = true;
    result = _.strRemoveBegin( result, this.hereUpToken );
  }

  /* remove second "." */

  if( result.indexOf( this.hereToken ) !== -1 )
  {

    while( this._delHereRegexp.test( result ) )
    result = result.replace( this._delHereRegexp, function( match, postSlash )
    {
      return postSlash || '';
    });
    if( result === '' )
    result = this.upToken;

  }

  /* remove .. */

  if( result.indexOf( this.downToken ) !== -1 )
  {

    while( this._delDownRegexp.test( result ) )
    result = result.replace( this._delDownRegexp, function( /* match, notBegin, split, preSlash, postSlash */ )
    {
      let match = arguments[ 0 ];
      let notBegin = arguments[ 1 ];
      let split = arguments[ 2 ];
      let preSlash = arguments[ 3 ];
      let postSlash = arguments[ 4 ];

      if( preSlash === '' )
      return notBegin;
      if( !notBegin )
      return notBegin + preSlash;
      else
      return notBegin + ( postSlash || '' );
    });

  }

  /* nothing left */

  if( !result.length )
  result = '.';

  /* dot and trail */

  if( o.detrailing )
  if( result !== this.upToken && !_.strEnds( result, this.upToken + this.upToken ) )
  result = _.strRemoveEnd( result, this.upToken );

  if( !o.detrailing && endsWithUp )
  if( result !== this.rootToken )
  result = result + this.upToken;

  if( !o.undoting && beginsWithHere )
  result = this._dot( result );

  // if( debug )
  // console.log( 'normalize.result : ' + result );

  return result;
}
_.path._normalize.defaults =
{
  "src" : null,
  "tolerant" : false,
  "detrailing" : false,
  "undoting" : false
}

//


  _.path.normalize = function normalize( src )
{
  let result = this._normalize({ src, tolerant : false, detrailing : false, undoting : false });

  _.assert( _.strIs( src ), 'Expects string' );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
  _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );

  if( Config.debug )
  {
    let i = result.lastIndexOf( this.upToken + this.downToken + this.upToken );
    _.assert( i === -1 || !/\w/.test( result.substring( 0, i ) ) );
  }

  return result;
}

//


  _.path.canonize = function canonize( src )
{
  let result = this._normalize({ src, tolerant : false, detrailing : true, undoting : true });

  _.assert( _.strIs( src ), 'Expects string' );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( result === this.upToken || _.strEnds( result, this.upToken + this.upToken ) || !_.strEnds( result, this.upToken ) );
  _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
  _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );

  if( Config.debug )
  {
    let i = result.lastIndexOf( this.upToken + this.downToken + this.upToken );
    _.assert( i === -1 || !/\w/.test( result.substring( 0, i ) ) );
  }

  return result;
}

//


  _.path.canonizeTolerant = function canonizeTolerant( src )
{
  _.assert( _.strIs( src ), 'Expects string' );

  let result = this._normalize({ src, tolerant : true, detrailing : true, undoting : true });

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( result === this.upToken || _.strEnds( result, this.upToken ) || !_.strEnds( result, this.upToken + this.upToken ) );
  _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
  _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );

  if( Config.debug )
  {
    _.assert( !this._delUpDupRegexp.test( result ) );
  }

  return result;
}

//


  _.path._unescape = function _unescape( filePath )
{
  let self = this;
  // let splits = self.split( filePath );
  /*
  cant use routine self.split because it normalizes path
  */
  let splits = filePath.split( self.upToken );

  let result = Object.create( null );
  result.wasEscaped = false;

  splits = splits.map( ( split ) =>
  {

    {
      let i = 0;
      while( split[ i ] === '"' )
      i += 1;
      if( i > 0 )
      {
        let c = i;
        if( c % 2 === 1 )
        result.wasEscaped = true;
        let c2 = Math.floor( ( c + 1 ) / 2 );
        split = split.substring( c2, split.length );
      }
    }

    {
      let i = split.length-1;
      while( split[ i ] === '"' )
      i -= 1;
      if( i < split.length-1 )
      {
        let c = split.length - i - 1;
        if( c % 2 === 1 )
        result.wasEscaped = true;
        let c2 = Math.floor( ( c + 1 ) / 2 );
        split = split.substring( 0, split.length - c2 );
      }
    }

    return split;
  });

  result.unescaped = splits.join( self.upToken );
  return result;
}

//


  _.path.unescape = function unescape( filePath )
{
  let self = this;
  return self._unescape( filePath ).unescaped;
}

//


  _.path._nativizeWindows = function _nativizeWindows( filePath )
{
  let self = this;
  _.assert( _.strIs( filePath ), 'Expects string' ) ;

  let result = filePath;

  _.assert( _.routine.is( self.unescape ) );
  result = self.unescape( result ); /* xxx : remove from here */

  result = self._nativizeMinimalWindows( result );

  return result;
}

//


  _.path._nativizeMinimalWindows = function _nativizeMinimalWindows( filePath )
{
  let self = this;

  let result = filePath;

  result = result.replace( /\//g, '\\' );

  if( result[ 0 ] === '\\' )
  if( result.length === 2 || result[ 2 ] === ':' || result[ 2 ] === '\\' )
  result = result[ 1 ] + ':' + result.substring( 2 );

  if( result.length === 2 && result[ 1 ] === ':' )
  result = result + '\\';

  return result;
}

//


  _.path._nativizePosix = function _nativizePosix( filePath )
{
  let self = this;
  let result = filePath;
  _.assert( _.strIs( filePath ), 'Expects string' );
  _.assert( _.routine.is( self.unescape ) );
  result = self.unescape( result ); /* xxx : remove from here */
  return result;
}

//


  _.path.isGlob = function isGlob( src ) /* qqq2 : extend and implement perfect coverage taking into account escaping */
{
  let self = this;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) );

  if( self.fileProvider && !self.fileProvider.globing )
  {
    return false;
  }

  if( !self._pathIsGlobRegexp )
  _setup();

  return self._pathIsGlobRegexp.test( src );

  function _setup()
  {
    let _pathIsGlobRegexpStr = '';
    _pathIsGlobRegexpStr += '(?:[?*]+)'; /* asterix, question mark */
    _pathIsGlobRegexpStr += '|(?:([!?*@+]*)\\((.*?(?:\\|(.*?))*)\\))'; /* parentheses */
    _pathIsGlobRegexpStr += '|(?:\\[(.+?)\\])'; /* square brackets */
    _pathIsGlobRegexpStr += '|(?:\\{(.*)\\})'; /* curly brackets */
    _pathIsGlobRegexpStr += '|(?:\0)'; /* zero */
    self._pathIsGlobRegexp = new RegExp( _pathIsGlobRegexpStr );
  }

}

//


  _.path.isRelative = function isRelative( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string {-filePath-}, but got', _.entity.strType( filePath ) );
  return !this.isAbsolute( filePath );
}

//


  _.path.isAbsolute = function isAbsolute( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string {-filePath-}, but got', _.entity.strType( filePath ) );
  filePath = this.refine( filePath );
  return _.strBegins( filePath, this.upToken );
}

//


  _.path.ext = function ext( path )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( path ), 'Expects string {-path-}, but got', _.entity.strType( path ) );

  let index = path.lastIndexOf( '/' );
  if( index >= 0 )
  path = path.substr( index+1, path.length-index-1 );

  index = path.lastIndexOf( '.' );
  if( index === -1 || index === 0 )
  return '';

  index += 1;

  return path.substr( index, path.length-index ).toLowerCase();
}

//


  _.path.isGlobal = function isGlobal( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string' );
  return _.strHas( filePath, '://' );
}

//


  _.path.rootToken = `/`;

//

  _.path.upToken = `/`;

//

  _.path.hereToken = `.`;

//

  _.path.downToken = `..`;

//

  _.path.hereUpToken = `./`;

//

  _.path.downUpToken = `../`;

//

  _.path._delHereRegexp = /\/\.(\/|$)/;

//

  _.path._delDownRegexp = /((?:.|^))(?:(?:\/\/)|(((?:^|\/))(?!\.\.(?:\/|$))(?:(?!\/).)+\/))\.\.((?:\/|$))/;

//

  _.path._delUpDupRegexp = /\/{2,}/g;

//

  _.path._pathIsGlobRegexp = /(?:[?*]+)|(?:([!?*@+]*)\((.*?(?:\|(.*?))*)\))|(?:\[(.+?)\])|(?:\{(.*)\})|(?: )/;

//

  _.path.currentAtBegin = `/mnt/home-hdd//Intellectual/wTools`;

//



  _.long.is = ( function is_functor()
{
  let result;
  const TypedArray = Object.getPrototypeOf( Int8Array );
  //const iteratorSymbol = Symbol.iterator;

  if( _global_.BufferNode )
  result = isNjs;
  else
  result = isBrowser;
  result.functor = is_functor;
  return result;

  function isNjs( src )
  {
    if( Array.isArray( src ) )
    return true

    if( src instanceof TypedArray )
    {
      if( src instanceof BufferNode )
      return false;
      return true;
    }
    isNjs.functor = is_functor;

    // if( arguments[ iteratorSymbol ] === undefined )
    // return false;
    if( Object.prototype.toString.call( src ) === '[object Arguments]' )
    return true;

    return false;
  }

  function isBrowser( src )
  {
    if( Array.isArray( src ) )
    return true

    if( src instanceof TypedArray )
    return true;

    // if( arguments[ iteratorSymbol ] === undefined )
    // return false;
    if( Object.prototype.toString.call( src ) === '[object Arguments]' )
    return true;

    return false;
  }
  isBrowser.functor = is_functor;

} )();

//


  _.long.like = function like( src ) /* qqq : cover */
{
  if( _.primitive.is( src ) )
  return false;
  return _.long.is( src );
}

//


  _.long._make = function _make( src, length )
{
  if( arguments.length === 2 )
  {
    let data = length;
    if( _.number.is( length ) )
    {
      data = src;
    }
    else
    {
      if( _.number.is( length.length ) )
      {
        length = length.length;
      }
      else
      {
        data = [ ... length ];
        length = data.length;
      }
    }
    if( _.argumentsArray.is( src ) )
    return fill( _.argumentsArray._make( length ), data );
    if( _.unroll.is( src ) )
    return fill( _.unroll._make( length ), data );
    if( src === null )
    return fill( this.tools.long.default._make( length ), data );
    let result;
    if( _.routine.is( src ) )
    result = fill( new src( length ), data )
    else if( src.constructor )
    result = fill( new src.constructor( length ), data );
    _.assert( _.long.is( result ), 'Not clear how to make such long' );
    return result;
  }
  else if( src !== undefined && src !== null )
  {
    if( _.number.is( src ) )
    return this.tools.long.default._make( src );
    if( _.unroll.is( src ) )
    return _.unroll._make( src );
    if( _.argumentsArray.is( src ) )
    return _.argumentsArray._make( src );
    if( src.constructor === Array )
    return [ ... src ];
    if( _.buffer.typedIs( src ) )
    return new src.constructor( src );
    if( _.countable.is( src ) )
    return this.tools.long.default._make( src );
    if( _.routine.is( src ) )
    {
      let result = new src();
      _.assert( this.is( result ), 'Expects long as returned instance' );
      return result;
    }
  }

  return this.tools.long.default.make();

  /* */

  function fill( dst, data )
  {
    if( data === null || data === undefined )
    return dst;
    let l = Math.min( length, data.length );
    for( let i = 0 ; i < l ; i++ )
    dst[ i ] = data[ i ];
    return dst;
  }
}

//


  _.long.make = function make( src, length )
{
  _.assert( arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routine.is( src ) );
    _.assert( _.number.is( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.number.is( src ) || _.long.is( src ) || _.countable.is( src ) || _.routine.is( src ) );
  }
  return this._make( ... arguments );
}

//


  _.long._makeUndefined = function _makeUndefined( src, length )
{
  if( arguments.length === 2 )
  {
    if( !_.number.is( length ) )
    {
      if( _.number.is( length.length ) )
      length = length.length;
      else
      length = [ ... length ].length;
    }

    if( src === null )
    return this.tools.long.default._makeUndefined( length );
    if( _.argumentsArray.is( src ) )
    return _.argumentsArray._makeUndefined( src, length );
    if( _.unroll.is( src ) )
    return _.unroll._makeUndefined( src, length );
    if( _.routine.is( src ) )
    {
      let result = new src( length );
      _.assert( _.long.is( result ) );
      return result;
    }
    return new src.constructor( length );
  }
  else if( arguments.length === 1 )
  {
    let constructor;
    if( this.like( src ) )
    {
      if( _.argumentsArray.is( src ) )
      return _.argumentsArray._makeUndefined( src );
      if( _.unroll.is( src ) )
      return _.unroll._makeUndefined( src );
      constructor = src.constructor;
      length = src.length;
    }
    else
    {
      return this.tools.long.default._makeUndefined( src );
    }
    return new constructor( length );
  }

  return this.tools.long.default._makeUndefined();
}

//


  _.long.makeUndefined = function makeUndefined( src, length )
{
  // _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  _.assert( 0 <= arguments.length && arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routine.is( src ) );
    _.assert( _.number.is( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.number.is( src ) || this.like( src ) || _.countable.is( src ) || _.routine.is( src ) );
  }
  return this._makeUndefined( ... arguments );
}

//


  _.long._lengthOf = function _lengthOf( src )
{
  return src.length;
}

//


  _.long.lengthOf = function lengthOf( src )
{
  _.assert( arguments.length === 1 );
  _.assert( this.like( src ) );
  return this._lengthOf( src );
}

//


  _.long._exportStringDiagnosticShallow = function _exportStringDiagnosticShallow( src )
{
  if( _.unroll.is( src ) )
  return `{- ${_.entity.strType( src )}.unroll with ${this._lengthOf( src )} elements -}`;
  return `{- ${_.entity.strType( src )} with ${this._lengthOf( src )} elements -}`;
}

//


  _.long.exportStringDiagnosticShallow = function exportStringDiagnosticShallow( src, o )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( o === undefined || _.object.isBasic( o ) );
  return this._exportStringDiagnosticShallow( ... arguments );
}

//


  _.longIs = _.long.is.bind( _.long )
  _.longLike = _.long.like.bind( _.long )

  /* _.longIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.longLike = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.argumentsArray.is = function is( src )
{
  return Object.prototype.toString.call( src ) === '[object Arguments]';
}

//


  _.argumentsArray.like = function like( src )
{
  if( Array.isArray( src ) )
  return true;
  if( Object.prototype.toString.call( src ) === '[object Arguments]' )
  return true;
  return false;
}

//


  _.argumentsArrayIs = _.argumentsArray.is.bind( _.argumentsArray )
  /* _.argumentsArrayIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.array.is = function is( src )
{
  return Array.isArray( src );
  // return Object.prototype.toString.call( src ) === '[object Array]';
}

//


  _.array.like = function like( src ) /* qqq : cover */
{
  return this.is( src );
}

//


  _.array.isEmpty = function isEmpty( src )
{
  if( !_.array.is( src ) )
  return false;
  return src.length === 0;
}

//


  _.array.likeResizable = function likeResizable( src )
{
  return _.array.is( src );
}

//


  _.array._make = function _make( src, length )
{
  if( arguments.length === 2 )
  {
    let data = length;
    if( _.number.is( length ) )
    {
      data = src;
    }
    else if( length.length )
    {
      length = length.length;
    }
    if( _.countable.is( length ) )
    {
      data = [ ... length ];
      length = data.length;
    }

    return fill( new Array( length ), data );
  }
  else if( arguments.length === 1 )
  {
    if( _.number.is( src ) )
    return new Array( src );
    if( _.countable.is( src ) )
    return [ ... src ];
  }
  return [];

  /* */

  function fill( dst, data )
  {
    if( data === null || data === undefined )
    return dst;
    let l = Math.min( length, data.length );
    for( let i = 0 ; i < l ; i++ )
    dst[ i ] = data[ i ];
    return dst;
  }

}

//


  _.array.make = function make( src, length )
{
  // if( !( arguments.length === 0 || src === null || _.countable.is( src ) || _.numberIs( src ) ) )
  // debugger;
  _.assert( arguments.length === 0 || src === null || _.countable.is( src ) || _.numberIs( src ) );
  _.assert( length === undefined || !_.number.is( src ) || !_.number.is( length ) );
  _.assert( arguments.length < 2 || _.number.is( length ) || _.countable.is( length ) );
  _.assert( arguments.length <= 2 );
  return this._make( ... arguments );
}

//


  _.array.as = function as( src )
{
  _.assert( arguments.length === 1 );
  _.assert( src !== undefined );

  //src === undefined check below conflicts with above assert
  // if( src === null || src === undefined )
  if( src === null )
  return [];
  else if( _.array.is( src ) )
  return src;
  else if( _.countable.like( src ) )
  return [ ... src ];
  else
  return [ src ];

}

//


  _.arrayIs = _.array.is.bind( _.array )
  _.arrayLike = _.array.like.bind( _.array )
  _.arrayIsEmpty = _.array.isEmpty.bind( _.array )
  _.arrayLikeResizable = _.array.likeResizable.bind( _.array )
  /* _.arrayIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.arrayLike = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.arrayIsEmpty = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.arrayLikeResizable = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.unroll.is = function is( src )
{
  if( !_.arrayIs( src ) )
  return false;
  return !!src[ unrollSymbol ];
}

//


  _.unroll.from = function from( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( this.is( src ) )
  return src;
  return this.make( src );
}

//


  _.unroll._make = function _make( src, length )
{
  let result = _.array._make( ... arguments );
  result[ unrollSymbol ] = true;
  if
  (
    ( src !== null && src !== undefined && !_.unroll.is( src ) )
    || ( src !== null && src !== undefined && !_.unroll.is( src ) )
  )
  result = _.unroll.normalize( result );
  return result;

  // let result;
  // result = _.array._make( ... arguments );
  // result[ unrollSymbol ] = true;
  // if( src !== null && src !== undefined && !_.unroll.is( src ) )
  // result = _.unroll.normalize( result );
  // return result;
}

//


  _.unroll.make = function make( src, length )
{
  // if( !( arguments.length === 0 || src === null || _.countable.is( src ) || _.numberIs( src ) ) )
  // debugger;
  _.assert( arguments.length === 0 || src === null || _.countable.is( src ) || _.numberIs( src ) );
  _.assert( length === undefined || !_.number.is( src ) || !_.number.is( length ) );
  _.assert( arguments.length < 2 || _.number.is( length ) || _.countable.is( length ) );
  _.assert( arguments.length <= 2 );
  return this._make( ... arguments );
}

//


  _.unroll.normalize = function normalize( dstArray )
{

  _.assert( arguments.length === 1 );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  for( let a = 0 ; a < dstArray.length ; a++ )
  {
    if( _.unrollIs( dstArray[ a ] ) )
    {
      let args = [ a, 1 ];
      args.push.apply( args, dstArray[ a ] );
      dstArray.splice.apply( dstArray, args );
      a += args.length - 3;
      /* no normalization of ready unrolls, them should be normal */
    }
    else if( _.arrayIs( dstArray[ a ] ) )
    {
      _.unroll.normalize( dstArray[ a ] );
    }
  }

  return dstArray;
}

//


  _.unroll.append = function append( dstArray )
{
  _.assert( arguments.length >= 1 );
  _.assert( _.longIs( dstArray ) || dstArray === null, 'Expects long or unroll' );

  dstArray = dstArray || [];

  _append( dstArray, Array.prototype.slice.call( arguments, 1 ) );

  return dstArray;

  function _append( dstArray, srcArray )
  {
    _.assert( arguments.length === 2 );

    for( let a = 0, len = srcArray.length ; a < len; a++ )
    {
      if( _.unrollIs( srcArray[ a ] ) )
      {
        _append( dstArray, srcArray[ a ] );
      }
      else
      {
        if( _.arrayIs( srcArray[ a ] ) )
        _.unroll.normalize( srcArray[ a ] )
        dstArray.push( srcArray[ a ] );
      }
    }

    return dstArray;
  }

}

//


  _.unrollAppend = _.unroll.append.bind( _.unroll )
  _.unrollIs = _.unroll.is.bind( _.unroll )
  /* _.unrollIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.bufferRaw.is = function rawIs( src )
{
  let type = Object.prototype.toString.call( src );
  // let result = type === '[object ArrayBuffer]';
  // return result;
  if( type === '[object ArrayBuffer]' || type === '[object SharedArrayBuffer]' )
  return true;
  return false;
}

//


  _.bufferRawIs = _.bufferRaw.is.bind( _.bufferRaw )
  /* _.bufferRawIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.bufferTyped.is = function is( src )
{
  if( !( src instanceof Object.getPrototypeOf( Int8Array ) ) )
  return false;
  if( _.buffer.nodeIs( src ) )
  return false;
  return true;
}

//


  _.bufferTypedIs = _.bufferTyped.is.bind( _.bufferTyped )
  /* _.bufferTypedIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.bufferNode.is = function nodeIs( src )
{
  // if( typeof BufferNode !== 'undefined' )
  if( _global_.BufferNode )
  return src instanceof BufferNode;
  return false;
}

//


  _.bufferNodeIs = _.bufferNode.is.bind( _.bufferNode )
  _.bufferNode.nodeIs = function nodeIs( src )
{
  // if( typeof BufferNode !== 'undefined' )
  if( _global_.BufferNode )
  return src instanceof BufferNode;
  return false;
}

//


  /* _.bufferNodeIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */


  _.buffer.like = function anyIs( src )
{
  if( src instanceof ArrayBuffer )
  return true;
  if( _global.BufferRawShared && src instanceof SharedArrayBuffer )
  return true;
  if( ArrayBuffer.isView( src ) )
  return true;
  return false;
}

//


  _.buffer.nodeIs = _.bufferNode.nodeIs.bind( _.bufferNode )

  _.vector.is = function is( src )
{

  if( _.arrayIs( src ) )
  return true;
  if( _.primitive.is( src ) )
  return false;

  if( _.class.methodIteratorOf( src ) )
  if( _.number.is( src.length ) ) /* yyy */
  if( !_.mapIs( src ) )
  return true;

  return false;
}

//


  _.vector.like = function like( src )
{
  return _.vector.is( src );
}

//


  _.vectorIs = _.vector.is.bind( _.vector )
  _.vectorLike = _.vector.like.bind( _.vector )
  /* _.vectorIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.vectorLike = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.primitive._is = ( function _primitiveIs_functor()
{
  const is = new Set();
  is.add( '[object Symbol]' );
  is.add( '[object Number]' );
  is.add( '[object BigInt]' );
  is.add( '[object Boolean]' );
  is.add( '[object String]' );
  return _primitiveIs;

  function _primitiveIs( src, typeStr )
  {
    return is.has( typeStr );
  }

} )();

//


  _.primitive.is = function is( src )
{
  if( !src )
  return true;
  let t = Object.prototype.toString.call( src );
  return _.primitive._is( src, t );
}

//


  _._primitiveIs = _.primitive._is.bind( _.primitive )
  _.primitiveIs = _.primitive.is.bind( _.primitive )
  /* _._primitiveIs = undefined;

//

 */ /* Dmytro : binded, source code is not available */
  /* _.primitiveIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.number.is = function is( src )
{
  return typeof src === 'number';
  return Object.prototype.toString.call( src ) === '[object Number]';
}

//


  _.number.isFinite = function numberIsFinite( src )
{
  if( !_.number.is( src ) )
  return false;
  return isFinite( src );
}

//


  _.number.defined = function numberIsFinite( src )
{
  if( !_.number.is( src ) )
  return false;
  return isFinite( src );
}

//


  _.number.fromStrMaybe = function fromStrMaybe( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) || _.number.is( src ) );

  if( _.number.is( src ) )
  return src;
  if( !src ) /* qqq : cover */
  return src;

  // let parsed = !src ? NaN : Number( src ); /* Dmytro : it is strange code, the previous branch checks this condition */
  // if( !isNaN( parsed ) )
  // return parsed;
  // return src;

  let parsed = src ? Number( src ) : NaN;
  if( !isNaN( parsed ) )
  return parsed;
  return src;
}

//


  _.number.s = {
  "areAll" : function areAll( src )
{
  _.assert( arguments.length === 1 );

  if( _.bufferTypedIs( src ) )
  return true;

  if( _.argumentsArray.like( src ) && !_.arrayIsEmpty( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.number.is( src[ s ] ) )
    return false;

    return true;
  }

  return false;
},
  "areFinite" : function areFinite( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );

  if( !_.number.s.areAll( src ) )
  return false;

  if( _.longIs( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.number.isFinite( src[ s ] ) )
    return false;
  }

  return true;
},
  "arePositive" : function arePositive( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );

  if( !_.number.s.areAll( src ) )
  return false;

  if( _.longIs( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( src[ s ] < 0 || !_.number.isNotNan( src[ s ] ) )
    return false;
  }

  return true;
},
  "areInt" : function areInt( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );

  if( !_.number.s.areAll( src ) )
  return false;

  if( _.longIs( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.intIs( src[ s ] ) )
    return false;
  }

  return true;
},
  "total" : function numbersTotal( numbers )
{
  let result = 0;
  _.assert( _.longIs( numbers ) );
  _.assert( arguments.length === 1, 'Expects single argument' );
  for( let n = 0 ; n < numbers.length ; n++ )
  {
    let number = numbers[ n ];
    _.assert( _.number.is( number ) )
    result += number;
  }
  return result;
},
  "from" : function numbersFrom( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.strIs( src ) )
  return _.number.from( src );

  if( _.number.is( src ) )
  return src;

  let result;

  if( _.longIs( src ) )
  {
    result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _.number.from( src[ s ] );
  }
  else if( _.object.isBasic( src ) )
  {
    result = Object.create( null );
    for( let s in src )
    result[ s ] = _.number.from( src[ s ] );
  }
  else
  {
    result = _.number.from( src );
  }

  return result;
},
  "slice" : function numbersSlice( src, f, l )
{
  if( _.argumentsArray.like( src ) )
  _.assert( _.number.s.areAll( src ) )

  if( _.number.is( src ) )
  return src;
  return _.longSlice( src, f, l );
},
  "make" : function numbersMake( src, length )
{
  let result;

  if( _.vector.adapterIs( src ) )
  src = _.vectorAdapter.slice( src );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.number.is( src ) || _.argumentsArray.like( src ) );

  if( _.argumentsArray.like( src ) )
  {
    _.assert( src.length === length );
    result = _.long.makeUndefined( length );
    for( let i = 0 ; i < length ; i++ )
    result[ i ] = src[ i ];
  }
  else
  {
    result = _.long.makeUndefined( length );
    for( let i = 0 ; i < length ; i++ )
    result[ i ] = src;
  }

  return result;
},
  "fromNumber" : function numbersFromNumber( src, length )
{

  if( _.vector.adapterIs( src ) )
  src = _.vectorAdapter.slice( src );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.number.is( src ) || _.argumentsArray.like( src ) );

  if( _.argumentsArray.like( src ) )
  {
    _.assert( src.length === length );
    return src;
  }

  // debugger; /* xxx2 : test */
  let result = _.long.makeUndefined( length );
  for( let i = 0 ; i < length ; i++ )
  result[ i ] = src;

  return result;
},
  "fromInt" : function numbersFromInt( dst, length )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.intIs( dst ) || _.arrayIs( dst ), 'Expects array of number as argument' );
  _.assert( length >= 0 );

  if( _.number.is( dst ) )
  {
    debugger;
    // dst = _.longFillTimes( [], length , dst );
    dst = _.longFill( [], dst, length );
  }
  else
  {
    for( let i = 0 ; i < dst.length ; i++ )
    _.assert( _.intIs( dst[ i ] ), 'Expects integer, but got', dst[ i ] );
    _.assert( dst.length === length, 'Expects array of length', length, 'but got', dst );
  }

  return dst;
},
  "make_functor" : function numbersMake_functor( length )
{
  // let _ = this;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.number.is( length ) );

  function numbersMake( src )
  {
    return _.number.s.make( src, length );
  }

  return numbersMake;
},
  "from_functor" : function numbersFrom_functor( length )
{
  // let _ = this;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.number.is( length ) );

  function numbersFromNumber( src )
  {
    return _.number.s.fromNumber( src, length );
  }

  return numbersFromNumber;
}
};

//



  _.aux.is = function is( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return true;

  if( proto === Object.prototype )
  {
    if( src[ Symbol.iterator ] )
    return Object.prototype.toString.call( src ) !== '[object Arguments]';
    return true;
  }

  if( _.routineIs( proto[ Symbol.iterator ] ) )
  return false;

  if( !_.primitive.is( proto ) )
  if( !Reflect.has( proto, 'constructor' ) || proto.constructor === Object.prototype.constructor )
  return true;

  return false;
}

//


  _.aux.isPure = function isPure( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return true;

  if( proto.constructor === Object )
  return false;

  if( _.routineIs( proto[ Symbol.iterator ] ) )
  return false;

  if( !_.primitive.is( proto ) )
  if( !Reflect.has( proto, 'constructor' ) )
  return true;

  return false;
}

//


  _.aux.isPolluted = function isPolluted( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return false;

 if( proto === Object.prototype )
 {
   if( src[ Symbol.iterator ] )
   return Object.prototype.toString.call( src ) !== '[object Arguments]';
   return true;
 }

  if( _.routineIs( proto[ Symbol.iterator ] ) )
  return false;

  if( proto.constructor === Object )
  return true;

  return false;
}

//


  _.aux.isPrototyped = function isPrototyped( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return false;

  if( proto === Object.prototype )
  return false;

  if( _.routineIs( proto[ Symbol.iterator ] ) )
  return false;

  if( !_.primitive.is( proto ) )
  if( !Reflect.has( proto, 'constructor' ) || proto.constructor === Object.prototype.constructor )
  return true;

  return false;
}

//


  _.aux.like = function like( src )
{
  return _.aux.is( src );
}

//


  _.aux._make = function _make( src )
{
  if( src )
  {
    if( this.like( src ) )
    return this._cloneShallow( src );
    else
    return this.extendUniversal( Object.create( null ), src );
  }
  return Object.create( null );
}

//


  _.aux.make = function make( src, length )
{
  _.assert( arguments.length === 0 || src === null || !_.primitive.is( src ) );
  _.assert( length === undefined || length === 0 );
  _.assert( arguments.length <= 2 );
  return this._make( ... arguments );
}

//


  _.aux._makeUndefined = function _makeUndefined( src, length )
{
  let result = Object.create( null );
  return result;
}

//


  _.aux.makeUndefined = function makeUndefined( src, length )
{
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 2 )
  {
    _.assert( this.like( src ) );
    _.assert( _.number.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( _.number.is( src ) || this.like( src ) );
  }

  return this._makeUndefined( src );
}

//


  _.aux._keys = function _keys( o )
{
  let result = [];

  _.routine.options( _keys, o );

  let srcMap = o.srcMap;
  let selectFilter = o.selectFilter;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this.like( srcMap ) );
  _.assert( selectFilter === null || _.routine.is( selectFilter ) );

  /* */

  if( o.onlyEnumerable )
  {
    let result1 = [];

    if( o.onlyOwn )
    {
      for( let k in srcMap )
      if( Object.hasOwnProperty.call( srcMap, k ) )
      result1.push( k );
    }
    else
    {
      for( let k in srcMap )
      result1.push( k );
    }

    filter( srcMap, result1 );

  }
  else
  {

    if( o.onlyOwn  )
    {
      filter( srcMap, Object.getOwnPropertyNames( srcMap ) );
    }
    else
    {
      let proto = srcMap;
      result = [];
      do
      {
        filter( proto, Object.getOwnPropertyNames( proto ) );
        proto = Object.getPrototypeOf( proto );
      }
      while( proto );
    }

  }

  return result;

  /* */

  function filter( srcMap, keys )
  {

    if( !selectFilter )
    {
      /* qqq : for junior : rewrite without arrayAppend and without duplicating array */
      arrayAppendArrayOnce( result, keys );
    }
    else for( let k = 0 ; k < keys.length ; k++ )
    {
      let e = selectFilter( srcMap, keys[ k ] );
      if( e !== undefined )
      arrayAppendOnce( result, e );
      /* qqq : for junior : rewrite without arrayAppend and without duplicating array */
    }

  }

  /* */

  function arrayAppendOnce( dst, element )
  {
    let i = dst.indexOf( element );
    if( i === -1 )
    dst.push( element );
    return dst;
  }

  /* */

  function arrayAppendArrayOnce( dst, src )
  {
    src.forEach( ( element ) =>
    {
      let i = dst.indexOf( element );
      if( i === -1 )
      dst.push( element );
    });
    return dst;
  }

  /* */

}
_.aux._keys.defaults =
{
  "srcMap" : null,
  "onlyOwn" : 0,
  "onlyEnumerable" : 1,
  "selectFilter" : null
}

//


  _.aux.keys = function keys( srcMap, o )
{
  let result;

  // _.assert( this === _.object );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( keys, o || null );
  // _.assert( !_.primitive.is( srcMap ) );

  o.srcMap = srcMap;

  result = this._keys( o );

  return result;
}
_.aux.keys.defaults =
{ "onlyOwn" : 0, "onlyEnumerable" : 1 }

//


  _.aux.namespaceOf = function namespaceOf( src )
{

  if( _.map.is( src ) )
  return _.map;
  if( _.aux.is( src ) )
  return _.aux;

  return null;
}

//


  _.aux._lengthOf = function _lengthOf( src )
{
  return this.keys( src ).length;
}

//


  _.aux.lengthOf = function lengthOf( src )
{
  _.assert( arguments.length === 1 );
  _.assert( this.like( src ) );
  return this._lengthOf( src );
}

//


  _.aux.supplement = function supplement( dstMap, srcMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    srcMap = arguments[ a ];
    this._supplementWithProps( dstMap, srcMap );
  }

  return dstMap
}

//


  _.aux._exportStringDiagnosticShallow = function _exportStringDiagnosticShallow( src, o )
{
  return `{- ${_.entity.strType( src )} with ${this._lengthOf( src )} elements -}`;
}

//


  _.aux.exportStringDiagnosticShallow = function exportStringDiagnosticShallow( src, o )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( o === undefined || _.object.isBasic( o ) );
  return this._exportStringDiagnosticShallow( ... arguments );
}

//


  _.constructible.is = function is( src ) /* xxx qqq : optimize */
{
  if( _.primitive.is( src ) )
  return false;

  let proto = Object.getPrototypeOf( src );
  if( proto === null )
  return false;

  if( !Reflect.has( proto, 'constructor' ) )
  return false;
  if( proto.constructor === Object )
  return false;

  if( _.aux.is( src ) ) /* xxx : remove? */
  return false;
  if( _.vector.is( src ) )
  return false;
  if( _.set.is( src ) )
  return false;
  if( _.hashMap.is( src ) )
  return false;

  return true;
}

//


  _.constructibleIs = function is( src ) /* xxx qqq : optimize */
{
  if( _.primitive.is( src ) )
  return false;

  let proto = Object.getPrototypeOf( src );
  if( proto === null )
  return false;

  if( !Reflect.has( proto, 'constructor' ) )
  return false;
  if( proto.constructor === Object )
  return false;

  if( _.aux.is( src ) ) /* xxx : remove? */
  return false;
  if( _.vector.is( src ) )
  return false;
  if( _.set.is( src ) )
  return false;
  if( _.hashMap.is( src ) )
  return false;

  return true;
}

//



  _.container._functor_functor = function _functor_functor( methodName, typer, which )
{
  _.assert( !!( methodName ) );
  if( !typer )
  typer = 'namespaceOf';
  if( !which )
  which = 0;
  if( which === 0 )
  return end( _functor0 );
  if( which === 1 )
  return end( _functor1 );
  _.assert( 0 );

  function _functor0( container )
  {
    _.assert( arguments.length === 1 );
    _.assert( _.routine.is( this[ typer ] ), () => `No routine::${typer} in the namesapce::${this.NamespaceName}` );
    const namespace = this[ typer ]( container );
    _.assert( _.routine.is( namespace[ methodName ] ), `No routine::${methodName} in the namesapce::${namespace.NamespaceName}` );
    return namespace[ methodName ].bind( namespace, container );
  }

  function _functor1( container )
  {
    _.assert( arguments.length === 1 );
    _.assert( _.routine.is( this[ typer ] ), () => `No routine::${typer} in the namesapce::${this.NamespaceName}` );
    const namespace = this[ typer ]( container );
    _.assert( _.routine.is( namespace[ methodName ] ), `No routine::${methodName} in the namesapce::${namespace.NamespaceName}` );
    const routine0 = namespace[ methodName ];
    return routine1.bind( namespace );
    function routine1( arg1, ... args )
    {
      return routine0.call( this, arg1, container, ... args );
    }
  }

  function end( result )
  {
    result.functor = new Function( `return _.long._functor_functor( '${methodName}', '${typer}', ${which} )` );
    return result;
  }

}

//



  _.object.is = function is( src ) /* xxx : qqq : for junior : optimize */
{

  if( Object.prototype.toString.call( src ) === '[object Object]' )
  return true;

  if( _.primitive.is( src ) )
  return false;

  // if( _.vector.is( src ) )
  // return false;

  if( _.long.is( src ) )
  return false;

  if( _.set.is( src ) )
  return false;

  if( _.hashMap.is( src ) )
  return false;

  if( _.routine.isTrivial( src ) )
  return false;

  return true;
}

//


  _.object.like = function like( src ) /* xxx : qqq : for junior : optimize */
{
  return _.object.is( src );
  // if( _.object.isBasic( src ) )
  // return true;
  //
  // if( _.primitive.is( src ) )
  // return false;
  //
  // if( _.vector.is( src ) )
  // return false;
  //
  // if( _.routine.isTrivial( src ) )
  // return false;
  //
  // if( _.set.is( src ) )
  // return false;
  //
  // if( _.hashMap.is( src ) )
  // return false;
  //
  // return true;
}

//


  _.objectLike = _.object.like.bind( _.object )
  /* _.objectLike = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.set.is = function is( src )
{
  if( !src )
  return false;
  return src instanceof Set || src instanceof WeakSet;
}

//


  _.set.like = function like( src )
{
  return _.set.is( src );
}

//


  _.setIs = _.set.is.bind( _.set )
  _.setLike = _.set.like.bind( _.set )
  /* _.setIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.setLike = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.map.is = function is( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return true;

  if( proto === Object.prototype )
  {
    if( src[ Symbol.iterator ] )
    return Object.prototype.toString.call( src ) !== '[object Arguments]';
    return true;
  }

  return false;
}

//


  _.map.isPure = function isPure( src )
{
  if( !src )
  return false;

  if( Object.getPrototypeOf( src ) === null )
  return true;

  return false;
}

//


  _.map.isPolluted = function isPolluted( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return false;

  if( proto === Object.prototype )
  {
    if( src[ Symbol.iterator ] )
    return Object.prototype.toString.call( src ) !== '[object Arguments]';
    return true;
  }

  return false;
}

//


  _.map.sureHasAll = function sureHasAll( srcMap, all, msg )
{

  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  let but = Object.keys( _.mapBut_( null, all, srcMap ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should have fields :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//


  _.map.sureHasOnly = function sureHasOnly( srcMap, screenMaps, msg )
{
  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  /* qqq : for Dmytro : bad ! */
  // let but = Object.keys( _.mapBut_( null, srcMap, screenMaps ) );
  let but = Object.keys( _.mapButOld( srcMap, screenMaps ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    err = _._err
    ({
      args : [ `${ _.entity.strType( srcMap ) } should have no fields :`, _.strQuote( but ).join( ', ' ) ],
      level : 2,
    });
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//


  _.map.sureHasNoUndefine = function sureHasNoUndefine( srcMap, msg )
{

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3, 'Expects one, two or three arguments' )

  let but = [];

  for( let s in srcMap )
  if( srcMap[ s ] === undefined )
  but.push( s );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 1 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should have no undefines, but has :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 1; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//


  _.map.assertHasOnly = function assertHasOnly( srcMap, screenMaps, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureHasOnly.apply( this, arguments );

  /* */

  // _.assert( 2 <= arguments.length && arguments.length <= 4, 'Expects two, three or four arguments' );
  //
  // let but = mapButKeys( srcMap, screenMaps );
  //
  // if( but.length > 0 )
  // {
  //   let err;
  //   let msgKeys = _.strQuote( but ).join( ', ' );
  //   if( arguments.length === 2 )
  //   err = errFromArgs([ `${ _.entity.strType( srcMap ) } should have no fields : ${ msgKeys }` ]);
  //   else
  //   err = errFromArgs([ msgMake( arguments ), msgKeys ]);
  //   throw err;
  // }
  //
  // return true;
  //
  // /* */
  //
  // function mapButKeys( srcMap, butMap )
  // {
  //   let result = [];
  //   _.assert( !_.primitive.is( srcMap ), 'Expects map {-srcMap-}' );
  //
  //   /* aaa : allow and cover vector */ /* Dmytro : this inlining is not needed, that was mistake */
  //   if( _.vector.is( butMap ) )
  //   {
  //     /* aaa : for Dmytro : bad */ /* Dmytro : this inlining is not needed, that was mistake */
  //     for( let s in srcMap )
  //     {
  //       let m;
  //       for( m = 0 ; m < butMap.length ; m++ )
  //       {
  //         /* aaa : for Dmytro : was bad implementation. cover */ /* Dmytro : this inlining is not needed, that was mistake */
  //         if( _.primitive.is( butMap[ m ] ) )
  //         {
  //           if( s === butMap[ m ] )
  //           break;
  //         }
  //         else
  //         {
  //           if( s in butMap[ m ] )
  //           break;
  //         }
  //       }
  //
  //       if( m === butMap.length )
  //       result.push( s );
  //     }
  //   }
  //   else if( !_.primitive.is( butMap ) )
  //   {
  //     for( let s in srcMap )
  //     {
  //       if( !( s in butMap ) )
  //       result.push( s );
  //     }
  //   }
  //   else
  //   {
  //     _.assert( 0, 'Expects object-like or long-like {-butMap-}' );
  //   }
  //
  //   return result;
  // }
  //
  // /* */
  //
  // function errFromArgs( args )
  // {
  //   return _._err
  //   ({
  //     args,
  //     level : 2,
  //   });
  // }
  //
  // /* */
  //
  // function msgMake( args )
  // {
  //   let arr = [];
  //   for( let i = 2; i < args.length; i++ )
  //   {
  //     if( _.routineIs( args[ i ] ) )
  //     args[ i ] = args[ i ]();
  //     arr.push( args[ i ] );
  //   }
  //   return arr.join( ' ' );
  // }
}

//


  _.map.assertHasNoUndefine = function assertHasNoUndefine( srcMap, msg )
{
  if( Config.debug === false )
  return true;

  /* */

  _.assert( 1 <= arguments.length && arguments.length <= 3, 'Expects one, two or three arguments' )
  _.assert( !_.primitive.is( srcMap ) );

  let but = [];

  for( let s in srcMap )
  if( srcMap[ s ] === undefined )
  but.push( s );

  if( but.length > 0 )
  {
    let msgKeys = _.strQuote( but ).join( ', ' );
    if( arguments.length === 1 )
    throw errFromArgs([ `${ _.entity.strType( srcMap ) } should have no undefines, but has : ${ msgKeys }` ]);
    else
    throw errFromArgs([ msgMake( arguments ), msgKeys ])
  }

  return true;

  /* */

  function errFromArgs( args )
  {
    return _._err
    ({
      args,
      level : 2,
    });
  }

  /* */

  function msgMake( args )
  {
    let arr = [];
    for( let i = 1 ; i < args.length ; i++ )
    {
      if( _.routine.is( args[ i ] ) )
      args[ i ] = args[ i ]();
      arr.push( args[ i ] );
    }
    return arr.join( ' ' );
  }
}

//


  _.map.extend = function extend( dstMap, srcMap )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  if( arguments.length === 2 )
  {
    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    return Object.assign( dstMap, srcMap );
  }

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    let srcMap = arguments[ a ];

    _.assert( !_.primitive.is( srcMap ), 'Expects non-primitive' );

    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    Object.assign( dstMap, srcMap );
    else
    this._extendWithProps( dstMap, srcMap );

  }

  return dstMap;
}

//


  _.map.supplement = function supplement( dstMap, srcMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    srcMap = arguments[ a ];
    this._supplementWithProps( dstMap, srcMap );
  }

  return dstMap
}

//


  _.mapIs = _.map.is.bind( _.map )
  _.mapIsPure = _.map.isPure.bind( _.map )
  _.mapIsPolluted = _.map.isPolluted.bind( _.map )
  _.mapExtend = _.map.extend.bind( _.map )
  _.mapSupplement = _.map.supplement.bind( _.map )
  /* _.mapIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.mapExtend = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.mapSupplement = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.hashMap.is = function is( src )
{
  if( !src )
  return false;
  return src instanceof HashMap || src instanceof HashMapWeak;
}

//


  _.hashMap.like = function like( src )
{
  return _.hashMap.is( src );
}

//


  _.hashMapIs = _.hashMap.is.bind( _.hashMap )
  _.hashMapLike = _.hashMap.like.bind( _.hashMap )
  /* _.hashMapIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.hashMapLike = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.countable.is = function is( src )
{

  if( _.arrayIs( src ) )
  return true;

  if( _.primitive.is( src ) )
  return false;

  // if( _.routine.like( _.class.methodIteratorOf( src ) ) )
  // if( !_.mapIs( src ) )
  if( _.class.methodIteratorOf( src ) !== undefined ) /* qqq : for Junior : cover please */
  return true;

  return false;
}

//


  _.countable.like = function like( src )
{
  return _.countable.is( src );
}

//


  _.countableIs = _.countable.is.bind( _.countable )
  /* _.countableIs = function () { [native code] }

//

 */

  _.symbol.is = function is( src )
{
  let result = Object.prototype.toString.call( src ) === '[object Symbol]';
  return result;
}

//



  _.routine._is = function _is( src, typeStr )
{
  return typeStr === '[object Function]' || typeStr === '[object AsyncFunction]';
}

//


  _.routine.is = function is( src )
{
  let typeStr = Object.prototype.toString.call( src );
  return _.routine._is( src, typeStr );
}

//


  _.routine._like = function _like( src, typeStr )
{
  return typeStr === '[object Function]' || typeStr === '[object AsyncFunction]' || typeStr === '[object GeneratorFunction]' || typeStr === '[object AsyncGeneratorFunction]';
}

//


  _.routine.like = function like( src )
{
  let typeStr = Object.prototype.toString.call( src );
  return _.routine._like( src, typeStr );
}

//


  var __mapButKeys = function __mapButKeys( srcMap, butMap )
{
  let result = [];

  for( let s in srcMap )
  if( !( s in butMap ) )
  result.push( s );

  return result;
}

//

var __mapUndefinedKeys = function __mapUndefinedKeys( srcMap )
{
  let result = [];

  for( let s in srcMap )
  if( srcMap[ s ] === undefined )
  result.push( s );

  return result;
}

//

var __keysQuote = function __keysQuote( keys )
{
  let result = `"${ keys[ 0 ] }"`;
  for( let i = 1 ; i < keys.length ; i++ )
  result += `, "${ keys[ i ] }"`;
  return result.trim();
}

//

var __primitiveLike = function __primitiveLike( src )
{
  if( _.primitive.is( src ) )
  return true;
  if( _.regexpIs( src ) )
  return true;
  if( _.routineIs( src ) )
  return true;
  return false;
}

//

var __strType = function __strType( src )
{
  if( _.strType )
  return _.strType( src );
  return String( src );
}

//

var __mapSupplementWithoutUndefined = function __mapSupplementWithoutUndefined( dstMap, srcMap )
{
  for( let k in srcMap )
  {
    if( Config.debug )
    _.assert
    (
      __primitiveLike( srcMap[ k ] ),
      () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( srcMap[ k ] ) }`
    );
    if( dstMap[ k ] !== undefined )
    continue;
    dstMap[ k ] = srcMap[ k ];
  }
}

//

_.routine.optionsWithoutUndefined = function optionsWithoutUndefined( routine, options )
{

  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    if( options.length === 0 )
    options = Object.create( null )
    else
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  if( options === null || options === undefined )
  options = Object.create( null );

  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  // if( options === undefined ) /* qqq : for Dmytro : bad : should be error */
  // options = Object.create( null );
  // if( defaults === null )
  // defaults = Object.create( null );

  // let name = _.routineIs( defaults ) ? defaults.name : '';
  // defaults = ( _.routineIs( defaults ) && defaults.defaults ) ? defaults.defaults : defaults;
  // _.assert( _.aux.is( defaults ), 'Expects defined defaults' );

  /* */

  if( Config.debug )
  {
    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );
  }

  __mapSupplementWithoutUndefined( options, defaults );

  if( Config.debug )
  {
    let undefineKeys = __mapUndefinedKeys( options );
    _.assert
    (
      undefineKeys.length === 0,
      () => `Options map for routine "${ name }" should have no undefined fields, but it does have ${ __keysQuote( undefineKeys ) }`
    );
  }

  return options;
}

//


  _.routine.isTrivial = ( function routineIsTrivial_functor()
{

  const syncPrototype = Object.getPrototypeOf( Function );
  const asyncPrototype = Object.getPrototypeOf( _async );
  return routineIsTrivial;

  function routineIsTrivial( src )
  {
    if( !src )
    return false;
    let prototype = Object.getPrototypeOf( src );
    if( prototype === syncPrototype )
    return true;
    if( prototype === asyncPrototype )
    return true;
    return false;
  }

  async function _async()
  {
  }

} )();

//


  _.routine.extend = function extendCloning( dst, ... srcs )
{

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  return _.routine._amend
  ({
    dst,
    srcs : [ ... srcs ],
    strategy : 'cloning',
    amending : 'extending',
  });

}

//


  _.routine.__mapButKeys = undefined;

//


  _.routine.__mapUndefinedKeys = undefined;

//


  _.routine.__mapSupplementWithoutUndefined = undefined;

//


  _.routine.__mapSupplementWithUndefined = undefined;

//


  _.routine.__keysQuote = undefined;

//


  _.routine.__strType = undefined;

//


  _.routine.__primitiveLike = undefined;

//


  _._routineIs = _.routine._is.bind( _.routine )
  _.routineIs = _.routine.is.bind( _.routine )
  _._routineLike = _.routine._like.bind( _.routine )
  _.routineLike = _.routine.like.bind( _.routine )
  _.routineIsTrivial = _.routine.isTrivial.bind( _.routine )
  _.routineExtend = _.routine.extend.bind( _.routine )
  /* _._routineIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.routineIs = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _._routineLike = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.routineLike = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.routineIsTrivial = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.routineExtend = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.regexp.is = function is( src )
{
  return Object.prototype.toString.call( src ) === '[object RegExp]';
}

//


  _.regexp.like = function like( src )
{
  if( src instanceof RegExp || Object.prototype.toString.call( src ) === '[object String]' )
  return true;
  return false;
}

//



  _.props.is = function is( src )
{
  if( src === null )
  return false;
  if( src === undefined )
  return false;
  return true;
}

//


  _.props.like = function like( src )
{
  return _.props.is( src );
}

//


  _.props._ofAct = function _ofAct( o )
{
  let result = Object.create( null );

  _.routine.options( _ofAct, o );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this === _.props );
  _.assert( this.like( o.srcMap ) );

  let keys = this._keys( o );

  for( let k = 0 ; k < keys.length ; k++ )
  {
    result[ keys[ k ] ] = o.srcMap[ keys[ k ] ];
  }

  return result;
}
_.props._ofAct.defaults =
{
  "srcMap" : null,
  "onlyOwn" : 0,
  "onlyEnumerable" : 1,
  "selectFilter" : null
}

//


  _.props.fields = function fields( srcMap, o )
{

  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( fields, o || null );

  o.srcMap = srcMap;
  o.selectFilter = function selectRoutine( srcMap, k )
  {
    if( !_.routine.is( srcMap[ k ] ) )
    return k;
  }

  let result = _.props._ofAct( o );
  return result;
}
_.props.fields.defaults =
{ "onlyOwn" : 0, "onlyEnumerable" : 1 }

//


  _.props._keys = function _keys( o )
{
  let result = [];

  _.routine.options( _keys, o );

  let srcMap = o.srcMap;
  let selectFilter = o.selectFilter;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this.like( srcMap ) );
  _.assert( selectFilter === null || _.routine.is( selectFilter ) );

  /* */

  if( o.onlyEnumerable )
  {
    let result1 = [];

    if( o.onlyOwn )
    {
      for( let k in srcMap )
      if( Object.hasOwnProperty.call( srcMap, k ) )
      result1.push( k );
    }
    else
    {
      for( let k in srcMap )
      result1.push( k );
    }

    filter( srcMap, result1 );

  }
  else
  {

    if( o.onlyOwn  )
    {
      filter( srcMap, Object.getOwnPropertyNames( srcMap ) );
    }
    else
    {
      let proto = srcMap;
      result = [];
      do
      {
        filter( proto, Object.getOwnPropertyNames( proto ) );
        proto = Object.getPrototypeOf( proto );
      }
      while( proto );
    }

  }

  return result;

  /* */

  function filter( srcMap, keys )
  {

    if( !selectFilter )
    {
      /* qqq : for junior : rewrite without arrayAppend and without duplicating array */
      arrayAppendArrayOnce( result, keys );
    }
    else for( let k = 0 ; k < keys.length ; k++ )
    {
      let e = selectFilter( srcMap, keys[ k ] );
      if( e !== undefined )
      arrayAppendOnce( result, e );
      /* qqq : for junior : rewrite without arrayAppend and without duplicating array */
    }

  }

  /* */

  function arrayAppendOnce( dst, element )
  {
    let i = dst.indexOf( element );
    if( i === -1 )
    dst.push( element );
    return dst;
  }

  /* */

  function arrayAppendArrayOnce( dst, src )
  {
    src.forEach( ( element ) =>
    {
      let i = dst.indexOf( element );
      if( i === -1 )
      dst.push( element );
    });
    return dst;
  }

  /* */

}
_.props._keys.defaults =
{
  "srcMap" : null,
  "onlyOwn" : 0,
  "onlyEnumerable" : 1,
  "selectFilter" : null
}

//


  _.props.keys = function keys( srcMap, o )
{
  let result;

  // _.assert( this === _.object );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( keys, o || null );
  // _.assert( !_.primitive.is( srcMap ) );

  o.srcMap = srcMap;

  result = this._keys( o );

  return result;
}
_.props.keys.defaults =
{ "onlyOwn" : 0, "onlyEnumerable" : 1 }

//


  _.props.own = function own( src, key )
{
  // if( src === null )
  // return false;
  // if( src === undefined )
  // return false;
  if( _.primitive.is( src ) )
  return false;
  return Object.hasOwnProperty.call( src, key );
}

//


  _.props.onlyOwnKeys = function onlyOwnKeys( srcMap, o )
{
  let result;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyOwnKeys, o || null );
  _.assert( this.like( srcMap ) );

  o.srcMap = srcMap;
  o.onlyOwn = 1;

  result = this._keys( o );

  if( !o.onlyEnumerable )
  debugger;

  return result;
}
_.props.onlyOwnKeys.defaults =
{ "onlyEnumerable" : 1 }

//


  _.props._extendWithProps = function _extendWithProps( dstMap, src )
{
  for( let k in src )
  dstMap[ k ] = src[ k ];
  return dstMap;
}

//


  _.props.extend = function extend( dstMap, srcMap )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  if( arguments.length === 2 )
  {
    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    return Object.assign( dstMap, srcMap );
  }

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    let srcMap = arguments[ a ];

    _.assert( !_.primitive.is( srcMap ), 'Expects non-primitive' );

    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    Object.assign( dstMap, srcMap );
    else
    this._extendWithProps( dstMap, srcMap );

  }

  return dstMap;
}

//


  _.props._supplementWithProps = function _supplementWithProps( dstMap, src )
{
  for( let k in src )
  if( !( k in dstMap ) )
  dstMap[ k ] = src[ k ];
  return dstMap;
}

//


  _.props.supplement = function supplement( dstMap, srcMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    srcMap = arguments[ a ];
    this._supplementWithProps( dstMap, srcMap );
  }

  return dstMap
}

//



  _.strIs = function is( src )
{
  let result = Object.prototype.toString.call( src ) === '[object String]';
  return result;
}

//


  _.strDefined = function defined( src )
{
  if( !src )
  return false;
  let result = Object.prototype.toString.call( src ) === '[object String]';
  return result;
}

//


  _._strBeginOf = function _beginOf( src, begin )
{

  // _.assert( _.strIs( src ), 'Expects string' );
  // _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.strIs( begin ) )
  {
    if( src.lastIndexOf( begin, 0 ) === 0 )
    return begin;
  }
  else if( _.regexpIs( begin ) )
  {
    let matched = begin.exec( src );
    if( matched && matched.index === 0 )
    return matched[ 0 ];
  }
  else _.assert( 0, 'Expects string-like ( string or regexp )' );

  return undefined;
}

//


  _._strEndOf = function _endOf( src, end )
{

  // _.assert( _.strIs( src ), 'Expects string' );
  // _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.strIs( end ) )
  {
    if( src.indexOf( end, src.length - end.length ) !== -1 )
    return end;
  }
  else if( _.regexpIs( end ) )
  {
    // let matched = end.exec( src );
    let newEnd = RegExp( end.toString().slice(1, -1) + '$' );
    let matched = newEnd.exec( src );

    //if( matched && matched.index === 0 )
    if( matched && matched.index + matched[ 0 ].length === src.length )
    return matched[ 0 ];
  }
  else _.assert( 0, 'Expects string-like ( string or regexp )' );

  return undefined;
}

//


  _._strRemovedBegin = function _removedBegin( src, begin )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );

  let result = src;
  let beginOf = _._strBeginOf( result, begin );
  if( beginOf !== undefined )
  result = result.substr( beginOf.length, result.length );

  return result;
}

//


  _._strRemovedEnd = function _removedEnd( src, end )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );

  let result = src;
  let endOf = _._strEndOf( result, end );
  if( endOf !== undefined )
  result = result.substr( 0, result.length - endOf.length );

  return result;
}

//


  _.strBegins = function begins( src, begin )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( begin ) || _.regexpIs( begin ) || _.longIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( begin ) )
  {
    let result = _._strBeginOf( src, begin );
    return !( result === undefined );
    // return result === undefined ? false : true;
  }

  for( let b = 0, blen = begin.length ; b < blen; b++ )
  {
    let result = _._strBeginOf( src, begin[ b ] );
    if( result !== undefined )
    return true;
  }

  return false;
}

//


  _.strEnds = function ends( src, end )
{

  _.assert( _.strIs( src ), () => `Expects argument::src of type::string, but got ${_.entity.strType( src )}` );
  _.assert( _.strIs( end ) || _.regexpIs( end ) || _.longIs( end ), 'Expects string/regexp or array of strings/regexps {-end-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( end ) )
  {
    let result = _._strEndOf( src, end );
    return !( result === undefined );
  }

  for( let b = 0, blen = end.length ; b < blen; b++ )
  {
    let result = _._strEndOf( src, end[ b ] );
    if( result !== undefined )
    return true;
  }

  return false;
}

//


  _.strRemoveBegin = function removeBegin( src, begin )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( src ) || _.strIs( src ), 'Expects string or array of strings {-src-}' );
  _.assert( _.longIs( begin ) || _.strIs( begin ) || _.regexpIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );

  let result = [];
  let srcIsArray = _.longIs( src );

  if( _.strIs( src ) && !_.longIs( begin ) )
  return _._strRemovedBegin( src, begin );

  src = _.array.as( src );
  begin = _.array.as( begin );
  for( let s = 0, slen = src.length ; s < slen ; s++ )
  {
    let beginOf = undefined;
    let src1 = src[ s ]
    for( let b = 0, blen = begin.length ; b < blen ; b++ )
    {
      beginOf = _._strBeginOf( src1, begin[ b ] );
      if( beginOf !== undefined )
      break;
    }
    if( beginOf !== undefined )
    src1 = src1.substr( beginOf.length, src1.length );
    result[ s ] = src1;
  }

  if( !srcIsArray )
  return result[ 0 ];

  return result;
}

//


  _.strRemoveEnd = function removeEnd( src, end )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( src ) || _.strIs( src ), 'Expects string or array of strings {-src-}' );
  _.assert( _.longIs( end ) || _.strIs( end ) || _.regexpIs( end ), 'Expects string/regexp or array of strings/regexps {-end-}' );

  let result = [];
  let srcIsArray = _.longIs( src );

  if( _.strIs( src ) && !_.longIs( end ) )
  return _._strRemovedEnd( src, end );

  src = _.array.as( src );
  end = _.array.as( end );

  for( let s = 0, slen = src.length ; s < slen ; s++ )
  {
    let endOf = undefined;
    let src1 = src[ s ]
    for( let b = 0, blen = end.length ; b < blen ; b++ )
    {
      endOf = _._strEndOf( src1, end[ b ] );
      if( endOf !== undefined )
      break;
    }
    if( endOf !== undefined )
    src1 = src1.substr( 0, src1.length - endOf.length );
    result[ s ] = src1;
  }

  if( !srcIsArray )
  return result[ 0 ];

  return result;
}

//


  _.regexpIs = function is( src )
{
  return Object.prototype.toString.call( src ) === '[object RegExp]';
}

//


  _.symbolIs = function is( src )
{
  let result = Object.prototype.toString.call( src ) === '[object Symbol]';
  return result;
}

//


  _.strBegins = function begins( src, begin )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( begin ) || _.regexpIs( begin ) || _.longIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( begin ) )
  {
    let result = _._strBeginOf( src, begin );
    return !( result === undefined );
    // return result === undefined ? false : true;
  }

  for( let b = 0, blen = begin.length ; b < blen; b++ )
  {
    let result = _._strBeginOf( src, begin[ b ] );
    if( result !== undefined )
    return true;
  }

  return false;
}

//


  _.object.isBasic = function isBasic( src )
{
  return Object.prototype.toString.call( src ) === '[object Object]';
}

//


  _.boolLike = function like( src )
{
  return src === true || src === false || src === 0 || src === 1;
  // let type = Object.prototype.toString.call( src );
  // return type === '[object Boolean]' || src === 0 || src === 1;
}

//


  _.bool.like = function like( src )
{
  return src === true || src === false || src === 0 || src === 1;
  // let type = Object.prototype.toString.call( src );
  // return type === '[object Boolean]' || src === 0 || src === 1;
}

//


  _.boolLikeTrue = function likeTrue( src )
{
  if( !_.bool.like( src ) )
  return false;
  return !!src;
}

//


  _.bool.likeTrue = function likeTrue( src )
{
  if( !_.bool.like( src ) )
  return false;
  return !!src;
}

//


  _.numberIsFinite = function numberIsFinite( src )
{
  if( !_.number.is( src ) )
  return false;
  return isFinite( src );
}

//


  _.numberIs = function is( src )
{
  return typeof src === 'number';
  return Object.prototype.toString.call( src ) === '[object Number]';
}

//


  _.intIs = function intIs( src )
{

  if( !_.number.is( src ) || !_.number.isFinite( src ) )
  return false;

  return Math.floor( src ) === src;
}

//


  _.sure = function sure( condition, ... args )
{

  if( !condition || !__boolLike( condition ) )
  {
    _sureDebugger( condition );
    if( !_._err )
    throw Error( ... args );
    if( arguments.length === 1 )
    throw _._err
    ({
      args : [ 'Assertion fails' ],
      level : 2,
    });
    else if( arguments.length === 2 )
    throw _._err
    ({
      args : [ arguments[ 1 ] ],
      level : 2,
    });
    else
    throw _._err
    ({
      args : Array.prototype.slice.call( arguments, 1 ),
      level : 2,
    });
  }

  return;
}

//


  _.mapBut_ = function mapBut_( dstMap, srcMap, butMap )
{
  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );

  if( dstMap === null )
  dstMap = arguments[ 0 ] = arguments[ 0 ] || Object.create( null );

  _.assert( arguments.length === 3, 'Not clear how to construct {-dstMap-}. Please, specify exactly 3 arguments' );
  // if( arguments.length === 2 )
  // {
  //   butMap = arguments[ 1 ];
  //   srcMap = arguments[ 0 ];
  // }

  /* */

  let o =
  {
    dstMap,
    srcMap,
    butMap,
  };

  o = _._mapBut_VerifyMapFields( o );

  let mapsAreIdentical = o.dstMap === o.srcMap ? 1 : 0;
  let butMapsIsCountable = _.countable.is( o.butMap ) ? 2 : 0;
  let filterRoutines =
  [
    filterNotIdenticalWithAuxScreenMap,
    filterIdenticalWithAuxScreenMap,
    filterNotIdenticalWithVectorScreenMap,
    filterIdenticalWithVectorScreenMap
  ];
  let key = mapsAreIdentical + butMapsIsCountable;
  let filterRoutine = filterRoutines[ key ];
  let searchingRoutine;
  if( butMapsIsCountable )
  searchingRoutine = _screenMapSearchingRoutineFunctor( o.butMap );

  for( let key in o.srcMap )
  filterRoutine( key );

  return o.dstMap;

  /* */

  function filterNotIdenticalWithAuxScreenMap( key )
  {
    if( !( key in o.butMap ) )
    o.dstMap[ key ] = o.srcMap[ key ];
  }

  /* */

  function filterIdenticalWithAuxScreenMap( key )
  {
    if( key in o.butMap )
    delete o.dstMap[ key ];
  }

  /* */

  function filterNotIdenticalWithVectorScreenMap( key )
  {
    let butKey = searchingRoutine( o.butMap, key );
    if( butKey !== undefined )
    return;

    o.dstMap[ key ] = o.srcMap[ key ];
  }

  /* */

  function filterIdenticalWithVectorScreenMap( key )
  {
    let butKey = searchingRoutine( o.butMap, key );
    if( butKey !== undefined )
    delete o.dstMap[ key ];
  }

  // let filter = _.props.conditionFrom( filterBut );
  //
  // return _._mapBut_
  // ({
  //   filter,
  //   dstMap,
  //   srcMap,
  //   butMap,
  // });
  //
  // /* */
  //
  // /* qqq : for Dmytro : bad : not optimal */
  // function filterBut( butMap, srcMap, key )
  // {
  //   if( _.aux.is( butMap ) )
  //   {
  //     if( !( key in butMap ) )
  //     return key;
  //   }
  //   else if( _.primitive.is( butMap ) )
  //   {
  //     if( key !== butMap )
  //     return key;
  //   }
  // }
  // filterBut.identity = { propertyCondition : true, propertyTransformer : true };
  //
  // _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );
  // _.assert( !_.primitive.is( dstMap ), 'Expects map like destination map {-dstMap-}' );
  // _.assert( !_.primitive.is( srcMap ) || _.longIs( srcMap ), 'Expects long or map {-srcMap-}' );
  // _.assert( !_.primitive.is( butMap ) || _.longIs( butMap ) || _.routineIs( butMap ), 'Expects object like {-butMap-}' );
  //
  // if( dstMap === srcMap )
  // {
  //
  //   /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  //   if( _.vector.is( butMap ) )
  //   {
  //     /* aaa : for Dmytro : bad */ /* Dmytro : for butMap types implemented two cyles. Types of elements is checked in filters */
  //     for( let s in srcMap )
  //     {
  //       for( let m = 0 ; m < butMap.length ; m++ )
  //       {
  //         /* aaa : for Dmytro : write GOOD coverage */ /* Dmytro : coverage extended */
  //         if( _.aux.is( butMap[ m ] ) )
  //         {
  //           if( s in butMap[ m ] )
  //           delete dstMap[ s ];
  //         }
  //         else
  //         {
  //           if( s === butMap[ m ] )
  //           delete dstMap[ s ];
  //         }
  //       }
  //     }
  //   }
  //   else
  //   {
  //     for( let s in srcMap )
  //     {
  //       if( s in butMap )
  //       delete dstMap[ s ];
  //     }
  //   }
  //
  // }
  // else
  // {
  //
  //   /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  //   if( _.vector.is( butMap ) )
  //   {
  //     /* aaa : for Dmytro : bad */ /* Dmytro : for butMap types implemented two cyles. Types of elements is checked in filters */
  //     for( let s in srcMap )
  //     {
  //       let m;
  //       for( m = 0 ; m < butMap.length ; m++ )
  //       {
  //         /* aaa : for Dmytro : was bad implementation. cover */ /* Dmytro : improved, implemented, covered */
  //         if( _.primitiveIs( butMap[ m ] ) )
  //         {
  //           if( s === butMap[ m ] )
  //           break;
  //         }
  //         else
  //         {
  //           if( s in butMap[ m ] )
  //           break;
  //         }
  //       }
  //
  //       if( m === butMap.length )
  //       dstMap[ s ] = srcMap[ s ];
  //     }
  //   }
  //   else
  //   {
  //     for( let s in srcMap )
  //     {
  //       if( !( s in butMap ) )
  //       dstMap[ s ] = srcMap[ s ];
  //     }
  //   }
  //
  // }
  //
  // return dstMap;
}

//


  _.mapButOld = function mapButOld( srcMap, butMap )
{
  let result = Object.create( null );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( srcMap ), 'Expects map {-srcMap-}' );

  /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  if( _.countable.is( butMap ) )
  {
    let filterRoutines = [ filterWithVectorButMap, filterWithArrayLikeButMap ];
    let arrayLikeIs = _.argumentsArray.like( butMap ) ? 1 : 0;
    for( let s in srcMap )
    {
      let butKey = filterRoutines[ arrayLikeIs ]( s );
      if( butKey === undefined )
      result[ s ] = srcMap[ s ];
    }

    // /* aaa : for Dmytro : bad */ /* Dmytro : improved, used checks with types */
    // for( let s in srcMap )
    // {
    //   let m;
    //   for( m = 0 ; m < butMap.length ; m++ )
    //   {
    //     /* aaa : for Dmytro : write GOOD coverage */ /* Dmytro : coverage extended */
    //     if( _.primitive.is( butMap[ m ] ) )
    //     {
    //       if( s === butMap[ m ] )
    //       break;
    //     }
    //     else
    //     {
    //       if( s in butMap[ m ] )
    //       break;
    //     }
    //     //
    //     // if( s === butMap[ m ] )
    //     // break;
    //     // if( _.aux.is( butMap[ m ] ) )
    //     // if( s in butMap[ m ] )
    //     // break;
    //   }
    //
    //   if( m === butMap.length )
    //   result[ s ] = srcMap[ s ];
    // }
  }
  else if( !_.primitive.is( butMap ) )
  {
    for( let s in srcMap )
    {
      if( !( s in butMap ) )
      result[ s ] = srcMap[ s ];
    }
  }
  else
  {
    _.assert( 0, 'Expects object-like or long-like {-butMap-}' ); /* xxx */
  }

  return result;

  /* */

  function filterWithVectorButMap( s )
  {
    for( let but of butMap )
    {
      if( _.primitive.is( but ) )
      {
        if( s === but )
        return s;
      }
      else if( _.aux.is( but ) )
      {
        if( s in but )
        return s;
      }
      else
      {
        _.assert( 0, 'Unexpected type of element' );
      }
    }
  }

  /* */

  function filterWithArrayLikeButMap( s )
  {
    for( let m = 0 ; m < butMap.length ; m++ )
    {
      if( _.primitive.is( butMap[ m ] ) )
      {
        if( s === butMap[ m ] )
        return s;
      }
      else if( _.aux.is( butMap[ m ] ) )
      {
        if( s in butMap[ m ] )
        return s;
      }
      else
      {
        _.assert( 0, 'Unexpected type of element' );
      }
    }
  }
}

//

 // xxx : remove
  _.mapOwn = function mapOwnKey( srcMap, key )
{
  // if( srcMap === null )
  // return false;
  // if( srcMap === undefined )
  // return false;
  if( _.primitive.is( srcMap ) )
  return false;
  return Object.hasOwnProperty.call( srcMap, key );
}

//


  _.mapOnly_ = function mapOnly_( dstMap, srcMaps, screenMaps )
{


  if( arguments.length === 1 )
  return _.mapsExtend( null, dstMap );

  _.assert( arguments.length === 3, 'Not clear how to construct {-dstMap-}. Please, specify exactly 3 arguments' );

  // else if( arguments.length === 2 )
  // {
  //
  //   // return _.mapOnlyOld( srcMaps, screenMaps );
  //
  //   // aaa : for Dmytro : bad! /* Dmytro : this condition allow modify srcMaps if passed only 2 arguments */
  //   if( dstMap === null )
  //   return Object.create( null );
  //   screenMaps = arguments[ 1 ];
  //   srcMaps = arguments[ 0 ];
  // }
  // else if( arguments.length !== 3 )
  // {
  //   _.assert( 0, 'Expects at least one argument and no more then three arguments' );
  // }

  let o = _._mapOnly_VerifyMapFields
  ({
    srcMaps,
    screenMaps,
    dstMap : dstMap || Object.create( null ),
  });

  let mapsAreIdentical = o.dstMap === o.srcMaps ? 1 : 0;
  let screenMapsIsCountable = _.countable.is( o.screenMaps ) ? 2 : 0;
  let filterRoutines =
  [
    filterNotIdenticalWithAuxScreenMap,
    filterIdenticalWithAuxScreenMap,
    filterNotIdenticalWithVectorScreenMap,
    filterIdenticalWithVectorScreenMap
  ];
  let key = mapsAreIdentical + screenMapsIsCountable;
  let filterRoutine = filterRoutines[ key ];
  let searchingRoutine;
  if( screenMapsIsCountable )
  searchingRoutine = _screenMapSearchingRoutineFunctor( o.screenMaps );

  if( _.countable.is( o.srcMaps ) )
  {
    for( let srcMap of o.srcMaps )
    {
      _.assert( !_.primitive.is( srcMap ), 'Expects no primitive in {-o.srcMaps-}' );
      filterRoutine( srcMap );
    }
  }
  else
  {
    filterRoutine( o.srcMaps );
  }

  return o.dstMap;

  /* */

  function filterNotIdenticalWithVectorScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      let screenKey = searchingRoutine( o.screenMaps, key );
      if( screenKey !== undefined )
      o.dstMap[ screenKey ] = srcMap[ screenKey ];
    }
  }

  /* */

  function filterIdenticalWithVectorScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      let screenKey = searchingRoutine( o.screenMaps, key );
      if( screenKey === undefined )
      delete srcMap[ key ];
    }
  }

  /* */

  function filterNotIdenticalWithAuxScreenMap( srcMap )
  {
    for( let key in o.screenMaps )
    {
      if( o.screenMaps[ key ] === undefined )
      continue;

      if( key in srcMap )
      o.dstMap[ key ] = srcMap[ key ];
    }
  }


  /* */

  function filterIdenticalWithAuxScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      if( !( key in o.screenMaps ) )
      delete srcMap[ key ];
    }
  }

  // return _.mapOnlyOld( srcMaps, screenMaps );
  // aaa : for Dmytro : bad! /* Dmytro : improved, optimized */

  // return _._mapOnly_
  // ({
  //   srcMaps,
  //   screenMaps,
  //   dstMap,
  // });

}

//


  _._mapBut_VerifyMapFields = function _mapBut_VerifyMapFields( o )
{
  _.assert( arguments.length === 1, 'Expects single options map {-o-}' );
  _.assert( !_.primitive.is( o.dstMap ), 'Expects non primitive {-o.dstMap-}' );
  _.assert( !_.primitive.is( o.srcMap ), 'Expects non primitive {-o.srcMap-}' );
  _.assert( !_.primitive.is( o.butMap ), 'Expects object like {-o.butMap-}' );
  _.assert( !_.vector.is( o.dstMap ), 'Expects aux like {-o.dstMap-}' );
  return o;
}

//


  _._mapOnly_VerifyMapFields = function _mapOnly_VerifyMapFields( o )
{
  _.assert( arguments.length === 1, 'Expects single options map {-o-}' );
  _.assert( !_.primitive.is( o.dstMap ), 'Expects non primitive {-o.dstMap-}' );
  _.assert( !_.primitive.is( o.screenMaps ), 'Expects non primitive {-o.screenMaps-}' );
  _.assert( !_.primitive.is( o.srcMaps ), 'Expects non primitive {-o.srcMaps-}' );
  _.map.assertHasOnly( o, _mapOnly_VerifyMapFields.defaults );
  _.assert( !_.vector.is( o.dstMap ), 'Expects not a vector {-o.dstMap-}' );

  return o;
}
_._mapOnly_VerifyMapFields.defaults =
{
  "dstMap" : null,
  "srcMaps" : null,
  "screenMaps" : null,
  "filter" : null
}

//


  _.arrayAs = undefined;

//


  _.arrayAppend = function arrayAppend( dstArray, ins )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayAppended.apply( this, arguments );
  return dstArray;
}

//


  _.arrayAppendArray = function arrayAppendArray( dstArray, insArray )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayAppendedArray.apply( this, arguments );
  return dstArray;
}

//


  _.arrayAppendArrays = function arrayAppendArrays( dstArray, insArray )
{

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  if( dstArray === undefined )
  {
    _.assert( arguments.length === 2 );
    return insArray;
  }

  _.arrayAppendedArrays.apply( this, arguments );

  return dstArray;
}

//


  _.arrayAppendedArray = function arrayAppendedArray( dstArray, insArray )
{
  _.assert( arguments.length === 2 )
  _.assert( _.array.is( dstArray ), 'arrayPrependedArray :', 'Expects array' );
  _.assert( _.longLike( insArray ), 'arrayPrependedArray :', 'Expects longLike' );

  let result = insArray.length;
  dstArray.push.apply( dstArray, insArray );
  return result;
}

//


  _.arrayAppendedArrays = function arrayAppendedArrays( dstArray, insArray )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longLike( insArray ) && insArray !== undefined )
  insArray = [ insArray ];

  // if( !_.longLike( insArray ) )
  // {
  //   if( !_.array.is( dstArray ) )
  //   return [ dstArray, insArray ];
  //   else
  //   dstArray.push( insArray );
  //   return 1;
  // }

  // if( !_.array.is( insArray ) && insArray !== undefined )
  // insArray = [ insArray ];
  // if( !_.array.is( insArray ) && insArray !== undefined )
  // insArray = [ insArray ];

  _.assert( _.array.is( dstArray ), 'Expects array' );
  _.assert( _.longLike( insArray ), 'Expects longLike entity' );

  let result = 0;

  for( let a = 0, len = insArray.length; a < len; a++ )
  {
    if( _.longLike( insArray[ a ] ) )
    {
      dstArray.push.apply( dstArray, insArray[ a ] );
      result += insArray[ a ].length;
    }
    else
    {
      dstArray.push( insArray[ a ] );
      result += 1;
    }
  }

  return result;
}

//


  _.arrayAppended = function arrayAppended( dstArray, ins )
{
  _.assert( arguments.length === 2 );
  _.assert( _.array.is( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
  dstArray.push( ins );
  return dstArray.length - 1;
}

//


  _.arrayAppendOnceStrictly = function arrayAppendOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    result = _.arrayAppendedOnce.apply( this, arguments );
    _.assert( result >= 0, () => `Array should have only unique elements, but has several ${ _.entity.exportStringDiagnosticShallow( ins ) }` );
  }
  else
  {
    result = _.arrayAppended.apply( this, [ dstArray, ins ] );
  }
  return dstArray;
}

//


  _.arrayAppendArrayOnce = function arrayAppendArrayOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayAppendedArrayOnce.apply( this, arguments )
  return dstArray;
}

//


  _.arrayAppendedArrayOnce = function arrayAppendedArrayOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( _.longLike( insArray ) );
  _.assert( 2 <= arguments.length && arguments.length <= 4 );

  let result = 0;

  if( dstArray === insArray )
  if( arguments.length === 2 )
  return result;

  for( let i = 0, len = insArray.length; i < len ; i++ )
  {
    if( _.longLeftIndex( dstArray, insArray[ i ], evaluator1, evaluator2 ) === -1 )
    {
      dstArray.push( insArray[ i ] );
      result += 1;
    }
  }

  return result;
}

//


  _.arrayAppendedArraysOnce = function arrayAppendedArraysOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );

  if( dstArray === undefined )
  return insArray;

  if( !_.array.is( insArray ) && insArray !== undefined )
  insArray = [ insArray ];

  _.assert( _.array.is( dstArray ), 'Expects array' );
  _.assert( _.longLike( insArray ), 'Expects longLike entity' );

  let result = 0;

  if( dstArray === insArray )
  if( arguments.length === 2 )
  return result;

  for( let a = 0, len = insArray.length; a < len; a++ )
  {
    if( _.longLike( insArray[ a ] ) )
    {
      let array = insArray[ a ];
      for( let i = 0, alen = array.length; i < alen; i++ )
      _appendOnce( array[ i ] );
    }
    else
    {
      _appendOnce( insArray[ a ] );
    }
  }

  return result;

  function _appendOnce( argument )
  {
    let index = _.longLeftIndex( dstArray, argument, evaluator1, evaluator2 );
    if( index === -1 )
    {
      dstArray.push( argument );
      result += 1;
    }
  }

}

//


  _.arrayAppendArraysOnce = function arrayAppendArraysOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }
  else if( dstArray === undefined )
  {
    if( _.array.is( insArray ) )
    {
      dstArray = [];
      arguments[ 0 ] = dstArray;
    }
    else
    {
      _.assert( 2 <= arguments.length && arguments.length <= 4 );
      return insArray;
    }
  }

  _.arrayAppendedArraysOnce.apply( this, arguments );

  return dstArray;
}

//


  _.arrayAppendedOnce = function arrayAppendedOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let i = _.longLeftIndex.apply( _, arguments );

  if( i === -1 )
  {
    dstArray.push( ins );
    return dstArray.length - 1;
  }

  return -1;
}

//


  _.arrayRemoveOnceStrictly = function arrayRemoveOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.arrayRemoveElementOnceStrictly.apply( this, arguments );
  return dstArray;
}

//


  _.arrayRemoveElementOnceStrictly = function arrayRemoveElementOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    let result = _.arrayRemovedElementOnce.apply( this, arguments );
    let index = _.longLeftIndex.apply( _, arguments );
    _.assert( index < 0 );
    _.assert( result >= 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
  }
  else
  {
    let result = _.arrayRemovedElement.apply( this, [ dstArray, ins ] );
  }
  return dstArray;
}

//


  _.arrayRemovedElement = function arrayRemovedElement( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let index = _.longLeftIndex.apply( this, arguments );
  let removedElements = 0;

  for( let i = 0; i < dstArray.length; i++ ) /* Dmytro : bad implementation, this cycle run routine longLeftIndex even if it not needs, better implementation commented below */
  {
    if( index !== -1 )
    {
      dstArray.splice( index, 1 );
      removedElements = removedElements + 1;
      i = i - 1 ;
    }
    index = _.longLeftIndex.apply( this, arguments ); /* Dmytro : this call uses not offset, it makes routine slower */
  }

  return removedElements;

  // let removedElements = 0;
  // let index = _.longLeftIndex.apply( this, arguments );
  // evaluator1 = _.number.is( evaluator1 ) ? undefined : evaluator1;
  //
  // while( index !== -1 )
  // {
  //   dstArray.splice( index, 1 );
  //   removedElements = removedElements + 1;
  //   index = _.longLeftIndex( dstArray, ins, index, evaluator1, evaluator2 );
  // }
  //
  // return removedElements;
}

//


  _.arrayRemovedElementOnce = function arrayRemovedElementOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let index = _.longLeftIndex.apply( _, arguments );
  if( index >= 0 )
  dstArray.splice( index, 1 );

  return index;
  /* "!!! : breaking" */
  /* // arrayRemovedElementOnce should return the removed element
  let result;
  let index = _.longLeftIndex.apply( _, arguments );

  if( index >= 0 )
  {
    result = dstArray[ index ];
    dstArray.splice( index, 1 );
  }

  return result;
  */
}

//


  _.longLeft = function left( /* arr, ins, fromIndex, evaluator1, evaluator2 */ )
{
  let arr = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let fromIndex = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result = Object.create( null );
  let i = _.longLeftIndex( arr, ins, fromIndex, evaluator1, evaluator2 );

  _.assert( 2 <= arguments.length && arguments.length <= 5 );

  result.index = i;

  if( i >= 0 )
  result.element = arr[ i ];

  return result;
}

//


  _.longLeftIndex = function leftIndex( /* arr, ins, evaluator1, evaluator2 */ )
{
  let arr = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let fromIndex = 0;

  if( _.number.is( arguments[ 2 ] ) )
  {
    fromIndex = arguments[ 2 ];
    evaluator1 = arguments[ 3 ];
    evaluator2 = arguments[ 4 ];
  }

  _.assert( 2 <= arguments.length && arguments.length <= 5, 'Expects 2-5 arguments: source array, element, and optional evaluator / equalizer' );
  _.assert( _.longLike( arr ), 'Expect a Long' );
  _.assert( _.number.is( fromIndex ) );
  _.assert( !evaluator1 || evaluator1.length === 1 || evaluator1.length === 2 || evaluator1.length === 3 );
  _.assert( !evaluator1 || _.routine.is( evaluator1 ) );
  _.assert( !evaluator2 || evaluator2.length === 1 );
  _.assert( !evaluator2 || _.routine.is( evaluator2 ) );

  if( !evaluator1 )
  {
    _.assert( !evaluator2 );
    return Array.prototype.indexOf.call( arr, ins, fromIndex );
  }
  else if( evaluator1.length === 1 ) /* equalizer */
  {

    if( evaluator2 )
    ins = evaluator2( ins );
    else
    ins = evaluator1( ins );

    if( arr.findIndex && fromIndex === 0 )
    {
      return arr.findIndex( ( val ) => evaluator1( val ) === ins );
    }
    else
    {
      for( let a = fromIndex; a < arr.length ; a++ )
      {
        if( evaluator1( arr[ a ] ) === ins )
        return a;
      }
    }

  }
  else /* evaluator */
  {
    _.assert( !evaluator2 );
    for( let a = fromIndex ; a < arr.length ; a++ )
    {
      if( evaluator1( arr[ a ], ins ) )
      return a;
    }
  }

  return -1;
}

//


  _.longLeftDefined = function leftDefined( arr )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  return _.longLeft( arr, true, function( val ){ return val !== undefined; } );
}

//


  _.longHas = function longHas( /* array, element, evaluator1, evaluator2 */ )
{
  let array = arguments[ 0 ];
  let element = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.argumentsArray.like( array ) );

  if( !evaluator1 && !evaluator2 )
  {
    // return _ArrayIndexOf.call( array, element ) !== -1;
    return _ArrayIncludes.call( array, element );
  }
  else
  {
    if( _.longLeftIndex( array, element, evaluator1, evaluator2 ) >= 0 )
    return true;
    return false;
  }

}

//


  _.longGrow_ = function longGrow_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval - 1 ];

  _.assert( _.longIs( dst ) || dst === null, 'Expects {-dst-} of any long type or null' );
  _.assert( _.longIs( src ), 'Expects {-src-} of any long type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] !== undefined ? cinterval[ 0 ] : 0;
  let last = cinterval[ 1 ] = cinterval[ 1 ] !== undefined ? cinterval[ 1 ] : src.length - 1;

  if( first > 0 )
  first = 0;
  if( last < src.length - 1 )
  last = src.length - 1;

  if( first < 0 )
  {
    last -= first;
    first -= first;
  }

  if( last + 1 < first )
  last = first - 1;

  let first2 = Math.max( -cinterval[ 0 ], 0 );
  let last2 = Math.min( src.length - 1 + first2, last + first2 );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.long.makeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( dst.length === resultLength )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      _.assert( Object.isExtensible( dst ), 'Array is not extensible, cannot change array' );
      dst.splice( 0, 0, ... _.dup( ins, first2 ) );
      dst.splice( last2 + 1, 0, ... _.dup( ins, resultLength <= last2 ? 0 : resultLength - last2 - 1 ) );
      return dst;
    }
    else if( dst.length !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.long.makeUndefined( dst, resultLength );
    }
  }
  else if( dst.length !== resultLength )
  {
    if( !_.arrayLikeResizable( result ) )
    result = _.bufferMakeUndefined( dst, resultLength );
    else
    result.splice( resultLength );
  }

  for( let r = first2 ; r < last2 + 1 ; r++ )
  result[ r ] = src[ r - first2 ];

  if( ins !== undefined )
  {
    for( let r = 0 ; r < first2 ; r++ )
    result[ r ] = ins;
    for( let r = last2 + 1 ; r < resultLength ; r++ )
    result[ r ] = ins;
  }

  return result;
}

//


  _.vectorAdapterIs = function adapterIs( src )
{
  return Object.prototype.toString.call( src ) === '[object VectorAdapter]';
}

//


  _.dup = function dup( ins, times, result )
{
  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );
  _.assert( _.number.is( times ) || _.longIs( times ), 'dup expects times as number or array' );

  if( _.number.is( times ) )
  {
    if( !result )
    result = new Array( times );
    for( let t = 0 ; t < times ; t++ )
    result[ t ] = ins;
    return result;
  }
  else if( _.longIs( times ) )
  {
    _.assert( times.length === 2 );
    let l = times[ 1 ] - times[ 0 ];
    if( !result )
    result = new Array( times[ 1 ] );
    for( let t = 0 ; t < l ; t++ )
    result[ times[ 0 ] + t ] = ins;
    return result;
  }
  else _.assert( 0, 'unexpected' );

}

//


  _.routine.unite = ( function() {

  const _uniteReplacing_head = function unite_head( routine, args )
  {
    let o = args[ 0 ];

    if( args[ 1 ] !== undefined )
    {
      if( args.length === 3 )
      o = { head : args[ 0 ], body : args[ 1 ], tail : args[ 2 ] };
      else
      o = { head : args[ 0 ], body : ( args.length > 1 ? args[ 1 ] : null ) };
    }

    _.routine.optionsWithoutUndefined( routine, o );
    _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
    _.assert( arguments.length === 2 );
    _.assert
    (
      o.head === null || _.numberIs( o.head ) || _.routine.is( o.head ) || _.routine.s.are( o.head )
      , 'Expects either routine, routines or number of arguments {-o.head-}'
    );
    _.assert( _.routine.is( o.body ), 'Expects routine {-o.body-}' );
    _.assert( o.tail === null || _.routine.is( o.tail ), () => `Expects routine {-o.tail-}, but got ${_.entity.strType( o.tail )}` );
    _.assert( o.body.defaults !== undefined, 'Body should have defaults' );

    return o;
  }

  const _uniteReplacing_body = function unite_body( o )
  {

    if( _.longIs( o.head ) )
    {
      /* xxx : deprecate compose */
      /* qqq : for Dmytro : implement without compose */
      // let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
      // {
      //   let args = arguments[ 0 ];
      //   let result = arguments[ 1 ];
      //   let op = arguments[ 2 ];
      //   let k = arguments[ 3 ];
      //   _.assert( arguments.length === 4 );
      //   _.assert( !_.unrollIs( result ) );
      //   _.assert( _.object.isBasic( result ) );
      //   return _.unrollAppend([ unitedRoutine, [ result ] ]);
      // });
      let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
      {
        let args = arguments[ 0 ];
        let result = arguments[ 1 ];
        let op = arguments[ 2 ];
        let k = arguments[ 3 ];
        _.assert( arguments.length === 4 );
        _.assert( !_.unrollIs( result ) );
        _.assert( _.object.isBasic( result ) );
        return _.unroll.from([ unitedRoutine, [ result ] ]);
      });
      _.assert( _.routine.is( _head ) );
      o.head = function head()
      {
        let result = _head.apply( this, arguments );
        return result[ result.length-1 ];
      }
      o.head.composed = _head.composed;
    }
    else if( _.number.is( o.head ) )
    {
      o.head = headWithNargs_functor( o.head, o.body );
    }

    if( o.head === null )
    {
      /* qqq : for Dmytro : cover please */
      if( o.body.defaults )
      o.head = headWithDefaults;
      else
      o.head = headWithoutDefaults;
    }

    if( !o.name )
    {
      _.assert( _.strDefined( o.body.name ), 'Body routine should have name' );
      o.name = o.body.name;
      if( o.name.indexOf( '_body' ) === o.name.length-5 && o.name.length > 5 )
      o.name = o.name.substring( 0, o.name.length-5 );
    }

    /* generate body */

    /* qqq : for Dmytro : cover in separate test routine */
    let body;
    if( o.strategy === 'replacing' )
    body = o.body;
    else
    body = _.routine._amend
    ({
      dst : null,
      srcs : o.body,
      strategy : o.strategy,
      amending : 'extending',
    });

    /* make routine */

    let unitedRoutine = _unite_functor( o.name, o.head, body, o.tail );

    _.assert( _.strDefined( unitedRoutine.name ), 'Looks like your interpreter does not support dynamic naming of functions. Please use ES2015 or later interpreter.' );

    /* qqq : for Dmytro : cover option::strategy */

    _.routine._amend
    ({
      dst : unitedRoutine,
      srcs : body,
      strategy : 'replacing',
      amending : 'extending',
    });

    unitedRoutine.head = o.head;
    unitedRoutine.body = body;
    if( o.tail )
    unitedRoutine.tail = o.tail;

    _.assert
    (
      unitedRoutine.defaults === body.defaults,
      'Something wrong, united routined should have same instance of defaults its body has'
    );

    return unitedRoutine;

    function headWithNargs_functor( nargs, body )
    {
      _.assert( !!o.body.defaults );
      return function headWithDefaults( routine, args )
      {
        _.assert( args.length <= nargs+1 );
        _.assert( arguments.length === 2 );
        let o = _.routine.options( routine, args[ nargs ] || Object.create( null ) );
        return _.unroll.from([ ... Array.prototype.slice.call( args, 0, nargs ), o ]);
      }
    }

    /* */

    function headWithoutDefaults( routine, args )
    {
      let o = args[ 0 ];
      _.assert( arguments.length === 2 );
      _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
      _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
      return o || null;
    }

    /* */

    function headWithDefaults( routine, args )
    {
      let o = args[ 0 ];
      _.assert( arguments.length === 2 );
      _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
      _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
      return _.routine.options( routine, o || Object.create( null ) );
    }

    /* */

    function _unite_functor()
    {
      const name = arguments[ 0 ];
      const head = arguments[ 1 ];
      const body = arguments[ 2 ];
      const tail = arguments[ 3 ];
      let r;

      _.assert( head === null || _.routineIs( head ) );
      _.assert( body === null || _.routineIs( body ) );
      _.assert( tail === null || _.routineIs( tail ) );

      if( tail === null )
      r =
      {
        [ name ] : function()
        {
          let result;
          let o = head.call( this, unitedRoutine, arguments );

          _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

          if( _.unrollIs( o ) )
          result = body.apply( this, o );
          else
          result = body.call( this, o );

          return result;
        }
      };
      else if( head === null )
      r =
      {
        [ name ] : function()
        {
          let result;
          let o = arguments[ 0 ];

          _.assert( arguments.length === 1, 'Expects single argument {-o-}.' );

          if( _.unrollIs( o ) )
          result = body.apply( this, o );
          else if( _.mapIs( o ) )
          result = body.call( this, o );
          else
          _.assert( 0, 'Unexpected type of {-o-}, expects options map or unroll.' );

          result = tail.call( this, result, o );

          return result;
        }
      };
      else
      r =
      {
        [ name ] : function()
        {
          let result;
          let o = head.call( this, unitedRoutine, arguments );

          _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

          if( _.unrollIs( o ) )
          result = body.apply( this, o );
          else
          result = body.call( this, o );

          debugger;
          result = tail.call( this, result, o );

          return result;
        }
      };

      return r[ name ]
    }
  }
  _uniteReplacing_body.defaults = {
      "head" : null,
      "body" : null,
      "tail" : null,
      "name" : null,
      "strategy" : null
    }

  const _uniteReplacing_ = function uniteReplacing()
  {
    let o = uniteReplacing.head.call( this, uniteReplacing, arguments );
    let result = uniteReplacing.body.call( this, o );
    return result;
  }
  _uniteReplacing_.head = function unite_head( routine, args )
    {
      let o = args[ 0 ];

      if( args[ 1 ] !== undefined )
      {
        if( args.length === 3 )
        o = { head : args[ 0 ], body : args[ 1 ], tail : args[ 2 ] };
        else
        o = { head : args[ 0 ], body : ( args.length > 1 ? args[ 1 ] : null ) };
      }

      _.routine.optionsWithoutUndefined( routine, o );
      _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
      _.assert( arguments.length === 2 );
      _.assert
      (
        o.head === null || _.numberIs( o.head ) || _.routine.is( o.head ) || _.routine.s.are( o.head )
        , 'Expects either routine, routines or number of arguments {-o.head-}'
      );
      _.assert( _.routine.is( o.body ), 'Expects routine {-o.body-}' );
      _.assert( o.tail === null || _.routine.is( o.tail ), () => `Expects routine {-o.tail-}, but got ${_.entity.strType( o.tail )}` );
      _.assert( o.body.defaults !== undefined, 'Body should have defaults' );

      return o;
    }
    _uniteReplacing_.body = function unite_body( o )
    {

      if( _.longIs( o.head ) )
      {
        /* xxx : deprecate compose */
        /* qqq : for Dmytro : implement without compose */
        // let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
        // {
        //   let args = arguments[ 0 ];
        //   let result = arguments[ 1 ];
        //   let op = arguments[ 2 ];
        //   let k = arguments[ 3 ];
        //   _.assert( arguments.length === 4 );
        //   _.assert( !_.unrollIs( result ) );
        //   _.assert( _.object.isBasic( result ) );
        //   return _.unrollAppend([ unitedRoutine, [ result ] ]);
        // });
        let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
        {
          let args = arguments[ 0 ];
          let result = arguments[ 1 ];
          let op = arguments[ 2 ];
          let k = arguments[ 3 ];
          _.assert( arguments.length === 4 );
          _.assert( !_.unrollIs( result ) );
          _.assert( _.object.isBasic( result ) );
          return _.unroll.from([ unitedRoutine, [ result ] ]);
        });
        _.assert( _.routine.is( _head ) );
        o.head = function head()
        {
          let result = _head.apply( this, arguments );
          return result[ result.length-1 ];
        }
        o.head.composed = _head.composed;
      }
      else if( _.number.is( o.head ) )
      {
        o.head = headWithNargs_functor( o.head, o.body );
      }

      if( o.head === null )
      {
        /* qqq : for Dmytro : cover please */
        if( o.body.defaults )
        o.head = headWithDefaults;
        else
        o.head = headWithoutDefaults;
      }

      if( !o.name )
      {
        _.assert( _.strDefined( o.body.name ), 'Body routine should have name' );
        o.name = o.body.name;
        if( o.name.indexOf( '_body' ) === o.name.length-5 && o.name.length > 5 )
        o.name = o.name.substring( 0, o.name.length-5 );
      }

      /* generate body */

      /* qqq : for Dmytro : cover in separate test routine */
      let body;
      if( o.strategy === 'replacing' )
      body = o.body;
      else
      body = _.routine._amend
      ({
        dst : null,
        srcs : o.body,
        strategy : o.strategy,
        amending : 'extending',
      });

      /* make routine */

      let unitedRoutine = _unite_functor( o.name, o.head, body, o.tail );

      _.assert( _.strDefined( unitedRoutine.name ), 'Looks like your interpreter does not support dynamic naming of functions. Please use ES2015 or later interpreter.' );

      /* qqq : for Dmytro : cover option::strategy */

      _.routine._amend
      ({
        dst : unitedRoutine,
        srcs : body,
        strategy : 'replacing',
        amending : 'extending',
      });

      unitedRoutine.head = o.head;
      unitedRoutine.body = body;
      if( o.tail )
      unitedRoutine.tail = o.tail;

      _.assert
      (
        unitedRoutine.defaults === body.defaults,
        'Something wrong, united routined should have same instance of defaults its body has'
      );

      return unitedRoutine;

      function headWithNargs_functor( nargs, body )
      {
        _.assert( !!o.body.defaults );
        return function headWithDefaults( routine, args )
        {
          _.assert( args.length <= nargs+1 );
          _.assert( arguments.length === 2 );
          let o = _.routine.options( routine, args[ nargs ] || Object.create( null ) );
          return _.unroll.from([ ... Array.prototype.slice.call( args, 0, nargs ), o ]);
        }
      }

      /* */

      function headWithoutDefaults( routine, args )
      {
        let o = args[ 0 ];
        _.assert( arguments.length === 2 );
        _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
        _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
        return o || null;
      }

      /* */

      function headWithDefaults( routine, args )
      {
        let o = args[ 0 ];
        _.assert( arguments.length === 2 );
        _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
        _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
        return _.routine.options( routine, o || Object.create( null ) );
      }

      /* */

      function _unite_functor()
      {
        const name = arguments[ 0 ];
        const head = arguments[ 1 ];
        const body = arguments[ 2 ];
        const tail = arguments[ 3 ];
        let r;

        _.assert( head === null || _.routineIs( head ) );
        _.assert( body === null || _.routineIs( body ) );
        _.assert( tail === null || _.routineIs( tail ) );

        if( tail === null )
        r =
        {
          [ name ] : function()
          {
            let result;
            let o = head.call( this, unitedRoutine, arguments );

            _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

            if( _.unrollIs( o ) )
            result = body.apply( this, o );
            else
            result = body.call( this, o );

            return result;
          }
        };
        else if( head === null )
        r =
        {
          [ name ] : function()
          {
            let result;
            let o = arguments[ 0 ];

            _.assert( arguments.length === 1, 'Expects single argument {-o-}.' );

            if( _.unrollIs( o ) )
            result = body.apply( this, o );
            else if( _.mapIs( o ) )
            result = body.call( this, o );
            else
            _.assert( 0, 'Unexpected type of {-o-}, expects options map or unroll.' );

            result = tail.call( this, result, o );

            return result;
          }
        };
        else
        r =
        {
          [ name ] : function()
          {
            let result;
            let o = head.call( this, unitedRoutine, arguments );

            _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

            if( _.unrollIs( o ) )
            result = body.apply( this, o );
            else
            result = body.call( this, o );

            debugger;
            result = tail.call( this, result, o );

            return result;
          }
        };

        return r[ name ]
      }
    }
    _uniteReplacing_.defaults = {
      "head" : null,
      "body" : null,
      "tail" : null,
      "name" : null,
      "strategy" : `replacing`
    }
  ;
_uniteReplacing_.head = _uniteReplacing_head;
_uniteReplacing_.body = _uniteReplacing_body;
  return _uniteReplacing_;
})();
_.routine.unite.defaults =
{
  "head" : null,
  "body" : null,
  "tail" : null,
  "name" : null,
  "strategy" : `replacing`
}

//


  _.routine.uniteCloning_replaceByUnite = ( function() {

  const _uniteCloning_head = function unite_head( routine, args )
  {
    let o = args[ 0 ];

    if( args[ 1 ] !== undefined )
    {
      if( args.length === 3 )
      o = { head : args[ 0 ], body : args[ 1 ], tail : args[ 2 ] };
      else
      o = { head : args[ 0 ], body : ( args.length > 1 ? args[ 1 ] : null ) };
    }

    _.routine.optionsWithoutUndefined( routine, o );
    _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
    _.assert( arguments.length === 2 );
    _.assert
    (
      o.head === null || _.numberIs( o.head ) || _.routine.is( o.head ) || _.routine.s.are( o.head )
      , 'Expects either routine, routines or number of arguments {-o.head-}'
    );
    _.assert( _.routine.is( o.body ), 'Expects routine {-o.body-}' );
    _.assert( o.tail === null || _.routine.is( o.tail ), () => `Expects routine {-o.tail-}, but got ${_.entity.strType( o.tail )}` );
    _.assert( o.body.defaults !== undefined, 'Body should have defaults' );

    return o;
  }

  const _uniteCloning_body = function unite_body( o )
  {

    if( _.longIs( o.head ) )
    {
      /* xxx : deprecate compose */
      /* qqq : for Dmytro : implement without compose */
      // let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
      // {
      //   let args = arguments[ 0 ];
      //   let result = arguments[ 1 ];
      //   let op = arguments[ 2 ];
      //   let k = arguments[ 3 ];
      //   _.assert( arguments.length === 4 );
      //   _.assert( !_.unrollIs( result ) );
      //   _.assert( _.object.isBasic( result ) );
      //   return _.unrollAppend([ unitedRoutine, [ result ] ]);
      // });
      let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
      {
        let args = arguments[ 0 ];
        let result = arguments[ 1 ];
        let op = arguments[ 2 ];
        let k = arguments[ 3 ];
        _.assert( arguments.length === 4 );
        _.assert( !_.unrollIs( result ) );
        _.assert( _.object.isBasic( result ) );
        return _.unroll.from([ unitedRoutine, [ result ] ]);
      });
      _.assert( _.routine.is( _head ) );
      o.head = function head()
      {
        let result = _head.apply( this, arguments );
        return result[ result.length-1 ];
      }
      o.head.composed = _head.composed;
    }
    else if( _.number.is( o.head ) )
    {
      o.head = headWithNargs_functor( o.head, o.body );
    }

    if( o.head === null )
    {
      /* qqq : for Dmytro : cover please */
      if( o.body.defaults )
      o.head = headWithDefaults;
      else
      o.head = headWithoutDefaults;
    }

    if( !o.name )
    {
      _.assert( _.strDefined( o.body.name ), 'Body routine should have name' );
      o.name = o.body.name;
      if( o.name.indexOf( '_body' ) === o.name.length-5 && o.name.length > 5 )
      o.name = o.name.substring( 0, o.name.length-5 );
    }

    /* generate body */

    /* qqq : for Dmytro : cover in separate test routine */
    let body;
    if( o.strategy === 'replacing' )
    body = o.body;
    else
    body = _.routine._amend
    ({
      dst : null,
      srcs : o.body,
      strategy : o.strategy,
      amending : 'extending',
    });

    /* make routine */

    let unitedRoutine = _unite_functor( o.name, o.head, body, o.tail );

    _.assert( _.strDefined( unitedRoutine.name ), 'Looks like your interpreter does not support dynamic naming of functions. Please use ES2015 or later interpreter.' );

    /* qqq : for Dmytro : cover option::strategy */

    _.routine._amend
    ({
      dst : unitedRoutine,
      srcs : body,
      strategy : 'replacing',
      amending : 'extending',
    });

    unitedRoutine.head = o.head;
    unitedRoutine.body = body;
    if( o.tail )
    unitedRoutine.tail = o.tail;

    _.assert
    (
      unitedRoutine.defaults === body.defaults,
      'Something wrong, united routined should have same instance of defaults its body has'
    );

    return unitedRoutine;

    function headWithNargs_functor( nargs, body )
    {
      _.assert( !!o.body.defaults );
      return function headWithDefaults( routine, args )
      {
        _.assert( args.length <= nargs+1 );
        _.assert( arguments.length === 2 );
        let o = _.routine.options( routine, args[ nargs ] || Object.create( null ) );
        return _.unroll.from([ ... Array.prototype.slice.call( args, 0, nargs ), o ]);
      }
    }

    /* */

    function headWithoutDefaults( routine, args )
    {
      let o = args[ 0 ];
      _.assert( arguments.length === 2 );
      _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
      _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
      return o || null;
    }

    /* */

    function headWithDefaults( routine, args )
    {
      let o = args[ 0 ];
      _.assert( arguments.length === 2 );
      _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
      _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
      return _.routine.options( routine, o || Object.create( null ) );
    }

    /* */

    function _unite_functor()
    {
      const name = arguments[ 0 ];
      const head = arguments[ 1 ];
      const body = arguments[ 2 ];
      const tail = arguments[ 3 ];
      let r;

      _.assert( head === null || _.routineIs( head ) );
      _.assert( body === null || _.routineIs( body ) );
      _.assert( tail === null || _.routineIs( tail ) );

      if( tail === null )
      r =
      {
        [ name ] : function()
        {
          let result;
          let o = head.call( this, unitedRoutine, arguments );

          _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

          if( _.unrollIs( o ) )
          result = body.apply( this, o );
          else
          result = body.call( this, o );

          return result;
        }
      };
      else if( head === null )
      r =
      {
        [ name ] : function()
        {
          let result;
          let o = arguments[ 0 ];

          _.assert( arguments.length === 1, 'Expects single argument {-o-}.' );

          if( _.unrollIs( o ) )
          result = body.apply( this, o );
          else if( _.mapIs( o ) )
          result = body.call( this, o );
          else
          _.assert( 0, 'Unexpected type of {-o-}, expects options map or unroll.' );

          result = tail.call( this, result, o );

          return result;
        }
      };
      else
      r =
      {
        [ name ] : function()
        {
          let result;
          let o = head.call( this, unitedRoutine, arguments );

          _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

          if( _.unrollIs( o ) )
          result = body.apply( this, o );
          else
          result = body.call( this, o );

          debugger;
          result = tail.call( this, result, o );

          return result;
        }
      };

      return r[ name ]
    }
  }
  _uniteCloning_body.defaults = {
      "head" : null,
      "body" : null,
      "tail" : null,
      "name" : null,
      "strategy" : null
    }

  const _uniteCloning_ = function uniteCloning()
  {
    let o = uniteCloning.head.call( this, uniteCloning, arguments );
    let result = uniteCloning.body.call( this, o );
    return result;
  }
  _uniteCloning_.head = function unite_head( routine, args )
    {
      let o = args[ 0 ];

      if( args[ 1 ] !== undefined )
      {
        if( args.length === 3 )
        o = { head : args[ 0 ], body : args[ 1 ], tail : args[ 2 ] };
        else
        o = { head : args[ 0 ], body : ( args.length > 1 ? args[ 1 ] : null ) };
      }

      _.routine.optionsWithoutUndefined( routine, o );
      _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
      _.assert( arguments.length === 2 );
      _.assert
      (
        o.head === null || _.numberIs( o.head ) || _.routine.is( o.head ) || _.routine.s.are( o.head )
        , 'Expects either routine, routines or number of arguments {-o.head-}'
      );
      _.assert( _.routine.is( o.body ), 'Expects routine {-o.body-}' );
      _.assert( o.tail === null || _.routine.is( o.tail ), () => `Expects routine {-o.tail-}, but got ${_.entity.strType( o.tail )}` );
      _.assert( o.body.defaults !== undefined, 'Body should have defaults' );

      return o;
    }
    _uniteCloning_.body = function unite_body( o )
    {

      if( _.longIs( o.head ) )
      {
        /* xxx : deprecate compose */
        /* qqq : for Dmytro : implement without compose */
        // let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
        // {
        //   let args = arguments[ 0 ];
        //   let result = arguments[ 1 ];
        //   let op = arguments[ 2 ];
        //   let k = arguments[ 3 ];
        //   _.assert( arguments.length === 4 );
        //   _.assert( !_.unrollIs( result ) );
        //   _.assert( _.object.isBasic( result ) );
        //   return _.unrollAppend([ unitedRoutine, [ result ] ]);
        // });
        let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
        {
          let args = arguments[ 0 ];
          let result = arguments[ 1 ];
          let op = arguments[ 2 ];
          let k = arguments[ 3 ];
          _.assert( arguments.length === 4 );
          _.assert( !_.unrollIs( result ) );
          _.assert( _.object.isBasic( result ) );
          return _.unroll.from([ unitedRoutine, [ result ] ]);
        });
        _.assert( _.routine.is( _head ) );
        o.head = function head()
        {
          let result = _head.apply( this, arguments );
          return result[ result.length-1 ];
        }
        o.head.composed = _head.composed;
      }
      else if( _.number.is( o.head ) )
      {
        o.head = headWithNargs_functor( o.head, o.body );
      }

      if( o.head === null )
      {
        /* qqq : for Dmytro : cover please */
        if( o.body.defaults )
        o.head = headWithDefaults;
        else
        o.head = headWithoutDefaults;
      }

      if( !o.name )
      {
        _.assert( _.strDefined( o.body.name ), 'Body routine should have name' );
        o.name = o.body.name;
        if( o.name.indexOf( '_body' ) === o.name.length-5 && o.name.length > 5 )
        o.name = o.name.substring( 0, o.name.length-5 );
      }

      /* generate body */

      /* qqq : for Dmytro : cover in separate test routine */
      let body;
      if( o.strategy === 'replacing' )
      body = o.body;
      else
      body = _.routine._amend
      ({
        dst : null,
        srcs : o.body,
        strategy : o.strategy,
        amending : 'extending',
      });

      /* make routine */

      let unitedRoutine = _unite_functor( o.name, o.head, body, o.tail );

      _.assert( _.strDefined( unitedRoutine.name ), 'Looks like your interpreter does not support dynamic naming of functions. Please use ES2015 or later interpreter.' );

      /* qqq : for Dmytro : cover option::strategy */

      _.routine._amend
      ({
        dst : unitedRoutine,
        srcs : body,
        strategy : 'replacing',
        amending : 'extending',
      });

      unitedRoutine.head = o.head;
      unitedRoutine.body = body;
      if( o.tail )
      unitedRoutine.tail = o.tail;

      _.assert
      (
        unitedRoutine.defaults === body.defaults,
        'Something wrong, united routined should have same instance of defaults its body has'
      );

      return unitedRoutine;

      function headWithNargs_functor( nargs, body )
      {
        _.assert( !!o.body.defaults );
        return function headWithDefaults( routine, args )
        {
          _.assert( args.length <= nargs+1 );
          _.assert( arguments.length === 2 );
          let o = _.routine.options( routine, args[ nargs ] || Object.create( null ) );
          return _.unroll.from([ ... Array.prototype.slice.call( args, 0, nargs ), o ]);
        }
      }

      /* */

      function headWithoutDefaults( routine, args )
      {
        let o = args[ 0 ];
        _.assert( arguments.length === 2 );
        _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
        _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
        return o || null;
      }

      /* */

      function headWithDefaults( routine, args )
      {
        let o = args[ 0 ];
        _.assert( arguments.length === 2 );
        _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
        _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
        return _.routine.options( routine, o || Object.create( null ) );
      }

      /* */

      function _unite_functor()
      {
        const name = arguments[ 0 ];
        const head = arguments[ 1 ];
        const body = arguments[ 2 ];
        const tail = arguments[ 3 ];
        let r;

        _.assert( head === null || _.routineIs( head ) );
        _.assert( body === null || _.routineIs( body ) );
        _.assert( tail === null || _.routineIs( tail ) );

        if( tail === null )
        r =
        {
          [ name ] : function()
          {
            let result;
            let o = head.call( this, unitedRoutine, arguments );

            _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

            if( _.unrollIs( o ) )
            result = body.apply( this, o );
            else
            result = body.call( this, o );

            return result;
          }
        };
        else if( head === null )
        r =
        {
          [ name ] : function()
          {
            let result;
            let o = arguments[ 0 ];

            _.assert( arguments.length === 1, 'Expects single argument {-o-}.' );

            if( _.unrollIs( o ) )
            result = body.apply( this, o );
            else if( _.mapIs( o ) )
            result = body.call( this, o );
            else
            _.assert( 0, 'Unexpected type of {-o-}, expects options map or unroll.' );

            result = tail.call( this, result, o );

            return result;
          }
        };
        else
        r =
        {
          [ name ] : function()
          {
            let result;
            let o = head.call( this, unitedRoutine, arguments );

            _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

            if( _.unrollIs( o ) )
            result = body.apply( this, o );
            else
            result = body.call( this, o );

            debugger;
            result = tail.call( this, result, o );

            return result;
          }
        };

        return r[ name ]
      }
    }
    _uniteCloning_.defaults = {
      "head" : null,
      "body" : null,
      "tail" : null,
      "name" : null,
      "strategy" : `cloning`
    }
  ;
_uniteCloning_.head = _uniteCloning_head;
_uniteCloning_.body = _uniteCloning_body;
  return _uniteCloning_;
})();
_.routine.uniteCloning_replaceByUnite.defaults =
{
  "head" : null,
  "body" : null,
  "tail" : null,
  "name" : null,
  "strategy" : `cloning`
}

//


  _.routine._amend = function _amend( o )
{
  let dst = o.dst;
  let srcs = o.srcs;
  let srcIsVector = _.vectorIs( srcs );
  let extended = false;

  _.routine.assertOptions( _amend, o );
  _.assert( arguments.length === 1 );
  _.assert( _.routine.is( dst ) || dst === null );
  _.assert( srcs === null || srcs === undefined || _.aux.is( srcs ) || _.routine.is( srcs ) || _.vector.is( srcs ) );
  _.assert( o.amending === 'extending', 'not implemented' );
  _.assert
  (
    o.strategy === 'cloning' || o.strategy === 'replacing' || o.strategy === 'inheriting',
    () => `Unknown strategy ${o.strategy}`
  );

  /* generate dst routine */

  if( dst === null ) /* qqq : for Dmytro : good coverage required */
  dst = _dstMake( srcs );

  // /* shallow clone properties of dst routine */
  //
  // if( o.strategy === 'cloning' )
  // _fieldsClone( dst );
  // else if( o.strategy === 'inheriting' )
  // _fieldsInherit( dst );

  /* extend dst routine */

  let _dstAmend;
  if( o.strategy === 'cloning' )
  _dstAmend = _dstAmendCloning;
  else if( o.strategy === 'replacing' )
  _dstAmend = _dstAmendReplacing;
  else if( o.strategy === 'inheriting' )
  _dstAmend = _dstAmendInheriting;
  else _.assert( 0, 'not implemented' );

  if( srcIsVector )
  for( let src of srcs )
  _dstAmend( dst, src );
  else
  _dstAmend( dst, srcs );

  /* qqq : for Dmytro : it should be optimal, no redundant cloning of body should happen
  check and cover it by good test, please
  */
  if( extended )
  // if( dst.body && dst.body.defaults )
  if( dst.body )
  dst.body = bodyFrom( dst.body );

  if( Config.debug )
  {
    /* qqq : for Dmytro : cover, please */
    if( _.strEnds( dst.name, '_body' ) )
    {
      _.assert( dst.body === undefined, 'Body of routine should not have its own body' );
      _.assert( dst.head === undefined, 'Body of routine should not have its own head' );
      _.assert( dst.tail === undefined, 'Body of routine should not have its own tail' );
    }
    // xxx : uncomment?
    // if( dst.defaults )
    // _.routine._verifyDefaults( dst.defaults );
  }

  return dst;

  /* */

  function _dstMake( srcs )
  {
    let dstMap = Object.create( null );

    /* qqq : option amendment influence on it */
    if( srcIsVector )
    for( let src of srcs )
    {
      if( src === null )
      continue;
      _.props.extend( dstMap, src );
    }
    else
    {
      if( srcs !== null )
      _.props.extend( dstMap, srcs );
    }

    if( dstMap.body )
    {
      // dst = _.routine.uniteCloning( dstMap.head, dstMap.body );
      dst = _.routine.unite
      ({
        head : dstMap.head || null,
        body : dstMap.body || null,
        tail : dstMap.tail || null,
        name : dstMap.name || null,
        strategy : o.strategy,
      });
    }
    else
    {
      if( srcIsVector )
      dst = dstFrom( srcs[ 0 ] );
      else
      dst = dstFrom( srcs );
    }

    _.assert( _.routineIs( dst ) );
    // _.props.extend( dst, dstMap );

    return dst;
  }

  /* */

  // function _fieldsClone( dst )
  // {
  //
  //   for( let s in dst )
  //   {
  //     let property = dst[ s ];
  //     if( _.object.isBasic( property ) )
  //     {
  //       property = _.props.extend( null, property );
  //       dst[ s ] = property;
  //     }
  //   }
  //
  // }
  //
  // /* */
  //
  // function _fieldsInherit( dst )
  // {
  //
  //   for( let s in dst )
  //   {
  //     let property = dst[ s ];
  //     if( _.object.isBasic( property ) )
  //     {
  //       property = Object.create( property );
  //       dst[ s ] = property;
  //     }
  //   }
  //
  // }

  /* */

  function _dstAmendCloning( dst, src )
  {
    _.assert( !!dst );
    _.assert( _.aux.is( src ) || _.routine.is( src ) );
    for( let s in src )
    {
      let property = src[ s ];
      if( dst[ s ] === property )
      continue;
      let d = Object.getOwnPropertyDescriptor( dst, s );
      if( d && !d.writable )
      continue;
      extended = true;
      if( _.object.isBasic( property ) )
      {
        _.assert( !_.props.own( dst, s ) || _.object.isBasic( dst[ s ] ) );

        if( dst[ s ] )
        _.props.extend( dst[ s ], property );
        else
        dst[ s ] = property = _.props.extend( null, property );

        // property = _.props.extend( null, property );
        // if( dst[ s ] )
        // _.props.supplement( property, dst[ s ] );
      }
      else
      {
        dst[ s ] = property;
      }
    }
  }

  /* */

  function _dstAmendInheriting( dst, src )
  {
    _.assert( !!dst );
    _.assert( _.aux.is( src ) || _.routine.is( src ) );
    /* qqq : for Dmytro : on extending should inherit from the last one, on supplementing should inherit from the first one
    implement, and cover in separate test
    */
    for( let s in src )
    {
      let property = src[ s ];
      if( dst[ s ] === property )
      continue;
      let d = Object.getOwnPropertyDescriptor( dst, s );
      if( d && !d.writable )
      continue;
      extended = true;
      if( _.object.isBasic( property ) )
      {
        property = Object.create( property );
        if( dst[ s ] )
        _.props.supplement( property, dst[ s ] );
      }
      dst[ s ] = property;
    }
  }

  /* */

  function _dstAmendReplacing( dst, src )
  {
    _.assert( !!dst );
    _.assert( _.aux.is( src ) || _.routine.is( src ) );
    for( let s in src )
    {
      let property = src[ s ];
      if( dst[ s ] === property )
      continue;
      let d = Object.getOwnPropertyDescriptor( dst, s );
      if( d && !d.writable )
      continue;
      extended = true;
      dst[ s ] = property;
    }
  }

  /* */

  function bodyFrom()
  {
    const body = dst.body;
    let body2 = body;
    _.assert( body.head === undefined, 'Body should not have own head' );
    _.assert( body.tail === undefined, 'Body should not have own tail' );
    _.assert( body.body === undefined, 'Body should not have own body' );
    {
      // let srcs = srcIsVector ? _.map_( null, o.srcs, ( src ) => propertiesBut( src ) ) : [ propertiesBut( o.srcs ) ];
      let srcs;
      if( srcIsVector )
      {
        // debugger;
        srcs = o.srcs.map( (src ) => propertiesBut( src ) );
      }
      else
      {
        srcs = [ propertiesBut( o.srcs ) ];
      }
      srcs.unshift( body );
      body2 = _.routine._amend
      ({
        dst : o.strategy === 'replacing' ? body2 : null,
        srcs,
        strategy : o.strategy,
        amending : o.amending,
      });
      _.assert( body2.head === undefined, 'Body should not have own head' );
      _.assert( body2.tail === undefined, 'Body should not have own tail' );
      _.assert( body2.body === undefined, 'Body should not have own body' );
    }
    return body2;
  }

  /* */

  function propertiesBut( src )
  {
    if( !src )
    return src;
    let result = _.props.extend( null, src );
    delete result.head;
    delete result.body;
    delete result.taul;
    // return src ? _.mapBut_( null, src, [ 'head', 'body', 'tail' ] ) : src;
    return result;
  }

  /* */

  /* xxx : make routine? */
  function routineClone( routine )
  {
    _.assert( _.routine.is( routine ) );
    let name = routine.name;
    // const routine2 = routine.bind();
    // _.assert( routine2 !== routine );
    const routine2 =
    ({
      [ name ] : function()
      {
        return routine.apply( this, arguments );
      }
    })[ name ];

    let o2 =
    {
      value : routine,
      enumerable : false,
    };
    Object.defineProperty( routine2, 'originalRoutine', o2 ); /* qqq : for Dmytro : cover */

    return routine2;
  }

  /* */

  function dstFrom( routine )
  {
    return routineClone( routine );
  }

  /* */

}
_.routine._amend.defaults =
{
  "dst" : null,
  "srcs" : null,
  "strategy" : `cloning`,
  "amending" : `extending`
}

//


  _.routine._is = function _is( src, typeStr )
{
  return typeStr === '[object Function]' || typeStr === '[object AsyncFunction]';
}

//


  _.routine.is = function is( src )
{
  let typeStr = Object.prototype.toString.call( src );
  return _.routine._is( src, typeStr );
}

//


  var __keysQuote = function __keysQuote( keys )
{
  let result = `"${ keys[ 0 ] }"`;
  for( let i = 1 ; i < keys.length ; i++ )
  result += `, "${ keys[ i ] }"`;
  return result.trim();
}

//

var __primitiveLike = function __primitiveLike( src )
{
  if( _.primitive.is( src ) )
  return true;
  if( _.regexpIs( src ) )
  return true;
  if( _.routineIs( src ) )
  return true;
  return false;
}

//

var __strType = function __strType( src )
{
  if( _.strType )
  return _.strType( src );
  return String( src );
}

//

var __mapSupplementWithUndefined = function __mapSupplementWithUndefined( dstMap, srcMap )
{
  for( let k in srcMap )
  {
    if( Config.debug )
    _.assert
    (
      __primitiveLike( srcMap[ k ] ),
      () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( srcMap[ k ] ) }`
    );
    if( Object.hasOwnProperty.call( dstMap, k ) )
    continue;
    dstMap[ k ] = srcMap[ k ];
  }
}

//

_.routine.options = function optionsWithUndefined( routine, options )
{

  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    if( options.length === 0 )
    options = Object.create( null )
    else
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  if( options === null )
  options = Object.create( null );
  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  /* */

  if( Config.debug )
  {
    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );
  }

  __mapSupplementWithUndefined( options, defaults );

  return options;
}

//


  var __keysQuote = function __keysQuote( keys )
{
  let result = `"${ keys[ 0 ] }"`;
  for( let i = 1 ; i < keys.length ; i++ )
  result += `, "${ keys[ i ] }"`;
  return result.trim();
}

//

var __primitiveLike = function __primitiveLike( src )
{
  if( _.primitive.is( src ) )
  return true;
  if( _.regexpIs( src ) )
  return true;
  if( _.routineIs( src ) )
  return true;
  return false;
}

//

var __strType = function __strType( src )
{
  if( _.strType )
  return _.strType( src );
  return String( src );
}

//

var __mapSupplementWithUndefined = function __mapSupplementWithUndefined( dstMap, srcMap )
{
  for( let k in srcMap )
  {
    if( Config.debug )
    _.assert
    (
      __primitiveLike( srcMap[ k ] ),
      () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( srcMap[ k ] ) }`
    );
    if( Object.hasOwnProperty.call( dstMap, k ) )
    continue;
    dstMap[ k ] = srcMap[ k ];
  }
}

//

_.routine.options_ = function optionsWithUndefined( routine, options )
{

  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    if( options.length === 0 )
    options = Object.create( null )
    else
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  if( options === null )
  options = Object.create( null );
  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  /* */

  if( Config.debug )
  {
    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );
  }

  __mapSupplementWithUndefined( options, defaults );

  return options;
}

//


  var __keysQuote = function __keysQuote( keys )
{
  let result = `"${ keys[ 0 ] }"`;
  for( let i = 1 ; i < keys.length ; i++ )
  result += `, "${ keys[ i ] }"`;
  return result.trim();
}

//

var __primitiveLike = function __primitiveLike( src )
{
  if( _.primitive.is( src ) )
  return true;
  if( _.regexpIs( src ) )
  return true;
  if( _.routineIs( src ) )
  return true;
  return false;
}

//

var __strType = function __strType( src )
{
  if( _.strType )
  return _.strType( src );
  return String( src );
}

//

_.routine.assertOptions = function assertOptionsWithUndefined( routine, options )
{

  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  /* */

  if( Config.debug )
  {

    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );

    for( let k in defaults )
    {
      _.assert
      (
        __primitiveLike( defaults[ k ] ),
        () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( defaults[ k ] ) }`
      );
      _.assert
      (
        Reflect.has( options, k ),
        `Options map does not have option::${k}`
      )
    }

  }

  return options;
}

//


  _.routine.isTrivial = ( function routineIsTrivial_functor()
{

  const syncPrototype = Object.getPrototypeOf( Function );
  const asyncPrototype = Object.getPrototypeOf( _async );
  return routineIsTrivial;

  function routineIsTrivial( src )
  {
    if( !src )
    return false;
    let prototype = Object.getPrototypeOf( src );
    if( prototype === syncPrototype )
    return true;
    if( prototype === asyncPrototype )
    return true;
    return false;
  }

  async function _async()
  {
  }

} )();

//


  _.routine.extend = function extendCloning( dst, ... srcs )
{

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  return _.routine._amend
  ({
    dst,
    srcs : [ ... srcs ],
    strategy : 'cloning',
    amending : 'extending',
  });

}

//


  var __arrayFlatten = function __arrayFlatten( src )
{
  let result = [];
  if( src === null )
  return result;
  if( !_.argumentsArray.like( src ) )
  result.push( src );
  else
  for( let i = 0 ; i < src.length ; i++ )
  {
    let e = src[ i ];
    if( _.array.is( e ) || _.argumentsArray.is( e ) )
    result.push( ... e );
    else
    result.push( e );
  }
  return result;
}

//

_.routine.s.compose = ( function() {

  const _compose_head = function _compose_head( routine, args )
  {
    let o = args[ 0 ];

    if( !_.mapIs( o ) )
    o = { bodies : args[ 0 ] };
    if( args[ 1 ] !== undefined )
    o.chainer = args[ 1 ];

    // if( o.bodies === null )
    // debugger;
    // o.bodies = _.arrayAppendArrays( [], [ o.bodies ] );
    // o.bodies = merge( o.bodies );

    // let bodies2 = __arrayFlatten( o.bodies );
    // if( bodies2.length && bodies2[ 0 ] === undefined )
    // debugger;

    o.bodies = __arrayFlatten( o.bodies );
    o.bodies = o.bodies.filter( ( e ) => e !== null );

    _.routine.options( routine, o );
    _.assert( _.routine.s.are( o.bodies ) );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 || args.length === 2 );
    _.assert( args.length === 1 || !_.object.isBasic( args[ 0 ] ) );
    _.assert( _.arrayIs( o.bodies ) || _.routine.is( o.bodies ) );
    _.assert( _.routine.is( args[ 1 ] ) || args[ 1 ] === undefined || args[ 1 ] === null );
    _.assert( o.chainer === null || _.routine.is( o.chainer ) );
    _.assert( o.tail === null || _.routine.is( o.tail ) );

    return o;

    // function merge( arrays )
    // {
    //   let result = [];
    //   if( arrays === null )
    //   return result;
    //   for( let i = 0 ; i < arrays.length ; i++ )
    //   {
    //     let array = arrays[ i ];
    //     if( _.array.is( array ) || _.argumentsArray.is( array ) )
    //     result.push( ... array );
    //     else
    //     result.push( array );
    //   }
    //   return result;
    // }
  }
  _compose_head.locals = {
      "__arrayFlatten" : function __arrayFlatten( src )
    {
      let result = [];
      if( src === null )
      return result;
      if( !_.argumentsArray.like( src ) )
      result.push( src );
      else
      for( let i = 0 ; i < src.length ; i++ )
      {
        let e = src[ i ];
        if( _.array.is( e ) || _.argumentsArray.is( e ) )
        result.push( ... e );
        else
        result.push( e );
      }
      return result;
    }
    }

  const _compose_body = function _compose_body( o )
  {

    // if( o.chainer === null )
    // o.chainer = defaultChainer;
    // o.bodies = __arrayFlatten( o.bodies );
    if( o.chainer === null )
    o.chainer = _.routine.chainer.default;

    let bodies = [];
    for( let s = 0 ; s < o.bodies.length ; s++ )
    {
      let body = o.bodies[ s ];
      _.assert( _.routine.is( body ) );
      if( body.composed )
      {
        if( body.composed.chainer === o.chainer && body.composed.tail === o.tail )
        {
          bodies.push( ... body.composed.elements );
        }
        else
        {
          bodies.push( ... body );
        }
      }
      else
      {
        bodies.push( body );
      }
    }

    o.bodies = bodies;

    let tail = o.tail;
    let chainer = o.chainer;

    _.assert( _.routine.is( chainer ) );
    _.assert( tail === null || _.routine.is( tail ) );

    /* */

    if( bodies.length === 0 )
    o.act = compositionEmpty;
    else if( bodies.length === 1 )
    o.act = compositionOfSingle;
    else
    o.act = composition;

    o.act.composed = o;

    if( tail )
    {
      _.routine.extendReplacing( routineWithTail, o.act );
      return routineWithTail;
    }

    return o.act;

    /* */

    function compositionEmpty()
    {
      return [];
    }

    function compositionOfSingle()
    {
      let result = [];
      let args = _.unroll.from( arguments );
      // _.assert( _.unrollIs( args ), () => `Expects unroll, but got ${_.entity.strType( args )}` );
      let routine = bodies[ 0 ];
      let r = routine.apply( this, args );
      _.assert( !_.argumentsArray.is( r ) );
      if( r !== undefined )
      _.unrollAppend( result, r );
      return result;
    }

    function composition()
    {
      let result = [];
      let args = _.unroll.from( arguments );
      for( let k = 0 ; k < bodies.length ; k++ )
      {
        // _.assert( _.unrollIs( args ), () => `Expects unroll, but got ${_.entity.strType( args )}` );
        let routine = bodies[ k ];
        let r = routine.apply( this, args );
        _.assert( !_.argumentsArray.is( r ) );
        if( r !== undefined )
        _.unrollAppend( result, r );
        args = chainer( args, r, o, k );
        if( args === _.dont )
        break;
        _.assert( _.unroll.is( args ) );
      }
      return result;
    }

    // function defaultChainer( /* args, result, op, k */ )
    // {
    //   let args = arguments[ 0 ];
    //   let result = arguments[ 1 ];
    //   let op = arguments[ 2 ];
    //   let k = arguments[ 3 ];
    //   if( result === _.dont )
    //   return result;
    //   return args;
    // }

    function routineWithTail()
    {
      let result = tail.call( this, arguments, o );
      return result;
    }
  }
  _compose_body.defaults = { "chainer" : null, "bodies" : null, "tail" : null }

  const _compose_ = _.routine.unite
  ({
    head : _compose_head,
    body : _compose_body,
  });

  return _compose_;
})();
_.routine.s.compose.defaults =
{ "chainer" : null, "bodies" : null, "tail" : null }

//


  _.routine.s.are = function are( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.argumentsArray.like( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.routine.is( src[ s ] ) )
    return false;
    return true;
  }

  return _.routine.is( src );
}

//


  _.errIs = function is( src )
{
  return src instanceof Error || Object.prototype.toString.call( src ) === '[object Error]';
}

//


  _.regexpLike = function like( src )
{
  if( src instanceof RegExp || Object.prototype.toString.call( src ) === '[object String]' )
  return true;
  return false;
}

//


  _.intervalIs = function intervalIs( range )
{
  _.assert( arguments.length === 1 );
  if( !_.number.s.areAll( range ) )
  return false;
  if( range.length !== 2 )
  return false;
  return true;
}

//


  _.numberDefined = function numberIsFinite( src )
{
  if( !_.number.is( src ) )
  return false;
  return isFinite( src );
}

//


  _.numbersAreAll = function areAll( src )
{
  _.assert( arguments.length === 1 );

  if( _.bufferTypedIs( src ) )
  return true;

  if( _.argumentsArray.like( src ) && !_.arrayIsEmpty( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.number.is( src[ s ] ) )
    return false;

    return true;
  }

  return false;
}

//


  _.strConcat = function concat( srcs, o )
{

  o = _.routine.options( concat, o || Object.create( null ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( this.strConcat === concat );

  if( o.onToStr === null )
  o.onToStr = onToStr;

  let defaultOptionsForToStr =
  {
    stringWrapper : '',
  };

  o.optionsForToStr = _.props.supplement( o.optionsForToStr, defaultOptionsForToStr );
  o.optionsForToStr.format = o.optionsForToStr.format || 'string.diagnostic';

  if( _.routine.is( srcs ) )
  srcs = srcs();

  if( !_.argumentsArray.like( srcs ) )
  srcs = [ srcs ];

  let result = '';
  if( !srcs.length )
  return result;

  let concatenatePairWithLineDelimeter = o.onPairWithDelimeter ? o.onPairWithDelimeter : concatenateSimple;

  /* */

  let a = 0;

  while( !result && a < srcs.length )
  {
    result = o.onToStr( srcs[ a ], o );
    ++a;
  }

  for( ; a < srcs.length ; a++ )
  {
    let src = srcs[ a ];
    src = o.onToStr( src, o );

    result = result.replace( /[^\S\n]\s*$/, '' );

    if( _.strEnds( result, o.lineDelimter ) || _.strBegins( src, o.lineDelimter ) )
    result = concatenatePairWithLineDelimeter( result, src, o );
    else
    result = `${result} ${src.replace( /^\s+/, '' )}`;
  }

  /* */

  if( o.linePrefix || o.linePostfix )
  {
    result = result.split( o.lineDelimter );
    result = o.linePrefix + result.join( o.linePostfix + o.lineDelimter + o.linePrefix ) + o.linePostfix;
  }

  /* */

  return result;

  /* */

  function onToStr( src, op )
  {
    return _.entity.exportString( src, op.optionsForToStr );
  }

  /* */

  function concatenateSimple( src1, src2 )
  {
    return src1 + src2;
  }
}
_.strConcat.defaults =
{
  "linePrefix" : ``,
  "linePostfix" : ``,
  "lineDelimter" : `\n`,
  "optionsForToStr" : null,
  "onToStr" : null,
  "onPairWithDelimeter" : null
}

//


  _.strHas = function has( src, ins )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), () => `Expects string, got ${_.entity.strType( src )}` );
  _.assert( _.regexpLike( ins ), () => `Expects string-like, got ${_.entity.strType( ins )}` );

  if( _.strIs( ins ) )
  return src.indexOf( ins ) !== -1;
  else
  return ins.test( src );

}

//


  _.strHasAny = function strHasAny( src, ins )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.arrayIs( ins ) )
  {
    for( let i = 0 ; i < ins.length ; i++ )
    if( _.strHas( src, ins[ i ] ) )
    return true;
    return false;
  }

  return _.strHas( src, ins );
}

//


  _.strLinesStrip = function strip( src )
{

  if( arguments.length > 1 )
  {
    let result = _.unroll.make( null );
    for( let a = 0 ; a < arguments.length ; a++ )
    result[ a ] = _.str.lines.strip( arguments[ a ] );
    return result;
  }

  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 );

  let lines = _.strLinesSplit( src );
  lines = lines.map( ( line ) => line.trim() ).filter( ( line ) => line );

  if( _.strIs( src ) )
  lines = _.str.lines.join( lines );
  return lines;
}

//


  _.strLinesNumber = function strLinesNumber( o )
{

  if( !_.object.isBasic( o ) )
  o = { src : arguments[ 0 ], zeroLine : ( arguments.length > 1 ? arguments[ 1 ] : null ) };

  _.routine.options( strLinesNumber, o );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.strIs( o.src ) || _.strsAreAll( o.src ), 'Expects string or strings {-o.src-}' );

  /* */

  if( o.zeroLine === null )
  {
    if( o.zeroChar === null )
    {
      o.zeroLine = 1;
    }
    else if( _.number.is( o.zeroChar ) )
    {
      let src = _.arrayIs( o.src ) ? o.src.join( '\n' ) : o.src;
      o.zeroLine = _.strLinesCount( src.substring( 0, o.zeroChar+1 ) );
    }
  }

  /* */

  let lines = _.strIs( o.src ) ? _.str.lines.split( o.src ) : o.src;

  /* */

  let maxNumberLength = String( lines.length - 1 + o.zeroLine ).length;
  let zeroLineLength = String( o.zeroLine ).length;
  let maxNumLength = maxNumberLength > zeroLineLength ? maxNumberLength : zeroLineLength;

  if( o.onLine )
  for( let l = 0; l < lines.length; l += 1 )
  {
    let numLength = String( l + o.zeroLine ).length;

    lines[ l ] = o.onLine( [ ' '.repeat( maxNumLength - numLength ), ( l + o.zeroLine ), ' : ', lines[ l ] ], o.zeroLine + l, o );
    if( lines[ l ] === undefined )
    {
      lines.splice( l, 1 );
      l -= 1;
    }
    _.assert( _.strIs( lines[ l ] ) );
  }
  else
  for( let l = 0; l < lines.length; l += 1 )
  {
    let numLength = String( l + o.zeroLine ).length;
    lines[ l ] = ' '.repeat( maxNumLength - numLength ) + ( l + o.zeroLine ) + ' : ' + lines[ l ];
  }
  if( o.highlightingToken && o.highlighting )
  {
    let results;

    _.assert( o.highlighting === null || _.number.is( o.highlighting ) || _.longIs( o.highlighting ), 'Expects number or array of numbers {-o.highlighting-}' );

    if( !_.arrayIs( o.highlighting ) )
    {
      if( o.highlighting > o.zeroLine + lines.length - 1 || o.highlighting < o.zeroLine )
      return lines.join( '\n' );
    }

    results = lines.map( ( el ) =>
    {
      if( _.arrayIs( o.highlighting ) )
      return o.highlighting.includes( parseInt( el, 10 ) ) ? '' + o.highlightingToken + ' ' + el : '' + ' '.repeat( o.highlightingToken.length + 1 ) + el;
      else
      return ( '' + o.highlighting ).includes( parseInt( el, 10 ) ) ? '' + o.highlightingToken + ' ' + el : '' + ' '.repeat( o.highlightingToken.length + 1 ) + el;
    } )

    if( JSON.stringify( lines ) === JSON.stringify( results.map( ( el ) => el.trim() ) ) )
    return lines.join( '\n' );

    return results.join( '\n' );

  }

  return lines.join( '\n' );
}
_.strLinesNumber.defaults =
{
  "src" : null,
  "zeroLine" : null,
  "zeroChar" : null,
  "onLine" : null,
  "highlighting" : null,
  "highlightingToken" : `*`
}

//


  _.strLinesSplit = function split( src, eol )
{
  if( _.arrayIs( src ) )
  return src;
  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( eol === undefined )
  eol = _.str.lines.Eol.default;
  return src.split( eol );
}

//


  _.strLinesJoin = function join( src, eol )
{
  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( eol === undefined )
  eol = _.str.lines.Eol.default;
  let result = src;
  if( _.arrayIs( src ) )
  result = src.join( eol );
  return result;
}

//


  _.strSplit = ( function() {

    const _strSplit_head = [];
    var _body_0 = function strSplitFast_head( routine, args )
  {
    let o = args[ 0 ];

    if( args.length === 2 )
    o = { src : args[ 0 ], delimeter : args[ 1 ] }
    else if( _.strIs( args[ 0 ] ) )
    o = { src : args[ 0 ] }

    _.routine.options( routine, o );

    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 || args.length === 2, 'Expects one or two arguments' );
    _.assert( _.strIs( o.src ) );
    _.assert( o.delimeter === null || _.regexp.like( o.delimeter ) || _.arrayIs( o.delimeter ) );
    _.assert( _.object.isBasic( o ) );

    return o;
  }

  //


   _strSplit_head.push( _body_0 );
    var _body_1 = function strSplitsQuotedRejoin_head( routine, args )
  {
    let o = args[ 0 ];

    _.routine.options( routine, o );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1, 'Expects one or two arguments' );
    _.assert( _.object.isBasic( o ) );

    if( o.quoting )
    {

      if( _.bool.like( o.quoting ) )
      {
        if( !o.quotingPrefixes )
        o.quotingPrefixes = [ '"' ];
        if( !o.quotingPostfixes )
        o.quotingPostfixes = [ '"' ];
      }
      else if( _.strIs( o.quoting ) || _.regexpIs( o.quoting ) || _.arrayIs( o.quoting ) )
      {
        _.assert( !o.quotingPrefixes );
        _.assert( !o.quotingPostfixes );
        o.quoting = _.array.as( o.quoting );
        o.quotingPrefixes = o.quoting.map( ( q ) => _.arrayIs( q ) ? q[ 0 ] : q );
        o.quotingPostfixes = o.quoting.map( ( q ) => _.arrayIs( q ) ? q[ 0 ] : q );
        o.quoting = true;
      }
      else _.assert( 0, 'unexpected type of {-o.quoting-}' );

      _.assert
      (
        !o.pairing || o.quotingPrefixes.length === o.quotingPostfixes.length,
        `If option::o.paring is true then the length of o.quotingPrefixes should be equal to the length of o.quotingPostfixes`
      );

      if( Config.debug )
      {
        _.assert( o.quotingPrefixes.length === o.quotingPostfixes.length );
        _.assert( _.bool.like( o.quoting ) );
        o.quotingPrefixes.forEach( ( q ) => _.assert( _.strIs( q ) ) );
        o.quotingPostfixes.forEach( ( q ) => _.assert( _.strIs( q ) ) );
      }

    }

    return o;
  }

  //


   _strSplit_head.push( _body_1 );
    var _body_2 = function strSplitsDropDelimeters_head( routine, args )
  {
    let o = args[ 0 ];

    _.routine.options( routine, o );

    if( _.strIs( o.delimeter ) )
    o.delimeter = [ o.delimeter ];

    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 );
    _.assert( _.object.isBasic( o ) );

    return o;
  }

  //


   _strSplit_head.push( _body_2 );
    var _body_3 = function strSplitsStrip_head( routine, args )
  {
    let o = args[ 0 ];

    _.routine.options( routine, o );

    if( o.stripping && _.bool.like( o.stripping ) )
    o.stripping = _.strStrip.defaults.stripper;

    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 );
    _.assert( _.object.isBasic( o ) );
    _.assert( !o.stripping || _.strIs( o.stripping ) || _.regexpIs( o.stripping ) );

    return o;
  }

  //


   _strSplit_head.push( _body_3 );
    var _body_4 = function strSplitsDropEmpty_head( routine, args )
  {
    let o = args[ 0 ];

    _.routine.options( routine, o );

    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 );
    _.assert( _.object.isBasic( o ) );

    return o;
  }

  //


   _strSplit_head.push( _body_4 );

  const _strSplit_body = function strSplit_body( o )
  {

    o.delimeter = _.array.as( o.delimeter );

    if( !o.stripping && !o.quoting && !o.onDelimeter )
    {
      return _.strSplitFast.body( _.mapOnly_( null, o, _.strSplitFast.defaults ) );
    }

    /* */

    _.assert( arguments.length === 1 );

    /* */

    let result = [];
    let fastOptions = _.mapOnly_( null, o, _.strSplitFast.defaults );
    fastOptions.preservingEmpty = 1;
    fastOptions.preservingDelimeters = 1;

    if( o.quoting )
    fastOptions.delimeter = _.arrayAppendArraysOnce( [], [ o.quotingPrefixes, o.quotingPostfixes, fastOptions.delimeter ] );

    o.splits = _.strSplitFast.body( fastOptions );

    if( o.quoting && o.onQuote )
    {
      let quotes = _.arrayAppendArraysOnce( null, [ o.quotingPrefixes, o.quotingPostfixes ] );
      for( let i = 0 ; i < o.splits.length ; i++ )
      {
        let index = _.longLeftIndex( quotes, o.splits[ i ], equalizeStrings );
        if( index !== -1 )
        o.splits[ i ] = o.onQuote( o.splits[ i ], index, quotes );
      }
    }
    if( o.onDelimeter )
    {
      let delimeter = _.filter_( null, o.delimeter, function( pattern )
      {
        if( _.regexpIs( pattern ) )
        return pattern.test( o.src ) ? pattern : null;
        return pattern;
      });
      for( let i = 0 ; i < o.splits.length ; i++ )
      {
        let index = _.longLeftIndex( delimeter, o.splits[ i ], equalizeStrings );
        if( index !== -1 )
        o.splits[ i ] = o.onDelimeter( o.splits[ i ], index, o.delimeter );
      }
    }

    if( o.quoting )
    _.strSplitsQuotedRejoin.body( o );

    if( !o.preservingDelimeters )
    _.strSplitsDropDelimeters.body( o );

    if( o.stripping )
    _.strSplitsStrip.body( o );

    if( !o.preservingEmpty )
    _.strSplitsDropEmpty.body( o );

    /* */

    return o.splits;

    /* */

    function equalizeStrings( pattern, el )
    {
      if( _.strIs( pattern ) )
      return pattern === el;
      if( pattern !== null )
      return pattern.test( el );
      return false;
    }

  }
  _strSplit_body.defaults = {
      "preservingEmpty" : 1,
      "preservingDelimeters" : 1,
      "preservingQuoting" : 1,
      "inliningQuoting" : 1,
      "stripping" : 1,
      "quoting" : 1,
      "quotingPrefixes" : null,
      "quotingPostfixes" : null,
      "onDelimeter" : null,
      "onQuote" : null
    }

  const _strSplit_ = _.routine.unite
  ({
    head : _strSplit_head,
    body : _strSplit_body,
  });

  return _strSplit_;
})();
_.strSplit.defaults =
{
  "preservingEmpty" : 1,
  "preservingDelimeters" : 1,
  "preservingQuoting" : 1,
  "inliningQuoting" : 1,
  "stripping" : 1,
  "quoting" : 1,
  "quotingPrefixes" : null,
  "quotingPostfixes" : null,
  "onDelimeter" : null,
  "onQuote" : null,
  "src" : null,
  "delimeter" : ` `
}

//


  _.strSplitFast = ( function() {

  const _strSplitFast_head = function strSplitFast_head( routine, args )
  {
    let o = args[ 0 ];

    if( args.length === 2 )
    o = { src : args[ 0 ], delimeter : args[ 1 ] }
    else if( _.strIs( args[ 0 ] ) )
    o = { src : args[ 0 ] }

    _.routine.options( routine, o );

    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 || args.length === 2, 'Expects one or two arguments' );
    _.assert( _.strIs( o.src ) );
    _.assert( o.delimeter === null || _.regexp.like( o.delimeter ) || _.arrayIs( o.delimeter ) );
    _.assert( _.object.isBasic( o ) );

    return o;
  }

  const _strSplitFast_body = function strSplitFast_body( o )
  {
    let result, closests, position, closestPosition, closestIndex, hasEmptyDelimeter, delimeter

    o.delimeter = _.array.as( o.delimeter );

    let foundDelimeters = o.delimeter.slice();

    _.assert( arguments.length === 1 );
    _.assert( _.arrayIs( o.delimeter ) );
    _.assert( _.bool.like( o.preservingDelimeters ) );

    /* */

    if( !o.preservingDelimeters && o.delimeter.length === 1 )
    {

      result = o.src.split( o.delimeter[ 0 ] );

      if( !o.preservingEmpty )
      result = result.filter( ( e ) => e ? e : false );

    }
    else
    {

      if( !o.delimeter.length )
      {
        result = [ o.src ];
        return result;
      }

      result = [];
      closests = [];
      position = 0;
      closestPosition = 0;
      closestIndex = -1;
      hasEmptyDelimeter = false;

      for( let d = 0 ; d < o.delimeter.length ; d++ )
      {
        let delimeter = o.delimeter[ d ];
        if( _.regexpIs( delimeter ) )
        {
          _.assert( !delimeter.sticky );
          if( delimeter.source === '' || delimeter.source === '()' || delimeter.source === '(?:)' )
          hasEmptyDelimeter = true;
        }
        else
        {
          if( delimeter.length === 0 )
          hasEmptyDelimeter = true;
        }
        closests[ d ] = delimeterNext( d, position );
      }

      do
      {
        closestWhich();

        if( closestPosition === o.src.length )
        break;

        if( !delimeter.length )
        position += 1;

        ordinaryAdd( o.src.substring( position, closestPosition ) );

        if( delimeter.length > 0 || position < o.src.length )
        delimeterAdd( delimeter );

        position = closests[ closestIndex ] + ( delimeter.length ? delimeter.length : 1 );

        for( let d = 0 ; d < o.delimeter.length ; d++ )
        if( closests[ d ] < position )
        closests[ d ] = delimeterNext( d, position );

      }
      while( position < o.src.length );

      if( delimeter || !hasEmptyDelimeter )
      ordinaryAdd( o.src.substring( position, o.src.length ) );

    }

    return result;

    /* */

    function delimeterAdd( delimeter )
    {

      if( o.preservingDelimeters )
      if( o.preservingEmpty || delimeter )
      {
        result.push( delimeter );
        // if( _.regexpIs( delimeter ) )
        // result.push( delimeter );
        // o.src.substring( position, closestPosition )
        // else
        // result.push( delimeter );
      }

    }

    /*  */

    function ordinaryAdd( ordinary )
    {
      if( o.preservingEmpty || ordinary )
      result.push( ordinary );
    }

    /* */

    function closestWhich()
    {

      closestPosition = o.src.length;
      closestIndex = -1;
      for( let d = 0 ; d < o.delimeter.length ; d++ )
      {
        if( closests[ d ] < o.src.length && closests[ d ] < closestPosition )
        {
          closestPosition = closests[ d ];
          closestIndex = d;
        }
      }

      delimeter = foundDelimeters[ closestIndex ];

    }

    /* */

    function delimeterNext( d, position )
    {
      _.assert( position <= o.src.length );
      let delimeter = o.delimeter[ d ];
      let result;

      if( _.strIs( delimeter ) )
      {
        result = o.src.indexOf( delimeter, position );
      }
      else
      {
        let execed = delimeter.exec( o.src.substring( position ) );
        if( execed )
        {
          result = execed.index + position;
          foundDelimeters[ d ] = execed[ 0 ];
        }
      }

      if( result === -1 )
      return o.src.length;
      return result;
    }

  }
  _strSplitFast_body.defaults = {
      "src" : null,
      "delimeter" : ` `,
      "preservingEmpty" : 1,
      "preservingDelimeters" : 1
    }

  const _strSplitFast_ = _.routine.unite
  ({
    head : _strSplitFast_head,
    body : _strSplitFast_body,
  });

  return _strSplitFast_;
})();
_.strSplitFast.defaults =
{
  "src" : null,
  "delimeter" : ` `,
  "preservingEmpty" : 1,
  "preservingDelimeters" : 1
}

//


  _.strSplitsQuotedRejoin = ( function() {

  const _strSplitsQuotedRejoin_head = function strSplitsQuotedRejoin_head( routine, args )
  {
    let o = args[ 0 ];

    _.routine.options( routine, o );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1, 'Expects one or two arguments' );
    _.assert( _.object.isBasic( o ) );

    if( o.quoting )
    {

      if( _.bool.like( o.quoting ) )
      {
        if( !o.quotingPrefixes )
        o.quotingPrefixes = [ '"' ];
        if( !o.quotingPostfixes )
        o.quotingPostfixes = [ '"' ];
      }
      else if( _.strIs( o.quoting ) || _.regexpIs( o.quoting ) || _.arrayIs( o.quoting ) )
      {
        _.assert( !o.quotingPrefixes );
        _.assert( !o.quotingPostfixes );
        o.quoting = _.array.as( o.quoting );
        o.quotingPrefixes = o.quoting.map( ( q ) => _.arrayIs( q ) ? q[ 0 ] : q );
        o.quotingPostfixes = o.quoting.map( ( q ) => _.arrayIs( q ) ? q[ 0 ] : q );
        o.quoting = true;
      }
      else _.assert( 0, 'unexpected type of {-o.quoting-}' );

      _.assert
      (
        !o.pairing || o.quotingPrefixes.length === o.quotingPostfixes.length,
        `If option::o.paring is true then the length of o.quotingPrefixes should be equal to the length of o.quotingPostfixes`
      );

      if( Config.debug )
      {
        _.assert( o.quotingPrefixes.length === o.quotingPostfixes.length );
        _.assert( _.bool.like( o.quoting ) );
        o.quotingPrefixes.forEach( ( q ) => _.assert( _.strIs( q ) ) );
        o.quotingPostfixes.forEach( ( q ) => _.assert( _.strIs( q ) ) );
      }

    }

    return o;
  }

  const _strSplitsQuotedRejoin_body = function strSplitsQuotedRejoin_body( o )
  {

    _.assert( arguments.length === 1 );
    _.assert( _.arrayIs( o.splits ) );

    /* quoting */

    // let s = 1; // why was it 1??
    let s = 0;
    if( o.quoting )
    {
      for( s ; s < o.splits.length ; s += 1 )
      splitsQuote( o.splits[ s ], s );
    }

    return o.splits;

    function splitsQuote( split, i )
    {
      let s2;
      let q = o.quotingPrefixes.indexOf( split );

      if( q >= 0 )
      {
        let postfix = o.quotingPostfixes[ q ];
        for( s2 = i+2 ; s2 < o.splits.length ; s2 += 1 )
        {
          let split2 = o.splits[ s2 ];
          if( split2 === postfix )
          {
            if( o.pairing )
            if( o.quotingPrefixes.indexOf( o.splits[ s ] ) !== o.quotingPostfixes.indexOf( o.splits[ s2 ] ) )
            break;
            let bextra = 0;
            let eextra = 0;
            if( o.inliningQuoting )
            {
              s -= 1;
              bextra += 1;
              s2 += 1;
              eextra += 1;
            }
            let splitNew = o.splits.splice( s, s2-s+1, null );
            if( !o.preservingQuoting )
            {
              splitNew.splice( bextra, 1 );
              splitNew.splice( splitNew.length-1-eextra, 1 );
            }
            splitNew = splitNew.join( '' );
            if( o.onQuoting )
            o.splits[ s ] = o.onQuoting( splitNew, o );
            else
            o.splits[ s ] = splitNew;
            s2 = s;
            break;
          }
        }
      }

      /* if complementing postfix not found */

      if( s2 >= o.splits.length )
      {
        if( !_.longHas( o.delimeter, split ) )
        {
          let splitNew = o.splits.splice( s, 2 ).join( '' );
          o.splits[ s-1 ] = o.splits[ s-1 ] + splitNew;
        }
        else
        {
        }
      }
    }
  }
  _strSplitsQuotedRejoin_body.defaults = {
      "quoting" : 1,
      "quotingPrefixes" : null,
      "quotingPostfixes" : null,
      "preservingQuoting" : 1,
      "inliningQuoting" : 1,
      "splits" : null,
      "delimeter" : null,
      "onQuoting" : null,
      "pairing" : 0
    }

  const _strSplitsQuotedRejoin_ = _.routine.unite
  ({
    head : _strSplitsQuotedRejoin_head,
    body : _strSplitsQuotedRejoin_body,
  });

  return _strSplitsQuotedRejoin_;
})();
_.strSplitsQuotedRejoin.defaults =
{
  "quoting" : 1,
  "quotingPrefixes" : null,
  "quotingPostfixes" : null,
  "preservingQuoting" : 1,
  "inliningQuoting" : 1,
  "splits" : null,
  "delimeter" : null,
  "onQuoting" : null,
  "pairing" : 0
}

//


  _.strSplitsDropDelimeters = ( function() {

  const _strSplitsDropDelimeters_head = function strSplitsDropDelimeters_head( routine, args )
  {
    let o = args[ 0 ];

    _.routine.options( routine, o );

    if( _.strIs( o.delimeter ) )
    o.delimeter = [ o.delimeter ];

    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 );
    _.assert( _.object.isBasic( o ) );

    return o;
  }

  const _strSplitsDropDelimeters_body = function strSplitsDropDelimeters_body( o )
  {

    _.assert( arguments.length === 1 );
    _.assert( _.arrayIs( o.splits ) );

    /* stripping */

    // if( o.delimeter.some( ( d ) => _.regexpIs( d ) ) )
    // debugger;

    for( let s = o.splits.length-1 ; s >= 0 ; s-- )
    {
      let split = o.splits[ s ];

      if( _.regexpsTestAny( o.delimeter, split ) ) /* xxx qqq : ? */
      o.splits.splice( s, 1 );

      // if( _.longHas( o.delimeter, split ) )
      // o.splits.splice( s, 1 );
      //
      // if( s % 2 === 1 )
      // o.splits.splice( s, 1 );

    }

    return o.splits;
  }
  _strSplitsDropDelimeters_body.defaults = { "splits" : null, "delimeter" : null }

  const _strSplitsDropDelimeters_ = _.routine.unite
  ({
    head : _strSplitsDropDelimeters_head,
    body : _strSplitsDropDelimeters_body,
  });

  return _strSplitsDropDelimeters_;
})();
_.strSplitsDropDelimeters.defaults =
{ "splits" : null, "delimeter" : null }

//


  _.strSplitsStrip = ( function() {

  const _strSplitsStrip_head = function strSplitsStrip_head( routine, args )
  {
    let o = args[ 0 ];

    _.routine.options( routine, o );

    if( o.stripping && _.bool.like( o.stripping ) )
    o.stripping = _.strStrip.defaults.stripper;

    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 );
    _.assert( _.object.isBasic( o ) );
    _.assert( !o.stripping || _.strIs( o.stripping ) || _.regexpIs( o.stripping ) );

    return o;
  }

  const _strSplitsStrip_body = function strSplitsStrip_body( o )
  {

    _.assert( arguments.length === 1 );
    _.assert( _.arrayIs( o.splits ) );

    if( !o.stripping )
    return o.splits;

    /* stripping */

    for( let s = 0 ; s < o.splits.length ; s++ )
    {
      let split = o.splits[ s ];

      if( _.strIs( split ) )
      split = _.strStrip({ src : split, stripper : o.stripping });

      o.splits[ s ] = split;
    }

    return o.splits;
  }
  _strSplitsStrip_body.defaults = { "stripping" : 1, "splits" : null }

  const _strSplitsStrip_ = _.routine.unite
  ({
    head : _strSplitsStrip_head,
    body : _strSplitsStrip_body,
  });

  return _strSplitsStrip_;
})();
_.strSplitsStrip.defaults =
{ "stripping" : 1, "splits" : null }

//


  _.strSplitsDropEmpty = ( function() {

  const _strSplitsDropEmpty_head = function strSplitsDropEmpty_head( routine, args )
  {
    let o = args[ 0 ];

    _.routine.options( routine, o );

    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( args.length === 1 );
    _.assert( _.object.isBasic( o ) );

    return o;
  }

  const _strSplitsDropEmpty_body = function strSplitsDropEmpty_body( o )
  {

    _.assert( arguments.length === 1 );
    _.assert( _.arrayIs( o.splits ) );

    /* stripping */

    for( let s = 0 ; s < o.splits.length ; s++ )
    {
      let split = o.splits[ s ];

      if( !split )
      {
        o.splits.splice( s, 1 );
        s -= 1;
      }

    }

    return o.splits;
  }
  _strSplitsDropEmpty_body.defaults = { "splits" : null }

  const _strSplitsDropEmpty_ = _.routine.unite
  ({
    head : _strSplitsDropEmpty_head,
    body : _strSplitsDropEmpty_body,
  });

  return _strSplitsDropEmpty_;
})();
_.strSplitsDropEmpty.defaults =
{ "splits" : null }

//


  _.strStrip = function strip( o )
{

  if( _.strIs( o ) || _.arrayIs( o ) )
  o = { src : o };

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.routine.options( strip, o );

  o.stripper = stripperNormalize();
  let stripRoutine = _.regexpIs( o.stripper ) ? singleStripByRegexp : singleStripByArrayOfStrings;

  if( _.arrayIs( o.src ) )
  {
    _.assert( _.strsAreAll( o.src ), 'Expects strings {-o.srs-}' );

    let result = [];
    for( let i = 0 ; i < o.src.length ; i++ )
    result[ i ] = stripRoutine( o.src[ i ] );
    return result;
  }

  _.assert( _.strIs( o.src ) );
  return stripRoutine( o.src );

  /* */

  function stripperNormalize()
  {
    let stripper = o.stripper;
    if( _.bool.likeTrue( o.stripper ) )
    {
      stripper = strip.defaults.stripper;
    }
    else if( _.arrayIs( o.stripper ) )
    {
      _.assert( _.strsAreAll( o.stripper ), 'Expects characters in container {-o.stripper-}' );
    }
    else if( _.strIs( o.stripper ) )
    {
      stripper = _.regexpEscape( o.stripper );
      stripper = new RegExp( stripper, 'g' );
    }
    else if( !_.regexpIs( o.stripper ) )
    {
      _.assert( 0, 'Unexpected type of {-o.stripper-}. Expects either a String, an Array or a Regexp {-o.stripper-}' );
    }
    return stripper;
  }

  /* */

  function singleStripByRegexp( src )
  {
    return src.replace( o.stripper, '' );
  }

  /* */

  function singleStripByArrayOfStrings( src )
  {
    let begin = 0;
    for( ; begin < src.length ; begin++ )
    if( o.stripper.indexOf( src[ begin ] ) === -1 )
    break;

    let end = src.length-1;
    for( ; end >= 0 ; end-- )
    if( o.stripper.indexOf( src[ end ] ) === -1 )
    break;

    if( begin >= end )
    return '';

    return src.substring( begin, end + 1 );
  }

}
_.strStrip.defaults =
{ "src" : null, "stripper" : /^(\s|\n|\0)+|(\s|\n|\0)+$/g }

//


  _.strLinesSelect = function strLinesSelect( o )
{

  if( arguments.length === 2 )
  {

    if( _.arrayIs( arguments[ 1 ] ) )
    o = { src : arguments[ 0 ], range : arguments[ 1 ] };
    else if( _.number.is( arguments[ 1 ] ) )
    o = { src : arguments[ 0 ], range : [ arguments[ 1 ], arguments[ 1 ]+1 ] };
    else _.assert( 0, 'unexpected argument', _.entity.strType( range ) );

  }
  else if( arguments.length === 3 )
  {
    o = { src : arguments[ 0 ], range : [ arguments[ 1 ], arguments[ 2 ] ] };
  }

  _.routine.options( strLinesSelect, o );
  _.assert( arguments.length <= 3 );
  _.assert( _.strIs( o.src ) );
  _.assert( _.bool.like( o.highlighting ) || _.longHas( [ '*' ], o.highlighting ) );

  if( _.bool.like( o.highlighting ) && o.highlighting )
  o.highlighting = '*';

  /* range */

  if( !o.range )
  {
    if( o.line === null )
    {
      o.range = [ 0, _.strCount( o.src, o.delimteter )+1 ];
    }
    else
    {
      if( o.selectMode === 'center' )
      o.range = [ o.line - Math.ceil( ( o.nearestLines + 1 ) / 2 ) + 1, o.line + Math.floor( ( o.nearestLines - 1 ) / 2 ) + 1 ];
      else if( o.selectMode === 'begin' )
      o.range = [ o.line, o.line + o.nearestLines ];
      else if( o.selectMode === 'end' )
      o.range = [ o.line - o.nearestLines+1, o.line+1 ];
    }
    // if( o.line !== null )
    // {
    //   if( o.selectMode === 'center' )
    //   o.range = [ o.line - Math.ceil( ( o.nearestLines + 1 ) / 2 ) + 1, o.line + Math.floor( ( o.nearestLines - 1 ) / 2 ) + 1 ];
    //   else if( o.selectMode === 'begin' )
    //   o.range = [ o.line, o.line + o.nearestLines ];
    //   else if( o.selectMode === 'end' )
    //   o.range = [ o.line - o.nearestLines+1, o.line+1 ];
    // }
    // else
    // {
    //   o.range = [ 0, _.strCount( o.src, o.delimteter )+1 ];
    // }
  }

  if( o.line === null )
  {
    if( o.selectMode === 'center' )
    o.line = Math.floor( ( o.range[ 0 ] + o.range[ 1 ] ) / 2 );
    else if( o.selectMode === 'begin' )
    o.line = o.range[ 0 ];
    else if( o.selectMode === 'end' )
    o.line = o.range[ 1 ] - 1;

    o.line = o.line > 0 ? o.line : 1;
  }

  _.assert( _.longIs( o.range ) );
  _.assert( _.intIs( o.line ) && o.line >= 0, 'Expects positive integer {-o.line-}.' );

  /* */

  let f = 0;
  let counter = o.zeroLine;
  while( counter < o.range[ 0 ] )
  {
    f = o.src.indexOf( o.delimteter, f );
    if( f === -1 )
    return '';
    f += o.delimteter.length;
    counter += 1;
  }

  /* */

  let l = f-1;
  while( counter < o.range[ 1 ] )
  {
    l += 1;
    l = o.src.indexOf( o.delimteter, l );
    if( l === -1 )
    {
      l = o.src.length;
      break;
    }
    counter += 1;
  }

  /* */

  let result = f < l ? o.src.substring( f, l ) : '';

  /* numbering */

  let zeroLine = o.range[ 0 ] <= 0 ? o.zeroLine : o.range[ 0 ];

  if( o.numbering && result.length )
  result = _.strLinesNumber
  ({
    src : result,
    zeroLine,
    onLine : lineHighlight,
  });

  return result;

  /* */

  function lineHighlight( line, l )
  {
    if( !o.highlighting )
    return line.join( '' );
    if( l === o.line )
    line[ 0 ] = '* ' + line[ 0 ];
    else
    line[ 0 ] = '  ' + line[ 0 ];
    // line[ 1 ] = _.strBut( line[ 1 ], 0, '*' );
    return line.join( '' );
  }

  /* */

}
_.strLinesSelect.defaults =
{
  "src" : null,
  "range" : null,
  "line" : null,
  "nearestLines" : 3,
  "selectMode" : `center`,
  "highlighting" : `*`,
  "numbering" : 0,
  "zeroLine" : 1,
  "delimteter" : `\n`
}

//


  _._strLeftSingle_ = function _leftSingle_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.strIs( src ) );

  if( _.number.is( cinterval ) )
  cinterval = [ cinterval, src.length - 1 ];
  else if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];

  cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  cinterval[ 1 ] = cinterval[ 1 ] === undefined ? src.length - 1 : cinterval[ 1 ];

  if( cinterval[ 0 ] < 0 )
  cinterval[ 0 ] = src.length + cinterval[ 0 ];
  if( cinterval[ 1 ] < -1 )
  cinterval[ 1 ] = src.length + cinterval[ 1 ];

  _.assert( _.intervalIs( cinterval ) );
  _.assert( 0 <= cinterval[ 0 ] && cinterval[ 0 ] <= src.length );
  _.assert( -1 <= cinterval[ 1 ] && cinterval[ 1 ] <= src.length - 1 );

  let result = Object.create( null );
  result.index = src.length;
  result.instanceIndex = -1;
  result.entry = undefined;

  let src1 = src.substring( cinterval[ 0 ], cinterval[ 1 ] + 1 );

  ins = _.array.as( ins );

  for( let k = 0 ; k < ins.length ; k++ )
  {
    let entry = ins[ k ];
    if( _.strIs( entry ) )
    {
      let found = src1.indexOf( entry );
      if( found >= 0 && ( found < result.index || result.entry === undefined ) )
      {
        result.instanceIndex = k;
        result.index = found;
        result.entry = entry;
      }
    }
    else if( _.regexpIs( entry ) )
    {
      let found = src1.match( entry );
      if( found && ( found.index < result.index || result.entry === undefined ) )
      {
        result.instanceIndex = k;
        result.index = found.index;
        result.entry = found[ 0 ];
      }
    }
    else _.assert( 0, 'Expects string-like ( string or regexp )' );
  }

  if( cinterval[ 0 ] !== 0 && result.index !== src.length )
  result.index += cinterval[ 0 ];

  return result;
}

//


  _._strRightSingle_ = function _rightSingle_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.strIs( src ) );

  if( _.number.is( cinterval ) )
  cinterval = [ cinterval, src.length - 1 ];
  else if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];

  cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  cinterval[ 1 ] = cinterval[ 1 ] === undefined ? src.length - 1 : cinterval[ 1 ];

  if( cinterval[ 0 ] < 0 )
  cinterval[ 0 ] = src.length + cinterval[ 0 ];
  if( cinterval[ 1 ] < -1 )
  cinterval[ 1 ] = src.length + cinterval[ 1 ];

  _.assert( _.intervalIs( cinterval ) );
  _.assert( 0 <= cinterval[ 0 ] && cinterval[ 0 ] <= src.length );
  _.assert( -1 <= cinterval[ 1 ] && cinterval[ 1 ] <= src.length - 1 );

  let olength = src.length;

  let result = Object.create( null );
  result.index = -1;
  result.instanceIndex = -1;
  result.entry = undefined;

  let src1 = src.substring( cinterval[ 0 ], cinterval[ 1 ] + 1 );

  ins = _.array.as( ins );

  for( let k = 0, len = ins.length ; k < len ; k++ )
  {
    let entry = ins[ k ];
    if( _.strIs( entry ) )
    {
      let found = src1.lastIndexOf( entry );
      if( found >= 0 && found > result.index )
      {
        result.instanceIndex = k;
        result.index = found;
        result.entry = entry;
      }
    }
    else if( _.regexpIs( entry ) )
    {

      let regexp1 = _.regexpsJoin([ '.*', '(', entry, ')' ]);
      let match1 = src1.match( regexp1 );
      if( !match1 )
      continue;

      let regexp2 = _.regexpsJoin([ entry, '(?!(?=.).*', entry, ')' ]);
      let match2 = src1.match( regexp2 );
      _.assert( !!match2 );

      let found;
      let found1 = match1[ 1 ];
      let found2 = match2[ 0 ];
      let index;
      let index1 = match1.index + match1[ 0 ].length;
      let index2 = match2.index + match2[ 0 ].length;

      if( index1 === index2 )
      {
        if( found1.length < found2.length )
        {
          found = found2;
          index = index2 - found.length;
        }
        else
        {
          found = found1;
          index = index1 - found.length;
        }
      }
      else if( index1 < index2 )
      {
        found = found2;
        index = index2 - found.length;
      }
      else
      {
        found = found1;
        index = index1 - found.length;
      }

      if( index > result.index )
      {
        result.instanceIndex = k;
        result.index = index;
        result.entry = found;
      }

    }
    else _.assert( 0, 'Expects string-like ( string or regexp )' );
  }

  if( cinterval[ 0 ] !== 0 && result.index !== -1 )
  result.index += cinterval[ 0 ];

  return result;
}

//


  _.strIsolate = ( function() {

  const _strIsolate_head = function strIsolate_head( routine, args )
  {
    let o;

    if( args.length > 1 )
    {
      if( args.length === 3 )
      o = { src : args[ 0 ], delimeter : args[ 1 ], times : args[ 2 ] };
      else if( args.length === 2 )
      o = { src : args[ 0 ], delimeter : args[ 1 ] };
      else
      o = { src : args[ 0 ] };
    }
    else
    {
      o = args[ 0 ];
      _.assert( args.length === 1, 'Expects single argument' );
    }

    _.routine.options( routine, o );
    _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( _.strIs( o.src ) );
    _.assert( _.regexpsLikeAll( o.delimeter ) )
    _.assert( _.number.is( o.times ) );

    return o;
  }

  const _strIsolate_body = function strIsolate_body( o )
  {
    let result = [];
    let times = o.times;
    let delimeter
    let index = o.left ? 0 : o.src.length;
    let more = o.left ? strLeft : strRight;
    let delta = ( o.left ? +1 : -1 );

    _.routine.assertOptions( strIsolate_body, arguments );

    /* */

    if( _.arrayIs( o.delimeter ) && o.delimeter.length === 1 )
    o.delimeter = o.delimeter[ 0 ];

    let quote;
    if( o.quote )
    quote = _.strQuoteAnalyze({ src : o.src, quote : o.quote });

    /* */

    while( times > 0 )
    {
      let found = more( index );

      if( found.entry === undefined )
      break;

      times -= 1;

      if( o.left )
      index = found.index + delta;
      else
      index = found.index + found.entry.length + delta;

      if( times === 0 )
      {
        result.push( o.src.substring( 0, found.index ) );
        result.push( found.entry );
        result.push( o.src.substring( found.index + found.entry.length ) );
        return result;
      }

      /* */

      if( o.left )
      {
        if( index >= o.src.length )
        break;
      }
      else
      {
        if( index <= 0 )
        break;
      }

    }

    /* */

    if( !result.length )
    {

      if( o.times === 0 )
      return everything( !o.left );
      else if( times === o.times )
      return everything( o.left ^ o.none );
      else
      return everything( o.left );

    }

    return result;

    /* */

    function everything( side )
    {
      return ( side ) ? [ o.src, undefined, '' ] : [ '', undefined, o.src ];
    }

    /* */

    function strLeft( index )
    {
      // let r = _._strLeftSingle( o.src, o.delimeter, [ index, undefined ] );
      let r = _._strLeftSingle_( o.src, o.delimeter, [ index, undefined ] );
      if( quote )
      if( r.entry !== undefined )
      {
        let range = inQuoteRange( r.index );
        if( range )
        return strLeft( range[ 1 ]+1 );
      }
      return r;
    }

    /* */

    function strRight( index )
    {
      // let r = _._strRightSingle( o.src, o.delimeter, [ undefined, index ] );
      let r = _._strRightSingle_( o.src, o.delimeter, [ undefined, index-1 ] );
      if( quote )
      if( r.entry !== undefined )
      {
        let range = inQuoteRange( r.index );
        if( range )
        return strRight( range[ 0 ] );
      }
      return r;
    }

    /* */

    function inQuoteRange( offset )
    {
      let i = _.sorted.searchFirstIndex( quote.ranges, offset );
      if( i % 2 )
      {
        i -= 1;
      }
      if( i < 0 || i >= quote.ranges.length )
      return false;
      let b = quote.ranges[ i ];
      let e = quote.ranges[ i+1 ];
      if( !( b <= offset && offset <= e ) )
      return false;
      return [ b, e ];
    }

    /* */

    // function binSearch( val )
    // {
    //   let l = 0;
    //   let r = quote.ranges.length;
    //   let m;
    //   if( quote.ranges.length )
    //   debugger;
    //   do
    //   {
    //     m = Math.floor( ( l + r ) / 2 );
    //     if( quote.ranges[ m ] < val )
    //     l = m+1;
    //     else if( quote.ranges[ m ] > val )
    //     r = m;
    //     else
    //     return m;
    //   }
    //   while( l < r );
    //   if( quote.ranges[ m ] < val )
    //   return m+1;
    //   return m;
    // }

    /* */

    // let quotedRanges = [];
    //
    // function quoteRangesSetup( index )
    // {
    //   let quotes = [];
    //   for( let i = 0 ; i < o.src.length ; i++ )
    //   {
    //     if( _.arrayHas( o.quote,  ) )
    //   }
    // }
    //
    // function quoteRange( index )
    // {
    //   for( let i = 0 ; i < x ; i++ )
    //
    // }

  }
  _strIsolate_body.defaults = {
      "src" : null,
      "delimeter" : ` `,
      "quote" : 0,
      "left" : 1,
      "times" : 1,
      "none" : 1
    }

  const _strIsolate_ = _.routine.unite
  ({
    head : _strIsolate_head,
    body : _strIsolate_body,
  });

  return _strIsolate_;
})();
_.strIsolate.defaults =
{
  "src" : null,
  "delimeter" : ` `,
  "quote" : 0,
  "left" : 1,
  "times" : 1,
  "none" : 1
}

//


  _.strIsolateLeftOrNone = ( function() {

  const _strIsolateLeftOrNone_head = function strIsolate_head( routine, args )
  {
    let o;

    if( args.length > 1 )
    {
      if( args.length === 3 )
      o = { src : args[ 0 ], delimeter : args[ 1 ], times : args[ 2 ] };
      else if( args.length === 2 )
      o = { src : args[ 0 ], delimeter : args[ 1 ] };
      else
      o = { src : args[ 0 ] };
    }
    else
    {
      o = args[ 0 ];
      _.assert( args.length === 1, 'Expects single argument' );
    }

    _.routine.options( routine, o );
    _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( _.strIs( o.src ) );
    _.assert( _.regexpsLikeAll( o.delimeter ) )
    _.assert( _.number.is( o.times ) );

    return o;
  }

  const _strIsolateLeftOrNone_body = function strIsolateLeftOrNone_body( o )
  {
    o.left = 1;
    o.none = 1;
    let result = _.strIsolate.body( o );
    return result;
  }
  _strIsolateLeftOrNone_body.defaults = {
      "src" : null,
      "delimeter" : ` `,
      "times" : 1,
      "quote" : null
    }

  const _strIsolateLeftOrNone_ = _.routine.unite
  ({
    head : _strIsolateLeftOrNone_head,
    body : _strIsolateLeftOrNone_body,
  });

  return _strIsolateLeftOrNone_;
})();
_.strIsolateLeftOrNone.defaults =
{
  "src" : null,
  "delimeter" : ` `,
  "times" : 1,
  "quote" : null
}

//


  _.strIsolateRightOrNone = ( function() {

  const _strIsolateRightOrNone_head = function strIsolate_head( routine, args )
  {
    let o;

    if( args.length > 1 )
    {
      if( args.length === 3 )
      o = { src : args[ 0 ], delimeter : args[ 1 ], times : args[ 2 ] };
      else if( args.length === 2 )
      o = { src : args[ 0 ], delimeter : args[ 1 ] };
      else
      o = { src : args[ 0 ] };
    }
    else
    {
      o = args[ 0 ];
      _.assert( args.length === 1, 'Expects single argument' );
    }

    _.routine.options( routine, o );
    _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( _.strIs( o.src ) );
    _.assert( _.regexpsLikeAll( o.delimeter ) )
    _.assert( _.number.is( o.times ) );

    return o;
  }

  const _strIsolateRightOrNone_body = function strIsolateRightOrNone_body( o )
  {
    o.left = 0;
    o.none = 1;
    let result = _.strIsolate.body( o );
    return result;
  }
  _strIsolateRightOrNone_body.defaults = {
      "src" : null,
      "delimeter" : ` `,
      "times" : 1,
      "quote" : null
    }

  const _strIsolateRightOrNone_ = _.routine.unite
  ({
    head : _strIsolateRightOrNone_head,
    body : _strIsolateRightOrNone_body,
  });

  return _strIsolateRightOrNone_;
})();
_.strIsolateRightOrNone.defaults =
{
  "src" : null,
  "delimeter" : ` `,
  "times" : 1,
  "quote" : null
}

//


  _.strIsolateLeftOrAll = ( function() {

  const _strIsolateLeftOrAll_head = function strIsolate_head( routine, args )
  {
    let o;

    if( args.length > 1 )
    {
      if( args.length === 3 )
      o = { src : args[ 0 ], delimeter : args[ 1 ], times : args[ 2 ] };
      else if( args.length === 2 )
      o = { src : args[ 0 ], delimeter : args[ 1 ] };
      else
      o = { src : args[ 0 ] };
    }
    else
    {
      o = args[ 0 ];
      _.assert( args.length === 1, 'Expects single argument' );
    }

    _.routine.options( routine, o );
    _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( _.strIs( o.src ) );
    _.assert( _.regexpsLikeAll( o.delimeter ) )
    _.assert( _.number.is( o.times ) );

    return o;
  }

  const _strIsolateLeftOrAll_body = function strIsolateLeftOrAll_body( o )
  {
    o.left = 1;
    o.none = 0;
    let result = _.strIsolate.body( o );
    return result;
  }
  _strIsolateLeftOrAll_body.defaults = {
      "src" : null,
      "delimeter" : ` `,
      "times" : 1,
      "quote" : null
    }

  const _strIsolateLeftOrAll_ = _.routine.unite
  ({
    head : _strIsolateLeftOrAll_head,
    body : _strIsolateLeftOrAll_body,
  });

  return _strIsolateLeftOrAll_;
})();
_.strIsolateLeftOrAll.defaults =
{
  "src" : null,
  "delimeter" : ` `,
  "times" : 1,
  "quote" : null
}

//


  _.strIsolateRightOrAll = ( function() {

  const _strIsolateRightOrAll_head = function strIsolate_head( routine, args )
  {
    let o;

    if( args.length > 1 )
    {
      if( args.length === 3 )
      o = { src : args[ 0 ], delimeter : args[ 1 ], times : args[ 2 ] };
      else if( args.length === 2 )
      o = { src : args[ 0 ], delimeter : args[ 1 ] };
      else
      o = { src : args[ 0 ] };
    }
    else
    {
      o = args[ 0 ];
      _.assert( args.length === 1, 'Expects single argument' );
    }

    _.routine.options( routine, o );
    _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( _.strIs( o.src ) );
    _.assert( _.regexpsLikeAll( o.delimeter ) )
    _.assert( _.number.is( o.times ) );

    return o;
  }

  const _strIsolateRightOrAll_body = function strIsolateRightOrAll_body( o )
  {
    o.left = 0;
    o.none = 0;
    let result = _.strIsolate.body( o );
    return result;
  }
  _strIsolateRightOrAll_body.defaults = {
      "src" : null,
      "delimeter" : ` `,
      "times" : 1,
      "quote" : null
    }

  const _strIsolateRightOrAll_ = _.routine.unite
  ({
    head : _strIsolateRightOrAll_head,
    body : _strIsolateRightOrAll_body,
  });

  return _strIsolateRightOrAll_;
})();
_.strIsolateRightOrAll.defaults =
{
  "src" : null,
  "delimeter" : ` `,
  "times" : 1,
  "quote" : null
}

//


  _.strLinesIndentation = function strLinesIndentation( src, tab, every )
{

  if( every === undefined )
  every = true;

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.strIs( src ) || _.arrayIs( src ), 'Expects src as string or array' );
  _.assert( _.strIs( tab ) || _.number.is( tab ), 'Expects tab as string or number' );
  _.assert( every === undefined || _.bool.like( every ) );

  if( _.number.is( tab ) )
  tab = _.strDup( ' ', tab );

  if( _.strIs( src ) )
  {
    if( src.indexOf( '\n' ) === -1 )
    return src;
    src = _.str.lines.split( src );
  }

  /*
    should be no tab in prolog
  */

  if( every === true )
  {
    let result = src.join( '\n' + tab );
    return result;
  }
  else
  {
    let result = '';
    src.forEach( ( e, c ) =>
    {
      if( c > 0 )
      result += '\n';
      result += e.length > 0 && c > 0 ? tab + e : e;
    });
    return result;
  }
}

//


  _.strEscape = function strEscape( o )
{

  // 007f : ''
  // . . .
  // 009f : ''

  // 00ad : ''

  // \'   single quote   byte 0x27 in ASCII encoding
  // \'   double quote   byte 0x22 in ASCII encoding
  // \\   backslash   byte 0x5c in ASCII encoding
  // \b   backspace   byte 0x08 in ASCII encoding
  // \f   form feed - new page   byte 0x0c in ASCII encoding
  // \n   line feed - new line   byte 0x0a in ASCII encoding
  // \r   carriage return   byte 0x0d in ASCII encoding
  // \t   horizontal tab   byte 0x09 in ASCII encoding
  // \v   vertical tab   byte 0x0b in ASCII encoding
  // source : http://en.cppreference.com/w/cpp/language/escape

  if( _.strIs( o ) )
  o = { src : o }

  _.assert( _.strIs( o.src ), 'Expects string {-o.src-}, but got', _.entity.strType( o.src ) );
  _.routine.options( strEscape, o );

  let result = '';
  let stringWrapperCode = o.stringWrapper.charCodeAt( 0 );
  for( let s = 0 ; s < o.src.length ; s++ )
  {
    let code = o.src.charCodeAt( s );

    if( o.stringWrapper === '`' && code === 0x24 /* $ */ )
    {
      result += '\\$';
    }
    else if( o.stringWrapper && code === stringWrapperCode )
    {
      result += '\\' + o.stringWrapper;
    }
    else if( 0x007f <= code && code <= 0x009f || code === 0x00ad /*|| code >= 65533*/ )
    {
      result += _.strCodeUnicodeEscape( code );
    }
    else switch( code )
    {

      case 0x5c /* '\\' */ :
        result += '\\\\';
        break;

      case 0x08 /* '\b' */ :
        result += '\\b';
        break;

      case 0x0c /* '\f' */ :
        result += '\\f';
        break;

      case 0x0a /* '\n' */ :
        result += '\\n';
        break;

      case 0x0d /* '\r' */ :
        result += '\\r';
        break;

      case 0x09 /* '\t' */ :
        result += '\\t';
        break;

      // /* xxx : extend coverage of routine _.strEscape. don't forget this test case */
      // case 0x0b /* '\v' */ :
      //   result += '\\v';
      //   break;

      default :
        if( code < 32 )
        {
          result += _.strCodeUnicodeEscape( code );
        }
        else
        {
          result += String.fromCharCode( code );
        }

    }

  }

  return result;
}
_.strEscape.defaults =
{ "src" : null, "stringWrapper" : `'`, "charsToEscape" : null }

//


  _.strShort_ = function short_( o )  /* version with binary search cutting */
{

  if( arguments.length === 2 )
  o = { src : arguments[ 0 ], widthLimit : arguments[ 1 ] };
  else if( arguments.length === 1 )
  if( _.strIs( o ) )
  o = { src : arguments[ 0 ] };

  _.routine.options( short_, o );

  _.assert( _.strIs( o.src ) );
  _.assert( _.number.is( o.widthLimit ) );
  _.assert( o.widthLimit >= 0, 'Option::o.widthLimit must be greater or equal to zero' );
  _.assert
  (
    _.number.is( o.heightLimit ) && o.heightLimit >= 0,
    'If provided option::o.heightLimit must be greater or equal to zero'
  );
  _.assert( o.delimeter === null || _.strIs( o.delimeter ) || _.bool.likeTrue( o.delimeter ));
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( !o.delimeter )
  o.delimeter = '';
  if( !o.heightDelimeter )
  o.heightDelimeter = '';
  if( o.widthLimit === 0 )
  o.widthLimit = Infinity;
  if( o.heightLimit === 0 )
  o.heightLimit = Infinity;

  if( _.bool.likeTrue( o.delimeter ) )
  o.delimeter = '...';

  if( !o.onLength )
  o.onLength = ( src ) => src.length;

  let src = o.src;

  let isOneLine = o.src.indexOf( '\n' ) === -1;

  if( isOneLine && o.onLength( o.src ) < o.widthLimit )
  {
    o.changed = false;
    o.result = o.src;

    return o;
  }

  let options = Object.create( null ); /* width cutting options */
  options.limit = o.widthLimit;
  options.delimeter = o.delimeter;
  options.onLength = o.onLength;
  options.cutting = o.cutting;

  if( isOneLine )
  {
    options.src = src;
    _.strShortWidth( options );

    o.result = options.result;
    o.changed = options.changed;

    return o;
  }
  else
  {
    let splitted = o.src.split( '\n' );

    let options2 = Object.create( null );  /* height cutting */
    options2.src = splitted;
    options2.limit = o.heightLimit;
    options2.delimeter = o.heightDelimeter;
    options2.cutting = o.heightCutting;
    _._strShortHeight( options2 );

    options.src = options2.result;

    _._strShortWidth( options );

    let result = options.result.join( '\n' );

    if( result === o.src )
    o.changed = false;
    else if( result !== o.src )
    o.changed = true;

    o.result = result;

    return o;
  }
}
_.strShort_.defaults =
{
  "src" : null,
  "widthLimit" : 40,
  "heightLimit" : 0,
  "delimeter" : null,
  "heightDelimeter" : null,
  "onLength" : null,
  "cutting" : `center`,
  "heightCutting" : `center`
}

//


  _.numberFromStrMaybe = function fromStrMaybe( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) || _.number.is( src ) );

  if( _.number.is( src ) )
  return src;
  if( !src ) /* qqq : cover */
  return src;

  // let parsed = !src ? NaN : Number( src ); /* Dmytro : it is strange code, the previous branch checks this condition */
  // if( !isNaN( parsed ) )
  // return parsed;
  // return src;

  let parsed = src ? Number( src ) : NaN;
  if( !isNaN( parsed ) )
  return parsed;
  return src;
}

//



  _.path.name = ( function() {

  const _name_head = function name_head( routine, args )
  {
    let o = args[ 0 ];
    if( _.strIs( o ) )
    o = { path : o };

    _.routine.options_( routine, o );
    _.assert( args.length === 1 );
    _.assert( arguments.length === 2 );
    _.assert( _.strIs( o.path ), 'Expects string {-o.path-}' );

    return o;
  }

  const _name_body = function name_body( o )
  {

    if( _.strIs( o ) )
    o = { path : o };

    _.routine.assertOptions( name_body, arguments );

    o.path = this.canonize( o.path );

    let i = o.path.lastIndexOf( '/' );
    if( i !== -1 )
    o.path = o.path.substr( i+1 );

    if( !o.full )
    {
      let i = o.path.lastIndexOf( '.' );
      if( i !== -1 ) o.path = o.path.substr( 0, i );
    }

    return o.path;
  }
  _name_body.defaults = { "path" : null, "full" : 0 }

  const _name_ = _.routine.unite
  ({
    head : _name_head,
    body : _name_body,
  });

  return _name_;
})();
_.path.name.defaults =
{ "path" : null, "full" : 0 }

//


  _.path.fullName = ( function() {

  const _name_head = function name_head( routine, args )
  {
    let o = args[ 0 ];
    if( _.strIs( o ) )
    o = { path : o };

    _.routine.options_( routine, o );
    _.assert( args.length === 1 );
    _.assert( arguments.length === 2 );
    _.assert( _.strIs( o.path ), 'Expects string {-o.path-}' );

    return o;
  }

  const _name_body = function name_body( o )
  {

    if( _.strIs( o ) )
    o = { path : o };

    _.routine.assertOptions( name_body, arguments );

    o.path = this.canonize( o.path );

    let i = o.path.lastIndexOf( '/' );
    if( i !== -1 )
    o.path = o.path.substr( i+1 );

    if( !o.full )
    {
      let i = o.path.lastIndexOf( '.' );
      if( i !== -1 ) o.path = o.path.substr( 0, i );
    }

    return o.path;
  }
  _name_body.defaults = { "path" : null, "full" : 0 }

  const _name_ = _.routine.unite
  ({
    head : _name_head,
    body : _name_body,
  });

  return _name_;
})();
_.path.fullName.defaults =
{ "path" : null, "full" : 1 }

//



  _.str = {
  "lines" :
  {
    "Eol" :
    {
      "any" : [ `\r\n`, `\n\r`, `\n` ],
      "posix" : `\n`,
      "windows" : `\r\n`,
      "mac" : `\n\r`,
      "default" : `\n`
    },
    "split" : function split( src, eol )
{
  if( _.arrayIs( src ) )
  return src;
  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( eol === undefined )
  eol = _.str.lines.Eol.default;
  return src.split( eol );
},
    "join" : function join( src, eol )
{
  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( eol === undefined )
  eol = _.str.lines.Eol.default;
  let result = src;
  if( _.arrayIs( src ) )
  result = src.join( eol );
  return result;
},
    "strip" : function strip( src )
{

  if( arguments.length > 1 )
  {
    let result = _.unroll.make( null );
    for( let a = 0 ; a < arguments.length ; a++ )
    result[ a ] = _.str.lines.strip( arguments[ a ] );
    return result;
  }

  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 );

  let lines = _.strLinesSplit( src );
  lines = lines.map( ( line ) => line.trim() ).filter( ( line ) => line );

  if( _.strIs( src ) )
  lines = _.str.lines.join( lines );
  return lines;
},
    "atLeft" : function atLeft( src, index, eol )
{
  let result;

  _.assert( _.number.is( index ) );

  if( index < 0 )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ 0, -1 ];
    return result;
  }

  let o2 = Object.create( null );
  o2.src = src;
  o2.eol = eol;
  o2.onEach = onEach;
  o2.interval = [ index, index ];
  o2.withLine = false;
  this.eachLeft( o2 );

  if( !result )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ src.length, src.length-1 ];
  }

  delete result.eol;
  delete result.onEach;
  delete result.interval;
  delete result.withLine;

  return result;

  function onEach( it )
  {
    result = it;
    result.line = src.slice( it.charInterval[ 0 ], it.charInterval[ 1 ]-it.nl.length+1 );
  }

},
    "atRight" : function atRight( src, index, eol )
{
  let result;

  _.assert( _.number.is( index ) );

  if( index < 0 )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ src.length, src.length-1 ];
    return result;
  }

  let o2 = Object.create( null );
  o2.src = src;
  o2.eol = eol;
  o2.onEach = onEach;
  o2.interval = [ index, index ];
  o2.withLine = false;

  this.eachRight( o2 );

  if( !result )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ 0, -1 ];
  }

  delete result.eol;
  delete result.onEach;
  delete result.interval;
  delete result.withLine;

  return result;

  function onEach( it )
  {
    result = it;
    result.line = src.slice( it.charInterval[ 0 ], it.charInterval[ 1 ]-it.nl.length+1 );
  }

},
    "at" : function atLeft( src, index, eol )
{
  let result;

  _.assert( _.number.is( index ) );

  if( index < 0 )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ 0, -1 ];
    return result;
  }

  let o2 = Object.create( null );
  o2.src = src;
  o2.eol = eol;
  o2.onEach = onEach;
  o2.interval = [ index, index ];
  o2.withLine = false;
  this.eachLeft( o2 );

  if( !result )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ src.length, src.length-1 ];
  }

  delete result.eol;
  delete result.onEach;
  delete result.interval;
  delete result.withLine;

  return result;

  function onEach( it )
  {
    result = it;
    result.line = src.slice( it.charInterval[ 0 ], it.charInterval[ 1 ]-it.nl.length+1 );
  }

},
    "_eachLeft" : function _eachLeft( o )
{

  if( o.eol === undefined )
  o.eol = _.str.lines.Eol.default;
  else if( !_.str.is( o.eol ) )
  o.eol = [ ... o.eol ];

  const lastIndex = o.interval ? o.interval[ 1 ] : Infinity;
  const src = o.src;
  let foundTokenIndex;
  let foundOffset;
  let handleEach;

  o.charInterval = [ -1, -1 ];
  o.lineIndex = -1;

  if( o.interval && o.interval[ 1 ] < 0 )
  {
    o.charInterval[ 0 ] = 0;
    return o;
  }

  o.nl = '';

  if( o.interval )
  {
    if( o.withLine )
    handleEach = handleWithIntervalWithLine;
    else
    handleEach = handleWithIntervalWithoutLine;
  }
  else
  {
    if( o.withLine )
    handleEach = handleWithoutIntervalWithLine;
    else
    handleEach = handleWithoutIntervalWithoutLine;
  }

  if( _.str.is( o.eol ) )
  single();
  else
  multiple();

  if( !o.interval || o.lineIndex < o.interval[ 1 ] )
  {
    o.lineIndex += 1;
    o.charInterval[ 0 ] = src.length;
    _.assert( o.charInterval[ 1 ] === src.length - 1 );
    if( o.withLine )
    o.line = '';
  }

  return o;

  /* */

  function single()
  {

    o.nl = o.eol;
    while( o.lineIndex !== lastIndex )
    {
      o.charInterval[ 0 ] = Math.max( o.charInterval[ 0 ], o.charInterval[ 1 ] ) + 1;
      o.charInterval[ 1 ] = src.indexOf( o.eol, o.charInterval[ 0 ] );
      o.lineIndex += 1;

      if( o.charInterval[ 1 ] === -1 )
      {
        o.charInterval[ 1 ] = src.length - 1;
        o.nl = '';
        handleEach();
        break;
      }
      else
      {
        o.charInterval[ 1 ] += o.nl.length - 1;
        handleEach();
      }

    }

  }

  /* */

  function multiple()
  {

    foundTokenIndex = -1;
    foundOffset = src.length;

    let first = indexInit();

    if( first.length === 1 )
    {
      o.eol = o.eol[ foundTokenIndex ];
      return single();
    }

    if( first.length === 0 )
    {

      o.lineIndex = 0;
      o.charInterval[ 0 ] = 0;
      o.charInterval[ 1 ] = src.length-1;
      handleEach();

      return;
    }

    while( o.lineIndex !== lastIndex )
    {
      o.charInterval[ 0 ] = Math.max( o.charInterval[ 0 ], o.charInterval[ 1 ] ) + 1;
      o.charInterval[ 1 ] = indexOf( first );
      o.lineIndex += 1;

      if( o.charInterval[ 1 ] === o.src.length )
      {
        o.charInterval[ 1 ] = src.length - 1;
        o.nl = '';
        handleEach();
        break;
      }
      else
      {
        o.nl = o.eol[ foundTokenIndex ];
        o.charInterval[ 1 ] += o.nl.length - 1;
        handleEach();
      }

    }

  }

  /* */

  function indexInit()
  {
    let first = [];
    for( let i = o.eol.length - 1 ; i >= 0 ; i-- )
    {
      let offset = src.indexOf( o.eol[ i ] );
      if( offset !== -1 )
      {
        first.unshift( offset );
        if( foundOffset >= offset )
        {
          foundOffset = offset;
          foundTokenIndex = i;
        }
      }
      else
      {
        o.eol.splice( i, 1 );
        foundTokenIndex -= 1;
      }
    }
    return first;
  }

  /* */

  function indexOf( first )
  {
    if( first[ foundTokenIndex ] >= o.charInterval[ 0 ] )
    return first[ foundTokenIndex ];
    foundOffset = src.length;
    for( let i = first.length - 1; i >= 0 ; i-- )
    {
      let offset = first[ i ];
      if( offset < o.charInterval[ 0 ] )
      {
        offset = src.indexOf( o.eol[ i ], first[ i ]+1 );
        if( offset === -1 )
        {
          tokenDelete( first, i );
          if( first.length === 0 )
          return src.length;
        }
        else
        {
          first[ i ] = offset;
          if( foundOffset >= offset )
          {
            foundOffset = offset;
            foundTokenIndex = i;
          }
        }
      }
      else
      {
        if( foundOffset >= offset )
        {
          foundOffset = offset;
          foundTokenIndex = i;
        }
      }
    }
    return first[ foundTokenIndex ];
  }

  /* */

  function tokenDelete( first, i )
  {
    o.eol.splice( i, 1 );
    first.splice( i, 1 );
    if( foundTokenIndex > i )
    foundTokenIndex -= 1;
  }

  /* */

  function handleWithoutIntervalWithoutLine()
  {
    o.onEach( o );
  }

  /* */

  function handleWithIntervalWithoutLine()
  {
    if( o.interval && o.interval[ 0 ] > o.lineIndex )
    return;
    o.onEach( o );
  }

  /* */

  function handleWithoutIntervalWithLine()
  {
    o.line = src.slice( o.charInterval[ 0 ], o.charInterval[ 1 ] - o.nl.length + 1 );
    o.onEach( o );
  }

  /* */

  function handleWithIntervalWithLine()
  {
    if( o.interval && o.interval[ 0 ] > o.lineIndex )
    return;
    o.line = src.slice( o.charInterval[ 0 ], o.charInterval[ 1 ] - o.nl.length + 1 );
    o.onEach( o );
  }

  /* */

},
    "eachLeft" : function eachLeft( o )
{

  if( !_.map.is( o ) )
  {
    _.assert( arguments.length === 2 || arguments.length === 3 );
    if( arguments.length === 3 )
    o = { src : arguments[ 0 ], interval : arguments[ 1 ], onEach : arguments[ 2 ] };
    else
    o = { src : arguments[ 0 ], onEach : arguments[ 1 ] };
  }
  else
  {
    _.assert( arguments.length === 1 );
  }

  if( o.withLine === undefined )
  o.withLine = true;

  _.assert( _.routine.is( o.onEach ) );
  _.assert( _.str.is( o.src ) );

  return this._eachLeft( o );
},
    "_eachRight" : function _eachRight( o )
{

  if( o.eol === undefined )
  o.eol = _.str.lines.Eol.default;
  else if( !_.str.is( o.eol ) )
  o.eol = [ ... o.eol ];

  const lastIndex = o.interval ? o.interval[ 1 ] : Infinity;
  const src = o.src;
  let foundTokenIndex;
  let foundOffset;
  let nnl = '';
  let handleEach;

  if( o.interval )
  {
    if( o.withLine )
    handleEach = handleWithIntervalWithLine;
    else
    handleEach = handleWithIntervalWithoutLine;
  }
  else
  {
    if( o.withLine )
    handleEach = handleWithoutIntervalWithLine;
    else
    handleEach = handleWithoutIntervalWithoutLine;
  }

  o.charInterval = [ o.src.length, o.src.length ];
  o.lineIndex = -1;

  if( o.interval && o.interval[ 1 ] < 0 )
  {
    o.charInterval[ 1 ] = o.src.length-1;
    return o;
  }

  o.nl = '';

  if( _.str.is( o.eol ) )
  single();
  else
  multiple();

  if( !o.interval || o.lineIndex < o.interval[ 1 ] )
  {
    o.lineIndex += 1;
    o.charInterval[ 1 ] = -1;
    _.assert( o.charInterval[ 0 ] === 0 );
    if( o.withLine )
    o.line = '';
  }

  return o;

  /* */

  function single()
  {

    while( o.lineIndex !== lastIndex )
    {

      o.lineIndex += 1;
      o.nl = nnl;

      o.charInterval[ 1 ] = o.charInterval[ 0 ] - 1;
      let right = o.charInterval[ 1 ] - o.nl.length;
      if( right >= 0 || o.lineIndex === 0 )
      o.charInterval[ 0 ] = src.lastIndexOf( o.eol, right );
      else
      o.charInterval[ 0 ] = -1;

      if( o.charInterval[ 0 ] === -1 )
      {
        o.charInterval[ 0 ] = 0;
        handleEach();
        break;
      }
      else
      {
        nnl = o.eol;
        o.charInterval[ 0 ] += nnl.length;
        handleEach();
      }

    }

  }

  /* */

  function multiple()
  {

    foundTokenIndex = -1;
    foundOffset = 0;

    let first = indexInit();

    if( first.length === 1 )
    {
      o.eol = o.eol[ foundTokenIndex ];
      return single();
    }

    if( first.length === 0 )
    {
      o.lineIndex = 0;
      o.charInterval[ 0 ] = 0;
      o.charInterval[ 1 ] = src.length-1;
      handleEach();
      return;
    }

    while( o.lineIndex !== lastIndex )
    {

      o.lineIndex += 1;
      o.nl = nnl;

      o.charInterval[ 1 ] = o.charInterval[ 0 ] - 1;
      o.charInterval[ 0 ] = indexOf( first );

      if( o.charInterval[ 0 ] === -1 )
      {
        o.charInterval[ 0 ] = 0;
        handleEach();
        break;
      }
      else
      {
        nnl = o.eol[ foundTokenIndex ];
        handleEach();
      }

    }

  }

  /* */

  function indexInit()
  {
    let first = [];
    for( let i = o.eol.length - 1 ; i >= 0 ; i-- )
    {
      let offset = src.lastIndexOf( o.eol[ i ] );
      if( offset !== -1 )
      {
        offset += o.eol[ i ].length;
        first.unshift( offset );
        if( foundOffset <= offset )
        {
          foundOffset = offset;
          foundTokenIndex = i;
        }
      }
      else
      {
        o.eol.splice( i, 1 );
        foundTokenIndex -= 1;
      }
    }
    return first;
  }

  /* */

  function indexOf( first )
  {
    let left = o.charInterval[ 0 ] - nnl.length - 1;
    if( first[ foundTokenIndex ] <= left )
    return first[ foundTokenIndex ];
    foundOffset = -1;
    for( let i = first.length - 1; i >= 0 ; i-- )
    {
      let offset = first[ i ];
      if( offset > left )
      {
        if( left >= 0 )
        offset = src.lastIndexOf( o.eol[ i ], left );
        else
        offset = -1;
        if( offset === -1 )
        {
          tokenDelete( first, i );
          if( first.length === 0 )
          return -1;
        }
        else
        {
          offset += o.eol[ i ].length;
          first[ i ] = offset;
          if( foundOffset <= offset )
          {
            foundOffset = offset;
            foundTokenIndex = i;
          }
        }
      }
      else
      {
        if( foundOffset <= offset )
        {
          foundOffset = offset;
          foundTokenIndex = i;
        }
      }
    }
    return first[ foundTokenIndex ];
  }

  /* */

  function tokenDelete( first, i )
  {
    o.eol.splice( i, 1 );
    first.splice( i, 1 );
    if( foundTokenIndex > i )
    foundTokenIndex -= 1;
  }

  /* */

  function handleWithoutIntervalWithoutLine()
  {
    o.onEach( o );
  }

  /* */

  function handleWithIntervalWithoutLine()
  {
    if( o.interval && o.interval[ 0 ] > o.lineIndex )
    return;
    o.onEach( o );
  }

  /* */

  function handleWithoutIntervalWithLine()
  {
    o.line = src.slice( o.charInterval[ 0 ], o.charInterval[ 1 ] - o.nl.length + 1 );
    o.onEach( o );
  }

  /* */

  function handleWithIntervalWithLine()
  {
    if( o.interval && o.interval[ 0 ] > o.lineIndex )
    return;
    o.line = src.slice( o.charInterval[ 0 ], o.charInterval[ 1 ] - o.nl.length + 1 );
    o.onEach( o );
  }

  /* */

},
    "eachRight" : function eachRight( o )
{

  if( !_.map.is( o ) )
  {
    _.assert( arguments.length === 2 || arguments.length === 3 );
    if( arguments.length === 3 )
    o = { src : arguments[ 0 ], interval : arguments[ 1 ], onEach : arguments[ 2 ] };
    else
    o = { src : arguments[ 0 ], onEach : arguments[ 1 ] };
  }
  else
  {
    _.assert( arguments.length === 1 );
  }

  if( o.withLine === undefined )
  o.withLine = true;

  _.assert( _.routine.is( o.onEach ) );
  _.assert( _.str.is( o.src ) );

  return this._eachRight( o );
},
    "each" : function eachLeft( o )
{

  if( !_.map.is( o ) )
  {
    _.assert( arguments.length === 2 || arguments.length === 3 );
    if( arguments.length === 3 )
    o = { src : arguments[ 0 ], interval : arguments[ 1 ], onEach : arguments[ 2 ] };
    else
    o = { src : arguments[ 0 ], onEach : arguments[ 1 ] };
  }
  else
  {
    _.assert( arguments.length === 1 );
  }

  if( o.withLine === undefined )
  o.withLine = true;

  _.assert( _.routine.is( o.onEach ) );
  _.assert( _.str.is( o.src ) );

  return this._eachLeft( o );
}
  },
  "is" : function is( src )
{
  let result = Object.prototype.toString.call( src ) === '[object String]';
  return result;
},
  "like" : function like( src )
{
  if( _.str.is( src ) )
  return true;
  if( _.regexp.is( src ) )
  return true;
  return false;
},
  "defined" : function defined( src )
{
  if( !src )
  return false;
  let result = Object.prototype.toString.call( src ) === '[object String]';
  return result;
},
  "has" : function has( src, ins )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), () => `Expects string, got ${_.entity.strType( src )}` );
  _.assert( _.regexpLike( ins ), () => `Expects string-like, got ${_.entity.strType( ins )}` );

  if( _.strIs( ins ) )
  return src.indexOf( ins ) !== -1;
  else
  return ins.test( src );

},
  "short_" : function short_( o )  /* version with binary search cutting */
{

  if( arguments.length === 2 )
  o = { src : arguments[ 0 ], widthLimit : arguments[ 1 ] };
  else if( arguments.length === 1 )
  if( _.strIs( o ) )
  o = { src : arguments[ 0 ] };

  _.routine.options( short_, o );

  _.assert( _.strIs( o.src ) );
  _.assert( _.number.is( o.widthLimit ) );
  _.assert( o.widthLimit >= 0, 'Option::o.widthLimit must be greater or equal to zero' );
  _.assert
  (
    _.number.is( o.heightLimit ) && o.heightLimit >= 0,
    'If provided option::o.heightLimit must be greater or equal to zero'
  );
  _.assert( o.delimeter === null || _.strIs( o.delimeter ) || _.bool.likeTrue( o.delimeter ));
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( !o.delimeter )
  o.delimeter = '';
  if( !o.heightDelimeter )
  o.heightDelimeter = '';
  if( o.widthLimit === 0 )
  o.widthLimit = Infinity;
  if( o.heightLimit === 0 )
  o.heightLimit = Infinity;

  if( _.bool.likeTrue( o.delimeter ) )
  o.delimeter = '...';

  if( !o.onLength )
  o.onLength = ( src ) => src.length;

  let src = o.src;

  let isOneLine = o.src.indexOf( '\n' ) === -1;

  if( isOneLine && o.onLength( o.src ) < o.widthLimit )
  {
    o.changed = false;
    o.result = o.src;

    return o;
  }

  let options = Object.create( null ); /* width cutting options */
  options.limit = o.widthLimit;
  options.delimeter = o.delimeter;
  options.onLength = o.onLength;
  options.cutting = o.cutting;

  if( isOneLine )
  {
    options.src = src;
    _.strShortWidth( options );

    o.result = options.result;
    o.changed = options.changed;

    return o;
  }
  else
  {
    let splitted = o.src.split( '\n' );

    let options2 = Object.create( null );  /* height cutting */
    options2.src = splitted;
    options2.limit = o.heightLimit;
    options2.delimeter = o.heightDelimeter;
    options2.cutting = o.heightCutting;
    _._strShortHeight( options2 );

    options.src = options2.result;

    _._strShortWidth( options );

    let result = options.result.join( '\n' );

    if( result === o.src )
    o.changed = false;
    else if( result !== o.src )
    o.changed = true;

    o.result = result;

    return o;
  }
},
  "_shortWidth" : function _shortWidth( o )
{
  /*
    input : array of lines
    output : array of lines ( each cutted down to o.limit )
  */
  _.assert( _.arrayIs( o.src ) );
  _.routine.options( _shortWidth, o );

  let begin = '';
  let end = '';
  let fixLength = o.onLength( o.delimeter );

  o.changed = false;

  let result = o.src.map( ( el ) =>
  {
    let delimeter = o.delimeter;
    fixLength = o.onLength( o.delimeter );

    if( fixLength === o.limit )
    {
      o.changed = true;
      return o.delimeter;
    }
    else if( o.onLength( el ) + fixLength <= o.limit ) /* nothing to cut */
    {
      return el;
    }
    else
    {
      if( o.onLength( delimeter ) > o.limit )
      {
        el = delimeter;
        delimeter = '';
        fixLength = 0;
      }

      o.changed = true;

      if( o.cutting === 'left' )
      {
        return delimeter + cutLeft( el );
      }
      else if( o.cutting === 'right' )
      {
        return cutRight( el ) + delimeter;
      }
      else
      {
        let [ begin, end ] = cutMiddle( el );
        return begin + delimeter + end;
      }
    }
  });

  o.result = result;

  return o;

  /* - */

  function cutLeft( src )
  {
    let startIndex = 0;
    let endIndex = src.length - 1;
    let endLength = o.onLength( src );
    let middleIndex = src.length - o.limit - 1; /* optimize default option::onLength */

    while( endLength + fixLength > o.limit ) /* binary */
    {
      [ begin, end ] = splitInTwo( src, middleIndex + 1 );
      endLength = o.onLength( end );

      startIndex = middleIndex; /* all needed elements are in end */
      middleIndex = Math.floor( ( startIndex + endIndex ) / 2 );
    }

    while( o.onLength( end ) + fixLength <= o.limit ) /* add elements till o.limit is satisfied */
    {
      /*
        add elements and parts of element that might have been sliced,
        example : onLength considers as 1 element substring of the same characters
                  'aabbccdd' with o.limit = 2 might return 'cdd', but need 'ccdd'
      */
      end = begin[ begin.length - 1 ] + end;
      begin = begin.slice( 0, -1 );
    }

    return end.slice( 1 );
  }

  //

  function cutRight( src )
  {
    let startIndex = 0;
    let endIndex = src.length - 1;
    let beginLength = o.onLength( src );
    let middleIndex = o.limit; /* optimize default option::onLength */

    while( beginLength + fixLength > o.limit ) /* binary */
    {
      [ begin, end ] = splitInTwo( src, middleIndex );
      beginLength = o.onLength( begin );

      endIndex = middleIndex; /* all needed elements are in begin */
      middleIndex = Math.floor( ( startIndex + endIndex ) / 2 );
    }

    while( o.onLength( begin ) + fixLength <= o.limit ) /* add elements till o.limit is satisfied */
    {
      /*
        add elements and parts of element that might have been sliced,
        example : onLength considers as 1 element substring of the same characters
                  'aabbccdd' with o.limit = 2 might return 'aab', but need 'aabb'
      */
      begin += end[ 0 ];
      end = end.slice( 1 );
    }

    return begin.slice( 0, -1 );
  }

  //

  function cutMiddle( src )
  {
    let originalStr = src;
    let chunkSize, middleIndexLeft, middleIndexRight;

    if( o.limit % 2 === 0 ) /* optimize default option::onLength */
    {
      middleIndexLeft = ( o.limit / 2 ) - 1;
      middleIndexRight = ( -o.limit / 2 ) + src.length;
    }
    else
    {
      middleIndexLeft = Math.floor( ( o.limit / 2 ) );
      middleIndexRight = Math.ceil( ( -o.limit / 2 ) ) + src.length;
    }

    while( o.onLength( src ) + fixLength > o.limit ) /* binary */
    {
      if( src.length <= 5 ) /* src.length = 4 || 3 || 2, base case */
      {
        let index = Math.floor( src.length / 2 );
        begin = src.slice( 0, index );
        end = src.slice( index+1 );
      }
      else /* begin : first 1/3, end : last 1/3 */
      {
        begin = src.slice( 0, middleIndexLeft + 1 );
        end = src.slice( middleIndexRight );
      }

      /* delete middle, might delete part of the element, check later when desired length is obtained */
      src = begin + end;

      chunkSize = Math.floor( src.length / 3 ); /* split str into 3 'equal' parts, middle is to be removed */
      middleIndexLeft = chunkSize;
      middleIndexRight = chunkSize * 2;
    }

    while( o.onLength( begin + end ) + fixLength < o.limit ) /* overcut */
    {
      if( o.onLength( begin ) > o.onLength( end ) ) /* shrink middle from the right */
      {
        end = originalStr.slice( -end.length - 1 );
      }
      else                                          /* shrink middle from the left */
      {
        begin = originalStr.slice( 0, begin.length + 1 );
      }
    }

    /*
      add parts of elements that might have been sliced,
      example : onLength considers as 1 element substring of the same characters
                'aabbccdd' with o.limit = 2 might return 'ad', but need 'aadd'
    */

    let beginInitial = o.onLength( begin );
    let endInitial = o.onLength( end );

    while( o.onLength( begin ) === beginInitial ) /* try to increase begin */
    {
      begin = originalStr.slice( 0, begin.length + 1 );;
    }

    while( o.onLength( end ) === endInitial ) /* try to increase end */
    {
      end = originalStr.slice( -end.length - 1 );
    }

    return [ begin.slice( 0, -1 ), end.slice( 1 ) ];
  }

  //

  function splitInTwo( src, middle )
  {
    let begin = src.slice( 0, middle );
    let end = src.slice( middle );
    return [ begin, end ];
  }

},
  "shortHeight" : function shortHeight( o )
{

  if( arguments.length === 2 )
  o = { src : arguments[ 0 ], limit : arguments[ 1 ] };
  else if( arguments.length === 1 )
  if( _.strIs( o ) )
  o = { src : arguments[ 0 ] };

  _.routine.options( shortHeight, o );

  _.assert( _.strIs( o.src ) );
  _.assert
  (
    ( _.number.is( o.limit ) && o.limit >= 0 ),
    'option::o.limit must be greater or equal to zero'
  );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  let originalSrc = o.src;
  let splitted = o.src.split( '\n' );

  if( !o.delimeter )
  o.delimeter = '';

  o.src = splitted;

  _._strShortHeight( o );
  o.src = originalSrc;
  o.result = o.result.join( '\n' );

  return o;

},
  "_shortHeight" : function _shortHeight( o )  /* version with binary search cutting */
{
  /*
    input : array of lines
    output : array of lines ( cutted down to o.limit )
  */

  _.assert( _.arrayIs( o.src ) );
  _.routine.options( shortHeight, o );

  o.changed = false;

  let delimeterLength = o.delimeter === '' ? 0 : 1;

  if( delimeterLength === o.limit )
  {
    o.changed = true;
    o.result = [ o.delimeter ];

    return o;
  }

  let result = cut( o.src.slice() );
  o.result = result;

  return o;

  /* - */

  function cut( src )
  {
    if( src.length + delimeterLength > o.limit )
    {
      o.changed = true;

      if( o.cutting === 'left' )
      {
        src = src.slice( - ( o.limit - delimeterLength ) );

        if( o.delimeter !== '' )
        src.unshift( o.delimeter );
      }
      else if( o.cutting === 'right' )
      {
        src = src.slice( 0, o.limit - delimeterLength );

        if( o.delimeter !== '' )
        src.push( o.delimeter );
      }
      else
      {
        let [ left, right ] = handleHeightCuttingCenter( src );
        let result = [];

        result.push( ... left );

        if( o.delimeter !== '' )
        result.push( o.delimeter );

        if( right !== undefined ) /* no right when o.limit = 2 and there is a delimeter */
        result.push( ... right );

        src = result;

      }
    }

    return src;
  }

  //

  function handleHeightCuttingCenter( src )
  {
    let indexLeft, indexRight;

    let limit = o.limit - delimeterLength;

    if( limit === 1 )
    {
      return [ src.slice( 0, 1 ) ];
    }
    else if( limit % 2 === 0 )
    {
      indexLeft = limit / 2;
      indexRight = -indexLeft;
    }
    else
    {
      indexLeft = Math.floor( ( limit / 2 ) ) + 1;
      indexRight = -indexLeft + 1;
    }

    let splittedLeft = src.slice( 0, indexLeft );
    let splittedRight = src.slice( indexRight );

    return [ splittedLeft, splittedRight ];
  }

},
  "concat" : function concat( srcs, o )
{

  o = _.routine.options( concat, o || Object.create( null ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( this.strConcat === concat );

  if( o.onToStr === null )
  o.onToStr = onToStr;

  let defaultOptionsForToStr =
  {
    stringWrapper : '',
  };

  o.optionsForToStr = _.props.supplement( o.optionsForToStr, defaultOptionsForToStr );
  o.optionsForToStr.format = o.optionsForToStr.format || 'string.diagnostic';

  if( _.routine.is( srcs ) )
  srcs = srcs();

  if( !_.argumentsArray.like( srcs ) )
  srcs = [ srcs ];

  let result = '';
  if( !srcs.length )
  return result;

  let concatenatePairWithLineDelimeter = o.onPairWithDelimeter ? o.onPairWithDelimeter : concatenateSimple;

  /* */

  let a = 0;

  while( !result && a < srcs.length )
  {
    result = o.onToStr( srcs[ a ], o );
    ++a;
  }

  for( ; a < srcs.length ; a++ )
  {
    let src = srcs[ a ];
    src = o.onToStr( src, o );

    result = result.replace( /[^\S\n]\s*$/, '' );

    if( _.strEnds( result, o.lineDelimter ) || _.strBegins( src, o.lineDelimter ) )
    result = concatenatePairWithLineDelimeter( result, src, o );
    else
    result = `${result} ${src.replace( /^\s+/, '' )}`;
  }

  /* */

  if( o.linePrefix || o.linePostfix )
  {
    result = result.split( o.lineDelimter );
    result = o.linePrefix + result.join( o.linePostfix + o.lineDelimter + o.linePrefix ) + o.linePostfix;
  }

  /* */

  return result;

  /* */

  function onToStr( src, op )
  {
    return _.entity.exportString( src, op.optionsForToStr );
  }

  /* */

  function concatenateSimple( src1, src2 )
  {
    return src1 + src2;
  }
},
  "_beginOf" : function _beginOf( src, begin )
{

  // _.assert( _.strIs( src ), 'Expects string' );
  // _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.strIs( begin ) )
  {
    if( src.lastIndexOf( begin, 0 ) === 0 )
    return begin;
  }
  else if( _.regexpIs( begin ) )
  {
    let matched = begin.exec( src );
    if( matched && matched.index === 0 )
    return matched[ 0 ];
  }
  else _.assert( 0, 'Expects string-like ( string or regexp )' );

  return undefined;
},
  "_endOf" : function _endOf( src, end )
{

  // _.assert( _.strIs( src ), 'Expects string' );
  // _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.strIs( end ) )
  {
    if( src.indexOf( end, src.length - end.length ) !== -1 )
    return end;
  }
  else if( _.regexpIs( end ) )
  {
    // let matched = end.exec( src );
    let newEnd = RegExp( end.toString().slice(1, -1) + '$' );
    let matched = newEnd.exec( src );

    //if( matched && matched.index === 0 )
    if( matched && matched.index + matched[ 0 ].length === src.length )
    return matched[ 0 ];
  }
  else _.assert( 0, 'Expects string-like ( string or regexp )' );

  return undefined;
},
  "begins" : function begins( src, begin )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( begin ) || _.regexpIs( begin ) || _.longIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( begin ) )
  {
    let result = _._strBeginOf( src, begin );
    return !( result === undefined );
    // return result === undefined ? false : true;
  }

  for( let b = 0, blen = begin.length ; b < blen; b++ )
  {
    let result = _._strBeginOf( src, begin[ b ] );
    if( result !== undefined )
    return true;
  }

  return false;
},
  "ends" : function ends( src, end )
{

  _.assert( _.strIs( src ), () => `Expects argument::src of type::string, but got ${_.entity.strType( src )}` );
  _.assert( _.strIs( end ) || _.regexpIs( end ) || _.longIs( end ), 'Expects string/regexp or array of strings/regexps {-end-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( end ) )
  {
    let result = _._strEndOf( src, end );
    return !( result === undefined );
  }

  for( let b = 0, blen = end.length ; b < blen; b++ )
  {
    let result = _._strEndOf( src, end[ b ] );
    if( result !== undefined )
    return true;
  }

  return false;
},
  "beginOf" : function beginOf( src, begin )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( begin ) || _.regexpIs( begin ) || _.longIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( begin ) )
  {
    let result = _._strBeginOf( src, begin );
    return result;
  }

  for( let b = 0, blen = begin.length ; b < blen ; b++ )
  {
    let result = _._strBeginOf( src, begin[ b ] );
    if( result !== undefined )
    return result;
  }

  return undefined;
},
  "endOf" : function endOf( src, end )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( end ) || _.regexpIs( end ) || _.longIs( end ), 'Expects string/regexp or array of strings/regexps {-end-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( end ) )
  {
    let result = _._strEndOf( src, end );
    return result;
  }

  for( let b = 0, blen = end.length ; b < blen; b++ )
  {
    let result = _._strEndOf( src, end[ b ] );
    if( result !== undefined )
    return result;
  }

  return undefined;
},
  "removeBegin" : function removeBegin( src, begin )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( src ) || _.strIs( src ), 'Expects string or array of strings {-src-}' );
  _.assert( _.longIs( begin ) || _.strIs( begin ) || _.regexpIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );

  let result = [];
  let srcIsArray = _.longIs( src );

  if( _.strIs( src ) && !_.longIs( begin ) )
  return _._strRemovedBegin( src, begin );

  src = _.array.as( src );
  begin = _.array.as( begin );
  for( let s = 0, slen = src.length ; s < slen ; s++ )
  {
    let beginOf = undefined;
    let src1 = src[ s ]
    for( let b = 0, blen = begin.length ; b < blen ; b++ )
    {
      beginOf = _._strBeginOf( src1, begin[ b ] );
      if( beginOf !== undefined )
      break;
    }
    if( beginOf !== undefined )
    src1 = src1.substr( beginOf.length, src1.length );
    result[ s ] = src1;
  }

  if( !srcIsArray )
  return result[ 0 ];

  return result;
},
  "removeEnd" : function removeEnd( src, end )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( src ) || _.strIs( src ), 'Expects string or array of strings {-src-}' );
  _.assert( _.longIs( end ) || _.strIs( end ) || _.regexpIs( end ), 'Expects string/regexp or array of strings/regexps {-end-}' );

  let result = [];
  let srcIsArray = _.longIs( src );

  if( _.strIs( src ) && !_.longIs( end ) )
  return _._strRemovedEnd( src, end );

  src = _.array.as( src );
  end = _.array.as( end );

  for( let s = 0, slen = src.length ; s < slen ; s++ )
  {
    let endOf = undefined;
    let src1 = src[ s ]
    for( let b = 0, blen = end.length ; b < blen ; b++ )
    {
      endOf = _._strEndOf( src1, end[ b ] );
      if( endOf !== undefined )
      break;
    }
    if( endOf !== undefined )
    src1 = src1.substr( 0, src1.length - endOf.length );
    result[ s ] = src1;
  }

  if( !srcIsArray )
  return result[ 0 ];

  return result;
},
  "remove" : function remove( srcStr, insStr )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( srcStr ), 'Expects string {-src-}' );
  _.assert( _.strIs( insStr ) || _.regexpIs( insStr ), 'Expects string/regexp {-begin-}' );

  let result = srcStr;

  result = result.replace( insStr, '' );

  return result;
},
  "_exportStringDiagnosticShallow" : function _exportStringDiagnosticShallow( src, o )
{
  return src;
},
  "exportStringDiagnosticShallow" : function exportStringDiagnosticShallow( src, o )
{
  let result;
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects 1 or 2 arguments' );
  _.assert( this.like( src ) );
  return this._exportStringDiagnosticShallow( ... arguments );
},
  "_exportStringCodeShallow" : function _exportStringCodeShallow( src, o )
{
  return `'${src}'`;
},
  "exportStringCodeShallow" : function exportStringCodeShallow( src, o )
{
  let result;
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects 1 or 2 arguments' );
  _.assert( this.like( src ) );
  return this._exportStringCodeShallow( ... arguments );
},
  "exportString" : function exportStringDiagnosticShallow( src, o )
{
  let result;
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects 1 or 2 arguments' );
  _.assert( this.like( src ) );
  return this._exportStringDiagnosticShallow( ... arguments );
},
  "_identicalShallow" : function _identicalShallow( src1, src2 )
{
  return src1 === src2;
},
  "identicalShallow" : function identicalShallow( src1, src2, accuracy )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.is( src1 ) )
  return false;
  if( !this.is( src2 ) )
  return false;
  return this._identicalShallow( ... arguments );
},
  "identical" : function identicalShallow( src1, src2, accuracy )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.is( src1 ) )
  return false;
  if( !this.is( src2 ) )
  return false;
  return this._identicalShallow( ... arguments );
},
  "_equivalentShallow" : function _equivalentShallow( src1, src2 )
{
  let strIs1 = _.strIs( src1 );
  let strIs2 = _.strIs( src2 );

  if( !strIs1 && strIs2 )
  return this._equivalentShallow( src2, src1 );

  if( strIs1 && strIs2 )
  {
    if( src1 === src2 )
    return true;
    return _.str.lines.strip( src1 ) === _.str.lines.strip( src2 );
  }
  else if( strIs1 )
  {
    _.assert( !!src2.exec );
    let matched = src2.exec( src1 );
    if( !matched )
    return false;
    if( matched[ 0 ].length !== src1.length )
    return false;
    return true;
  }
  else
  {
    return _.regexpIdentical( src1, src2 );
  }

  return false;
},
  "equivalentShallow" : function equivalentShallow( src1, src2, accuracy )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !_.regexp.like( src1 ) )
  return false;
  if( !_.regexp.like( src2 ) )
  return false;
  return _.str._equivalentShallow( ... arguments );
},
  "equivalent" : function equivalentShallow( src1, src2, accuracy )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !_.regexp.like( src1 ) )
  return false;
  if( !_.regexp.like( src2 ) )
  return false;
  return _.str._equivalentShallow( ... arguments );
},
  "prependOnce" : function prependOnce( src, begin )
{
  _.assert( _.strIs( src ) && _.strIs( begin ), 'Expects {-src-} and {-begin-} as strings' );
  if( src.lastIndexOf( begin, 0 ) === 0 )
  return src;
  else
  return begin + src;
},
  "appendOnce" : function appendOnce( src, end )
{
  _.assert( _.strIs( src ) && _.strIs( end ), 'Expects {-src-} and {-end-} as strings' );
  if( src.indexOf( end, src.length - end.length ) === -1 )
  return src + end;
  else
  return src;
},
  "parseType" : function parseType( src )
{
  /*
    - 'string'
    - '5'
    - '5n'
    - 'null'
    - 'undefined'
    - 'Escape( 1 )'
    - '{- Symbol undefined -}'
    - '{- routine name -}'
    - '{- routine.anonymous -}'
    - '{- Map -}'
    - '{- Map name -}'
    - '{- Map with 9 elements -}'
    - '{- Map.polluted with 9 elements -}'
    - '{- Map name with 9 elements -}'
  */

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ), 'Expects string' );

  if( !( /^{- .+ -}$/g.test( src ) ) )
  return Object.create( null );

  src = src.slice( 3, -3 );

  return _.str._parseType( src );

},
  "_parseType" : function _parseType( src )
{
  /*

  {- with with 2 elements -} 4
  {- with name with 2 elements -} 5
  {- with.with with with 2 elements -} 5

  */
  _.assert( _.strIs( src ), 'Expects string' );

  let o =
  {
    type : '',
    traits : [],
  }

  let splitted = src.split( ' ' );
  let type = splitted[ 0 ];
  let length;

  if( splitted.length === 2 ) /* with name & no length */
  {
    o.name = splitted[ 1 ];
  }
  else if( splitted.length === 4 ) /* without name & with length */
  {
    length = +splitted[ 2 ];
  }
  else if( splitted.length === 5 ) /* with name & with length */
  {
    o.name = splitted[ 1 ];
    length = +splitted[ 3 ];
  }

  length = isNaN( length ) ? null : length;

  if( type.indexOf( '.' ) === -1 )
  {
    o.type = type;
  }
  else
  {
    let [ t, ... traits ] = type.split( '.' );
    o.type = t;
    o.traits = traits;
  }

  if( length !== null )
  o.length = length;

  return o;

},
  "quote" : function quote( o )
{

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ], quote : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  if( o.quote === undefined || o.quote === null )
  o.quote = quote.defaults.quote;
  _.map.assertHasOnly( o, quote.defaults );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( _.arrayIs( o.src ) )
  {
    let result = [];
    for( let s = 0 ; s < o.src.length ; s++ )
    result.push( _.strQuote({ src : o.src[ s ], quote : o.quote }) );
    return result;
  }

  let src = o.src;

  if( !_.primitive.is( src ) )
  src = _.entity.exportString( src );

  _.assert( _.primitive.is( src ) );

  let result = o.quote + String( src ) + o.quote;

  return result;
},
  "unquote" : function unquote( o )
{

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ], quote : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  if( o.quote === undefined || o.quote === null )
  o.quote = unquote.defaults.quote;
  _.map.assertHasOnly( o, unquote.defaults );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( _.arrayIs( o.src ) )
  {
    let result = [];
    for( let s = 0 ; s < o.src.length ; s++ )
    result.push( _.strUnquote({ src : o.src[ s ], quote : o.quote }) );
    return result;
  }

  let result = o.src;
  let isolated = _.strIsolateInside( result, o.quote );
  if( isolated[ 0 ] === '' && isolated[ 4 ] === '' )
  result = isolated[ 2 ];

  return result;
},
  "quotePairsNormalize" : function quotePairsNormalize( quote )
{

  if( ( _.bool.like( quote ) && quote ) )
  quote = quoteAnalyze.defaults.quote;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( quote ) || _.arrayIs( quote ) );

  quote = _.array.as( quote );
  for( let q = 0 ; q < quote.length ; q++ )
  {
    let quotingPair = quote[ q ];
    _.assert( _.pair.is( quotingPair ) || _.strIs( quotingPair ) );
    if( _.strIs( quotingPair ) )
    quotingPair = quote[ q ] = [ quotingPair, quotingPair ];
    _.assert( _.strIs( quotingPair[ 0 ] ) && _.strIs( quotingPair[ 1 ] ) );
  }

  return quote;
},
  "quoteAnalyze" : function quoteAnalyze( o )
{
  let i = -1;
  let result = Object.create( null );
  result.ranges = [];
  result.quotes = [];

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ], quote : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  if( o.quote === undefined || o.quote === null )
  o.quote = quoteAnalyze.defaults.quote;
  _.map.assertHasOnly( o, quoteAnalyze.defaults );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  o.quote = _.strQuotePairsNormalize( o.quote );
  let maxQuoteLength = 0;
  for( let q = 0 ; q < o.quote.length ; q++ )
  {
    let quotingPair = o.quote[ q ];
    maxQuoteLength = Math.max( maxQuoteLength, quotingPair[ 0 ].length, quotingPair[ 1 ].length );
  }

  let isEqual = maxQuoteLength === 1 ? isEqualChar : isEqualString;
  let inRange = false
  do
  {
    while( i < o.src.length )
    {
      i += 1;

      if( inRange )
      {
        if( isEqual( inRange ) )
        {
          result.ranges.push( i );
          inRange = false;
        }
        continue;
      }

      for( let q = 0 ; q < o.quote.length ; q++ )
      {
        let quotingPair = o.quote[ q ];
        if( isEqual( quotingPair[ 0 ] ) )
        {
          result.quotes.push( quotingPair[ 0 ] );
          result.ranges.push( i );
          inRange = quotingPair[ 1 ];
          break;
        }
      }
    }

    if( inRange )
    {
      result.quotes.pop();
      i = result.ranges.pop()+1;
      inRange = false;
    }

  }
  while( i < o.src.length );

  return result;

  function isEqualChar( quote )
  {
    _.assert( o.src.length >= i );
    if( o.src[ i ] === quote )
    return true;
    return false;
  }

  function isEqualString( quote )
  {
    if( i+quote.length > o.src.length )
    return false;
    let subStr = o.src.substring( i, i+quote.length );
    if( subStr === quote )
    return true;
    return false;
  }

},
  "_leftSingle_" : function _leftSingle_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.strIs( src ) );

  if( _.number.is( cinterval ) )
  cinterval = [ cinterval, src.length - 1 ];
  else if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];

  cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  cinterval[ 1 ] = cinterval[ 1 ] === undefined ? src.length - 1 : cinterval[ 1 ];

  if( cinterval[ 0 ] < 0 )
  cinterval[ 0 ] = src.length + cinterval[ 0 ];
  if( cinterval[ 1 ] < -1 )
  cinterval[ 1 ] = src.length + cinterval[ 1 ];

  _.assert( _.intervalIs( cinterval ) );
  _.assert( 0 <= cinterval[ 0 ] && cinterval[ 0 ] <= src.length );
  _.assert( -1 <= cinterval[ 1 ] && cinterval[ 1 ] <= src.length - 1 );

  let result = Object.create( null );
  result.index = src.length;
  result.instanceIndex = -1;
  result.entry = undefined;

  let src1 = src.substring( cinterval[ 0 ], cinterval[ 1 ] + 1 );

  ins = _.array.as( ins );

  for( let k = 0 ; k < ins.length ; k++ )
  {
    let entry = ins[ k ];
    if( _.strIs( entry ) )
    {
      let found = src1.indexOf( entry );
      if( found >= 0 && ( found < result.index || result.entry === undefined ) )
      {
        result.instanceIndex = k;
        result.index = found;
        result.entry = entry;
      }
    }
    else if( _.regexpIs( entry ) )
    {
      let found = src1.match( entry );
      if( found && ( found.index < result.index || result.entry === undefined ) )
      {
        result.instanceIndex = k;
        result.index = found.index;
        result.entry = found[ 0 ];
      }
    }
    else _.assert( 0, 'Expects string-like ( string or regexp )' );
  }

  if( cinterval[ 0 ] !== 0 && result.index !== src.length )
  result.index += cinterval[ 0 ];

  return result;
},
  "left_" : function left_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( _.argumentsArray.like( src ) )
  {
    let result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _._strLeftSingle_( src[ s ], ins, cinterval );
    return result;
  }
  else
  {
    return _._strLeftSingle_( src, ins, cinterval );
  }

},
  "right_" : function right_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( _.argumentsArray.like( src ) )
  {
    let result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _._strRightSingle_( src[ s ], ins, cinterval );
    return result;
  }
  else
  {
    return _._strRightSingle_( src, ins, cinterval );
  }

},
  "insideOf" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "insideOf_" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "outsideOf" : function outsideOf( src, begin, end )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );

  let beginOf, endOf;

  beginOf = _.strBeginOf( src, begin );
  if( beginOf === undefined )
  return undefined;

  endOf = _.strEndOf( src, end );
  if( endOf === undefined )
  return undefined;

  let result = beginOf + endOf;

  return result;
},
  "_removedBegin" : function _removedBegin( src, begin )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );

  let result = src;
  let beginOf = _._strBeginOf( result, begin );
  if( beginOf !== undefined )
  result = result.substr( beginOf.length, result.length );

  return result;
},
  "_removedEnd" : function _removedEnd( src, end )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );

  let result = src;
  let endOf = _._strEndOf( result, end );
  if( endOf !== undefined )
  result = result.substr( 0, result.length - endOf.length );

  return result;
},
  "replaceBegin" : function replaceBegin( src, begin, ins )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( _.strIs( ins ) || _.longIs( ins ), 'Expects {-ins-} as string/array of strings' );
  if( _.longIs( begin ) && _.longIs( ins ) )
  _.assert( begin.length === ins.length );

  begin = _.array.as( begin );
  let result = _.array.as( src ).slice();

  for( let k = 0, srcLength = result.length; k < srcLength; k++ )
  for( let j = 0, beginLength = begin.length; j < beginLength; j++ )
  if( _.strBegins( result[ k ], begin[ j ] ) )
  {
    let prefix = _.longIs( ins ) ? ins[ j ] : ins;
    _.assert( _.strIs( prefix ) );
    result[ k ] = prefix + _.strRemoveBegin( result[ k ], begin[ j ] );
    break;
  }

  if( result.length === 1 && _.strIs( src ) )
  return result[ 0 ];

  return result;
},
  "replaceEnd" : function replaceEnd( src, end, ins )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( _.strIs( ins ) || _.longIs( ins ), 'Expects {-ins-} as string/array of strings' );
  if( _.longIs( end ) && _.longIs( ins ) )
  _.assert( end.length === ins.length );

  end = _.array.as( end );
  let result = _.array.as( src ).slice();

  for( let k = 0, srcLength = result.length; k < srcLength; k++ )
  for( let j = 0, endLength = end.length; j < endLength; j++ )
  if( _.strEnds( result[ k ], end[ j ] ) )
  {
    let postfix = _.longIs( ins ) ? ins[ j ] : ins;
    _.assert( _.strIs( postfix ) );
    result[ k ] = _.strRemoveEnd( result[ k ], end[ j ] ) + postfix;
    break;
  }

  if( result.length === 1 && _.strIs( src ) )
  return result[ 0 ];

  return result;
},
  "replace" : function replace( src, ins, sub )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( _.strsAreAll( sub ), 'Expects {-sub-} as string/array of strings' );

  if( _.longIs( ins ) && _.longIs( sub ) )
  _.assert( ins.length === sub.length );

  ins = _.array.as( ins );
  for( let i = 0 ; i < ins.length ; i++ )
  _.assert( ins[ i ] !== '', '{-ins-} should be a string with length' );

  /* */

  let result = _.array.as( src ).slice();

  for( let i = 0 ; i < result.length ; i++ )
  {
    result[ i ] = _.strSplit
    ({
      src : result[ i ],
      delimeter : ins,
      quoting : 0,
      stripping : 0,
      preservingEmpty : 1,
      preservingDelimeters : 1,
      onDelimeter : ( e, k ) => _.strIs( sub ) ? sub : sub[ k ],
    });
    result[ i ] = result[ i ].join( '' );
  }

  if( result.length === 1 && _.strIs( src ) )
  return result[ 0 ];

  return result;
},
  "strip" : function strip( o )
{

  if( _.strIs( o ) || _.arrayIs( o ) )
  o = { src : o };

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.routine.options( strip, o );

  o.stripper = stripperNormalize();
  let stripRoutine = _.regexpIs( o.stripper ) ? singleStripByRegexp : singleStripByArrayOfStrings;

  if( _.arrayIs( o.src ) )
  {
    _.assert( _.strsAreAll( o.src ), 'Expects strings {-o.srs-}' );

    let result = [];
    for( let i = 0 ; i < o.src.length ; i++ )
    result[ i ] = stripRoutine( o.src[ i ] );
    return result;
  }

  _.assert( _.strIs( o.src ) );
  return stripRoutine( o.src );

  /* */

  function stripperNormalize()
  {
    let stripper = o.stripper;
    if( _.bool.likeTrue( o.stripper ) )
    {
      stripper = strip.defaults.stripper;
    }
    else if( _.arrayIs( o.stripper ) )
    {
      _.assert( _.strsAreAll( o.stripper ), 'Expects characters in container {-o.stripper-}' );
    }
    else if( _.strIs( o.stripper ) )
    {
      stripper = _.regexpEscape( o.stripper );
      stripper = new RegExp( stripper, 'g' );
    }
    else if( !_.regexpIs( o.stripper ) )
    {
      _.assert( 0, 'Unexpected type of {-o.stripper-}. Expects either a String, an Array or a Regexp {-o.stripper-}' );
    }
    return stripper;
  }

  /* */

  function singleStripByRegexp( src )
  {
    return src.replace( o.stripper, '' );
  }

  /* */

  function singleStripByArrayOfStrings( src )
  {
    let begin = 0;
    for( ; begin < src.length ; begin++ )
    if( o.stripper.indexOf( src[ begin ] ) === -1 )
    break;

    let end = src.length-1;
    for( ; end >= 0 ; end-- )
    if( o.stripper.indexOf( src[ end ] ) === -1 )
    break;

    if( begin >= end )
    return '';

    return src.substring( begin, end + 1 );
  }

},
  "stripLeft" : function stripLeft( o )
{

  if( _.strIs( o ) || _.arrayIs( o ) )
  o = { src : o };

  _.routine.options( stripLeft, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  return _.strStrip( o );
},
  "stripRight" : function stripRight( o )
{

  if( _.strIs( o ) || _.arrayIs( o ) )
  o = { src : o };

  _.routine.options( stripRight, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  return _.strStrip( o );
},
  "_removeAllSpaces" : function _removeAllSpaces( src, sub )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.strIs( src ) );

  if( sub === undefined )
  sub = '';

  return src.replace( /\s/g, sub );
},
  "_stripEmptyLines" : function _stripEmptyLines( srcStr )
{
  let result = '';
  let lines = srcStr.split( '\n' );

  _.assert( _.strIs( srcStr ) );
  _.assert( arguments.length === 1, 'Expects single argument' );

  for( let l = 0; l < lines.length; l += 1 )
  {
    let line = lines[ l ];

    if( !_.strStrip( line ) )
    continue;

    result += line + '\n';
  }

  result = result.substring( 0, result.length - 1 );
  return result;
},
  "splitsCoupledGroup" : function splitsCoupledGroup( o )
{

  if( _.arrayIs( o ) )
  o = { splits : o }

  o = _.routine.options( splitsCoupledGroup, o );

  o.prefix = _.array.as( o.prefix );
  o.postfix = _.array.as( o.postfix );

  _.assert( arguments.length === 1 );
  _.assert( _.regexpsLikeAll( o.prefix ) );
  _.assert( _.regexpsLikeAll( o.postfix ) );

  let level = 0;
  let begins = [];
  for( let i = 0 ; i < o.splits.length ; i++ )
  {
    let element = o.splits[ i ];

    if( _.regexpsTestAny( o.prefix, element ) )
    {
      begins.push( i );
    }
    else if( _.regexpsTestAny( o.postfix, element ) )
    {
      if( begins.length === 0 && !o.allowingUncoupledPostfix )
      throw _.err( `"${ element }" does not have complementing openning\n` );

      if( begins.length === 0 )
      continue;

      let begin = begins.pop();
      let end = i;
      let l = end-begin;

      _.assert( l >= 0 )
      let newElement = o.splits.splice( begin, l+1, null );
      o.splits[ begin ] = newElement;

      i -= l;
    }

  }

  if( begins.length && !o.allowingUncoupledPrefix )
  {
    debugger;
    throw _.err( `"${ begins[ begins.length-1 ] }" does not have complementing closing\n` );
  }

  return o.splits;
},
  "splitsUngroupedJoin" : function splitsUngroupedJoin( o )
{

  if( _.arrayIs( o ) )
  o = { splits : o }
  o = _.routine.options( splitsUngroupedJoin, o );

  let s = o.splits.length-1;
  let l = null;

  while( s >= 0 )
  {
    let split = o.splits[ s ];

    if( _.strIs( split ) )
    {
      if( l === null )
      l = s;
    }
    else if( l !== null )
    {
      join();
    }

    s -= 1;
  }

  if( l !== null )
  join();

  return o.splits;

  /* */

  function join()
  {
    if( s+1 < l )
    {
      let element = o.splits.slice( s+1, l+1 ).join( '' );
      o.splits.splice( s+1, l+1, element );
    }
    l = null;
  }

},
  "splitsQuotedRejoin" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "splitsDropDelimeters" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "splitsStrip" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "splitsDropEmpty" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "splitFast" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "split" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "splitNonPreserving" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "splitInlined" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "splitInlinedStereo_" : function splitInlinedStereo_( o )
{
  /*
    New delimeter.
    was : 'this #background:red#is#background:default# text and is not'.
    is  : 'this background:redisbackground:default text and is not'.
    */

  if( _.strIs( o ) )
  o = { src : o };
  o.quotingPrefixes = o.quotingPrefixes || [ '"' ];
  o.quotingPostfixes = o.quotingPostfixes || [ '"' ];

  _.assert( this === _ );
  _.assert( _.strIs( o.src ) );
  _.assert( _.object.isBasic( o ) );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.routine.options( splitInlinedStereo_, o );

  let isDefaultOnInlined = true;

  if( o.onInlined === null )
  {
    o.onInlined = ( e ) => [ e ];
  }
  else
  {
    _.assert( _.routine.is( o.onInlined ), 'Expects a routine as option::onInlined' );
    isDefaultOnInlined = false;
  }

  /* Trivial cases */
  let end = handleTrivial();
  if( end !== false )
  return end;

  let replacementForPrefix = '\u{20330}';
  let isReplacedPrefix = false;
  let splitOptions = _.mapOnly_( null, o, split.defaults );
  splitOptions.preservingDelimeters = 1; /* for distinguishing between inlined and ordinary */
  splitOptions.delimeter = o.prefix === o.postfix ? o.prefix : [ o.prefix, o.postfix ];
  splitOptions.stripping = 0;
  splitOptions.preservingEmpty = 1;

  let result = _.strSplit( splitOptions ); /* array with separated ordinary, inlined and delimeters */
  result = preprocessBeforeJoin( result );

  result = _.strSplitsQuotedRejoin
  ({
    splits : result,
    delimeter : [ o.prefix, o.postfix ],
    quoting : 1,
    quotingPrefixes : [ o.prefix ],
    quotingPostfixes : [ o.postfix ],
    preservingQuoting : o.preservingDelimeters,
    inliningQuoting : 0,
    onQuoting : o.preservingEmpty ? escapeInlined( o.onInlined ) : o.onInlined
  });

  if( o.preservingEmpty )
  handlePreservingEmpty();

  unescape();

  if( o.preservingDelimeters && !o.inliningDelimeters && isDefaultOnInlined ) /* for default onInlined */
  splitInlined();

  if( isReplacedPrefix )
  result = result.map( ( el ) =>
  {
    if( _.strIs( el ) )
    return el.replace( replacementForPrefix, o.prefix )
    else
    return el;
  });

  return result;

  /* - */

  function handleTrivial()
  {
    let delimLeftPosition = o.src.indexOf( o.prefix );
    let delimRightPosition = o.src.indexOf( o.postfix );

    if( delimLeftPosition === -1 || delimRightPosition === -1 )
    {
      if( o.preservingOrdinary )
      return [ o.src ];
      else
      return [];
    }

    if( !o.preservingOrdinary && !o.preservingInlined )
    return [];

    let splitted = o.src.split( o.prefix );

    if( splitted.length === 1 )
    {
      if( o.preservingOrdinary )
      return [ o.src ];
      else
      return [];
    }

    return false;
  }

  /* */

  function splitInlined()
  {
    result = result.map( ( el ) =>
    {
      if( _.arrayIs( el ) )
      el = [ o.prefix, el[ 0 ].slice( 1, -1 ), o.postfix ];

      return el;
    });
  }

  /* */

  function escapeInlined( func )
  {
    return function ( el )
    {
      return _.escape.wrap( func( el ) );
    }
  }

  /* */

  function preprocessBeforeJoin( array )
  {
    let ordinary = '';
    let result = []
    for( let i = 0; i < array.length; i++ )
    {
      /*
        [ '', '', ' ', '', ' ', '', 'inline1', '', ' ', '', ' inline2' ]
        into
        [ '  ', '', 'inline1', '', '  inline2' ]
      */
      if( array[ i ] === o.prefix )
      {
        if( array[ i + 2 ] === o.postfix )
        {
          /* push concatenated ordinary string */
          pushOrdinary( result, ordinary );
          /* push inlined : '', 'inline1', '' */
          if( o.preservingInlined )
          {
            result.push( array[ i ] );
            result.push( o.stripping ? array[ i+1 ].trim() : array[ i+1 ] );
            result.push( array[ i+2 ] );
          }
          i += 2;
          ordinary = '';
        }
        else
        {
          ordinary += array[ i ];
        }
      }
      else
      {
        ordinary += array[ i ];
      }
    }

    pushOrdinary( result, ordinary );

    return result;
  }

  /* */

  function pushOrdinary( result, ordinary )
  {
    if( o.preservingOrdinary && ordinary )
    {
      if( ordinary === o.prefix )
      {
        result.push( replacementForPrefix );
        isReplacedPrefix = true;
      }
      else
      {
        ordinary = o.stripping ? ordinary.trim() : ordinary;
        if( o.onOrdinary )
        {
          let ordinary1 = o.onOrdinary( ordinary );
          ordinary = ordinary1 ? ordinary1 : ordinary;
        }

        result.push( ordinary );
      }
    }
  }

  /* */

  function handlePreservingEmpty()
  {
    if( _.escape.is( result[ 0 ] ) )
    {
      result.unshift( '' );
    }
    if( _.escape.is( result[ result.length-1 ] ) )
    {
      result.push( '' );
    }
    let len = result.length;
    for( let i = 0; i < len; i++ )
    {
      if( _.escape.is( result[ i ] ) )
      if( _.escape.is( result[ i + 1 ] ) )
      {
        result.splice( i + 1, 0, '' );
        len++;
      }
    }
  }

  /* */

  function unescape()
  {
    for( let i = 0; i < result.length; i++ )
    {
      if( _.escape.is( result[ i ] ) )
      result[ i ] = _.escape.unwrap( result[ i ] );
    }
  }

},
  "from" : function from( src )
{

  if( src === null )
  return src;
  if( src === undefined )
  return src;

  if( _.primitive.is( src ) )
  return String( src );

  if( _.bufferAnyIs( src ) )
  return _.bufferToStr( src );

  _.assert( _.strIs( src ) );
  return src;
},
  "isolate" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "isolateLeftOrNone" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "isolateLeftOrAll" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "isolateRightOrNone" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "isolateRightOrAll" : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      },
  "isolateInsideSignle" : function isolateInsideSignle( src, begin, end )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( arguments.length === 2 || arguments.length === 3 );
  let b, e;

  if( end === undefined )
  {
    let pairs = arguments[ 1 ];
    _.assert( _.strIs( pairs ) || _.arrayIs( pairs ) );
    pairs = _.strQuotePairsNormalize( pairs );

    let l = 0;
    let begin = [];
    for( let q = 0 ; q < pairs.length ; q++ )
    {
      let quotingPair = pairs[ q ];
      begin.push( quotingPair[ 0 ] );
    }

    do
    {

      // b = _.strLeft( src, begin, [ l, src.length ] );
      b = _.strLeft_( src, begin, [ l, src.length-1 ] );

      if( b.entry === undefined )
      return notFound();

      _.assert( _.number.is( b.instanceIndex ) );
      let end = pairs[ b.instanceIndex ][ 1 ];

      // e = _.strRight( src, end, Math.min( b.index+1, src.length ) );
      // e = _.strRight_( src, end, Math.min( b.index, src.length-1 ) ); /* Dmytro : if cinterval is a Number, it is defined first index, not last */
      e = _.strRight_( src, end, Math.min( b.index, src.length ) );

      if( e.entry === undefined )
      l = b.index+1;
      else
      break;
      // return notFound();

    }
    while( l < src.length );

    if( e.entry === undefined )
    return notFound();

  }
  else
  {

    // b = _.strLeft( src, begin );
    b = _.strLeft_( src, begin );

    if( b.entry === undefined )
    return notFound();

    // e = _.strRight( src, end, Math.min( b.index+1, src.length ) );
    // e = _.strRight_( src, end, Math.min( b.index, src.length-1 ) ); /* Dmytro : if cinterval is a Number, it is defined first index, not last */
    e = _.strRight_( src, end, Math.min( b.index, src.length ) );

    if( e.entry === undefined )
    return notFound();

  }

  if( e.index < b.index + b.entry.length )
  return notFound();

  let result =
  [
    src.substring( 0, b.index ),
    b.entry,
    src.substring( b.index + b.entry.length, e.index ),
    e.entry,
    src.substring( e.index + e.entry.length, src.length )
  ];

  return result;

  function notFound()
  {
    // return [ '', '', src, '', '' ];
    return [ '', undefined, src, undefined, '' ];
  }
},
  "isolateInside" : function isolateInside( src, begin, end )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( _.argumentsArray.like( src ) )
  {
    let result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _.strIsolateInsideSignle( src[ s ], begin, end );
    return result;
  }
  else
  {
    return _.strIsolateInsideSignle( src, begin, end );
  }

}
};

//





  _.entity._exportStringIsVisibleElement = function _exportStringIsVisibleElement( src, o )
{

  var isPrimitive = _.primitiveIs( src );
  var isArray = _.longIs( src );
  var isObject = !isArray && _.objectLike( src );
  var type = _.entity.strTypeSecondary( src );

  /* */

  // if( !isPrimitive && 'exportString' in src && _.routineIs( src.exportString ) && !src.exportString.notMethod )
  if( !isPrimitive && 'exportString' in src && _.routineIs( src.exportString ) && _.instanceIs( src ) )
  {
    if( isObject && o.noObject )
    return false;
    if( isArray && o.noArray )
    return false;

    return true;
  }
  else if( _.vectorAdapterIs( src ) )
  {
    if( o.noRow )
    return false;
    return true;
  }
  else if( _.errIs( src ) )
  {
    if( o.noError )
    return false;
    return true;
  }
  else if( type === 'Function' )
  {
    if( o.noRoutine )
    return false;
    return true;
  }
  else if( type === 'Number' )
  {
    if( o.noNumber || o.noAtomic )
    return false;
    return true;
  }
  else if( type === 'String' )
  {
    if( o.noString || o.noAtomic  )
    return false;
    return true;
  }
  else if( type === 'Date' )
  {
    if( o.noDate )
    return false;
    return true;
  }
  else if( isArray )
  {
    if( o.noArray )
    return false;

    if( !o.wrap )
    {
      src = _.entity._exportStringFromArrayFiltered( src, o );
      if( !src.length )
      return false;
    }

    return true;
  }
  else if( isObject )
  {
    if( o.noObject )
    return false;

    if( !o.wrap )
    {
      var keys = _.entity._exportStringFromObjectKeysFiltered( src, o );
      if( !keys.length )
      return false;
    }

    return true;
  }
  else if( !isPrimitive && _.routineIs( src.toString ) )
  {
    if( isObject && o.noObject )
    return false;
    if( isArray && o.noArray )
    return false;
    return true;
  }
  else
  {
    if( o.noAtomic )
    return false;
    if( o.noUndefines && src === undefined )
    return false;
    return true;
  }

}

//


  _.entity._exportStringIsSimpleElement = function _exportStringIsSimpleElement( element, o )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.object.isBasic( o ) || o === undefined, 'Expects map {-o-}' );

  if( _.strIs( element ) )
  {
    if( element.length > 40 )
    return false;
    if( !o.escaping )
    return element.indexOf( '\n' ) === -1;
    return true;
  }
  else if( element && !_.object.isBasic( element ) && _.numberIs( element.length ) )
  return !element.length;
  else if( _.object.isBasic( element ) || _.objectLike( element ) )
  return !_.entity.lengthOf( element );
  else
  return _.primitiveIs( element );

}

//


  _.entity._exportStringFromStr = function _exportStringFromStr( src, o )
{
  var result = '';

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.object.isBasic( o ) || o === undefined, 'Expects map {-o-}' );

  if( o.stringWrapper === undefined )
  o.stringWrapper = `\'`;

  var q = o.stringWrapper;

  if( o.widthLimit )
  {

    if( o.shortDelimeter === undefined || o.shortDelimeter === null )
    o.shortDelimeter = _.strShort_.defaults.delimeter || '...';

    result = _.strShort_
    ({
      src : _.strEscape( src ),
      widthLimit : o.widthLimit - q.length*2,
      heightLimit : o.heightLimit || 0,
      delimeter : o.shortDelimeter,
    }).result;

    // if( result.length > o.widthLimit )
    // {
    //   result = '[ ' + result + ' ]';
    //   q = '';
    // }
  }
  else if( o.escaping )
  {
    if( o.stringWrapper === undefined )
    debugger;
    result = _.strEscape({ src, stringWrapper : o.stringWrapper });
  }
  else
  {
    result = src;
  }

  // if( o.stringWrapper && !o.widthLimit )
  // {
  //   result = q + result + q;
  // }

  if( q )
  // if( !o.widthLimit || result.length < o.widthLimit )
  {
    result = q + result + q;
  }

  return result;
}

//


  _.entity._exportStringFromSymbol = function _exportStringFromSymbol( src, o )
{
  let text = src.toString().slice( 7, -1 );
  let result = `{- Symbol${text ? ' ' + text + ' ' : ' '}-}`;
  return result;
}

//


  _.entity._exportStringFromBufferRaw = function _exportStringFromBufferRaw( src, o )
{
  var result = '';

  _.assert( _.bufferRawIs( src ) );

  ( new U8x( src ) ).forEach( function( e, k )
  {
    if( k !== 0 )
    result += ', ';
    result += '0x' + e.toString( 16 );
  });

  result = '( new U8x([ ' + result + ' ]) ).buffer';

  return { text : result, simple : true };
}

//


  _.entity._exportStringFromBufferTyped = function _exportStringFromBufferTyped( src, o )
{
  var result = '';

  _.assert( _.bufferTypedIs( src ) );

  src.forEach( function( e, k )
  {
    if( k !== 0 )
    result += ', ';
    result += _.entity._exportStringFromNumber( e, o );
  });

  result = '( new ' + src.constructor.name + '([ ' + result + ' ]) )';

  return { text : result, simple : true };
}

//


  _.entity._exportStringFromBufferNode = function _exportStringFromBufferNode( src, o )
{
  var result = '';

  _.assert( _.bufferNodeIs( src ) );

  let k = 0;
  for ( let value of src.values() )
  {
    if( k !== 0 )
    result += ', ';
    result += value;
    ++k;
  }

  result = '( BufferNode.from([ ' + result + ' ]) )';

  return { text : result, simple : true };
}

//


  _.entity._exportStringFromArray = function _exportStringFromArray( src, o )
{
  var result = '';

  _.assert( arguments.length === 2 );
  _.assert( src && _.numberIs( src.length ) );
  _.assert( _.object.isBasic( o ) || o === undefined, 'Expects map {-o-}' );


  if( o.level >= o.levels )
  {
    return { text : _.entity._exportStringShortAct( src, o ), simple : 1 };
  }

  /* item options */

  var optionsItem = _.props.extend( null, o );
  optionsItem.tab = o.tab + o.dtab;
  optionsItem.level = o.level + 1;
  optionsItem.prependTab = 0;

  /* empty case */

  if( src.length === 0 )
  {
    if( !o.wrap )
    return { text : '', simple : 1 };
    return { text : '[]', simple : 1 };
  }

  /* filter */

  src = _.entity._exportStringFromArrayFiltered( src, o );

  /* is simple */

  var length = src.length;
  var simple = !optionsItem.multiline;
  if( simple )
  simple = length < 8;
  if( simple )
  for( var i = 0 ; i < length ; i++ )
  {
    simple = _.entity._exportStringIsSimpleElement( src[ i ], optionsItem );;
    if( !simple )
    break;
  }

  /* */

  result += _.entity._exportStringFromContainer
  ({
    values : src,
    optionsContainer : o,
    optionsItem,
    simple,
    prefix : '[',
    postfix : ']',
  });

  return { text : result, simple };
}

//


  _.entity._exportStringFromArrayFiltered = function _exportStringFromArrayFiltered( src, o )
{
  var result = '';

  _.assert( arguments.length === 2 );

  /* item options */

  var optionsItem = _.props.extend( null, o );
  optionsItem.level = o.level + 1;

  /* filter */

  var v = 0;
  var length = src.length;
  for( var i = 0 ; i < length ; i++ )
  {
    v += !!_.entity._exportStringIsVisibleElement( src[ i ], optionsItem );
  }

  if( v !== length )
  {
    var i2 = 0;
    var i = 0;
    var src2 = _.long.makeUndefined( src, v );
    while( i < length )
    {
      if( _.entity._exportStringIsVisibleElement( src[ i ], optionsItem ) )
      {
        src2[ i2 ] = src[ i ];
        i2 += 1;
      }
      i += 1;
    }
    src = src2;
    length = src.length;
  }

  return src;
}

//


  _.entity._exportStringFromObject = function _exportStringFromObject( src, o )
{
  var result = '';

  _.assert( arguments.length === 2 );
  _.assert( _.objectLike( src ) || _.entity.strTypeSecondary( src ) === 'Error' );
  _.assert( _.object.isBasic( o ) || o === undefined, 'Expects map {-o-}' );


  if( o.level >= o.levels )
  {
    return { text : _.entity._exportStringShortAct( src, o ), simple : 1 };
  }

  if( o.noObject )
  return;

  /* item options */

  var optionsItem = _.props.extend( null, o );
  optionsItem.noObject = o.noSubObject ? 1 : optionsItem.noObject;
  optionsItem.tab = o.tab + o.dtab;
  optionsItem.level = o.level + 1;
  optionsItem.prependTab = 0;

  /* get names */

  var keys = _.entity._exportStringFromObjectKeysFiltered( src, o );

  /* empty case */

  var length = keys.length;
  if( length === 0 )
  {
    if( !o.wrap )
    return { text : '', simple : 1 };
    return { text : '{}', simple : 1 };
  }

  /* is simple */

  var simple = !optionsItem.multiline;
  if( simple )
  simple = length < 4;
  if( simple )
  for( var k in src )
  {
    simple = _.entity._exportStringIsSimpleElement( src[ k ], optionsItem );
    if( !simple )
    break;
  }

  /* */

  result += _.entity._exportStringFromContainer
  ({
    values : src,
    names : keys,
    optionsContainer : o,
    optionsItem,
    simple,
    prefix : '{',
    postfix : '}',
    keyWrapper : o.keyWrapper,
    stringWrapper : o.stringWrapper,
  });

  return { text : result, simple };
}

//


  _.entity._exportStringFromObjectKeysFiltered = function _exportStringFromObjectKeysFiltered( src, o )
{
  var result = '';

  _.assert( arguments.length === 2 );

  /* item options */

  var optionsItem = _.props.extend( null, o );
  optionsItem.noObject = o.noSubObject ? 1 : optionsItem.noObject;

  /* get keys */

  var keys = _.props._keys
  ({
    srcMap : src,
    onlyOwn : o.onlyOwn,
    onlyEnumerable : o.onlyEnumerable || o.onlyEnumerable === undefined || o.onlyEnumerable === null || false,
  });

  /* filter */

  for( var n = 0 ; n < keys.length ; n++ )
  {
    if( !_.entity._exportStringIsVisibleElement( src[ keys[ n ] ], optionsItem ) )
    {
      keys.splice( n, 1 );
      n -= 1;
    }
  }

  return keys;
}

//


  _.entity._exportStringFromHashMap = function _exportStringFromHashMap( src, o )
{
  var result = 'HashMap\n';
  var simple = 0;

  _.assert( src instanceof HashMap );

  src.forEach( function( e, k )
  {
    // result += '\n' + k + ' : ' + e;
    result += '\n' + k + ' : ' + _.entity.exportStringDiagnosticShallow( e );
  });

  return { text : result, simple : 0 };

  /* item options */

  var optionsItem = _.props.extend( null, o );
  optionsItem.noObject = o.noSubObject ? 1 : optionsItem.noObject;
  optionsItem.tab = o.tab + o.dtab;
  optionsItem.level = o.level + 1;
  optionsItem.prependTab = 0;

  /* get names */

  var keys = _.entity._exportStringFromObjectKeysFiltered( src, o );

  /* empty case */

  var length = keys.length;
  if( length === 0 )
  {
    if( !o.wrap )
    return { text : '', simple : 1 };
    return { text : '{}', simple : 1 };
  }

  /* is simple */

  var simple = !optionsItem.multiline;
  if( simple )
  simple = length < 4;
  if( simple )
  for( var k in src )
  {
    simple = _.entity._exportStringIsSimpleElement( src[ k ], optionsItem );
    if( !simple )
    break;
  }

  /* */

  result += _.entity._exportStringFromContainer
  ({
    values : src,
    names : keys,
    optionsContainer : o,
    optionsItem,
    simple,
    prefix : '{',
    postfix : '}',
  });

  return { text : result, simple };
}

//


  _.entity._exportStringFromSet = function _exportStringFromSet( src, o )
{
  let result = _.entity._exportStringFromArray( _.array.from( src ), o );
  result.text = `new Set(${result.text})` ;
  return result;
}

//


  _.entity._exportStringShortAct = function _exportStringShortAct( src, o )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.object.isBasic( o ), 'Expects map {-o-}' );

  var result = '';

  try
  {

    if( _.strIs( src ) )
    {

      /* xxx : ? */
      var o2 =
      {
        widthLimit : o.widthLimit ? Math.min( o.widthLimit, 40 ) : 40,
        heightLimit : o.heightLimit || 0,
        stringWrapper : o.stringWrapper,
        prefix : o.prefix,
        postfix : o.postfix,
        infix : o.infix,
        shortDelimeter : o.shortDelimeter,
      }
      result = _.entity._exportStringFromStr( src, o2 );

    }
    else if( _.errIs( src ) )
    {
      result += _ObjectToString.call( src );
    }
    else if( _.routineIs( src ) )
    {
      result += _.entity._exportStringFromRoutine( src, o );
    }
    else if( _.numberIs( src ) )
    {
      result += _.entity._exportStringFromNumber( src, o );
    }
    else
    {
      result = _.entity.exportStringDiagnosticShallow( src );
    }

  }
  catch( err )
  {
    throw _.err( err );
  }

  return result;
}

//


  _.entity._exportStringFromContainer = function _exportStringFromContainer( o )
{
  var result = '';

  _.assert( arguments.length > 0 );
  _.assert( _.object.isBasic( o ) || o === undefined, 'Expects map {-o-}' );
  _.assert( _.arrayIs( o.names ) || !o.names );

  var values = o.values;
  var names = o.names;
  var optionsContainer = o.optionsContainer;
  var optionsItem = o.optionsItem;

  var length = ( names ? names.length : values.length );
  var simple = o.simple;
  var prefix = o.prefix;
  var postfix = o.postfix;
  var limit = optionsContainer.limitElementsNumber;
  var l = length;

  if( o.keyWrapper === undefined )
  o.keyWrapper = '';

  if( limit > 0 && limit < l )
  {
    l = limit;
    optionsContainer.limitElementsNumber = 0;
  }

  /* line postfix */

  var linePostfix = '';
  if( optionsContainer.comma )
  linePostfix += optionsContainer.comma;

  if( !simple )
  {
    linePostfix += '\n' + optionsItem.tab;
  }

  /* prepend */

  if( optionsContainer.prependTab  )
  {
    result += optionsContainer.tab;
  }

  /* wrap */

  if( optionsContainer.wrap )
  {
    result += prefix;
    if( simple )
    {
      if( l )
      result += ' ';
    }
    else
    {
      result += '\n' + optionsItem.tab;
    }
  }
  else if( !simple )
  {
    /*result += '\n' + optionsItem.tab;*/
  }

  /* keyWrapper */

  if( optionsContainer.json )
  {
    optionsContainer.keyWrapper = '"';
  }

  /* exec */

  var r;
  var written = 0;
  for( var n = 0 ; n < l ; n++ )
  {

    _.assert( optionsItem.tab === optionsContainer.tab + optionsContainer.dtab );
    _.assert( optionsItem.level === optionsContainer.level + 1 );

    if( names )
    r = _.entity._exportString( values[ names[ n ] ], optionsItem );
    else
    r = _.entity._exportString( values[ n ], optionsItem );

    _.assert( _.object.isBasic( r ) && _.strIs( r.text ) );
    _.assert( optionsItem.tab === optionsContainer.tab + optionsContainer.dtab );

    if( written > 0 )
    {
      result += linePostfix;
    }
    else if( !optionsContainer.wrap )
    if( !names || !simple )
    //if( !simple )
    {
      result += optionsItem.dtab;
    }

    if( names )
    {
      if( o.keyWrapper === undefined )
      debugger;
      let name = _.strEscape({ src : names[ n ], stringWrapper : o.keyWrapper });
      if( optionsContainer.keyWrapper )
      result += optionsContainer.keyWrapper + name + optionsContainer.keyWrapper + optionsContainer.colon;
      else
      result += name + optionsContainer.colon;

      if( !r.simple )
      result += '\n' + optionsItem.tab;
    }

    if( r.text )
    {
      result += r.text;
      written += 1;
    }

  }

  /* other */

  // if( names && l < names.length )
  // result += other( names.length );
  // else if( l < names.length )
  // result += other( names.length );

  /* wrap */

  if( length - l > 0 )
  result += other( length );

  if( optionsContainer.wrap )
  {
    if( simple )
    {
      if( l )
      result += ' ';
    }
    else
    {
      result += '\n' + optionsContainer.tab;
    }
    result += postfix;
  }

  return result;

  function other( length )
  {
    return linePostfix + '[ ... other '+ ( length - l ) +' element(s) ]';
  }

}

//


  _.entity._exportStringFromNumber = function _exportStringFromNumber( src, o )
{
  var result = '';

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.numberIs( src ) && _.object.isBasic( o ) );

  if( o.precision !== null )
  if( o.precision < 1 || o.precision > 21 )
  throw _.err( 'RangeError' );

  if( o.fixed !== null )
  if( o.fixed < 0 || o.fixed > 20 )
  throw _.err( 'RangeError' );

  if( _.numberIs( o.precision ) )
  result += src.toPrecision( o.precision );
  else if( _.numberIs( o.fixed ) )
  result += src.toFixed( o.fixed );
  else
  result += String( src );

  if( Object.is( src, -0 ) )
  result = '-' + result;

  return result;
}

//


  _.entity._exportString = function _exportString( src, o )
{

  if( o.precision !== null )
  if( o.precision < 1 || o.precision > 21 )
  {
    throw _.err( 'RangeError' );
  }

  if( o.fixed !== null )
  if( o.fixed < 0 || o.fixed > 20 )
  throw _.err( 'RangeError' );

  var result = '';
  var simple = 1;
  var type = _.entity.strTypeSecondary( src );

  if( o.level >= o.levels )
  {
    return { text : _.entity._exportStringShortAct( src, o ), simple : 1 };
  }

  if( !_.entity._exportStringIsVisibleElement( src, o ) )
  return;

  var isPrimitive = _.primitiveIs( src );
  var isLong = _.longIs( src );
  var isArray = _.arrayIs( src );
  var isObject = !isLong && _.object.isBasic( src );
  var isObjectLike = !isLong && _.objectLike( src ) && !( 'toString' in src );

  /* */

  // if( !isPrimitive && 'exportString' in src && _.routineIs( src.exportString ) && !src.exportString.notMethod && !_ObjectHasOwnProperty.call( src, 'constructor' ) )
  if( !isPrimitive && 'exportString' in src && _.routineIs( src.exportString ) && _.instanceIs( src ) )
  {

    _.assert
    (
      src.exportString.length === 0 || src.exportString.length === 1,
      'Method exportString should expect either none or one argument'
    );

    // var r = src.exportString( o );
    var r = src.exportString({ it : o });
    if( _.object.isBasic( r ) )
    {
      _.assert( r.simple !== undefined && r.text !== undefined );
      simple = r.simple;
      result += r.text;
    }
    else if( _.strIs( r ) )
    {
      simple = r.indexOf( '\n' ) === -1;
      result += r;
    }
    else throw _.err( 'unexpected' );

  }
  // else if( _.vectorAdapterIs( src ) )
  // {
  //   result += _.vectorAdapter.exportString( src, o );
  // }
  else if( _.errIs( src ) )
  {

    if( !o.errorAsMap )
    {
      result += src.toString();
    }
    else
    {
      if( o.onlyEnumerable === undefined || o.onlyEnumerable === null )
      o.onlyEnumerable = 1;
      var o2 = _.props.extend( null, o );
      o2.onlyEnumerable = 0;
      var r = _.entity._exportStringFromObject( src, o2 );
      result += r.text;
      simple = r.simple;
    }

  }
  else if( type === 'Function' )
  {
    result += _.entity._exportStringFromRoutine( src, o );
  }
  else if( type === 'Number' && _.numberIs( src ) )
  {
    result += _.entity._exportStringFromNumber( src, o );
  }
  else if( type === 'BigInt' )
  {
    result += _.entity._exportStringFromBigInt( src, o );
  }
  else if( type === 'String' )
  {
    result += _.entity._exportStringFromStr( src, o );
  }
  else if( type === 'Date' )
  {
    if( o.jsonLike )
    result += '"' + src.toISOString() + '"';
    else if( o.jsLike )
    result += 'new Date( \'' + src.toISOString() + '\' )';
    else
    result += src.toISOString();
  }
  else if( type === 'Symbol' )
  {
    result += _.entity._exportStringFromSymbol( src, o );
  }
  else if( _.bufferRawIs( src ) )
  {
    var r = _.entity._exportStringFromBufferRaw( src, o );
    result += r.text;
    simple = r.simple;
  }
  else if( _.bufferTypedIs( src ) )
  {
    var r = _.entity._exportStringFromBufferTyped( src, o );
    result += r.text;
    simple = r.simple;
  }
  else if( _.bufferNodeIs( src ) )
  {
    var r = _.entity._exportStringFromBufferNode( src, o );
    result += r.text;
    simple = r.simple;
  }
  else if( isLong )
  {
    var r = _.entity._exportStringFromArray( src, o );
    result += r.text;
    simple = r.simple;
  }
  else if( isObject )
  {
    var r = _.entity._exportStringFromObject( src, o );
    result += r.text;
    simple = r.simple;
  }
  else if( _.hashMapLike( src ) )
  {
    var r = _.entity._exportStringFromHashMap( src, o );
    result += r.text;
    simple = r.simple;
  }
  else if( _.setLike( src ) )
  {
    var r = _.entity._exportStringFromSet( src, o );
    result += r.text;
    simple = r.simple;
  }
  else if( !isPrimitive && _.routineIs( src.toString ) )
  {
    result += src.toString();
  }
  else
  {
    if( o.jsonLike )
    {
      if( src === undefined || src === NaN )
      result += 'null';
      else
      result += String( src );
    }
    else
    {
      result += String( src );
    }
  }

  return { text : result, simple };
}

//


  _.entity.exportString = ( function _exportStringFine_functor()
{

  var primeFilter =
  {

    noRoutine : 0,
    noAtomic : 0,
    noArray : 0,
    noObject : 0,
    noRow : 0,
    noError : 0,
    noNumber : 0,
    noString : 0,
    noDate : 0,
    noUndefines : 0,

  }

  var composes =
  {

    levels : 1,
    level : 0,

    wrap : 1,
    // stringWrapper : '\'',
    stringWrapper : null,
    keyWrapper : '',
    prependTab : 1,
    errorAsMap : 0,
    onlyOwn : 1,
    tab : '',
    dtab : '  ',
    colon : ' : ',
    limitElementsNumber : 0,
    widthLimit : 0,
    heightLimit : 0,

    format : 'string.diagnostic',

  }

  /**/

  var optional =
  {

    /* secondary filter */

    noSubObject : 0,
    onlyRoutines : 0,
    onlyEnumerable : 1,

    /**/

    precision : null,
    fixed : null,
    // comma : ', ',
    comma : null,
    multiline : 0,
    multilinedString : null,
    escaping : 0,
    jsonLike : 0,
    jsLike : 0,

  }

  var restricts =
  {
    /*level : 0, */
  }

  Object.preventExtensions( primeFilter );
  Object.preventExtensions( composes );
  Object.preventExtensions( optional );
  Object.preventExtensions( restricts );

  var def;

  def = _.props.extend( null, optional, primeFilter, composes );

  var routine = exportStringFine;
  routine.defaults = def;
  routine.methods = _.entity.exportStringMethods;
  routine.fields = _.entity.exportStringFields;
  // routine.notMethod = 1;
  return routine;

  function exportStringFine( src, o )
  {

    _.assert( arguments.length === 1 || arguments.length === 2 );
    _.assert( _.object.isBasic( o ) || o === undefined, 'Expects map {-o-}' );

    var o = o || Object.create( null );
    var exportStringDefaults = Object.create( null );
    // if( !_.primitiveIs( src ) && 'exportString' in src && _.routineIs( src.exportString ) && !src.exportString.notMethod && _.object.isBasic( src.exportString.defaults ) )
    if( !_.primitiveIs( src ) && 'exportString' in src && _.routineIs( src.exportString ) && _.instanceIs( src ) && _.object.isBasic( src.exportString.defaults ) )
    exportStringDefaults = src.exportString.defaults;

    if( o.levels === undefined || o.levels === null )
    if( o.jsonLike || o.jsLike )
    o.levels = 1 << 20;

    if( o.jsLike )
    {
      if( o.escaping === undefined || o.escaping === null )
      o.escaping = 1;
      if( o.keyWrapper === undefined || o.keyWrapper === null )
      o.keyWrapper = '"';
      if( o.stringWrapper === undefined || o.stringWrapper === null )
      o.stringWrapper = '`';
    }

    if( o.jsonLike )
    {
      if( o.escaping === undefined || o.escaping === null )
      o.escaping = 1;
      if( o.keyWrapper === undefined || o.keyWrapper === null )
      o.keyWrapper = '"';
      if( o.stringWrapper === undefined || o.stringWrapper === null )
      o.stringWrapper = '"';
    }

    // _.map.assertHasOnly( o, [ composes, primeFilter, optional ] );
    // o = _.props.supplement( null, o, exportStringDefaults, composes, primeFilter );

    _.map.assertHasOnly( o, def );
    o = _.props.supplement( o, def );

    if( o.multilinedString === undefined || o.multilinedString === null )
    o.multilinedString = o.stringWrapper === '`';

    if( o.stringWrapper === undefined || o.stringWrapper === null )
    if( o.multilinedString )
    o.stringWrapper = '`';
    else
    o.stringWrapper = `'`;

    if( o.onlyRoutines )
    {
      _.assert( !o.noRoutine, 'Expects {-o.noRoutine-} false if( o.onlyRoutines ) is true' );
      for( var f in primeFilter )
      o[ f ] = 1;
      o.noRoutine = 0;
    }

    if( o.comma === undefined || o.comma === null )
    o.comma = o.wrap ? ', ' : ' ';

    if( o.comma && !_.strIs( o.comma ) )
    o.comma = ', ';

    // if( o.stringWrapper === '`' && o.multilinedString === undefined )
    // o.multilinedString = 1;

    _.assert( _.strIs( o.stringWrapper ), 'Expects string {-o.stringWrapper-}' );

    if( o.jsonLike )
    {
      if( !o.jsLike )
      _.assert( o.stringWrapper === '"', 'Expects double quote ( o.stringWrapper ) true if either ( o.jsonLike ) or ( o.jsLike ) is true' );
      _.assert( !o.multilinedString, 'Expects {-o.multilinedString-} false if either ( o.jsonLike ) or ( o.jsLike ) is true to make valid JSON' );
    }

    var r = _.entity._exportString( src, o );

    return r ? r.text : '';
  }

} )();
_.entity.exportString.defaults =
{
  "noSubObject" : 0,
  "onlyRoutines" : 0,
  "onlyEnumerable" : 1,
  "precision" : null,
  "fixed" : null,
  "comma" : null,
  "multiline" : 0,
  "multilinedString" : null,
  "escaping" : 0,
  "jsonLike" : 0,
  "jsLike" : 0,
  "noRoutine" : 0,
  "noAtomic" : 0,
  "noArray" : 0,
  "noObject" : 0,
  "noRow" : 0,
  "noError" : 0,
  "noNumber" : 0,
  "noString" : 0,
  "noDate" : 0,
  "noUndefines" : 0,
  "levels" : 1,
  "level" : 0,
  "wrap" : 1,
  "stringWrapper" : null,
  "keyWrapper" : ``,
  "prependTab" : 1,
  "errorAsMap" : 0,
  "onlyOwn" : 1,
  "tab" : ``,
  "dtab" : `  `,
  "colon" : ` : `,
  "limitElementsNumber" : 0,
  "widthLimit" : 0,
  "heightLimit" : 0,
  "format" : `string.diagnostic`
}

//


  _.entity.namespaceForExporting = function namespaceForExporting( src )
{
  if( _.primitive.is( src ) )
  return _.primitive;
  if( _.date.is( src ) )
  return _.date;
  if( _.regexp.is( src ) )
  return _.regexp;
  if( _.set.like( src ) )
  return _.set;
  if( _.hashMap.like( src ) )
  return _.hashMap;
  if( _.routine.is( src ) )
  return _.routine;
  if( _.buffer.like( src ) )
  return _.buffer;
  if( _.long.like( src ) )
  return _.long;
  if( _.vector.like( src ) )
  return _.vector;
  if( _.countable.like( src ) )
  return _.countable;
  if( _.aux.like( src ) )
  return _.aux;
  if( _.object.like( src ) )
  return _.object;

  return null;
}

//


  _.entity._exportStringShallow = function _exportStringShallow( src, o )
{

  _.assert( arguments.length === 2 );
  _.assert( _.number.is( o.widthLimit ) && o.widthLimit >= 0 );
  _.assert( _.number.is( o.heightLimit ) && o.heightLimit >= 0 );
  _.assert( o.src === undefined )
  _.assert( o.format === 'string.diagnostic' || o.format === 'string.code' );

  let result = '';
  let method = o.format === 'string.diagnostic' ? 'exportStringDiagnosticShallow' : 'exportStringCodeShallow';

  try
  {

    let namespace = this.namespaceForExporting( src );
    if( namespace === null )
    {
      _.assert( 0, 'not tested' );
      namespace = _.blank;
    }

    result = namespace[ method ]( src );
    result = _.strShort_({ src : result, widthLimit : o.widthLimit, heightLimit : o.heightLimit }).result;

  }
  catch( err )
  {
    debugger;
    throw err;
  }

  return result;
}
_.entity._exportStringShallow.defaults =
{ "format" : null, "widthLimit" : 0, "heightLimit" : 0 }

//


  _.entity._exportStringDiagnosticShallow = function _exportStringDiagnosticShallow( src, o )
{
  let result;
  let namespace = this.namespaceForExporting( src );

  if( namespace )
  result = namespace.exportStringDiagnosticShallow( src );
  else
  result = _.strShort_( String( src ) ).result;

  return result;
}

//


  _.entity.exportStringDiagnosticShallow = function exportStringDiagnosticShallow( src, o ) /* */
{
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects one or two arguments' );
  o = _.aux.supplement( o || null, exportStringDiagnosticShallow.defaults );
  o.format = o.format || exportStringDiagnosticShallow.defaults.format;
  return _.entity._exportStringShallow( src, o );
}
_.entity.exportStringDiagnosticShallow.defaults =
{ "format" : `string.diagnostic`, "widthLimit" : 0, "heightLimit" : 0 }

//


  _.entity._exportStringFromRoutine = function _exportStringFromRoutine( src, o )
{
  var result = '';

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.routineIs( src ), 'Expects routine {-src-}' );

  if( o.jsLike )
  {
    if( _.routineSourceGet )
    result = _.routineSourceGet( src );
    else
    result = src.toString();
  }
  else
  {
    result = '[ routine ' + ( src.name || src._name || 'without name' ) + ' ]';
  }

  return result;
}

//



  _.error._setupUncaughtErrorHandler2 = function _setupUncaughtErrorHandler2()
{

  if( _realGlobal_._setupUncaughtErrorHandlerDone )
  return;

  _realGlobal_._setupUncaughtErrorHandlerDone = 1;

  if( _realGlobal_.process && typeof _realGlobal_.process.on === 'function' )
  {

    _realGlobal_.process.on( 'uncaughtException', _.error._handleUncaught1 );
    _realGlobal_.process.on( 'unhandledRejection', _.error._handleUncaughtPromise1 );
    _.error._handleUncaughtHead = _handleUncaughtHeadNode;
    if( Config.interpreter === 'browser' )
    _.error._handleUncaughtHead = _handleUncaughtHeadBrowser;
  }
  else if( Object.hasOwnProperty.call( _realGlobal_, 'onerror' ) )
  {
    _.error._handleUncaught0 = _realGlobal_.onerror;
    _realGlobal_.onerror = _.error._handleUncaught1;
    _.error._handleUncaughtHead = _handleUncaughtHeadBrowser;
  }

  /* */

  function _handleUncaughtHeadBrowser( args )
  {
    debugger;
    let [ message, sourcePath, lineno, colno, error ] = args;
    let err = error || message;
    return [ { err : new Error( args[ 0 ] ), args } ];
  }

  /* */

  function _handleUncaughtHeadNode( args )
  {
    return [ { err : args[ 0 ], args } ];
  }

  /* */

}

//


  _.error._setupUncaughtErrorHandler9 = function _setupUncaughtErrorHandler9()
{

  if( !_realGlobal_._setupUncaughtErrorHandlerDone )
  {
    debugger;
    throw Error( 'setup0 should be called first' );
  }

  if( _realGlobal_._setupUncaughtErrorHandlerDone > 1 )
  return;

  _realGlobal_._setupUncaughtErrorHandlerDone = 2;

  /* */

  if( _global.process && _.routine.is( _global.process.on ) )
  {
    _.error._handleUncaughtHead = _errHeadNode;
  }
  else if( Object.hasOwnProperty.call( _global, 'onerror' ) )
  {
    _.error._handleUncaughtHead = _errHeadBrowser;
  }

  /* */

  function _errHeadBrowser( args )
  {
    let [ message, sourcePath, lineno, colno, error ] = args;
    let err = error || message;

    if( _._err )
    err = _._err
    ({
      args : [ error || message ],
      level : 1,
      fallBackStack : 'at handleError @ ' + sourcePath + ':' + lineno,
      throwLocation :
      {
        filePath : sourcePath,
        line : lineno,
        col : colno,
      },
    });

    return [ { err, args } ];
  }

  /* */

  function _errHeadNode( args )
  {
    return [ { err : args[ 0 ], args } ];
  }

  /* */

}

//


  _.error._handleUncaughtHead = function _errHeadNode( args )
  {
    return [ { err : args[ 0 ], args } ];
  }

//


  _.error._handleUncaught1 = function _handleUncaught1()
{

  debugger;
  let args = _.error._handleUncaughtHead( arguments );
  let result = _.error._handleUncaught2.apply( this, args );

  if( _.error._handleUncaught0 )
  _.error._handleUncaught0.apply( this, arguments );

  return result;
}

//


  _.error._handleUncaughtPromise1 = function _handleUncaughtPromise1( err, promise )
{
  let o = Object.create( null );
  o.promise = promise;
  o.err = err;
  o.origination = 'uncaught promise error';
  let result = _.error._handleUncaught2.call( this, o );
  return result;
}

//


  _.error._handleUncaught2 = function _handleUncaught2( o )
{
  const __ = _global_.globals && _globals_.testing.wTools;
  const process0 = processNamespaceGet();

  optionsRefine();

  /* xxx qqq : resolve issue in browser
    if file has syntax error then unachught error should not ( probably ) be throwen
    because browser thows uncontrolled information about syntax error after that
    avoid duplication of errors in log
  */

  o.err = errRefine( o.err );

  processUncaughtErrorEvent();

  if( _.error.isAttended( o.err ) )
  return;

  consoleUnbar();

  console.error( o.prefix );

  errLogFields();
  errLog();

  console.error( o.postfix );

  processExit();

  /* */

  function optionsRefine()
  {

    if( !o.origination )
    o.origination = 'uncaught error';

    // for( let k in o )
    // if( _handleUncaught2.defaults[ k ] !== undefined )
    // {
    //   console.error( `Routine::_handleUncaught2() does not expect option::${k}` );
    // }

    o.prefix = `--------------- ${o.origination} --------------->\n`;
    o.postfix = `--------------- ${o.origination} ---------------<\n`;
    o.logger = _global.logger || _global.console;

  }

  /* */

  function consoleUnbar()
  {
    let Logger = loggerClassGet();
    try
    {
      if( Logger && Logger.ConsoleBar && Logger.ConsoleIsBarred( console ) )
      Logger.ConsoleBar({ on : 0 });
    }
    catch( err2 )
    {
      debugger;
      console.error( err2 );
    }
  }

  /* */

  function errLog()
  {
    try
    {
      if( _.error && _.error._log )
      _.error._log( o.err, o.logger );
      else
      console.error( o.err );
    }
    catch( err2 )
    {
      debugger;
      console.error( err2 );
      console.error( o.err );
    }
  }

  /* */

  function errLogFields()
  {
    if( !o.err.originalMessage && _.object.like && _.object.like( o.err ) )
    try
    {
      let props = Object.create( null );
      for( let k in o.err )
      props[ k ] = o.err[ k ];
      // let serr = _.entity.exportString && _.props ? _.entity.exportString.fields( o.err, { errorAsMap : 1 } ) : o.err;
      o.logger.error( _.entity.exportString( props ) );
      debugger;
    }
    catch( err2 )
    {
      debugger;
      console.error( err2 );
    }
  }

  /* */

  function errRefine( err )
  {
    try
    {
      return _.error.process( err );
    }
    catch( err2 )
    {
      console.error( err2 );
      return err;
    }
  }

  /* */

  function processNamespaceGet()
  {
    let result;
    if( !result && _.process && _.process.exitReason )
    result = _.process;
    if( !result && _realGlobal_ && _realGlobal_.wTools && _realGlobal_.wTools.process && _realGlobal_.wTools.process.exitReason )
    result = _realGlobal_.wTools.process;
    if
    (
      !result
      && _realGlobal_._globals_.testing
      && __
      && __.process
      && __.process.exitReason
    )
    result = __.process;
    if( !result )
    result = _.process;
    return result;
  }

  /* */

  function loggerClassGet()
  {
    let result;
    if( !result && _.Logger && _.Logger.ConsoleBar )
    result = _.Logger;
    if( !result && _realGlobal_ && _realGlobal_.wTools && _realGlobal_.wTools.Logger && _realGlobal_.wTools.Logger.ConsoleBar )
    result = _realGlobal_.wTools.Logger;
    if
    (
      !result
      && __
      && __.Logger
      && __.Logger.ConsoleBar
    )
    result = __.Logger;
    return result;
  }

  /* */

  function processUncaughtErrorEvent()
  {
    try
    {
      // if( process0.eventGive ) /* xxx : cover in starter not catching uncaught error */
      if( process0 && process0.eventGive )
      // process0.eventGive({ event : 'uncaughtError', args : [ o ] });
      /* xxx : move to namespace app? */
      process0.eventGive({ event : 'uncaughtError', origination : o.origination, err : o.err });
      for( let g in _realGlobal_._globals_ )
      {
        const _global = _realGlobal_._globals_[ g ];
        if( _global.wTools && _global.wTools.process && _global.wTools.process.eventGive )
        if( _global.wTools.process !== process0 )
        _global.wTools.process.eventGive({ event : 'uncaughtError', origination : o.origination, err : o.err });
        // _global.wTools.process.eventGive({ event : 'uncaughtError', args : [ o ] });
      }
    }
    catch( err2 )
    {
      debugger;
      console.log( err2 );
      exitError( err2, false );
    }
  }

  /* */

  function exitError( err, rewriting )
  {
    let set = false;
    debugger;
    if( process0 && process0.exit )
    try
    {
      process0.exitCode( -1 );
      if( !process0.exitReason() )
      process0.exitReason( err );
      set = true;
    }
    catch( err2 )
    {
      debugger;
      console.log( err2 );
    }
    if( !set )
    try
    {
      if( _global.process )
      {
        if( !process.exitCode )
        process.exitCode = -1;
        set = true;
      }
    }
    catch( err2 )
    {
    }
  }

  /* */

  function processExit()
  {
    exitError( o.err, true );
    if( process0 && process0.exit )
    try
    {
      process0.exit();
    }
    catch( err2 )
    {
      debugger;
      console.log( err2 );
      exitError( o.err, false );
    }
    try
    {
      if( _global.process )
      process.exit();
    }
    catch( err2 )
    {
    }
  }

}
_.error._handleUncaught2.defaults =
{ "err" : null, "origination" : null }

//



  _.event._chainGenerate = function _chainGenerate( args )
{
  let chain = [];

  _.assert( arguments.length === 1 );
  _.assert( _.longIs( args ) );

  for( let a = 0 ; a < args.length-2 ; a++ )
  chainMake( a );

  chain.push([ _.event.nameValueFrom( args[ args.length-2 ] ), args[ args.length-1 ] ]);

  _.assert( _.routine.is( args[ args.length-1 ] ) );

  return chain;

  /* */

  function chainMake( a )
  {
    let e1 = _.event.nameValueFrom( args[ a ] );
    chain.push([ e1, on ]);
    function on()
    {
      let self = this;
      let next = chain[ a + 1 ];

      if( _.routine.is( self.on ) )
      {
        /*
            Dmytro : it is strange code because the owners of edispatcher can be classes like Process.
            And this solution allows direct call of callbacks when the routine eventGive is not used :
            https://github.com/Wandalen/wProcess/blob/master/proto/wtools/abase/l4_process/Basic.s#L210
            https://github.com/Wandalen/wProcedure/blob/master/proto/wtools/abase/l8_procedure/Namespace.s#L59
        */
        self.on( next[ 0 ], next[ 1 ] );
        if( self.eventHasHandler( e1, on ) )
        self.off( e1, on );
      }
      else
      {
        let o = _.event.onHead( _.event.on, next );
        o.once = on.once;
        _.event._on( self, o );

        if( !on.once )
        if( _.event.eventHasHandler( self, { eventName : e1, eventHandler : on } ) )
        _.event.off( self, { callbackMap : { [ e1 ] : on } } );
      }

    }
  }
}

//


  _.event._chainToCallback = function _chainToCallback( args )
{
  let chain = _.event._chainGenerate( args );
  let firstPair = chain[ 0 ];
  return firstPair[ 1 ];
}

//


  _.event._chainValidate = function _chainValidate( chain )
{

  for( let i = 0 ; i < chain.length - 1 ; i++ )
  {
    _.assert( _.event.nameIs( chain[ i ] ) );
  }
  _.assert( _.routine.is( chain[ chain.length - 1 ] ) );

  return true;
}

//


  _.event._callbackMapValidate = function _callbackMapValidate( callbackMap )
{

  _.assert( _.mapIs( callbackMap ) );
  for( let k in callbackMap )
  {
    let callback = callbackMap[ k ];
    _.assert( _.routine.is( callback ) || _.longIs( callback ) );
    if( _.routine.is( callback ) )
    continue;
    _.event._chainValidate( callback );
  }

}

//


  _.event.nameValueFrom = function nameValueFrom( name )
{
  if( _.strIs( name ) )
  return name;
  _.assert( _.event.nameIs( name ) );
  return name.value;
}

//


  _.event.nameIs = function nameIs( name )
{
  return name instanceof _.event.Name;
}

//


  _.event.chainIs = function chainIs( src )
{
  return src instanceof _.event.Chain;
}

//


  _.event.Name = function Name( name )
{
  if( !( this instanceof Name ) )
  {
    if( _.event.nameIs( name ) )
    return name;
    return new Name( ... arguments );
  }
  _.assert( arguments.length === 1 );
  _.assert( _.strIs( name ) );
  this.value = name;
  return this;
}

//


  _.event.Chain = function Chain()
{
  if( !( _.event.chainIs( this ) ) )
  {
    if( _.event.chainIs( arguments[ 0 ] ) )
    {
      _.assert( arguments.length === 1, 'Expects single Chain or set of event names' );
      return arguments[ 0 ];
    }
    return new Chain( ... arguments );
  }

  let result = _.array.make( arguments.length );
  _.assert( arguments.length >= 1, 'Expects events names' );
  for( let i = 0 ; i < arguments.length ; i++ )
  result[ i ] = _.event.Name( arguments[ i ] );

  this.chain = result;
  return this;
}

//


  _.event._on = function _on( edispatcher, o )
{

  _.routine.options( _on, o );
  _.assert( _.mapIs( o.callbackMap ) );
  _.assert( _.object.isBasic( edispatcher ) );
  _.assert( _.object.isBasic( edispatcher.events ) );
  _.map.assertHasOnly( o.callbackMap, edispatcher.events, 'Unknown kind of event' );
  _.assert( arguments.length === 2 );

  const once = !!o.once;
  let descriptors = Object.create( null );
  let append;
  if( o.first )
  append = _.arrayPrepend;
  else
  append = _.arrayAppend;

  for( let c in o.callbackMap )
  {
    let callback = o.callbackMap[ c ];
    descriptors[ c ] = descriptorMake();

    if( _.longIs( callback ) )
    callback = _.event._chainToCallback([ c, ... callback ]);

    _.assert( _.routine.is( callback ) );

    callback = callbackOn_functor.call( descriptors[ c ], callback, c );
    descriptors[ c ].off = off_functor.call( descriptors[ c ], edispatcher, { callbackMap : { [ c ] : callback } } );

    append( edispatcher.events[ c ], callback );

    // if( o.first )
    // _.arrayPrepend( edispatcher.events[ c ], callback );
    // else
    // _.arrayAppend( edispatcher.events[ c ], callback );

    /* */

  }

  return descriptors;

  /* */

  // function callbackOn_functor( callback ) /* Dmytro : can't extract name from descriptor. Maybe, it can contains field `name` */
  function callbackOn_functor( callback, name )
  {
    let self = this;

    function callbackOn()
    {
      let result;
      if( self.enabled )
      {
        result = callback.apply( this, arguments );
        if( once === true )
        _.event.off( edispatcher, { callbackMap : { [ name ] : callbackOn } } );
        // _.event.off( edispatcher, { callbackMap : { [ name ] : callbackOnce } } ); /* Dmytro : callbackOnce does not exist */
      }
      return result;
    }
    callbackOn.native = callback;
    callbackOn.native.once = once;

    return callbackOn;
  }

  /* */

  function descriptorMake()
  {
    let descriptor = Object.create( null );
    descriptor.off = null;
    descriptor.enabled = true;
    descriptor.first = o.first; /* Dmytro : please, explain, does it need to save original value? */
    descriptor.callbackMap = o.callbackMap; /* Dmytro : please, explain, does it need to save link to original callback map? */
    return descriptor;
  }

  /* */

  function off_functor( edispatcher, o )
  {
    let self = this;

    return function()
    {
      _.assert( arguments.length === 0, 'Expects no arguments.' );
      return _.event.off( edispatcher, o );
    }
  }

  /* */

}
_.event._on.defaults =
{ "callbackMap" : null, "first" : false, "once" : false }

//


  _.event.on = function on( edispatcher, o )
{
  o.once = false;
  return _.event._on( edispatcher, o );
}

//


  _.event.onHead = function onHead( routine, args )
{
  let o;

  _.assert( _.longIs( args ) );
  _.assert( arguments.length === 2 );

  if( args.length === 2 )
  {
    _.assert( _.routine.is( args[ 1 ] ) );

    o = Object.create( null );
    o.callbackMap = Object.create( null );

    if( _.event.chainIs( args[ 0 ] ) )
    {
      let chain = args[ 0 ].chain;
      o.callbackMap[ chain[ 0 ].value ] = _.longOnly_( null, chain, [ 1, chain.length - 1 ] );
      o.callbackMap[ chain[ 0 ].value ].push( args[ 1 ] );
    }
    else if( _.strIs( args[ 0 ] ) )
    {
      o.callbackMap[ args[ 0 ] ] = args[ 1 ];
    }
    else if( _.event.nameIs( args[ 0 ] ) )
    {
      o.callbackMap[ args[ 0 ].value ] = args[ 1 ];
    }
    else
    {
      _.assert( 0, 'Expects Chain with names or single name of event.' );
    }
  }
  else if( args.length === 1 )
  {
    o = args[ 0 ];
  }
  else
  {
    _.assert( 0, 'Expects single options map {-o-} or events Chain and callback as arguments.' );
  }

  if( Config.debug )
  {
    _.assert( _.mapIs( o ) );
    _.event._callbackMapValidate( o.callbackMap );
  }

  // _.event._callbackMapNormalize( o.callbackMap );

  return o;
}

//


  _.event.once = function once( edispatcher, o )
{
  o.once = true;
  return _.event._on( edispatcher, o );
}

//


  _.event.off = function off( edispatcher, o )
{

  _.routine.options( off, o );
  _.assert( _.mapIs( o.callbackMap ) );
  _.assert( _.object.isBasic( edispatcher ) );
  _.assert( _.object.isBasic( edispatcher.events ) );
  _.map.assertHasOnly( o.callbackMap, edispatcher.events, 'Unknown kind of event' );
  _.assert( arguments.length === 2 );

  for( let c in o.callbackMap )
  {
    if( o.callbackMap[ c ] === null )
    _.array.empty( edispatcher.events[ c ] );
    else
    _.arrayRemoveOnceStrictly( edispatcher.events[ c ], o.callbackMap[ c ], callbackEqualize );
  }

  return o;

  /* */

  function callbackEqualize( callback, handler )
  {
    return handler === callback || handler === callback.native;
  }
}
_.event.off.defaults =
{ "callbackMap" : null }

//


  _.event.eventHasHandler = function eventHasHandler( edispatcher, o )
{

  _.routine.options( eventHasHandler, o );
  _.assert( _.strIs( o.eventName ) );
  _.assert( _.routine.is( o.eventHandler ) );
  _.assert( _.mapIs( edispatcher ) );
  _.assert( _.mapIs( edispatcher.events ) );
  _.assert( arguments.length === 2 );

  return _.longHas( edispatcher.events[ o.eventName ], o.eventHandler, handlerEqualize );

  /* */

  function handlerEqualize( callback, handler )
  {
    return handler === callback || handler === callback.native;
  }
}
_.event.eventHasHandler.defaults =
{ "eventName" : null, "eventHandler" : null }

//


  _.event.eventGive = function eventGive( edispatcher, o )
{

  // if( _.strIs( o ) )
  // o = { event : o }
  // _.routine.options( eventGive, o );
  //
  // if( o.onError === null )
  // o.onError = onError;
  // if( o.args === null )
  // {
  //   o.args = [ Object.create( null ) ];
  //   o.args[ 0 ].event = o.event;
  // }

  _.assert( arguments.length === 2 );
  _.assert( !!edispatcher.events[ o.event ], `Unknown event ${o.event}` );
  _.assert( _.long.is( o.args ), 'Expects arguments {-o.args-}' );

  let was;
  let visited = [];
  do
  {
    was = visited.length;
    let events = edispatcher.events[ o.event ].slice();
    _.each( events, ( callback ) =>
    {
      if( _.longHas( visited, callback ) )
      return;
      visited.push( callback );
      try
      {
        callback.apply( edispatcher, o.args );
      }
      catch( err )
      {
        o.onError( err, o );
      }
    });
  }
  while( was !== visited.length );

  /* */

  // function onError( err, o )
  // {
  //   throw _.err( `Error on handing event ${o.event}\n`, err );
  // }

}
_.event.eventGive.defaults =
{ "event" : null, "args" : null, "onError" : null }

//


  _.event.eventGiveHead = function eventGiveHead( edispatcher, routine, args )
{
  let o = args[ 0 ];

  _.assert( arguments.length === 3, 'Expects exactly three arguments.' );
  _.assert( args.length > 0 );
  _.assert( _.aux.is( edispatcher.events ), 'Expects events dispatcher.' );

  if( _.strIs( o ) )
  o = { event : o };
  _.assert( _.aux.is( o ), 'Expects string or options map in {-o.args[ 1 ]-}.' ); /* Dmytro : restrict using options map in first argument */

  if( o.onError === null || o.onError === undefined )
  o.onError = onError;

  _.map.assertHasOnly( o, routine.defaults );

  if( o.args )
  _.assert( args.length === 1 ); /* Dmytro : restrict using options map in first argument */
  else /* Dmytro : do not overwrite arguments if the field exists */
  o.args = args;

  // if( o.args === null )
  // {
  //   o.args = [ Object.create( null ) ];
  //   o.args[ 0 ].event = o.event;
  // }

  return o;

  /* */

  function onError( err, o )
  {
    throw _.err( `Error on handing event ${o.event}\n`, err );
  }
}

//




  _.each = function entityEach( src, onEach )
{

  _.assert( arguments.length === 2 );
  _.assert( onEach.length <= 3 );
  _.assert( _.routine.is( onEach ) );

  /* */

  /* qqq for junior : add branch for countable case */
  if( _.longIs( src ) )
  {

    for( let k = 0 ; k < src.length ; k++ )
    {
      onEach( src[ k ], k, src );
    }

  }
  else if( _.aux.is( src ) )
  {

    for( let k in src )
    {
      onEach( src[ k ], k, src );
    }

  }
  else
  {
    onEach( src, undefined, undefined );
  }

  /* */

  return src;
}

//



  /*
  Uri namespace( parseConsecutive ) is required to make _.include working in a browser
  */

  // parseFull maybe?

  _.uri.isGlobal = function isGlobal( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string' );
  return _.strHas( filePath, '://' );
}

//


  _.uri.parseConsecutive = ( function() {

  const _parse_head = function parse_head( routine, args )
  {
    _.assert( args.length === 1, 'Expects single argument' );

    let o = { srcPath : args[ 0 ] };

    _.routine.options_( routine, o );
    _.assert( _.strIs( o.srcPath ) || _.mapIs( o.srcPath ) );
    _.assert( _.longHas( routine.Kind, o.kind ), () => 'Unknown kind of parsing ' + o.kind );

    return o;
  }

  const _parse_body = function parse_body( o )
  {
    let self = this;
    let result = Object.create( null );

    if( _.mapIs( o.srcPath ) )
    {
      _.map.assertHasOnly( o.srcPath, this.UriFull.propsExtension );
      if( o.srcPath.protocols )
      return o.srcPath;
      else if( o.srcPath.full )
      o.srcPath = o.srcPath.full;
      else
      o.srcPath = this.str( o.srcPath );
    }

    let postfixes = '';

    longPathParse();

    let delimeter = [ self.tagToken, self.hashToken, self.queryToken ];
    if( _.strHasAny( result.longPath, delimeter ) )
    postfixesParse( delimeter );

    /* */

    if( o.kind === 'full' )
    {

      result.postfixedPath = result.longPath + postfixes;

      self._parseLongPath( result, result.longPath );

      if( result.protocol )
      result.protocols = result.protocol.split( '+' );
      else
      result.protocols = [];

      if( _.strIs( result.protocol ) )
      result.origin = result.protocol + self.protocolToken + result.hostFull;

      result.full = o.srcPath;

    }
    else if( o.kind === 'consecutive' )
    {
    }
    else if( o.kind === 'atomic' )
    {
      self._parseLongPath( result, result.longPath );
      delete result.hostFull;
      delete result.longPath;
    }
    else _.assert( 0 );

    return result;

    /* */

    function longPathParse()
    {

      let isolates = _.strIsolateLeftOrNone.body
      ({
        src : o.srcPath,
        delimeter : self.protocolToken,
        times : 1,
        quote : false,
      });

      if( isolates[ 1 ] )
      result.protocol = isolates[ 0 ];

      result.longPath = isolates[ 2 ];
    }

    /* */

    function postfixesParse( delimeter )
    {

      let rest = '';
      let splits2 = _.path.split( result.longPath );
      let left, s;

      for( s = 0 ; s < splits2.length ; s++ )
      {
        let split = splits2[ s ];
        if( _.path._unescape( split ).wasEscaped )
        continue;
        left = _.strLeft_( split, delimeter );
        if( left.entry )
        {
          if( s > 0 )
          {
            result.longPath = splits2.slice( 0, s ).join( self.upToken );
            result.longPath += self.upToken + split.slice( 0, left.index );
          }
          else
          {
            result.longPath = split.slice( 0, left.index );
          }
          split = split.slice( left.index + 1 );
          splits2[ s ] = split
          rest = splits2.slice( s ).join( self.upToken );
          break;
        }
      }

      if( left && left.entry )
      restParse( rest, left.entry, delimeter );

    }

    /* */

    function restParse( rest, entry, delimeter )
    {

      _.arrayRemoveOnceStrictly( delimeter, entry );

      let isolates = _.strIsolateLeftOrAll( rest, delimeter );

      if( entry === self.queryToken )
      result.query = isolates[ 0 ];
      else if( entry === self.hashToken )
      result.hash = isolates[ 0 ];
      else if( entry === self.tagToken )
      result.tag = isolates[ 0 ];

      postfixes += entry + isolates[ 0 ];

      // rest = isolates[ 2 ]; /* xxx : remove variable? */
      if( isolates[ 1 ] )
      {
        restParse( isolates[ 2 ], isolates[ 1 ], delimeter );
      }

    }

    /* */

  }
  _parse_body.defaults = { "srcPath" : null, "kind" : `full` }
    _parse_body.components = {
      "protocol" : null,
      "query" : null,
      "hash" : null,
      "tag" : null,
      "protocols" : null,
      "postfixedPath" : null,
      "resourcePath" : null,
      "longPath" : null,
      "full" : null,
      "hostFull" : null,
      "host" : null,
      "port" : null,
      "user" : null,
      "origin" : null
    }
    _parse_body.Kind = [ `full`, `atomic`, `consecutive` ]

  const _parse_ = _.routine.unite
  ({
    head : _parse_head,
    body : _parse_body,
  });

  return _parse_;
})();
_.uri.parseConsecutive.defaults =
{ "srcPath" : null, "kind" : `consecutive` }

//


  _.uri.refine = function refine( filePath )
{
  let parent = this.path;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ) );

  if( this.isGlobal( filePath ) )
  filePath = this.parseConsecutive( filePath );
  else
  return parent.refine.call( this, filePath );

  if( _.strDefined( filePath.longPath ) )
  filePath.longPath = parent.refine.call( this, filePath.longPath );

  if( filePath.hash || filePath.tag )
  filePath.longPath = parent.detrail( filePath.longPath );

  return this.str( filePath );
}

//


  _.uri._normalize = function _normalize( o )
{
  // let debug = 0;
  // if( 0 )
  // debug = 1;

  _.routine.assertOptions( _normalize, arguments );
  _.assert( _.strIs( o.src ), 'Expects string' );

  if( !o.src.length )
  return '';

  let result = o.src;

  result = this.refine( result );

  // if( debug )
  // console.log( 'normalize.refined : ' + result );

  /* detrailing */

  if( o.tolerant )
  {
    /* remove "/" duplicates */
    result = result.replace( this._delUpDupRegexp, this.upToken );
  }

  let endsWithUp = false;
  let beginsWithHere = false;

  /* remove right "/" */

  if( result !== this.upToken && !_.strEnds( result, this.upToken + this.upToken ) && _.strEnds( result, this.upToken ) )
  {
    endsWithUp = true;
    result = _.strRemoveEnd( result, this.upToken );
  }

  /* undoting */

  while( !_.strBegins( result, this.hereUpToken + this.upToken ) && _.strBegins( result, this.hereUpToken ) )
  {
    beginsWithHere = true;
    result = _.strRemoveBegin( result, this.hereUpToken );
  }

  /* remove second "." */

  if( result.indexOf( this.hereToken ) !== -1 )
  {

    while( this._delHereRegexp.test( result ) )
    result = result.replace( this._delHereRegexp, function( match, postSlash )
    {
      return postSlash || '';
    });
    if( result === '' )
    result = this.upToken;

  }

  /* remove .. */

  if( result.indexOf( this.downToken ) !== -1 )
  {

    while( this._delDownRegexp.test( result ) )
    result = result.replace( this._delDownRegexp, function( /* match, notBegin, split, preSlash, postSlash */ )
    {
      let match = arguments[ 0 ];
      let notBegin = arguments[ 1 ];
      let split = arguments[ 2 ];
      let preSlash = arguments[ 3 ];
      let postSlash = arguments[ 4 ];

      if( preSlash === '' )
      return notBegin;
      if( !notBegin )
      return notBegin + preSlash;
      else
      return notBegin + ( postSlash || '' );
    });

  }

  /* nothing left */

  if( !result.length )
  result = '.';

  /* dot and trail */

  if( o.detrailing )
  if( result !== this.upToken && !_.strEnds( result, this.upToken + this.upToken ) )
  result = _.strRemoveEnd( result, this.upToken );

  if( !o.detrailing && endsWithUp )
  if( result !== this.rootToken )
  result = result + this.upToken;

  if( !o.undoting && beginsWithHere )
  result = this._dot( result );

  // if( debug )
  // console.log( 'normalize.result : ' + result );

  return result;
}
_.uri._normalize.defaults =
{
  "src" : null,
  "tolerant" : false,
  "detrailing" : false,
  "undoting" : false
}

//


  _.uri.canonize = function canonize( filePath )
{
  let parent = this.path;
  if( _.strIs( filePath ) )
  {
    if( this.isGlobal( filePath ) )
    filePath = this.parseConsecutive( filePath );
    else
    return parent.canonize.call( this, filePath );
  }
  _.assert( !!filePath );
  filePath.longPath = parent.canonize.call( this, filePath.longPath );
  return this.str( filePath );
}

//


  _.uri.canonizeTolerant = function canonizeTolerant( src )
{
  _.assert( _.strIs( src ), 'Expects string' );

  let result = this._normalize({ src, tolerant : true, detrailing : true, undoting : true });

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( result === this.upToken || _.strEnds( result, this.upToken ) || !_.strEnds( result, this.upToken + this.upToken ) );
  _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
  _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );

  if( Config.debug )
  {
    _.assert( !this._delUpDupRegexp.test( result ) );
  }

  return result;
}

//


  _.uri.protocolToken = `://`;

//

  _.uri.portToken = `:`;

//

  _.uri.userToken = `@`;

//

  _.uri.tagToken = `!`;

//

  _.uri.hashToken = `#`;

//

  _.uri.queryToken = `?`;

//

  _.uri._delDownRegexp = /((?:.|^))(?:(?:\/\/)|(((?:^|\/))(?!\.\.(?:\/|$))(?:(?!\/).)+\/))\.\.((?:\/|$))/;

//

  _.uri._delHereRegexp = /\/\.(\/|$)/;

//

  _.uri._delUpDupRegexp = /\/{2,}/g;

//

  _.uri.rootToken = `/`;

//

  _.uri.upToken = `/`;

//

  _.uri.hereToken = `.`;

//

  _.uri.downToken = `..`;

//

  _.uri.hereUpToken = `./`;

//

  _.uri.downUpToken = `../`;

//

  _.uri._pathIsGlobRegexp = /(?:[?*]+)|(?:([!?*@+]*)\((.*?(?:\|(.*?))*)\))|(?:\[(.+?)\])|(?:\{(.*)\})|(?: )/;

//

  _.uri.currentAtBegin = `/mnt/home-hdd//Intellectual/wTools`;

//



  _.color.strFg = function formatForeground( srcStr, color )
{

  if( _.number.is( color ) )
  color = _.color.colorNameNearest( color );

  _.assert( arguments.length === 2, 'Expects 2 arguments' );
  _.assert( _.strIs( srcStr ), 'Expects string {-srcStr-}' );
  _.assert( _.strIs( color ), 'Expects string {-color-}' );

  return `foreground : ${color}${srcStr}foreground : default`;
}

//


  _.color.strBg = function formatBackground( srcStr, color )
{

  if( _.number.is( color ) )
  color = _.color.colorNameNearest( color );

  _.assert( arguments.length === 2, 'Expects 2 arguments' );
  _.assert( _.strIs( srcStr ), 'Expects string {-srcStr-}' );
  _.assert( _.strIs( color ), 'Expects string {-color-}' );

  return `background : ${color}${srcStr}background : default`;
}

//


  _.color.rgbaHtmlFrom = function rgbaHtmlFrom( o )
{

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ], colorMap : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.routine.options_( rgbaHtmlFrom, o );

  let result = this.rgbaHtmlFromTry( o );

  if( !result )
  debugger;
  if( !result )
  throw _.err( `Not color : "${_.entity.exportStringDiagnosticShallow( o.src )}"` );

  return result;

  // let result;
  //
  // if( !_.mapIs( o ) )
  // o = { src : arguments[ 0 ], colorMap : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  //
  // _.assert( arguments.length === 1, 'Expects single argument' );
  // _.routine.options_( rgnaFrom, arguments );
  //
  // if( _.numberIs( o.src ) || _.longIs( o.src ) || ( !_.mapIs( o.src ) && _.object.isBasic( o.src ) ) )
  // return this._rgbaFromNotName( o.src );
  //
  // /* */
  //
  // if( _.strIs( o.src ) )
  // result = this.fromTable( o );
  //
  // if( result )
  // return end();
  //
  // /* */
  //
  // if( _.strIs( o.src ) )
  // result = _.color.hexToColor( o.src );
  //
  // if( result )
  // return end();
  //
  // /* */
  //
  // _.assertWithoutBreakpoint( 0, 'Unknown color', _.strQuote( o.src ) );
  //
  // function end()
  // {
  //   _.assert( _.longIs( result ) );
  //   if( result.length !== 4 )
  //   result = _.longGrow_( result, result, [ 0, 3 ], 1 ); /* xxx : replace */
  //   return result;
  // }

}
_.color.rgbaHtmlFrom.defaults =
{ "src" : null, "colorMap" : null }

//


  _.color.rgbaHtmlFromTry = function rgbaHtmlFromTry( o )
{
  let result;

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ] };

  _.assert( arguments.length === 1 );
  _.routine.options_( rgbaHtmlFromTry, o );

  if( _.numberIs( o.src ) || _.longIs( o.src ) || ( !_.mapIs( o.src ) && _.object.isBasic( o.src ) ) )
  return this._rgbaFromNotName( o.src );

  /* */

  if( _.strIs( o.src ) )
  result = this.fromTable( o );

  if( result )
  return end();

  /* */

  if( _.strIs( o.src ) )
  result = _.color.hexToColor( o.src );

  if( result )
  return end();

  if( _.strIs( o.src ) )
  result = _.color.rgbaHtmlToRgba( o.src );

  if( result )
  return end();

  if( _.strIs( o.src ) )
  result = _.color.hslaToRgba( o.src );

  if( result )
  return end();

  /* */

  return o.def;

  function end()
  {
    _.assert( _.longIs( result ) );
    if( result.length !== 4 )
    result = _.longGrow_( result, result, [ 0, 3 ], 1 ); /* xxx : replace */
    return result;
  }

}
_.color.rgbaHtmlFromTry.defaults =
{ "src" : null, "colorMap" : null, "def" : null }

//


  _.color.rgbaHtmlToRgba = function rgbaHtmlToRgba( src )
{
  _.assert( _.strDefined( src ) );

  let splitted = _.strSplitFast
  ({
    src,
    delimeter : [ '(', ')', ',' ],
    preservingDelimeters : 0,
    preservingEmpty : 0
  })

  if( _.strBegins( splitted[ 0 ], 'rgb' ) )
  {
    let result =
    [
      parseInt( splitted[ 1 ] ) / 255,
      parseInt( splitted[ 2 ] ) / 255,
      parseInt( splitted[ 3 ] ) / 255,
      1
    ]

    if( splitted[ 0 ] === 'rgba' )
    result[ 3 ] = Number( splitted[ 4 ] )

    return result;
  }

  return null;
}

//


  _.color.rgba.fromHexStr = function fromHexStr( hex )
{
  let result;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( hex ) );

  result = /^#?([a-f\d])([a-f\d])([a-f\d])$/i.exec( hex );
  if( result )
  {
    result =
    [
      parseInt( result[ 1 ], 16 ) / 15,
      parseInt( result[ 2 ], 16 ) / 15,
      parseInt( result[ 3 ], 16 ) / 15,
    ]
    return result;
  }

  result = /^#?([a-f\d])([a-f\d])([a-f\d])([a-f\d])$/i.exec( hex );
  if( result )
  {
    result =
    [
      parseInt( result[ 1 ], 16 ) / 15,
      parseInt( result[ 2 ], 16 ) / 15,
      parseInt( result[ 3 ], 16 ) / 15,
      parseInt( result[ 4 ], 16 ) / 15,
    ]
    return result;
  }

  result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec( hex );
  if( result )
  {
    result =
    [
      parseInt( result[ 1 ], 16 ) / 255,
      parseInt( result[ 2 ], 16 ) / 255,
      parseInt( result[ 3 ], 16 ) / 255,
    ]
    return result;
  }

  result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec( hex );
  if( result )
  {
    result =
    [
      parseInt( result[ 1 ], 16 ) / 255,
      parseInt( result[ 2 ], 16 ) / 255,
      parseInt( result[ 3 ], 16 ) / 255,
      parseInt( result[ 4 ], 16 ) / 255,
    ]
    return result;
  }

  return null;
}

//


  _.color.hslaToRgba = function hslaToRgba( hsla, result )
{

}

//


  _.color._colorDistance = function _colorDistance( c1, c2 )
{
  _.assert( _.longIs( c1 ) );
  _.assert( _.longIs( c2 ) );

  let a = c1.slice();
  let b = c2.slice();

  // function _definedIs( src )
  // {
  //   return src !== undefined && src !== null && !isNaN( src )
  // }

  for( let  i = 0 ; i < 4 ; i++ )
  {
    if( !_.numberIsFinite( a[ i ] ) )
    // a[ i ] = _definedIs( b[ i ] ) ? b[ i ] : 1;
    a[ i ] = 1;

    if( !_.numberIsFinite( b[ i ] ) )
    // b[ i ] = _definedIs( a[ i ] ) ? a[ i ] : 1;
    b[ i ] = 1;
  }

  // a[ 3 ] = _definedIs( a[ 3 ] ) ? a[ i ] : 1;
  // b[ 3 ] = _definedIs( b[ 3 ] ) ? b[ i ] : 1;

  return  Math.pow( a[ 0 ] - b[ 0 ], 2 )
          + Math.pow( a[ 1 ] - b[ 1 ], 2 )
          + Math.pow( a[ 2 ] - b[ 2 ], 2 )
          + Math.pow( a[ 3 ] - b[ 3 ], 2 )
}

//


  _.color._rgbByBitmask = function _rgbByBitmask( src )
{
  let result = [];

  result[ 0 ] = ( ( src >> 16 ) & 0xff ) / 255;
  result[ 1 ] = ( ( src >> 8 ) & 0xff ) / 255;
  result[ 2 ] = ( ( src >> 0 ) & 0xff ) / 255;

  return result;
}

//


  _.color._rgbaFromNotName = function _rgbaFromNotName( src )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.numberIs( src ) || _.longIs( src ) || _.object.isBasic( src ) );

  if( _.object.isBasic( src ) )
  {
    _.map.assertHasOnly( src, { r : null, g : null, b : null, a : null } );
    let result = [];
    result[ 0 ] = src.r === undefined ? 1 : src.r;
    result[ 1 ] = src.g === undefined ? 1 : src.g;
    result[ 2 ] = src.b === undefined ? 1 : src.b;
    result[ 3 ] = src.a === undefined ? 1 : src.a;
    return result;
  }

  if( _.numberIs( src ) )
  {
    let result = this._rgbByBitmask( src );
    return _.longGrow_( result, result, [ 0, 3 ], 1 );
  }

  let result = [];

  /* */

  for( let r = 0 ; r < src.length ; r++ )
  result[ r ] = Number( src[ r ] );

  if( result.length < 4 )
  result[ 3 ] = 1;

  /* */

  return result;
}

//


  _.color._colorNameNearest = function _colorNameNearest( color, map )
{
  let self = this;

  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 1 )
  map = _.color.ColorMap;

  _.assert( _.object.isBasic( map ) );

  if( _.strIs( color ) )
  {
    _.assertWithoutBreakpoint( map[ color ], 'Unknown color', _.strQuote( color ) );

    if( _.objectLike( map[ color ] ) )
    {
      _.assert( map[ color ].name );
      return self._colorNameNearest( map[ color ].name, map );
    }

    return color;
  }

  color = this._rgbaFromNotName( color );

  _.assert( color.length === 4 );

  for( let r = 0 ; r < 4 ; r++ )
  {
    color[ r ] = Number( color[ r ] );
    if( color[ r ] < 0 )
    color[ r ] = 0;
    else if( color[ r ] > 1 )
    color[ r ] = 1;
  }

  // if( color[ 3 ] === undefined )
  // color[ 3 ] = 1;

  /* */

  let names = Object.keys( map );
  let nearest = names[ 0 ];
  let max = this._colorDistance( map[ names[ 0 ] ], color );

  if( max === 0 )
  return nearest;

  for( let i = 1; i <= names.length - 1; i++ )
  {
    let d = this._colorDistance( map[ names[ i ] ], color );
    if( d < max )
    {
      max = d;
      nearest = names[ i ];
    }

    if( d === 0 )
    return names[ i ];
  }

  return nearest;
}

//


  _.color.colorNameNearest = function colorNameNearest( color )
{
  let self = this;

  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.strIs( color ) )
  {
    let color2 = _.color.hexToColor( color );
    if( color2 )
    color = color2;
  }

  try
  {
    return self._colorNameNearest( color );
  }
  catch( err )
  {
    return;
  }

}

//


  _.color._fromTable = function _fromTable( o )
{
  let result = o.colorMap[ o.src ];

  _.routine.assertOptions( _fromTable, o );

  if( !result )
  result = o.def;

  if( result )
  result = result.slice();

  return result;
}
_.color._fromTable.defaults =
{ "src" : null, "def" : null, "colorMap" : null }

//


  _.color.fromTable = function fromTable( o )
{
  // let o = _.routineOptionsFromThis( fromTable, this, Self );

  if( !_.mapIs( o ) )
  o =
  {
    src : arguments[ 0 ],
    def : ( arguments.length > 1 ? arguments[ 1 ] : null ),
    colorMap : ( arguments.length > 2 ? arguments[ 2 ] : null ),
  }

  let result;
  if( !o.colorMap )
  o.colorMap = this.ColorMap;

  _.routine.options_( fromTable, o );
  _.assert( arguments.length <= 3 );
  _.assert( _.strIs( o.src ) );

  o.src = o.src.toLowerCase();
  o.src = o.src.trim();

  return this._fromTable( o );
  // return this._fromTable( o.src, o.def, o.colorMap );
}
_.color.fromTable.defaults =
{ "src" : null, "def" : null, "colorMap" : null }

//


  _.color.hexToColor = function hexToColor( hex )
{
  return _.color.rgba.fromHexStr( hex );
}

//



  _.color.ColorMap = {
  "invisible" : [ 0, 0, 0, 0 ],
  "transparent" : [ 1, 1, 1, 0.5 ],
  "cyan" : [ 0, 1, 1 ],
  "magenta" : [ 1, 0, 1 ],
  "maroon" : [ 0.5, 0, 0 ],
  "dark green" : [ 0, 0.5, 0 ],
  "navy" : [ 0, 0, 0.5 ],
  "olive" : [ 0.5, 0.5, 0 ],
  "teal" : [ 0, 0.5, 0.5 ],
  "bright green" : [ 0.5, 1, 0 ],
  "spring green" : [ 0, 1, 0.5 ],
  "pink" : [ 1, 0, 0.5 ],
  "dark orange" : [ 1, 0.5, 0 ],
  "azure" : [ 0, 0.5, 1 ],
  "dark blue" : [ 0, 0, 0.63 ],
  "brown" : [ 0.65, 0.16, 0.16 ],
  "white" : [ 1, 1, 1 ],
  "smoke" : [ 0.9, 0.9, 0.9 ],
  "silver" : [ 0.75, 0.75, 0.75 ],
  "gray" : [ 0.5, 0.5, 0.5 ],
  "dim" : [ 0.35, 0.35, 0.35 ],
  "black" : [ 0, 0, 0 ],
  "yellow" : [ 1, 1, 0 ],
  "purple" : [ 0.5, 0, 0.5 ],
  "orange" : [ 1, 0.65, 0 ],
  "bright blue" : [ 0.68, 0.85, 0.9 ],
  "red" : [ 1, 0, 0 ],
  "buff" : [ 0.94, 0.86, 0.51 ],
  "green" : [ 0, 1, 0 ],
  "purplish pink" : [ 0.96, 0.46, 0.56 ],
  "blue" : [ 0, 0, 1 ],
  "yellowish pink" : [ 1, 0.48, 0.36 ],
  "violet" : [ 0.5, 0, 1 ],
  "orange yellow" : [ 1, 0.56, 0 ],
  "purplish red" : [ 0.7, 0.16, 0.32 ],
  "greenish yellow" : [ 0.96, 0.78, 0 ],
  "reddish brown" : [ 0.5, 0.1, 0.05 ],
  "yellow green" : [ 0.57, 0.6, 0 ],
  "yellowish brown" : [ 0.34, 0.2, 0.08 ],
  "reddish orange" : [ 0.95, 0.23, 0.07 ],
  "olive green" : [ 0.14, 0.17, 0.09 ],
  "aquamarine" : [ 0.5, 1, 0.83 ],
  "light blue" : [ 0.94, 1, 1 ],
  "beige" : [ 0.96, 0.96, 0.86 ],
  "bisque" : [ 1, 0.89, 0.77 ],
  "chocolate" : [ 0.82, 0.41, 0.12 ],
  "coral" : [ 1, 0.5, 0.3 ],
  "cornsilk" : [ 1, 0.97, 0.86 ],
  "crimson" : [ 0.86, 0.08, 0.23 ],
  "gainsboro" : [ 0.86, 0.86, 0.86 ],
  "gold" : [ 1, 0.84, 0 ],
  "honeydew" : [ 0.94, 1, 0.94 ],
  "indigo" : [ 0.29, 0, 0.51 ],
  "ivory" : [ 1, 1, 0.94 ],
  "khaki" : [ 0.94, 0.9, 0.55 ],
  "lavender" : [ 0.9, 0.9, 0.98 ],
  "linen" : [ 0.98, 0.94, 0.9 ],
  "moccasin" : [ 1, 0.89, 0.71 ],
  "orchid" : [ 0.85, 0.44, 0.84 ],
  "peru" : [ 0.8, 0.52, 0.25 ],
  "plum" : [ 0.87, 0.63, 0.87 ],
  "salmon" : [ 0.98, 0.5, 0.45 ],
  "sienna" : [ 0.63, 0.32, 0.17 ],
  "snow" : [ 1, 0.98, 0.98 ],
  "tan" : [ 0.82, 0.7, 0.55 ],
  "thistle" : [ 0.85, 0.75, 0.85 ],
  "tomato" : [ 1, 0.39, 0.28 ],
  "turquoise" : [ 0.25, 0.88, 0.81 ],
  "wheat" : [ 0.96, 0.87, 0.7 ],
  "moderate pink" : [ 0.93, 0.56, 0.53 ],
  "dark pink" : [ 0.78, 0.41, 0.39 ],
  "pale pink" : [ 1, 0.8, 0.73 ],
  "grayish pink" : [ 0.81, 0.61, 0.56 ],
  "pinkish white " : [ 0.98, 0.86, 0.78 ],
  "pinkish gray " : [ 0.78, 0.65, 0.59 ],
  "vivid red" : [ 0.76, 0, 0.13 ],
  "strong red" : [ 0.75, 0.13, 0.2 ],
  "deep red" : [ 0.48, 0, 0.11 ],
  "very deep red" : [ 0.31, 0, 0.08 ],
  "moderate red" : [ 0.67, 0.2, 0.23 ],
  "dark red" : [ 0.41, 0.11, 0.14 ],
  "very dark red" : [ 0.2, 0.04, 0.09 ],
  "light grayish red" : [ 0.69, 0.45, 0.4 ],
  "grayish red" : [ 0.55, 0.28, 0.26 ],
  "dark grayish red" : [ 0.28, 0.16, 0.16 ],
  "blackish red" : [ 0.12, 0.05, 0.07 ],
  "reddish gray" : [ 0.55, 0.42, 0.38 ],
  "dark reddish gray" : [ 0.32, 0.24, 0.21 ],
  "reddish black" : [ 0.12, 0.07, 0.07 ],
  "vivid yellowish pink" : [ 1, 0.52, 0.36 ],
  "deep yellowish pink" : [ 0.96, 0.29, 0.27 ],
  "light yellowish pink" : [ 1, 0.7, 0.55 ],
  "moderate yellowish pink" : [ 0.93, 0.58, 0.45 ],
  "dark yellowish pink" : [ 0.8, 0.42, 0.36 ],
  "pale yellowish pink" : [ 1, 0.78, 0.66 ],
  "grayish yellowish pink" : [ 0.83, 0.61, 0.52 ],
  "brownish pink" : [ 0.8, 0.6, 0.48 ],
  "strong reddish orange" : [ 1, 0.73, 0.38 ],
  "deep reddish orange" : [ 0.66, 0.11, 0.07 ],
  "moderate reddish orange" : [ 0.83, 0.33, 0.22 ],
  "dark reddish orange" : [ 0.61, 0.18, 0.12 ],
  "grayish reddish orange" : [ 0.72, 0.36, 0.26 ],
  "deep reddish brown" : [ 0.29, 0, 0.02 ],
  "light reddish brown" : [ 0.67, 0.4, 0.32 ],
  "moderate reddish brown" : [ 0.44, 0.18, 0.15 ],
  "dark reddish brown" : [ 0.2, 0.06, 0.07 ],
  "light grayish reddish brown" : [ 0.59, 0.42, 0.34 ],
  "grayish reddish brown" : [ 0.37, 0.22, 0.19 ],
  "dark grayish reddish brown" : [ 0.22, 0.12, 0.11 ],
  "vivid orange" : [ 1, 0.41, 0 ],
  "brilliant orange" : [ 1, 0.72, 0.25 ],
  "strong orange" : [ 1, 0.44, 0.1 ],
  "deep orange" : [ 0.76, 0.3, 0.04 ],
  "light orange" : [ 1, 0.63, 0.38 ],
  "moderate orange" : [ 0.91, 0.47, 0.24 ],
  "brownish orange" : [ 0.69, 0.32, 0.14 ],
  "strong brown" : [ 0.46, 0.2, 0.07 ],
  "deep brown" : [ 0.3, 0.13, 0.05 ],
  "light brown" : [ 0.66, 0.4, 0.25 ],
  "moderate brown" : [ 0.4, 0.22, 0.14 ],
  "dark brown" : [ 0.21, 0.09, 0.05 ],
  "light grayish brown" : [ 0.58, 0.42, 0.33 ],
  "grayish brown" : [ 0.35, 0.24, 0.19 ],
  "dark grayish brown" : [ 0.2, 0.13, 0.1 ],
  "light brownish gray" : [ 0.55, 0.43, 0.36 ],
  "brownish gray" : [ 0.31, 0.24, 0.2 ],
  "brownish black" : [ 0.08, 0.06, 0.04 ],
  "brilliant orange yellow" : [ 1, 0.69, 0.18 ],
  "strong orange yellow" : [ 1, 0.56, 0.05 ],
  "deep orange yellow" : [ 0.84, 0.43, 0 ],
  "light orange yellow" : [ 1, 0.73, 0.38 ],
  "moderate orange yellow" : [ 0.97, 0.58, 0.24 ],
  "dark orange yellow" : [ 0.76, 0.46, 0.16 ],
  "pale orange yellow" : [ 1, 0.79, 0.53 ],
  "strong yellowish brown" : [ 0.58, 0.31, 0.05 ],
  "light yellowish brown" : [ 0.73, 0.55, 0.33 ],
  "moderate yellowish brown" : [ 0.49, 0.32, 0.18 ],
  "dark yellowish brown" : [ 0.25, 0.15, 0.07 ],
  "light grayish yellowish brown" : [ 0.71, 0.53, 0.39 ],
  "grayish yellowish brown" : [ 0.47, 0.35, 0.25 ],
  "dark grayish yellowish brown" : [ 0.24, 0.17, 0.12 ],
  "vivid yellow" : [ 1, 0.7, 0 ],
  "brilliant yellow" : [ 1, 0.81, 0.25 ],
  "strong yellow" : [ 0.9, 0.62, 0.12 ],
  "deep yellow" : [ 0.71, 0.47, 0 ],
  "light yellow" : [ 1, 0.83, 0.37 ],
  "moderate yellow" : [ 0.84, 0.62, 0.25 ],
  "dark yellow" : [ 0.69, 0.49, 0.17 ],
  "pale yellow" : [ 1, 0.86, 0.55 ],
  "grayish yellow" : [ 0.81, 0.64, 0.38 ],
  "dark grayish yellow" : [ 0.64, 0.49, 0.27 ],
  "yellowish white" : [ 1, 0.89, 0.72 ],
  "yellowish gray" : [ 0.79, 0.66, 0.52 ],
  "light olive brown" : [ 0.58, 0.36, 0.04 ],
  "moderate olive brown" : [ 0.39, 0.25, 0.06 ],
  "dark olive brown" : [ 0.19, 0.13, 0.07 ],
  "vivid greenish yellow" : [ 0.96, 0.78, 0 ],
  "brilliant greenish yellow" : [ 1, 0.86, 0.2 ],
  "strong greenish yellow" : [ 0.8, 0.66, 0.09 ],
  "deep greenish yellow" : [ 0.62, 0.51, 0 ],
  "light greenish yellow" : [ 1, 0.87, 0.35 ],
  "moderate greenish yellow" : [ 0.77, 0.64, 0.24 ],
  "dark greenish yellow" : [ 0.61, 0.51, 0.15 ],
  "pale greenish yellow" : [ 1, 0.87, 0.52 ],
  "grayish greenish yellow" : [ 0.77, 0.65, 0.37 ],
  "light olive" : [ 0.52, 0.42, 0.13 ],
  "moderate olive" : [ 0.37, 0.29, 0.06 ],
  "dark olive" : [ 0.21, 0.17, 0.07 ],
  "light grayish olive" : [ 0.55, 0.45, 0.29 ],
  "grayish olive" : [ 0.32, 0.27, 0.17 ],
  "dark grayish olive" : [ 0.17, 0.15, 0.09 ],
  "light olive gray" : [ 0.53, 0.45, 0.35 ],
  "olive gray" : [ 0.3, 0.26, 0.2 ],
  "olive black" : [ 0.07, 0.1, 0.06 ],
  "brilliant yellow green" : [ 0.81, 0.82, 0.23 ],
  "strong yellow green" : [ 0.5, 0.56, 0.09 ],
  "deep yellow green" : [ 0.26, 0.37, 0.09 ],
  "light yellow green" : [ 0.86, 0.83, 0.42 ],
  "moderate yellow green" : [ 0.55, 0.54, 0.25 ],
  "pale yellow green" : [ 0.94, 0.84, 0.6 ],
  "grayish yellow green" : [ 0.56, 0.52, 0.36 ],
  "strong olive green" : [ 0.04, 0.27, 0 ],
  "deep olive green" : [ 0.08, 0.14, 0 ],
  "moderate olive green" : [ 0.26, 0.29, 0.11 ],
  "grayish olive green" : [ 0.28, 0.27, 0.18 ],
  "dark grayish olive green" : [ 0.15, 0.15, 0.1 ],
  "vivid yellowish green" : [ 0.22, 0.6, 0.19 ],
  "brilliant yellowish green" : [ 0.55, 0.8, 0.37 ],
  "strong yellowish green" : [ 0.28, 0.52, 0.19 ],
  "deep yellowish green" : [ 0, 0.33, 0.12 ],
  "very deep yellowish green" : [ 0, 0.16, 0 ],
  "very light yellowish green" : [ 0.78, 0.87, 0.56 ],
  "light yellowish green" : [ 0, 0.48, 0.65 ],
  "moderate yellowish green" : [ 0.4, 0.5, 0.29 ],
  "dark yellowish green" : [ 0.19, 0.29, 0.15 ],
  "very dark yellowish green" : [ 0.07, 0.15, 0.07 ],
  "vivid green" : [ 0, 0.49, 0.2 ],
  "brilliant green" : [ 0.28, 0.65, 0.42 ],
  "strong green" : [ 0, 0.42, 0.24 ],
  "deep green" : [ 0, 0.27, 0.14 ],
  "very light green" : [ 0.6, 0.78, 0.58 ],
  "light green" : [ 0.44, 0.61, 0.43 ],
  "moderate green" : [ 0.22, 0.4, 0.27 ],
  "very dark green" : [ 0.09, 0.15, 0.11 ],
  "very pale green" : [ 0.85, 0.87, 0.73 ],
  "pale green" : [ 0.55, 0.57, 0.48 ],
  "grayish green" : [ 0.34, 0.37, 0.31 ],
  "dark grayish green" : [ 0.19, 0.22, 0.19 ],
  "blackish green" : [ 0.08, 0.09, 0.07 ],
  "greenish white" : [ 0.96, 0.9, 0.8 ],
  "light greenish gray" : [ 0.73, 0.69, 0.59 ],
  "greenish gray" : [ 0.48, 0.46, 0.4 ],
  "dark greenish gray" : [ 0.27, 0.26, 0.23 ],
  "greenish black" : [ 0.09, 0.08, 0.07 ],
  "vivid bluish green" : [ 0, 0.51, 0.43 ],
  "brilliant bluish green" : [ 0, 0.61, 0.46 ],
  "strong bluish green" : [ 0, 0.43, 0.36 ],
  "deep bluish green" : [ 0, 0.22, 0.17 ],
  "very light bluish green" : [ 0.63, 0.84, 0.71 ],
  "light bluish green" : [ 0.4, 0.62, 0.52 ],
  "moderate bluish green" : [ 0.18, 0.4, 0.34 ],
  "dark bluish green" : [ 0, 0.23, 0.2 ],
  "very dark bluish green" : [ 0, 0.11, 0.09 ],
  "vivid greenish blue" : [ 0, 0.48, 0.65 ],
  "brilliant greenish blue" : [ 0.16, 0.55, 0.61 ],
  "strong greenish blue" : [ 0, 0.4, 0.49 ],
  "deep greenish blue" : [ 0, 0.48, 0.65 ],
  "very light greenish blue" : [ 0.64, 0.78, 0.75 ],
  "light greenish blue" : [ 0.39, 0.6, 0.62 ],
  "moderate greenish blue" : [ 0.19, 0.38, 0.42 ],
  "dark greenish blue" : [ 0, 0.22, 0.25 ],
  "very dark greenish blue" : [ 0.01, 0.13, 0.15 ],
  "vivid blue,ultramarine" : [ 0, 0.49, 0.68 ],
  "brilliant blue,celestial blue" : [ 0.26, 0.52, 0.71 ],
  "strong blue,bright blue" : [ 0, 0.33, 0.54 ],
  "deep blue,royal blue" : [ 0, 0.18, 0.33 ],
  "very light blue" : [ 0.65, 0.74, 0.84 ],
  "sky blue" : [ 0.42, 0.57, 0.69 ],
  "moderate blue,cerulean blue" : [ 0.22, 0.34, 0.47 ],
  "dark blue,navy blue" : [ 0, 0.13, 0.22 ],
  "very pale blue,cloud blue" : [ 0.76, 0.79, 0.79 ],
  "pale blue,alice blue" : [ 0.57, 0.57, 0.57 ],
  "grayish blue,slate blue" : [ 0.29, 0.33, 0.36 ],
  "dark grayish blue" : [ 0.17, 0.2, 0.22 ],
  "blackish blue" : [ 0.09, 0.1, 0.12 ],
  "bluish white" : [ 0.98, 0.87, 0.81 ],
  "light bluish gray" : [ 0.75, 0.68, 0.63 ],
  "bluish gray" : [ 0.49, 0.45, 0.43 ],
  "dark bluish gray" : [ 0.27, 0.27, 0.27 ],
  "bluish black" : [ 0.08, 0.09, 0.1 ],
  "vivid purplish blue" : [ 0.13, 0.08, 0.37 ],
  "brilliant purplish blue" : [ 0.38, 0.39, 0.61 ],
  "strong purplish blue" : [ 0.28, 0.26, 0.54 ],
  "deep purplish blue" : [ 0.1, 0.08, 0.25 ],
  "very light purplish blue" : [ 0.73, 0.67, 0.78 ],
  "light purplish blue" : [ 0.51, 0.49, 0.64 ],
  "moderate purplish blue" : [ 0.26, 0.24, 0.39 ],
  "dark purplish blue" : [ 0.1, 0.09, 0.16 ],
  "very pale purplish blue" : [ 0.8, 0.73, 0.77 ],
  "pale purplish blue" : [ 0.54, 0.5, 0.56 ],
  "grayish purplish blue" : [ 0.25, 0.24, 0.32 ],
  "vivid violet" : [ 0.53, 0.29, 0.68 ],
  "brilliant violet" : [ 0.46, 0.36, 0.6 ],
  "strong violet" : [ 0.33, 0.22, 0.48 ],
  "deep violet" : [ 0.14, 0.04, 0.21 ],
  "very light violet" : [ 0.93, 0.75, 0.95 ],
  "light violet" : [ 0.53, 0.42, 0.6 ],
  "moderate violet" : [ 0.33, 0.22, 0.39 ],
  "dark violet" : [ 0.13, 0.07, 0.17 ],
  "very pale violet" : [ 0.85, 0.69, 0.75 ],
  "pale violet" : [ 0.58, 0.48, 0.55 ],
  "grayish violet" : [ 0.27, 0.22, 0.29 ],
  "vivid purple" : [ 0.58, 0.2, 0.57 ],
  "brilliant purple" : [ 0.87, 0.5, 0.8 ],
  "strong purple" : [ 0.5, 0.24, 0.46 ],
  "deep purple" : [ 0.33, 0.1, 0.31 ],
  "very deep purple" : [ 0.2, 0.04, 0.21 ],
  "very light purple" : [ 0.89, 0.66, 0.75 ],
  "light purple" : [ 0.73, 0.5, 0.64 ],
  "moderate purple" : [ 0.5, 0.28, 0.44 ],
  "dark purple" : [ 0.28, 0.16, 0.25 ],
  "very dark purple" : [ 0.14, 0.05, 0.13 ],
  "very pale purple" : [ 0.9, 0.73, 0.76 ],
  "pale purple" : [ 0.68, 0.52, 0.55 ],
  "grayish purple" : [ 0.45, 0.32, 0.36 ],
  "dark grayish purple" : [ 0.27, 0.18, 0.21 ],
  "blackish purple" : [ 0.11, 0.06, 0.09 ],
  "purplish white" : [ 0.98, 0.86, 0.78 ],
  "light purplish gray" : [ 0.78, 0.66, 0.62 ],
  "purplish gray" : [ 0.53, 0.44, 0.42 ],
  "dark purplish gray" : [ 0.34, 0.25, 0.26 ],
  "purplish black" : [ 0.11, 0.07, 0.09 ],
  "vivid reddish purple" : [ 0.49, 0, 0.35 ],
  "strong reddish purple" : [ 0.6, 0.21, 0.42 ],
  "deep reddish purple" : [ 0.39, 0.07, 0.29 ],
  "very deep reddish purple" : [ 0.28, 0.03, 0.21 ],
  "light reddish purple" : [ 0.73, 0.42, 0.54 ],
  "moderate reddish purple" : [ 0.55, 0.27, 0.4 ],
  "dark reddish purple" : [ 0.31, 0.15, 0.23 ],
  "very dark reddish purple" : [ 0.15, 0.04, 0.12 ],
  "pale reddish purple" : [ 0.67, 0.46, 0.5 ],
  "grayish reddish purple" : [ 0.49, 0.3, 0.36 ],
  "brilliant purplish pink" : [ 1, 0.59, 0.73 ],
  "deep purplish pink" : [ 0.92, 0.32, 0.52 ],
  "light purplish pink" : [ 1, 0.66, 0.69 ],
  "moderate purplish pink" : [ 0.89, 0.5, 0.56 ],
  "dark purplish pink" : [ 0.78, 0.4, 0.45 ],
  "pale purplish pink" : [ 0.99, 0.74, 0.73 ],
  "grayish purplish pink" : [ 0.8, 0.57, 0.58 ],
  "vivid purplish red" : [ 0.84, 0.15, 0.36 ],
  "deep purplish red" : [ 0.44, 0, 0.21 ],
  "very deep purplish red" : [ 0.28, 0, 0.15 ],
  "moderate purplish red" : [ 0.65, 0.22, 0.33 ],
  "dark purplish red" : [ 0.36, 0.12, 0.19 ],
  "very dark purplish red" : [ 0.16, 0.03, 0.1 ],
  "light grayish purplish red" : [ 0.7, 0.44, 0.44 ],
  "grayish purplish red" : [ 0.55, 0.28, 0.32 ],
  "light gray" : [ 0.76, 0.66, 0.58 ],
  "medium gray" : [ 0.51, 0.44, 0.4 ],
  "dark gray" : [ 0.29, 0.26, 0.24 ],
  "bright black" : [ 0.5, 0.5, 0.5 ],
  "dark magenta" : [ 0.5, 0, 0.5 ],
  "dark cyan" : [ 0, 0.5, 0.5 ],
  "dark white" : [ 0.75, 0.75, 0.75 ],
  "bright white" : [ 1, 1, 1 ],
  "bright red" : [ 1, 0, 0 ],
  "bright yellow" : [ 1, 1, 0 ],
  "bright cyan" : [ 0, 1, 1 ],
  "bright magenta" : [ 1, 0, 1 ],
  "dark black" : [ 0, 0, 0 ]
};

//



  _.Logger.TransformCssStylingToDirectives = function TransformCssStylingToDirectives( input )
{
  //https://developers.google.com/web/tools/chrome-devtools/console/console-write#styling_console_output_with_css

  if( !_.strHas( input[ 0 ], '%c' ) )
  return input;

  let result = [ '' ];

  let splitted = _.strSplitFast
  ({
    src : input[ 0 ],
    delimeter : '%c',
    preservingEmpty : 0,
    preservingDelimeters : 0
  });

  splitted.forEach( ( chunk, i ) =>
  {
    let styles = input[ i + 1 ];

    if( styles )
    {
      let splits = _.strSplitFast
      ({
        src : styles,
        delimeter : [ ';', ':' ],
        preservingEmpty : 0,
        preservingDelimeters : 0
      });

      if( splits.length > 1 )
      for( let i = 0; i < splits.length; i += 2 )
      {
        let key = _.strStrip( splits[ i ] );
        let value = _.strStrip( splits[ i + 1 ] );

        if( value === 'none' )
        continue;

        if( key === 'color' )
        {
          value = _.color.rgbaHtmlFrom( value );
          value = _.color.colorNameNearest( value );
          chunk = _.color.strFg( chunk, value );
        }
        else if( key === 'background' )
        {
          value = _.color.rgbaHtmlFrom( value );
          value = _.color.colorNameNearest( value )
          chunk = _.color.strBg( chunk, value );
        }
        else if( key === 'text-decoration' )
        {
          chunk = `${value} : true${chunk}${value} : false`
        }
      }
    }

    result[ 0 ] += chunk;
  })

  if( !result[ 0 ] )
  return input;

  result.push( ... input.slice( splitted.length + 1 ) );

  return result;
}

//







  let StarterExtension =
  {

    debuggerEnabled : _starter_.debug,

  }

  Object.assign( _starter_, StarterExtension );

;

/* */  /* end of extract */ })();


/* */  /* begin of globing */ ( function _proceduring_() {



  'use strict';

  const _global = _global_;
  let _starter_ = _global._starter_ = _global._starter_ || Object.create( null );
  let _ = _starter_;

  //

  function TokensSyntax()
  {
    let result =
    {
      idToValue : null,
      idToName : [],
      nameToId : {},
      alternatives : {},
    }
    Object.setPrototypeOf( result, TokensSyntax );
    return result;
  }

  //

;



  _.array.likeResizable = function likeResizable( src )
{
  return _.array.is( src );
}

//


  _.arrayLikeResizable = _.array.likeResizable.bind( _.array )
  /* _.arrayLikeResizable = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.map.extend = function extend( dstMap, srcMap )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  if( arguments.length === 2 )
  {
    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    return Object.assign( dstMap, srcMap );
  }

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    let srcMap = arguments[ a ];

    _.assert( !_.primitive.is( srcMap ), 'Expects non-primitive' );

    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    Object.assign( dstMap, srcMap );
    else
    this._extendWithProps( dstMap, srcMap );

  }

  return dstMap;
}

//


  _.map.supplement = function supplement( dstMap, srcMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    srcMap = arguments[ a ];
    this._supplementWithProps( dstMap, srcMap );
  }

  return dstMap
}

//


  _.mapExtend = _.map.extend.bind( _.map )
  _.mapSupplement = _.map.supplement.bind( _.map )
  /* _.mapExtend = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */
  /* _.mapSupplement = function () { [native code] }

//

 */ /* Dmytro : binded, source code is not available */

  _.vectorize = ( function() {

  const _vectorize_head = function vectorize_head( routine, args )
  {
    let o = args[ 0 ];

    if( args.length === 2 )
    o = { routine : args[ 0 ], select : args[ 1 ] }
    else if( _.routine.is( o ) || _.strIs( o ) )
    o = { routine : args[ 0 ] }

    _.routine.options( routine, o );
    _.assert( arguments.length === 2, 'Expects exactly two arguments' );
    _.assert( _.routine.is( o.routine ) || _.strIs( o.routine ) || _.strsAreAll( o.routine ), () => 'Expects routine {-o.routine-}, but got ' + o.routine );
    _.assert( args.length === 1 || args.length === 2 );
    _.assert( o.select >= 1 || _.strIs( o.select ) || _.argumentsArray.like( o.select ), () => 'Expects {-o.select-} as number >= 1, string or array, but got ' + o.select );

    return o;
  }

  const _vectorize_body = function vectorize_body( o )
  {

    _.routine.assertOptions( vectorize_body, arguments );

    if( _.argumentsArray.like( o.routine ) && o.routine.length === 1 )
    o.routine = o.routine[ 0 ];

    let routine = o.routine;
    let propertyCondition = o.propertyCondition;
    let bypassingFilteredOut = o.bypassingFilteredOut;
    let bypassingEmpty = o.bypassingEmpty;
    let vectorizingArray = o.vectorizingArray;
    let vectorizingMapVals = o.vectorizingMapVals;
    let vectorizingMapKeys = o.vectorizingMapKeys;
    let vectorizingContainerAdapter = o.vectorizingContainerAdapter;
    let unwrapingContainerAdapter = o.unwrapingContainerAdapter;
    let head = null;
    let select = o.select === null ? 1 : o.select;
    let selectAll = o.select === Infinity;
    let multiply = select > 1 ? multiplyReally : multiplyNo;

    routine = routineNormalize( routine );

    _.assert( _.routine.is( routine ), () => 'Expects routine {-o.routine-}, but got ' + routine );

    /* */

    let resultRoutine = vectorizeArray;

    if( _.number.is( select ) )
    {

      if( !vectorizingArray && !vectorizingMapVals && !vectorizingMapKeys )
      resultRoutine = routine;
      else if( propertyCondition )
      resultRoutine = vectorizeWithFilters;
      else if( vectorizingMapKeys )
      {

        if( vectorizingMapVals )
        {
          _.assert( select === 1, 'Only single argument is allowed if {-o.vectorizingMapKeys-} and {-o.vectorizingMapVals-} are enabled.' );
          resultRoutine = vectorizeMapWithKeysOrArray;
        }
        else
        {
          resultRoutine = vectorizeKeysOrArray;
        }

      }
      else if( !vectorizingArray || vectorizingMapVals )
      resultRoutine = vectorizeMapOrArray;
      else if( multiply === multiplyNo )
      resultRoutine = vectorizeArray;
      else
      resultRoutine = vectorizeArrayMultiplying;

    }
    else
    {
      _.assert( multiply === multiplyNo );
      if( routine.head )
      {
        head = routine.head;
        routine = routine.body;
      }
      if( propertyCondition )
      {
        _.assert( 0, 'not implemented' );
      }
      else if( vectorizingArray || !vectorizingMapVals )
      {
        if( _.strIs( select ) )
        resultRoutine = vectorizeForOptionsMap;
        else
        resultRoutine = vectorizeForOptionsMapForKeys;
      }
      else _.assert( 0, 'not implemented' );
    }

    /* */

    resultRoutine.vectorized = o;

    /* */

    _.routine.extend( resultRoutine, routine );
    return resultRoutine;

    /*
      vectorizeWithFilters : multiply + array/map vectorizing + filter
      vectorizeArray : array vectorizing
      vectorizeArrayMultiplying :  multiply + array vectorizing
      vectorizeMapOrArray :  multiply +  array/map vectorizing
    */

    /* - */

    function routineNormalize( routine )
    {

      if( _.strIs( routine ) )
      {
        return function methodCall()
        {
          _.assert( _.routine.is( this[ routine ] ), () => 'Context ' + _.entity.exportStringDiagnosticShallow( this ) + ' does not have routine ' + routine );
          return this[ routine ].apply( this, arguments );
        }
      }
      else if( _.argumentsArray.like( routine ) )
      {
        _.assert( routine.length === 2 );
        return function methodCall()
        {
          let c = this[ routine[ 0 ] ];
          _.assert( _.routine.is( c[ routine[ 1 ] ] ), () => 'Context ' + _.entity.exportStringDiagnosticShallow( c ) + ' does not have routine ' + routine );
          return c[ routine[ 1 ] ].apply( c, arguments );
        }
      }

      return routine;
    }

    /* - */

    function multiplyNo( args )
    {
      return args;
    }

    /* - */

    function multiplyReally( args )
    {
      let length, keys;

      args = [ ... args ];

      if( selectAll )
      select = args.length;

      _.assert( args.length === select, () => 'Expects ' + select + ' arguments, but got ' + args.length );

      for( let d = 0 ; d < select ; d++ )
      {
        if( vectorizingArray && _.argumentsArray.like( args[ d ] ) )
        {
          length = args[ d ].length;
          break;
        }
        else if( vectorizingArray && _.set.like( args[ d ] ) )
        {
          length = args[ d ].size;
          break;
        }
        else if( vectorizingContainerAdapter && _.containerAdapter.is( args[ d ] ) )
        {
          length = args[ d ].length;
          break;
        }
        else if( vectorizingMapVals && _.aux.is( args[ d ] ) )
        {
          keys = _.props.onlyOwnKeys( args[ d ] );
          break;
        }
      }

      if( length !== undefined )
      {
        for( let d = 0 ; d < select ; d++ )
        {
          if( vectorizingMapVals )
          _.assert( !_.mapIs( args[ d ] ), () => 'Arguments should have only arrays or only maps, but not both. Incorrect argument : ' + args[ d ] );
          else if( vectorizingMapKeys && _.mapIs( args[ d ] ) )
          continue;
          args[ d ] = _.multiple( args[ d ], length );
        }

      }
      else if( keys !== undefined )
      {
        for( let d = 0 ; d < select ; d++ )
        if( _.mapIs( args[ d ] ) )
        {
          _.assert( _.arraySet.identical( _.props.onlyOwnKeys( args[ d ] ), keys ), () => 'Maps should have same keys : ' + keys );
        }
        else
        {
          if( vectorizingArray )
          _.assert( !_.argumentsArray.like( args[ d ] ), () => 'Arguments should have only arrays or only maps, but not both. Incorrect argument : ' + args[ d ] );
          let arg = Object.create( null );
          _.mapSetWithKeys( arg, keys, args[ d ] );
          args[ d ] = arg;
        }
      }

      return args;
    }

    /* - */

    function vectorizeArray()
    {
      if( bypassingEmpty && !arguments.length )
      return [];

      let args = arguments;
      let src = args[ 0 ];

      if( _.arrayIs( src ) ) /* Dmytro : arrayLike returns true for instances of containerAdapter */
      {
        let args2 = [ ... args ];
        let result = _.long.makeEmpty( src );
        let append = _.long.appender( result );
        let each = _.long.eacher( src );
        each( ( e ) =>
        {
          args2[ 0 ] = e;
          append( routine.apply( this, args2 ) );
        });
        return result;
      }
      else if( _.set.like( src ) ) /* qqq : cover please */
      {
        let args2 = [ ... args ];
        let result = new Set;
        for( let e of src )
        {
          args2[ 0 ] = e;
          result.add( routine.apply( this, args2 ) );
        }
        return result;
      }
      else if( vectorizingContainerAdapter && _.containerAdapter.is( src ) )
      {
        let args2 = [ ... args ];
        let result = src.filter( ( e ) =>
        {
          args2[ 0 ] = e;
          return routine.apply( this, args2 );
        });
        if( unwrapingContainerAdapter )
        return result.original;
        else
        return result;
      }

      return routine.apply( this, args );
    }

    /* - */

    function vectorizeArrayMultiplying()
    {
      if( bypassingEmpty && !arguments.length )
      return [];

      let args = multiply( arguments );
      let src = args[ 0 ];

      if( _.argumentsArray.like( src ) )
      {

        let args2 = [ ... args ];
        let result = _.long.makeEmpty( src );
        let append = _.long.appender( result );
        let each = _.long.eacher( src );
        each( ( e, r ) =>
        {
          for( let m = 0 ; m < select ; m++ )
          args2[ m ] = args[ m ][ r ]; /* zzz qqq : use _.long.get */
          append( routine.apply( this, args2 ) );
        });
        return result;
      }

      return routine.apply( this, args );
    }

    /* - */

    function vectorizeForOptionsMap( srcMap )
    {
      if( bypassingEmpty && !arguments.length )
      return [];

      let src = srcMap[ select ];
      let args = [ ... arguments ];
      _.assert( arguments.length === 1, 'Expects single argument' );

      if( _.argumentsArray.like( src ) )
      {
        if( head )
        {
          args = head( routine, args );
          _.assert( _.arrayLikeResizable( args ) );
        }

        let result = _.long.makeEmpty( src );
        let append = _.long.appender( result );
        let each = _.long.eacher( src );
        each( ( e ) =>
        {
          args[ 0 ] = _.props.extend( null, srcMap );
          args[ 0 ][ select ] = e;
          append( routine.apply( this, args ) );
        });
        return result;

      }
      else if( _.set.like( src ) ) /* qqq : cover */
      {
        if( head )
        {
          args = head( routine, args );
          _.assert( _.arrayLikeResizable( args ) );
        }
        let result = new Set;
        for( let e of src )
        {
          args[ 0 ] = _.props.extend( null, srcMap );
          args[ 0 ][ select ] = e;
          result.add( routine.apply( this, args ) );
        }
        return result;
      }
      else if( vectorizingContainerAdapter && _.containerAdapter.is( src ) ) /* qqq : cover */
      {
        if( head )
        {
          args = head( routine, args );
          _.assert( _.arrayLikeResizable( args ) );
        }
        result = src.filter( ( e ) =>
        {
          args[ 0 ] = _.props.extend( null, srcMap );
          args[ 0 ][ select ] = e;
          return routine.apply( this, args );
        });
        if( unwrapingContainerAdapter )
        return result.original;
        else
        return result;
      }

      return routine.apply( this, arguments );
    }

    /* - */

    function vectorizeForOptionsMapForKeys()
    {
      let result = [];

      if( bypassingEmpty && !arguments.length )
      return result;

      for( let i = 0; i < o.select.length; i++ )
      {
        select = o.select[ i ];
        result[ i ] = vectorizeForOptionsMap.apply( this, arguments );
      }
      return result;
    }

    /* - */

    function vectorizeMapOrArray()
    {
      if( bypassingEmpty && !arguments.length )
      return [];

      let args = multiply( arguments );
      let src = args[ 0 ];

      if( vectorizingArray && _.argumentsArray.like( src ) )
      {

        let args2 = [ ... args ];
        let result = _.long.makeEmpty( src );
        let append = _.long.appender( result );
        let each = _.long.eacher( src );
        each( ( e, r ) =>
        {

          for( let m = 0 ; m < select ; m++ )
          args2[ m ] = args[ m ][ r ]; /* qqq zzz : use _.long.get? */

          append( routine.apply( this, args2 ) );
        });
        return result;
      }
      else if( vectorizingMapVals && _.mapIs( src ) )
      {
        let args2 = [ ... args ];
        let result = Object.create( null );
        for( let r in src )
        {
          for( let m = 0 ; m < select ; m++ )
          args2[ m ] = args[ m ][ r ];

          result[ r ] = routine.apply( this, args2 );
        }
        return result;
      }

      return routine.apply( this, arguments );
    }

    /* - */

    function vectorizeMapWithKeysOrArray()
    {
      if( bypassingEmpty && !arguments.length )
      return [];

      let args = multiply( arguments );
      let srcs = args[ 0 ];

      _.assert( args.length === select, () => 'Expects ' + select + ' arguments but got : ' + args.length );

      if( vectorizingMapKeys && vectorizingMapVals &&_.mapIs( srcs ) )
      {
        let result = Object.create( null );
        for( let s in srcs )
        {
          let val = routine.call( this, srcs[ s ] );
          let key = routine.call( this, s );
          result[ key ] = val;
        }
        return result;
      }
      else if( vectorizingArray && _.argumentsArray.like( srcs ) )
      {
        let result = [];
        for( let s = 0 ; s < srcs.length ; s++ )
        result[ s ] = routine.call( this, srcs[ s ] );
        return result;
      }

      return routine.apply( this, arguments );
    }

    /* - */

    function vectorizeWithFilters( src )
    {

      _.assert( 0, 'not tested' ); /* qqq : cover please */
      _.assert( arguments.length === 1, 'Expects single argument' );

      let args = multiply( arguments );

      if( vectorizingArray && _.argumentsArray.like( src ) )
      {
        args = [ ... args ];
        throw _.err( 'not tested' ); /* cover please */

        let result = _.long.makeEmpty( src );
        let append = _.long.appender( result );
        let each = _.long.eacher( src );
        each( ( e, r ) =>
        {
          if( propertyCondition( e, r, src ) )
          {
            args[ 0 ] = e;
            append( routine.apply( this, args ) );
          }
          else if( bypassingFilteredOut )
          {
            append( e );
          }

          args2[ 0 ] = e;
          append( routine.apply( this, args2 ) );
        });
        return result;

      }
      else if( vectorizingMapVals && _.mapIs( src ) )
      {
        args = [ ... args ];
        let result = Object.create( null );
        throw _.err( 'not tested' ); /* qqq : cover please */
        for( let r in src )
        {
          if( propertyCondition( src[ r ], r, src ) )
          {
            args[ 0 ] = src[ r ];
            result[ r ] = routine.apply( this, args );
          }
          else if( bypassingFilteredOut )
          {
            result[ r ] = src[ r ];
          }
        }
        return result;
      }

      return routine.call( this, src );
    }

    /* - */

    function vectorizeKeysOrArray()
    {
      if( bypassingEmpty && !arguments.length )
      return [];

      // let args = multiply( _.originalsFromAdaptersInplace( arguments ) );
      let args = multiply( arguments );
      let src = args[ 0 ];
      let args2, result, map, mapIndex, arr;

      _.assert( args.length === select, () => 'Expects ' + select + ' arguments but got : ' + args.length );

      if( vectorizingMapKeys )
      {
        for( let d = 0; d < select; d++ )
        {
          if( vectorizingArray && _.argumentsArray.like( args[ d ] ) )
          arr = args[ d ];
          else if( _.mapIs( args[ d ] ) )
          {
            _.assert( map === undefined, () => 'Arguments should have only single map. Incorrect argument : ' + args[ d ] );
            map = args[ d ];
            mapIndex = d;
          }
        }
      }

      if( map )
      {
        result = Object.create( null );
        args2 = [ ... args ];

        if( vectorizingArray && _.argumentsArray.like( arr ) )
        {
          for( let i = 0; i < arr.length; i++ )
          {
            for( let m = 0 ; m < select ; m++ )
            args2[ m ] = args[ m ][ i ];

            for( let k in map )
            {
              args2[ mapIndex ] = k;
              let key = routine.apply( this, args2 );
              result[ key ] = map[ k ];
            }
          }
        }
        else
        {
          for( let k in map )
          {
            args2[ mapIndex ] = k;
            let key = routine.apply( this, args2 );
            result[ key ] = map[ k ];
          }
        }

        return result;
      }
      else if( vectorizingArray && _.argumentsArray.like( src ) )
      {

        let args2 = [ ... args ];
        let result = _.long.makeEmpty( src );
        let append = _.long.appender( result );
        let each = _.long.eacher( src );
        each( ( e, r ) =>
        {
          for( let m = 0 ; m < select ; m++ )
          args2[ m ] = args[ m ][ r ]; /* qqq zzz : use _.long.get */
          append( routine.apply( this, args2 ) );
        });
        return result;

      }

      return routine.apply( this, arguments );
    }

  }
  _vectorize_body.defaults = {
      "routine" : null,
      "propertyCondition" : null,
      "bypassingFilteredOut" : 1,
      "bypassingEmpty" : 0,
      "vectorizingArray" : 1,
      "vectorizingMapVals" : 0,
      "vectorizingMapKeys" : 0,
      "vectorizingContainerAdapter" : 0,
      "unwrapingContainerAdapter" : 0,
      "select" : 1
    }

  const _vectorize_ = _.routine.unite
  ({
    head : _vectorize_head,
    body : _vectorize_body,
  });

  return _vectorize_;
})();
_.vectorize.defaults =
{
  "routine" : null,
  "propertyCondition" : null,
  "bypassingFilteredOut" : 1,
  "bypassingEmpty" : 0,
  "vectorizingArray" : 1,
  "vectorizingMapVals" : 0,
  "vectorizingMapKeys" : 0,
  "vectorizingContainerAdapter" : 0,
  "unwrapingContainerAdapter" : 0,
  "select" : 1
}

//


  _.strsAreAll = function strsAreAll( src )
{
  _.assert( arguments.length === 1 );

  if( _.argumentsArray.like( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.strIs( src[ s ] ) )
    return false;
    return true;
  }

  return _.strIs( src );
}

//


  _.strReplaceAll = function strReplaceAll( src, ins, sub )
{
  let o;
  let foundArray = [];

  if( arguments.length === 3 )
  {
    o = { src };
    o.dictionary = [ [ ins, sub ] ];
  }
  else if( arguments.length === 2 )
  {
    o = { src : arguments[ 0 ], dictionary : arguments[ 1 ] };
  }
  else if( arguments.length === 1 )
  {
    o = arguments[ 0 ];
  }
  else
  {
    _.assert( 0, 'Expects at least single options map {-o-} or a combination of arguments : src-dictionary, src-ins-sub. ' );
  }

  /* verify */

  _.routine.options_( strReplaceAll, o );
  _.assert( _.strIs( o.src ) );

  _._strReplaceMapPrepare( o );

  /* */

  let found = _.strFindAll( o.src, o.ins );
  let result = [];
  let index = 0;

  found.forEach( ( it ) =>
  {
    let sub = o.sub[ it.tokenId ];

    let unknown = o.src.substring( index, it.charsRangeLeft[ 0 ] );
    if( unknown && o.onUnknown )
    unknown = o.onUnknown( unknown, it, o );

    if( unknown !== '' )
    result.push( unknown );

    if( _.routineIs( sub ) )
    sub = sub.call( o, it.match, it );

    if( sub !== '' )
    result.push( sub );

    index = it.charsRangeLeft[ 1 ];
  });

  result.push( o.src.substring( index, o.src.length ) );

  if( o.joining )
  result = result.join( '' )

  return result;
}
_.strReplaceAll.defaults =
{
  "src" : null,
  "dictionary" : null,
  "ins" : null,
  "sub" : null,
  "joining" : 1,
  "onUnknown" : null
}

//


  _.strFindAll = function strFindAll( src, ins )
{
  let o;

  if( arguments.length === 2 )
  {
    o = { src : arguments[ 0 ], ins : arguments[ 1 ] };
  }
  else if( arguments.length === 1 )
  {
    o = arguments[ 0 ];
  }

  if( _.strIs( o.ins ) || _.regexpIs( o.ins ) )
  o.ins = [ o.ins ];

  /* */

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.strIs( o.src ) );
  _.assert( _.argumentsArray.like( o.ins ) || _.object.isBasic( o.ins ) );
  _.routine.options_( strFindAll, o );

  /* */

  let tokensSyntax = _.tokensSyntaxFrom( o.ins );
  let descriptorsArray = [];
  let execeds = [];
  let closests = [];
  let closestTokenId = -1;
  let closestIndex = o.src.length;
  let currentIndex = 0;
  let descriptorFor = o.fast ? descriptorForFast : descriptorForFull;

  /* */

  tokensSyntax.idToValue.forEach( ( ins, tokenId ) =>
  {
    // Dmytro : not optimal - double check. qqq : ?
    _.assert( _.strIs( ins ) || _.regexpIs( ins ) );

    if( _.regexpIs( ins ) )
    _.assert( !ins.sticky );

    let found = find( o.src, ins, tokenId );
    closests[ tokenId ] = found;
    if( found < closestIndex )
    {
      closestIndex = found
      closestTokenId = tokenId;
    }
  });

  /* */

  while( closestIndex < o.src.length )
  {

    if( o.tokenizingUnknown && closestIndex > currentIndex )
    {
      descriptorFor( o.src, currentIndex, -1 );
    }

    descriptorFor( o.src, closestIndex, closestTokenId );

    closestIndex = o.src.length;
    closests.forEach( ( index, tokenId ) =>
    {
      if( index < currentIndex )
      index = closests[ tokenId ] = find( o.src, tokensSyntax.idToValue[ tokenId ], tokenId );

      _.assert( closests[ tokenId ] >= currentIndex );

      if( index < closestIndex )
      {
        closestIndex = index
        closestTokenId = tokenId;
      }
    });

    _.assert( closestIndex <= o.src.length );
  }

  if( o.tokenizingUnknown && closestIndex > currentIndex )
  {
    descriptorFor( o.src, currentIndex, -1 );
  }

  /* */

  return descriptorsArray;

  /* */

  function find( src, ins, tokenId )
  {
    let result;

    if( _.strIs( ins ) )
    {
      result = findWithString( o.src, ins, tokenId );
    }
    else if( _.regexpIs( ins ) )
    {
      if( ins.source === '(?:)' )
      result = src.length;
      else
      result = findWithRegexp( o.src, ins, tokenId );
    }
    else _.assert( 0 );

    _.assert( result >= 0 );
    return result;
  }

  /* */

  function findWithString( src, ins )
  {

    if( !ins.length )
    return src.length;

    let index = src.indexOf( ins, currentIndex );

    if( index < 0 )
    return src.length;

    return index;
  }

  /* */

  function findWithRegexp( src, ins, tokenId )
  {
    let execed;
    let result = src.length;

    if( currentIndex === 0 || ins.global )
    {

      do
      {

        execed = ins.exec( src );
        if( execed )
        result = execed.index;
        else
        result = src.length;

      }
      while( result < currentIndex );

    }
    else
    {
      execed = ins.exec( src.substring( currentIndex ) );

      if( execed )
      result = execed.index + currentIndex;

    }

    if( execed )
    execeds[ tokenId ] = execed;

    return result;
  }

  /* */

  function descriptorForFast( src, index, tokenId )
  {
    let originalIns = tokensSyntax.idToValue[ tokenId ];
    let match;
    let it = [];

    if( tokenId === -1 )
    originalIns = src.substring( index, closestIndex );

    if( _.strIs( originalIns ) )
    {
      match = originalIns;
    }
    else
    {
      let execed = execeds[ tokenId ];
      _.assert( !!execed );
      match = execed[ 0 ];
    }

    it[ 0 ] = index;
    it[ 1 ] = index + match.length;
    it[ 2 ] = tokenId;

    descriptorsArray.push( it );

    _.assert( _.strIs( match ) );
    if( match.length > 0 )
    currentIndex = index + match.length;
    else
    currentIndex = index + 1;

    o.counter += 1;
  }

  /* */

  function descriptorForFull( src, index, tokenId )
  {
    let originalIns = tokensSyntax.idToValue[ tokenId ];
    let match;
    let it = Object.create( null );
    let groups;

    if( tokenId === -1 )
    originalIns = src.substring( index, closestIndex );

    if( _.strIs( originalIns ) )
    {
      match = originalIns;
      groups = [];
    }
    else
    {
      let execed = execeds[ tokenId ];
      _.assert( !!execed );
      match = execed[ 0 ];
      groups = _.longSlice( execed, 1, execed.length );
    }

    it.match = match;
    it.groups = groups;
    it.tokenId = tokenId;
    it.charsRangeLeft = [ index, index + match.length ]; /* yyy */
    it.counter = o.counter;
    it.input = src;

    if( tokensSyntax.idToName && tokensSyntax.idToName[ tokenId ] )
    it.tokenName = tokensSyntax.idToName[ tokenId ];

    descriptorsArray.push( it );

    _.assert( _.strIs( match ) );
    if( match.length > 0 )
    currentIndex = index + match.length;
    else
    currentIndex = index + 1;

    o.counter += 1;
  }

  /* */

}
_.strFindAll.defaults =
{
  "src" : null,
  "ins" : null,
  "fast" : 0,
  "counter" : 0,
  "tokenizingUnknown" : 0
}

//


  _.strReverse = function strReverse( srcStr )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  let result = '';
  for( let i = 0 ; i < srcStr.length ; i++ )
  result = srcStr[ i ] + result;
  return result;
}

//


  _.strCount = function strCount( src, ins )
{
  let result = 0;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ) );
  _.assert( _.regexpLike( ins ) );

  let i = 0;
  do
  {
    // let found = _.strLeft( src, ins, [ i, src.length ] );
    let found = _.strLeft_( src, ins, [ i, src.length-1 ] );
    if( found.entry === undefined )
    break;
    i = found.index + found.entry.length;
    if( !found.entry.length )
    i += 1;
    result += 1;
    _.assert( i !== -1, 'not tested' );
  }
  while( i !== -1 && i < src.length );

  return result;
}

//


  _.strLeft_ = function left_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( _.argumentsArray.like( src ) )
  {
    let result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _._strLeftSingle_( src[ s ], ins, cinterval );
    return result;
  }
  else
  {
    return _._strLeftSingle_( src, ins, cinterval );
  }

}

//


  _.tokensSyntaxFrom = function tokensSyntaxFrom( ins )
{

  if( ins instanceof _.TokensSyntax )
  return ins

  let result = TokensSyntax();

  if( _.strIs( ins ) || _.regexpIs( ins ) )
  ins = [ ins ];

  /* */

  _.assert( arguments.length === 1 );
  _.assert( _.argumentsArray.like( ins ) || _.object.isBasic( ins ) );

  /* */

  result.idToValue = ins;
  if( _.mapIs( ins ) )
  {
    result.idToValue = [];
    result.idToName = [];
    let i = 0;
    for( var name in ins )
    {
      let element = ins[ name ];
      if( _.longIs( element ) )
      {
        let alternative = result.alternatives[ name ] = result.alternatives[ name ] || [];
        for( let e = 0 ; e < element.length ; e++ )
        {
          let name2 = name + '_' + element[ e ];
          result.idToValue[ i ] = ins[ name ][ e ]; // qqq : ? Dmytro : better to use local variable 'let element'. Also, maybe, needs check type of element - regexp or string.
          result.idToName[ i ] = name2;
          result.nameToId[ name2 ] = i;
          alternative.push( name2 );
          i += 1;
        }
      }
      else
      {
        result.idToValue[ i ] = ins[ name ]; // qqq : ? Dmytro : better to use local variable 'let element'
        result.idToName[ i ] = name;
        result.nameToId[ name ] = i;
        i += 1;
      }
    }
  }

  return result;
}

//


  _._strReplaceMapPrepare = function _strReplaceMapPrepare( o )
{

  /* verify */

  _.map.assertHasAll( o, _strReplaceMapPrepare.defaults );
  _.assert( arguments.length === 1 );
  _.assert( _.object.isBasic( o.dictionary ) || _.longIs( o.dictionary ) || o.dictionary === null );
  _.assert( ( _.longIs( o.ins ) && _.longIs( o.sub ) ) || ( o.ins === null && o.sub === null ) );

  /* head */

  if( o.dictionary )
  {

    o.ins = [];
    o.sub = [];

    if( _.object.isBasic( o.dictionary ) )
    {
      let i = 0;
      for( let d in o.dictionary )
      {
        o.ins[ i ] = d;
        o.sub[ i ] = o.dictionary[ d ];
        i += 1;
      }
    }
    else
    {
      let i = 0;
      o.dictionary.forEach( ( d ) =>
      {
        let ins = d[ 0 ];
        let sub = d[ 1 ];
        _.assert( d.length === 2 );
        // _.assert( !( _.arrayIs( ins ) ^ _.arrayIs( sub ) ) );
        // debugger;
        _.assert( _.arrayIs( ins ) === _.arrayIs( sub ) );
        if( _.arrayIs( ins ) )
        {
          _.assert( ins.length === sub.length )
          for( let n = 0 ; n < ins.length ; n++ )
          {
            o.ins[ i ] = ins[ n ];
            o.sub[ i ] = sub[ n ];
            i += 1;
          }
        }
        else
        {
          o.ins[ i ] = ins;
          o.sub[ i ] = sub;
          i += 1;
        }
      });
    }

    o.dictionary = null;
  }

  /* verify */

  _.assert( !o.dictionary );
  _.assert( o.ins.length === o.sub.length );

  if( Config.debug )
  {
    o.ins.forEach( ( ins ) => _.assert( _.strIs( ins ) || _.regexpIs( ins ) ), 'Expects String or RegExp' );
    o.sub.forEach( ( sub ) => _.assert( _.strIs( sub ) || _.routineIs( sub ) ), 'Expects String or Routine' );
  }

  return o;
}
_._strReplaceMapPrepare.defaults =
{ "dictionary" : null, "ins" : null, "sub" : null }

//


  _.map.assertHasAll = function assertHasAll( srcMap, all, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureHasAll.apply( this, arguments );
}

//


  _.map.sureHasAll = function sureHasAll( srcMap, all, msg )
{

  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  let but = Object.keys( _.mapBut_( null, all, srcMap ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should have fields :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//


  _.longSlice = function _longShallow( src, f, l )
{
  _.assert( 1 <= arguments.length && arguments.length <= 3 );
  _.assert( _.longIs( src ), 'Expects long {-src-}' );
  _.assert( f === undefined || _.number.is( f ) );
  _.assert( l === undefined || _.number.is( l ) );

  /* xxx qqq for Dmytro : check and cover */

  f = f === undefined ? 0 : f;
  l = l === undefined ? src.length : l;

  if( f < 0 )
  f = src.length + f;
  if( l < 0 )
  l = src.length + l;

  if( f < 0 )
  f = 0;
  if( f > l )
  l = f;

  if( _.bufferTypedIs( src ) )
  return _.longOnly_( null, src, [ f, l - 1 ] );
  return Array.prototype.slice.call( src, f, l );

  // if( _.bufferTypedIs( src ) )
  // return src.subsrc( f, l );
  // else if( _.srcLikeResizable( src ) )
  // return src.slice( f, l );
  // else if( _.argumentssrcIs( src ) )
  // return src.prototype.slice.call( src, f, l );
  // else
  // _.assert( 0 );
}

//


  _.regexpEscape = function escape( src )
{
  _.assert( _.strIs( src ) );
  _.assert( arguments.length === 1, 'Expects single argument' );
  return src.replace( /([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1' );
}

//


  _.regexpLike = function like( src )
{
  if( src instanceof RegExp || Object.prototype.toString.call( src ) === '[object String]' )
  return true;
  return false;
}

//


  _.regexpsLikeAll = function likeAll( src )
{
  _.assert( arguments.length === 1 );

  if( _.argumentsArray.like( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.regexp.like( src[ s ] ) )
    return false;
    return true;
  }

  return _.regexp.like( src );
}

//


  _.filter_ = function filter_( dst, src, onEach )
{

  if( arguments.length === 2 )
  {
    _.assert( arguments.length === 3, 'Expects three arguments' );
    onEach = src;
    src = dst;
  }
  else
  {
    _.assert( arguments.length === 3, 'Expects two or three arguments' );
  }
  onEach = _._filter_functor( onEach, 1 );

  _.assert( _.routine.is( onEach ) );

  /* */

  let result;

  if( dst === src )
  {

    result = src;
    if( _.longIs( src ) )
    {
      /* qqq for junior : add branch for countable case */
      /* qqq : should be direct! check other cycles */
      for( let s = src.length - 1 ; s >= 0 ; s-- )
      {
        let r = onEach.call( src, src[ s ], s, src );
        if( _.unrollIs( r ) )
        _.longBut_( result, s, r );
        else if( r !== undefined )
        result[ s ] = r;
        else
        result.splice( s, 1 );
      }
    }
    else if( _.aux.is( src ) )
    {
      for( let s in src )
      {
        let r = onEach.call( src, src[ s ], s, src );
        if( r === undefined )
        delete src[ s ];
        else
        src[ s ] = r;
      }
    }
    else
    {
      result = onEach.call( null, src, null, null );
    }

  }
  else
  {

    result = dst;
    if( _.longIs( src ) )
    {
      if( dst === null )
      {
        if( _.argumentsArray.is( src ) )
        result = [];
        else
        result = _.long.make( src, 0 );
      }
      else
      {
        _.assert( _.longIs( dst ), '{-dst-} container should be long like' );
      }

      let s, d;
      /* qqq for junior : add branch for countable case */
      for( s = 0, d = 0 ; s < src.length ; s++ )
      {
        let r = onEach.call( src, src[ s ], s, src );
        if( _.unrollIs( r ) )
        {
          _.longBut_( result, d, r );
          d += r.length;
        }
        else if( r !== undefined )
        {
          result[ d ] = r;
          d += 1;
        }
      }
    }
    else if( _.aux.is( src ) )
    {
      if( dst === null )
      result = _.entity.makeUndefined( src );
      else
      _.assert( _.aux.is( dst ), '{-dst-} container should be map like' );

      for( let s in src )
      {
        let r = onEach.call( src, src[ s ], s, src );
        if( r !== undefined )
        result[ s ] = r;
      }
    }
    else
    {
      let r = onEach.call( null, src, null, null );

      if( r !== undefined )
      {
        if( _.longIs( dst ) )
        result = _.arrayAppendElement( dst, r );
        else if( _.aux.is( dst ) )
        result = _.props.extend( dst, r );
        else if( _.primitive.is( dst ) )
        result = r;
        else
        _.assert( 0, 'Not clear how to add result in destination container {-dst-}' );
      }
    }

  }

  return result;
}

//


  _._filter_functor = function _filter_functor( condition, levels )
{
  let result;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.routine.is( condition ) || _.object.isBasic( condition ) );

  if( _.object.isBasic( condition ) )
  {
    let template = condition;
    condition = function condition( e, k, src )
    {
      _.assert( arguments.length === 3 );
      if( e === template )
      return e;
      if( !_.object.like( e ) )
      return;
      let satisfied = _.objectSatisfy
      ({
        template,
        src : e,
        levels
      });
      if( satisfied )
      return e;
    };
  }

  return condition;
}

//


  _.entityMakeUndefined = undefined;

//


  _.props.keys = function keys( srcMap, o )
{
  let result;

  // _.assert( this === _.object );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( keys, o || null );
  // _.assert( !_.primitive.is( srcMap ) );

  o.srcMap = srcMap;

  result = this._keys( o );

  return result;
}
_.props.keys.defaults =
{ "onlyOwn" : 0, "onlyEnumerable" : 1 }

//



  _.path.globShortFilterKeys = ( function() {

  const _globShortFilter_head = function globShortFilter_head( routine, args )
  {
    let result;

    _.assert( arguments.length === 2 );
    _.assert( args.length === 1 || args.length === 2 );

    let o = args[ 0 ];
    if( args[ 1 ] !== undefined )
    o = { src : args[ 0 ], selector : args[ 1 ] }

    o = _.routine.options_( routine, o );

    if( o.onEvaluate === null )
    o.onEvaluate = function byVal( e, k, src )
    {
      return e;
    }

    return o;
  }

  const _globShortFilter_body = function globShortFilter_body( o )
  {
    let self = this;
    let result;

    _.assert( arguments.length === 1 );

    // if( _global_.debugger )
    // debugger;

    if( self.isGlob( o.selector ) )
    {
      let regexp = self.globShortSplitsToRegexps( o.selector );
      result = _.filter_( null, o.src, ( e, k ) =>
      {
        let val = o.onEvaluate( e, k, o.src );
        return regexp.test( val ) ? e : undefined;
      } );
    }
    else
    {
      result = _.filter_( null, o.src, ( e, k ) =>
      {
        return o.onEvaluate( e, k, o.src ) === o.selector ? e : undefined;
      } );
    }

    return result;
  }
  _globShortFilter_body.defaults = { "src" : null, "selector" : null, "onEvaluate" : null }

  const _globShortFilter_ = _.routine.unite
  ({
    head : _globShortFilter_head,
    body : _globShortFilter_body,
  });

  return _globShortFilter_;
})();
_.path.globShortFilterKeys.defaults =
{
  "src" : null,
  "selector" : null,
  "onEvaluate" : function byKey( e, k, src )
{
  return _.arrayIs( src ) ? e : k;
}
}

//


  _.path.globShortSplitsToRegexps =
(function()
{
  let toVectorize = Object.create( null );
  toVectorize.routine = function globShortSplitToRegexp( glob )
{
  let self = this;

  _.assert( _.strIs( glob ) || _.regexpIs( glob ) );
  _.assert( arguments.length === 1 );

  if( _.regexpIs( glob ) )
  return glob;

  let str = self._globShortSplitToRegexpSource( glob );
  let result = new RegExp( '^' + str + '$' );
  return result;
}

//

toVectorize.vectorizingArray = 1;

//

toVectorize.vectorizingMapVals = 0;

//

toVectorize.vectorizingMapKeys = 1;

//

toVectorize.select = 1;

//

toVectorize.propertyCondition = null;

//

toVectorize.bypassingFilteredOut = 1;

//

toVectorize.bypassingEmpty = 0;

//

toVectorize.vectorizingContainerAdapter = 0;

//

toVectorize.unwrapingContainerAdapter = 0;

//


  return _.vectorize( toVectorize );
})();


//


  _.path._globShortSplitToRegexpSource = ( function functor()
{

  let self;
  let _globRegexpSourceCache = Object.create( null )

  let _transformation0 =
  [
    [ /\[(.+?)\]/g, handlePass ], /* square brackets */
    [ /\.\./g, handlePass ], /* dual dot */
    [ /\./g, handlePass ], /* dot */
    [ /\(\)|\0/g, handlePass ], /* empty parentheses or zero */
    [ /([!?*@+]*)\((.*?(?:\|(.*?))*)\)/g, handlePass ], /* parentheses */
    [ /\*\*\*/g, handlePass ], /* triple asterix */
    [ /\*\*/g, handlePass ], /* dual asterix */
    [ /(\*)/g, handlePass ], /* single asterix */
    [ /(\?)/g, handlePass ], /* question mark */
  ]

  let _transformation1 =
  [
    [ /\[(.+?)\]/g, handleSquareBrackets ], /* square brackets */
    [ /\{(.*)\}/g, handleCurlyBrackets ], /* curly brackets */
  ]

  let _transformation2 =
  [
    [ /\.\./g, '\\.\\.' ], /* dual dot */
    [ /\./g, '\\.' ], /* dot */
    [ /\(\)|\0/g, '' ], /* empty parentheses or zero */
    [ /([!?*@+]?)\((.*?(?:\|(.*?))*)\)/g, hanleParentheses ], /* parentheses */
    // [ /\/\*\*/g, '(?:\/.*)?', ], /* slash + dual asterix */
    [ /\*\*\*/g, '(?:.*)' ], /* triple asterix */
    [ /\*\*/g, '.*' ], /* dual asterix */
    [ /(\*)/g, '[^\/]*' ], /* single asterix */
    [ /(\?)/g, '[^\/]' ], /* question mark */
  ]

  /* */

  _globShortSplitToRegexpSource.functor = functor;
  return _globShortSplitToRegexpSource;

  function _globShortSplitToRegexpSource( src )
  {
    self = this;

    let result = _globRegexpSourceCache[ src ];
    if( result )
    return result;

    _.assert( _.strIs( src ) );
    _.assert( arguments.length === 1, 'Expects single argument' );
    _.assert
    (
      !_.strHas( src, /(^|\/)\.\.(\/|$)/ ) || src === self.downToken,
      'glob should not has splits with ".." combined with something'
    );

    result = transform( src );

    _globRegexpSourceCache[ src ] = result;

    return result;
  }

  /* */

  function transform( src )
  {
    let result = src;

    result = _.strReplaceAll
    ( {
      src : result,
      dictionary : _transformation0,
      joining : 1,
      onUnknown : handleUnknown,
    } );

    result = _.strReplaceAll( result, _transformation1 );
    result = _.strReplaceAll( result, _transformation2 );

    return result;
  }

  /* */

  function handleUnknown( src )
  {
    return _.regexpEscape( src );
  }

  /* */

  function handlePass( src )
  {
    return src;
  }

  /* */

  function handleCurlyBrackets( src, it )
  {
    throw _.err( 'Glob with curly brackets is not allowed ', src );
  }

  /* */

  function handleSquareBrackets( src, it )
  {
    let inside = it.groups[ 0 ];
    /* escape inner [] */
    inside = inside.replace( /[\[\]]/g, ( m ) => '\\' + m );
    /* replace ! -> ^ at the beginning */
    inside = inside.replace( /^!/g, '^' );
    if( inside[ 0 ] === '^' )
    inside = inside + '\/';
    return [ '[' + inside + ']' ];
  }

  /* */

  function hanleParentheses( src, it )
  {

    let inside = it.groups[ 1 ].split( '|' );
    let multiplicator = it.groups[ 0 ];

    multiplicator = _.strReverse( multiplicator );
    if( multiplicator === '*' )
    multiplicator += '?';

    _.assert( _.strCount( multiplicator, '!' ) === 0 || multiplicator === '!' );
    _.assert( _.strCount( multiplicator, '@' ) === 0 || multiplicator === '@' );

    inside = inside.map( ( i ) => self._globShortSplitToRegexpSource( i ) );

    let result = '(?:' + inside.join( '|' ) + ')';
    if( multiplicator === '@' )
    result = result;
    else if( multiplicator === '!' )
      result = '(?:(?!(?:' + result + '|\/' + ')).)*?';
    else
      result += multiplicator;

    /* (?:(?!(?:abc)).)+ */

    return result;
  }

  /* */

} )();

//


  _.path.is = function is( path )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  return _.strIs( path );
}

//


  _.path.name = ( function() {

  const _name_head = function name_head( routine, args )
  {
    let o = args[ 0 ];
    if( _.strIs( o ) )
    o = { path : o };

    _.routine.options_( routine, o );
    _.assert( args.length === 1 );
    _.assert( arguments.length === 2 );
    _.assert( _.strIs( o.path ), 'Expects string {-o.path-}' );

    return o;
  }

  const _name_body = function name_body( o )
  {

    if( _.strIs( o ) )
    o = { path : o };

    _.routine.assertOptions( name_body, arguments );

    o.path = this.canonize( o.path );

    let i = o.path.lastIndexOf( '/' );
    if( i !== -1 )
    o.path = o.path.substr( i+1 );

    if( !o.full )
    {
      let i = o.path.lastIndexOf( '.' );
      if( i !== -1 ) o.path = o.path.substr( 0, i );
    }

    return o.path;
  }
  _name_body.defaults = { "path" : null, "full" : 0 }

  const _name_ = _.routine.unite
  ({
    head : _name_head,
    body : _name_body,
  });

  return _name_;
})();
_.path.name.defaults =
{ "path" : null, "full" : 0 }

//


  _.path.fullName = ( function() {

  const _name_head = function name_head( routine, args )
  {
    let o = args[ 0 ];
    if( _.strIs( o ) )
    o = { path : o };

    _.routine.options_( routine, o );
    _.assert( args.length === 1 );
    _.assert( arguments.length === 2 );
    _.assert( _.strIs( o.path ), 'Expects string {-o.path-}' );

    return o;
  }

  const _name_body = function name_body( o )
  {

    if( _.strIs( o ) )
    o = { path : o };

    _.routine.assertOptions( name_body, arguments );

    o.path = this.canonize( o.path );

    let i = o.path.lastIndexOf( '/' );
    if( i !== -1 )
    o.path = o.path.substr( i+1 );

    if( !o.full )
    {
      let i = o.path.lastIndexOf( '.' );
      if( i !== -1 ) o.path = o.path.substr( 0, i );
    }

    return o.path;
  }
  _name_body.defaults = { "path" : null, "full" : 0 }

  const _name_ = _.routine.unite
  ({
    head : _name_head,
    body : _name_body,
  });

  return _name_;
})();
_.path.fullName.defaults =
{ "path" : null, "full" : 1 }

//


  _.path.detrail = function detrail( path )
{
  _.assert( this.is( path ) );
  _.assert( arguments.length === 1 );

  if( path !== this.rootToken )
  return _.strRemoveEnd( path, this.upToken );

  return path;
}

//


  _.path.reroot = ( function() {

  const _join_head = function join_head( routine, args )
  {
    _.assert( args.length > 0, 'Expects argument' )
    let o = { paths : args };

    _.routine.options_( routine, o );
    //_.assert( o.paths.length > 0 );
    _.assert( _.boolLike( o.reroot ) );
    _.assert( _.boolLike( o.allowingNull ) );
    _.assert( _.boolLike( o.raw ) );

    return o;
  }

  const _join_body = function join_body( o )
  {
    let self = this;
    let result = null;
    let prepending = true;

    /* */

    if( Config.debug )
    for( let a = o.paths.length-1 ; a >= 0 ; a-- )
    {
      let src = o.paths[ a ];
      _.assert
      (
        _.strIs( src ) || src === null, () => `Expects strings as path arguments, but #${a} argument is ${_.entity.strType( src )}`
      );
    }

    /* */

    for( let a = o.paths.length-1 ; a >= 0 ; a-- )
    {
      let src = o.paths[ a ];

      if( o.allowingNull )
      if( src === null )
      break;

      if( result === null )
      result = '';

      _.assert( _.strIs( src ), () => `Expects strings as path arguments, but #${a} argument is ${_.entity.strType( src )}` );

      if( !prepend( src ) )
      break;

    }

    /* */

    if( !o.raw && result !== null )
    result = self.normalize( result );

    return result;

    /* */

    function prepend( src )
    {
      let trailed = false;
      let endsWithUp = false;

      if( src )
      src = self.refine( src );

      if( !src )
      return true;

      // src = src.replace( /\\/g, self.upToken );

      // if( result )
      if( _.strEnds( src, self.upToken ) )
      // if( _.strEnds( src, self.upToken ) && !_.strEnds( src, self.upToken + self.upToken ) )
      // if( src.length > 1 || result[ 0 ] === self.upToken )
      {
        if( src.length > 1 )
        {
          if( result )
          src = src.substr( 0, src.length-1 );
          trailed = true;

          if( result === self.downToken )
          result = self.hereToken;
          else if( result === self.downUpToken )
          result = self.hereUpToken;
          else
          result = _.strRemoveBegin( result, self.downUpToken );

        }
        else
        {
          endsWithUp = true;
        }
      }

      if( src && result )
      if( !endsWithUp && !_.strBegins( result, self.upToken ) )
      result = self.upToken + result;

      result = src + result;

      if( !o.reroot )
      {
        if( _.strBegins( result, self.rootToken ) )
        return false;
      }

      return true;
    }

  }
  _join_body.defaults = {
      "paths" : null,
      "reroot" : 0,
      "allowingNull" : 1,
      "raw" : 0
    }

  const _join_ = _.routine.unite
  ({
    head : _join_head,
    body : _join_body,
  });

  return _join_;
})();
_.path.reroot.defaults =
{
  "paths" : null,
  "reroot" : 1,
  "allowingNull" : 1,
  "raw" : 0
}

//


  _.path.traceToRoot = function traceToRoot( filePath )
{
  let self = this;
  let result = [];

  filePath = self.normalize( filePath );
  // filePath = self.detrail( filePath ); // Dmytro : cycled loop if path is absolute and has form '/..'
  // filePath = self.canonize( filePath );

  _.assert( arguments.length === 1 );
  _.assert( self.isAbsolute( filePath ) );

  /*
    should preserve trailing of the longest path
    /a/b/ -> [ '/', '/a', '/a/b/' ]
  */

  // if( self.isAbsolute( filePath ) )
  // {
  result.push( filePath );
  filePath = self.detrail( filePath );
  while( filePath !== self.rootToken )
  {
    _.assert
    (
      filePath !== self.rootToken + self.downToken
      && !_.strBegins( filePath, self.rootToken + self.downToken + self.upToken )
    );
    filePath = self.dir( filePath );
    result.push( filePath );
    // filePath = self.detrail( dir ); /* qqq : not optimal! | aaa : Moved outside of the loop. */
  }
  // }
  // else
  // {
  //   filePath = self.undot( filePath );
  //   if( !self.isDotted( filePath ) )
  //   do
  //   {
  //     result.unshift( filePath );
  //     filePath = self.detrail( self.dir( filePath ) ); /* qqq : not optimal! */
  //   }
  //   while( !self.isDotted( filePath ) );
  // }

  // result.push( filePath );

  return result.reverse();
}

//






  let ToolsExtension =
  {
    TokensSyntax,
  }

  Object.assign( _starter_, ToolsExtension );

  let PathExtension =
  {
  }

  Object.assign( _starter_.path, PathExtension );

;

/* */  /* end of globing */ })();


/* */  /* begin of njs */ ( function _njs_() {



  'use strict';

  const _global = _global_;
  let _starter_ = _global_._starter_;
  let _ = _starter_;
  // let path = _starter_.path; // xxx
  // let sourcesMap = _starter_.sourcesMap; // xxx

  // if( _global._starter_ && _global._starter_._inited ) // xxx
  // return;

  let _natInclude = typeof require === 'undefined' ? null : require;
  let _natResolve = typeof require === 'undefined' ? null : require.resolve;

  //

  function _njsModuleFromSource( sourceFile )
  {
    if( sourceFile.njsModule )
    return sourceFile.njsModule;
    let Module = _natInclude( 'module' );
    let natPath = this.path.nativize( sourceFile.filePath );
    let njsModule = Module._cache[ natPath ];
    if( !njsModule )
    {
      njsModule = new Module( natPath, sourceFile.parent ? sourceFile.parent.njsModule : null );
      Module._cache[ natPath ] = njsModule;
    }
    njsModule.sourceFile = sourceFile;
    sourceFile.njsModule = njsModule;
    return njsModule;
  }

  //

  function _sourceForIncludeWithNjsModule( njsModule, filePath )
  {
    let starter = this;
    let sourceFile = njsModule.sourceFile || null;
    return starter._sourceForInclude( sourceFile, _.path.dir( njsModule.filename ), filePath );
  }

  //

  function _sourceFromNjsModule( njsModule )
  {
    let starter = this;
    let r = starter._sourceForPathGet( njsModule.filename );
    if( r )
    {
      starter._njsSourceFileUpdateFromNjs( r, njsModule );
      return r;
    }
    r = starter.SourceFile({ filePath : njsModule.filename, njsModule });
    if( !r.parent )
    if( njsModule.parent )
    r.parent = starter._sourceFromNjsModule( njsModule.parent );
    return r;
  }

  //

  function _njsSourceFile( sourceFile, op )
  {
    let starter = this;

    sourceFile._natInclude = _natInclude;
    sourceFile._natResolve = _natResolve;

    if( sourceFile.njsModule === undefined )
    sourceFile.njsModule = null;
    if( op.njsModule )
    sourceFile.njsModule = op.njsModule;

    starter._njsSourceFileUpdateFromNjs( sourceFile, sourceFile.njsModule );

  }

  //

  function _njsSourceFileUpdateFromNjs( sourceFile, njsModule )
  {

    _.assert
    (
      !sourceFile.njsModule || sourceFile.njsModule === njsModule,
      'Something wrong!'
    );

    sourceFile.njsModule = njsModule;
    if( sourceFile.njsModule )
    {
      sourceFile.njsModule.sourceFile = sourceFile;
      sourceFile.state = njsModule.loaded ? 'opened' : 'opening';
      sourceFile.exports = njsModule.exports;
    }

  }

  //

  function _sourceResolveAct( parentSource, basePath, filePath )
  {
    let _natResolve;

    if( parentSource )
    {
      _natResolve = parentSource._natResolve;
    }
    else
    {
      _natResolve = this._natResolve;
    }

    return _natResolve( filePath );
  }

  //

  function _njsSourceIncludeFromNjsAct( njsModule, childSource, sourcePath )
  {
    let parentSource = njsModule.sourceFile || null;
    return this._sourceIncludeResolvedCalling( parentSource, childSource, sourcePath );
  }

  //

  function _includeAct( parentSource, basePath, filePath )
  {
    let starter = this;
    let resolvedFilePath = this._pathResolveLocal( parentSource, basePath, filePath );
    resolvedFilePath = _.path.nativize( resolvedFilePath );
    let _natInclude = parentSource ? parentSource._natInclude : starter._natInclude;
    return _natInclude( resolvedFilePath );
    // return _natInclude( filePath );
  }

  //

  function _sourceCodeModule()
  {
    let SourceFile = _starter_.SourceFile;

    accesor( '_cache', cacheGet, cacheSet );

    this.exports = SourceFile;

    return SourceFile;

    function cacheGet()
    {
      return _starter_.sourcesMap;
    }

    function cacheSet( src )
    {
      _starter_.sourcesMap = src;

      if( !_starter_.sourcesMap[ 'module' ] )
      _starter_._sourceMake( 'module', '/', _sourceCodeModule );

      return _starter_.sourcesMap;
    }

    function accesor( propName, onGet, onSet )
    {
      let property =
      {
        enumerable : true,
        configurable : true,
        get : onGet,
        set : onSet,
      }
      Object.defineProperty( SourceFile, propName, property );
    }

  }

  //

  function _SetupAct()
  {
    let starter = this;

    starter._sourceMake( 'module', '/', _sourceCodeModule );

    let Module = _natInclude( 'module' );
    let NjsResolveFilename = Module._resolveFilename;
    Module._resolveFilename = function _resolveFilename( request, parent, isMain )
    {
      // let options = arguments[ 3 ];
      let result = starter._sourceOwnResolve( parent, null, request );
      if( result === null )
      return NjsResolveFilename.apply( this, arguments );
      return result;
    }
    let NjsLoad = Module._load;
    Module._load = function _load( request, parent, isMain )
    {
      if( !parent.sourceFile )
      starter._sourceFromNjsModule( parent );
      let childSource = starter._sourceForIncludeWithNjsModule( parent, request );
      if( childSource === null )
      {
        let result = NjsLoad.apply( this, arguments );
        let child = Module._cache[ NjsResolveFilename.apply( this, arguments ) ];
        if( child )
        starter._sourceFromNjsModule( child );
        return result;
      }
      return starter._njsSourceIncludeFromNjsAct( parent, childSource, request );
    }
  }

;


  let Extension =
  {

    _natInclude,
    _natResolve,

    _njsModuleFromSource,
    _sourceForIncludeWithNjsModule,
    _sourceFromNjsModule,

    _njsSourceFile,
    _njsSourceFileUpdateFromNjs,
    _sourceResolveAct,
    _njsSourceIncludeFromNjsAct,
    _includeAct,
    _SetupAct,


  }

  Object.assign( _starter_, Extension );

;

/* */  /* end of njs */ })();


/* */  /* begin of starter */ ( function _starter_() {



  'use strict';

  const _global = _global_;
  if( _global._starter_ && _global._starter_._inited )
  return;

  let _starter_ = _global_._starter_;
  let _ = _starter_;
  let path = _starter_.path;
  let sourcesMap = _starter_.sourcesMap;

  //

  function SourceFile( o )
  {
    let starter = _starter_;
    let sourceFile = this;

    if( !( sourceFile instanceof SourceFile ) )
    return new SourceFile( o );

    if( o.isScript === undefined )
    o.isScript = true;

    o.filePath = starter.path.canonizeTolerant( o.filePath );
    if( !o.dirPath )
    o.dirPath = starter.path.dir( o.filePath );
    o.dirPath = starter.path.canonizeTolerant( o.dirPath );

    sourceFile.filePath = o.filePath;
    sourceFile.dirPath = o.dirPath;
    sourceFile.nakedCall = o.nakedCall;
    sourceFile.isScript = o.isScript;

    sourceFile.filename = o.filePath;
    sourceFile.exports = Object.create( null );
    sourceFile.parent = null;
    sourceFile.children = [];
    sourceFile.njsModule = o.njsModule;
    sourceFile.error = null;
    sourceFile.state = o.nakedCall ? 'preloaded' : 'created';

    sourceFile.starter = starter;
    // sourceFile.include = starter._sourceInclude.bind( starter, sourceFile, sourceFile.dirPath );
    sourceFile.include = include.bind( sourceFile );
    sourceFile.resolve = starter._sourceResolve.bind( starter, sourceFile, sourceFile.dirPath );
    sourceFile.include.resolve = sourceFile.resolve;
    sourceFile.include.sourceFile = sourceFile;
    sourceFile.isModuleDeclareFile = starter.path.name( sourceFile.dirPath ) === 'node_modules';

    /* njs compatibility */

    sourceFile.path = [ '/' ];
    getter( 'id', idGet );
    getter( 'loaded', loadedGet );

    /* interpreter-specific */

    if( starter.interpreter === 'browser' )
    starter._broSourceFile( sourceFile, o );
    else
    starter._njsSourceFile( sourceFile, o );

    /* */

    if( starter.loggingSourceFiles )
    console.log( ` . SourceFile ${o.filePath}` );


    starter.sourcesMap[ _.path.nativize( o.filePath ) ] = sourceFile;
    if( sourceFile.isModuleDeclareFile )
    starter.moduleMainFilesMap[ starter.path.fullName( o.filePath ) ] = sourceFile;
    // starter.sourcesMap[ o.filePath ] = sourceFile;
    // if( sourceFile.isModuleDeclareFile )
    // starter.moduleMainFilesMap[ starter.path.fullName( o.filePath ) ] = sourceFile;
    // Object.preventExtensions( sourceFile );
    return sourceFile;

    /* - */

    function idGet()
    {
      return this.filePath;
    }

    function loadedGet()
    {
      return this.state === 'opened';
    }

    function getter( propName, onGet )
    {
      let property =
      {
        enumerable : true,
        configurable : true,
        get : onGet,
      }
      Object.defineProperty( sourceFile, propName, property );
    }

    function include( id )
    {
      let sourceFile = this;
      return SourceFile._load( id, sourceFile, false );
    }
  }

  SourceFile._load = function _load( request, parent, isMain )
  {
    return _starter_._sourceInclude( parent, parent.dirPath, request );
  }

  SourceFile._resolveFilename = function _resolveFilename( request, parent/*, isMain, options*/ )
  {
    return _starter_._sourceResolveAct( parent, parent.dirPath, request );
  }

  SourceFile.prototype = Object.create( null );

  SourceFile.prototype.load = function load( filename )
  {
    let module = this;
    return _starter_._sourceIncludeResolvedCalling( null, module, module.filePath )
  }

  //

  function _sourceMake( filePath, dirPath, nakedCall )
  {
    let r = SourceFile({ filePath, dirPath, nakedCall });
    return r;
  }

  //

  function _sourceIncludeResolvedCalling( parentSource, childSource, sourcePath )
  {
    let starter = this;

    try
    {

      if( !childSource )
      throw _._err({ args : [ `Found no source file ${sourcePath}` ], level : 4 });

      if( childSource.state === 'errored' || childSource.state === 'opening' || childSource.state === 'opened' )
      return end();

      childSource.parent = parentSource || null;

      childSource.state = 'opening';
      childSource.nakedCall();
      childSource.state = 'opened';

      if( Config.interpreter === 'njs' )
      starter._njsModuleFromSource( childSource );

    }
    catch( err )
    {
      err = _.err( err, `\nError including source file ${ childSource ? childSource.filePath : sourcePath }` );
      if( childSource )
      {
        childSource.error = err;
        childSource.state = 'errored';
      }
      throw err;
    }

    return end();

    function end()
    {
      if( !starter.requireCache[ childSource.filePath ] )
      starter.requireCache[ childSource.filePath ] = childSource;

      return childSource.exports;
    }
  }

  //

  function _sourceInclude( parentSource, basePath, filePath )
  {
    let starter = this;

    try
    {

      if( _.arrayIs( filePath ) )
      {
        let result = [];
        for( let f = 0 ; f < filePath.length ; f++ )
        {
          let r = starter._sourceInclude( parentSource, basePath, filePath[ f ] );
          if( r === undefined )
          result.push( r );
          else
          _.arrayAppendArrays( result, r );
        }
        return result;
      }

      if( !_starter_.withServer && _.path.isGlob( filePath ) ) /* xxx : workaround */
      {
        let resolvedFilePath = starter._pathResolveLocal( parentSource, basePath, filePath );
        let filtered = _.props.keys( _.path.globShortFilterKeys( starter.sourcesMap, resolvedFilePath ) );
        if( filtered.length )
        return starter._sourceInclude( parentSource, basePath, filtered );
      }
      else
      {
        let resolvedFilePath = this._pathResolveLocal( parentSource, basePath, filePath );
        let chachedSource = this.requireCache[ resolvedFilePath ];
        if( chachedSource )
        {
          _.assert( chachedSource.state === 'errored' || chachedSource.state === 'opening' || chachedSource.state === 'opened' )
          return chachedSource.exports;
        }
        // let childSource = starter._sourceForInclude.apply( starter, arguments );
        let childSource = this.sourcesMap[ resolvedFilePath ];
        if( childSource )
        return starter._sourceIncludeResolvedCalling( parentSource, childSource, filePath );
      }

      return starter._includeAct( parentSource, basePath, filePath );
    }
    catch( err )
    {
      err = _.err( err, `\nError including source file ${ filePath }` );
      throw err;
    }

  }

  //

  function _sourceResolve( parentSource, basePath, filePath )
  {
    let starter = this;
    let result = starter._sourceOwnResolve( parentSource, basePath, filePath );
    if( result !== null )
    return result;

    return starter._sourceResolveAct( parentSource, basePath, filePath );
  }

  //

  function _sourceOwnResolve( parentSource, basePath, filePath )
  {
    let starter = this;
    let childSource = starter._sourceForInclude.apply( starter, arguments );
    if( !childSource )
    return null;
    return childSource.filePath;
  }

  //

  function _sourceForPathGet( filePath )
  {
    filePath = this.path.canonizeTolerant( filePath );
    let childSource = this.sourcesMap[ filePath ];
    if( childSource )
    return childSource;
    return null;
  }

  //

  function _sourceForInclude( sourceFile, basePath, filePath )
  {
    let resolvedFilePath = this._pathResolveLocal( sourceFile, basePath, filePath );
    let childSource = this.sourcesMap[ resolvedFilePath ];
    if( childSource )
    return childSource;
    return null;
  }

  //

  function _pathResolveLocal( sourceFile, basePath, filePath )
  {
    let starter = this;

    if( sourceFile && !basePath )
    {
      basePath = sourceFile.dirPath;
    }

    if( !basePath && !sourceFile )
    {
      throw _.err( 'Base path is not specified, neither script file' );
    }

    let isAbsolute = filePath[ 0 ] === '/';
    let isDotted = _.strBegins( filePath, './' ) || _.strBegins( filePath, '../' ) || filePath === '.' || filePath === '..';

    if( !isDotted )
    filePath = starter.path.canonizeTolerant( filePath );

    if( isDotted && !isAbsolute )
    {
      filePath = starter.path.canonizeTolerant( basePath + '/' + filePath );
      if( filePath[ 0 ] !== '/' )
      filePath = './' + filePath;
    }

    if( !isDotted && !isAbsolute )
    {
      if( starter.moduleMainFilesMap[ filePath ] )
      return starter.moduleMainFilesMap[ filePath ].filePath;
      let filePathLower = filePath.toLowerCase();
      if( starter.moduleMainFilesMap[ filePathLower ] )
      return starter.moduleMainFilesMap[ filePathLower ].filePath;
    }

    return _.path.nativize( filePath );
    // return filePath;
  }

  //

  function _Setup()
  {

    if( this._inited )
    {
      return;
    }

    if( _starter_.catchingUncaughtErrors )
    {
      _starter_.error._setupUncaughtErrorHandler2();
      _starter_.error._setupUncaughtErrorHandler9();
    }

    this._SetupAct();

    this._inited = 1;
  }

;


  let Extension =
  {

    SourceFile,

    _sourceMake,
    _sourceIncludeResolvedCalling,
    _includeAct : null,
    _sourceInclude,
    _sourceResolveAct : null,
    _sourceResolve,
    _sourceOwnResolve,
    _sourceForPathGet,
    _sourceForInclude,

    _pathResolveLocal,

    _Setup,

    // fields

    redirectingConsole : null,
    _inited : false,

  }

  for( let k in Extension )
  if( _starter_[ k ] === undefined )
  _starter_[ k ] = Extension[ k ];

  _starter_._Setup();

;

/* */  /* end of starter */ })();


/* */  let _libraryFilePath_ = _starter_.path.canonizeTolerant( __filename );
/* */  let _libraryDirPath_ = _starter_.path.canonizeTolerant( __dirname );

/* */  /* begin of file Include_s */ ( function Include_s() { function Include_s_naked() { //#! /usr/bin/env node
( function _l0_Include_s_()
{

'use strict';

if( typeof module !== 'undefined' )
{
  module[ 'exports' ] = require( './Include7.s' );
  require( './l8/Setup.s' );
}

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/Include.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Include_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Include_s */ })();

/* */  /* begin of file Include1_s */ ( function Include1_s() { function Include1_s_naked() { //#! /usr/bin/env node
( function _l0_Include1_s_()
{

'use strict';

if( typeof module !== 'undefined' )
{

  require( './l0/l0/Global.s' );
  require( './l0/l3/Config.s' );
  require( './l0/l3/Predefined.s' );
  module[ 'exports' ] = require( './l0/l5/Setup.s' );

  require( './l1/1Diagnostic.s' );
  require( './l1/2Long.s' );
  require( './l1/2Props.s' );
  require( './l1/3Blank.s' );
  require( './l1/5ArgumentsArray.s' );
  require( './l1/5BufferTyped.s' );
  require( './l1/Array.s' );
  require( './l1/ArraySet.s' );
  require( './l1/Auxiliary.s' );
  require( './l1/BigInt.s' );
  require( './l1/Bool.s' );
  require( './l1/Buffer.s' );
  require( './l1/BufferBytes.s' );
  require( './l1/BufferNode.s' );
  require( './l1/BufferRaw.s' );
  require( './l1/BuffersTyped.s' );
  require( './l1/BufferView.s' );
  require( './l1/Class.s' );
  require( './l1/Constructible.s' );
  require( './l1/Container.s' );
  require( './l1/ContainerAdapter.s' );
  require( './l1/Countable.s' );
  require( './l1/Ct.s' );
  require( './l1/Date.s' );
  require( './l1/Entity.s' );
  require( './l1/Escape.s' );
  require( './l1/Event.s' );
  require( './l1/Functional.s' );
  require( './l1/Functor.s' );
  require( './l1/Fuzzy.s' );
  require( './l1/Global.s' );
  require( './l1/HashMap.s' );
  require( './l1/Interval.s' );
  require( './l1/Intervalc.s' );
  require( './l1/Intervall.s' );
  require( './l1/Intervalo.s' );
  require( './l1/Introspector.s' );
  require( './l1/Itself.s' );
  require( './l1/Logger.s' );
  require( './l1/Logic.s' );
  require( './l1/LogicNode.s' );
  require( './l1/Seeker.s' );
  require( './l1/Map.s' );
  require( './l1/Module.s' );
  require( './l1/Number.s' );
  require( './l1/Object.s' );
  require( './l1/Primitive.s' );
  require( './l1/Process.s' );
  require( './l1/Pair.s' );
  require( './l1/Path.s' );
  require( './l1/Printer.s' );
  require( './l1/PropertyTransformer.s' );
  require( './l1/Prototype.s' );
  require( './l1/Regexp.s' );
  require( './l1/Routine.s' );
  require( './l1/Set.s' );
  require( './l1/Sorted.s' );
  require( './l1/Str.s' );
  require( './l1/Stringer.s' );
  require( './l1/StrLines.s' );
  require( './l1/Symbol.s' );
  require( './l1/Time.s' );
  require( './l1/Type.s' );
  require( './l1/Units.s' );
  require( './l1/Unroll.s' );
  require( './l1/Vector.s' );
  require( './l1/Wrap.s' );
  require( './l1/zErr.s' );

}

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/Include1.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Include1_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Include1_s */ })();

/* */  /* begin of file Include3_s */ ( function Include3_s() { function Include3_s_naked() { //#! /usr/bin/env node
( function _l0_Include3_s_()
{

'use strict';

if( typeof module !== 'undefined' )
{
  module[ 'exports' ] = require( './Include1.s' );

  require( './l3/1Wrap.s' );
  require( './l3/1LogicNode.s' );
  require( './l3/2Props.s' );
  require( './l3/3Blank.s' );
  require( './l3/3Long.s' );
  require( './l3/3Path.s' );
  require( './l3/ArgumentsArray.s' );
  require( './l3/Array.s' );
  require( './l3/ArraySet.s' );
  require( './l3/Auxiliary.s' );
  require( './l3/Bool.s' );
  require( './l3/Buffer.s' );
  require( './l3/BuffersTyped.s' );
  require( './l3/BufferTyped.s' );
  require( './l3/Container.s' );
  require( './l3/ContainerAdapter.s' );
  require( './l3/Countable.s' );
  require( './l3/Diagnostic.s' );
  require( './l3/Entity.s' );
  require( './l3/Event.s' );
  require( './l3/Escape.s' );
  require( './l3/HashMap.s' );
  require( './l3/Itself.s' );
  require( './l3/Logic.s' );
  require( './l3/Map.s' );
  require( './l3/Module.s' );
  require( './l3/Number.s' );
  require( './l3/Object.s' );
  require( './l3/Primitive.s' );
  require( './l3/Process.s' );
  require( './l3/Regexp.s' );
  require( './l3/Routine.s' );
  require( './l3/Seeker.s' );
  require( './l3/Set.s' );
  require( './l3/Str.s' );
  require( './l3/Stringer.s' );
  require( './l3/Time.s' );
  require( './l3/Unroll.s' );
  require( './l3/Vector.s' );
  require( './l3/zErr.s' );

}

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/Include3.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Include3_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Include3_s */ })();

/* */  /* begin of file Include5_s */ ( function Include5_s() { function Include5_s_naked() { //#! /usr/bin/env node
( function _l0_Include5_s_()
{

'use strict';

if( typeof module !== 'undefined' )
{
  module[ 'exports' ] = require( './Include3.s' );

  require( './l5/1Seeker.s' );
  require( './l5/ArgumentsArray.s' );
  require( './l5/Array.s' );
  require( './l5/ArraySet.s' );
  require( './l5/Auxiliary.s' );
  require( './l5/BigInt.s' );
  require( './l5/Bool.s' );
  require( './l5/Buffer.s' );
  require( './l5/Constructible.s' );
  require( './l5/Container.s' );
  require( './l5/Countable.s' );
  require( './l5/Ct.s' );
  require( './l5/Date.s' );
  require( './l5/Diagnostic.s' );
  require( './l5/Entity.s' );
  require( './l5/Err.s' );
  require( './l5/Escape.s' );
  require( './l5/Event.s' );
  require( './l5/Functional.s' );
  require( './l5/Fuzzy.s' );
  require( './l5/Global.s' );
  require( './l5/HashMap.s' );
  require( './l5/Interval.s' );
  require( './l5/Intervalc.s' );
  require( './l5/Intervall.s' );
  require( './l5/Intervalo.s' );
  require( './l5/Introspector.s' );
  require( './l5/Itself.s' );
  require( './l5/Logic.s' );
  require( './l5/Long.s' );
  require( './l5/Map.s' );
  require( './l5/Number.s' );
  require( './l5/Object.s' );
  require( './l5/Pair.s' );
  require( './l5/Path.s' );
  require( './l5/Permutation.s' );
  require( './l5/Primitive.s' );
  require( './l5/Printer.s' );
  require( './l5/Process.s' );
  require( './l5/Props.s' );
  require( './l5/PropertyTransformer.s' );
  require( './l5/Prototype.s' );
  require( './l5/Regexp.s' );
  require( './l5/Routine.s' );
  require( './l5/Set.s' );
  require( './l5/Sorted.s' );
  require( './l5/Str.s' );
  require( './l5/Stringer.s' );
  require( './l5/Symbol.s' );
  require( './l5/Time.s' );
  require( './l5/Type.s' );
  require( './l5/Units.s' );
  require( './l5/Unroll.s' );
  require( './l5/Vector.s' );
  require( './l5/zModule.s' );

}

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/Include5.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Include5_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Include5_s */ })();

/* */  /* begin of file Include7_s */ ( function Include7_s() { function Include7_s_naked() { //#! /usr/bin/env node
( function _l0_Include7_s_()
{

'use strict';

if( typeof module !== 'undefined' )
{
  module[ 'exports' ] = require( './Include5.s' );

  // require( './l6/l1/LongDescriptor.s' );
  // require( './l6/l3/Compose.s' );
  // require( './l6/l3/PropertyTransformers.s' );
  // require( './l6/l3/LongContext.s' );

  require( './l6/Compose.s' );
  require( './l6/PropertyTransformers.s' );

  require( './l7/ArgumentsArray.s' );
  require( './l7/Array.s' );
  require( './l7/ArraySet.s' );
  require( './l7/Auxiliary.s' );
  require( './l7/BigInt.s' );
  require( './l7/Bool.s' );
  require( './l7/Buffer.s' );
  require( './l7/Constructible.s' );
  require( './l7/Container.s' );
  require( './l7/Countable.s' );
  require( './l7/Ct.s' );
  require( './l7/Date.s' );
  require( './l7/Diagnostic.s' );
  require( './l7/Entity.s' );
  require( './l7/Err.s' );
  require( './l7/Escape.s' );
  require( './l7/Event.s' );
  require( './l7/Functional.s' );
  require( './l7/Fuzzy.s' );
  require( './l7/Global.s' );
  require( './l7/HashMap.s' );
  require( './l7/Interval.s' );
  require( './l7/Intervalc.s' );
  require( './l7/Intervall.s' );
  require( './l7/Intervalo.s' );
  require( './l7/Introspector.s' );
  require( './l7/Logic.s' );
  require( './l7/Seeker.s' );
  require( './l7/Long.s' );
  require( './l7/Map.s' );
  require( './l7/Module.s' );
  require( './l7/Number.s' );
  require( './l7/Object.s' );
  require( './l7/Pair.s' );
  require( './l7/Path.s' );
  require( './l7/Primitive.s' );
  require( './l7/Printer.s' );
  require( './l7/Process.s' );
  require( './l7/Props.s' );
  require( './l7/PropertyTransformer.s' );
  require( './l7/Prototype.s' );
  require( './l7/Regexp.s' );
  require( './l7/Routine.s' );
  require( './l7/Set.s' );
  require( './l7/Sorted.s' );
  require( './l7/Str.s' );
  require( './l7/Stringer.s' );
  require( './l7/Symbol.s' );
  require( './l7/Time.s' );
  require( './l7/Type.s' );
  require( './l7/Units.s' );
  require( './l7/Unroll.s' );
  require( './l7/Vector.s' );

}

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/Include7.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Include7_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Include7_s */ })();

/* */  /* begin of file Global_s */ ( function Global_s() { function Global_s_naked() { ( function _Global_s_()
{

'use strict';

// global

let _global = get();
if( !_global._globals_ )
{
  _global._globals_ = Object.create( null );
  _global._globals_.real = _global._realGlobal_ || _global;
  _global._realGlobal_ = _global;
  _global._global_ = _global;
}

//

function get()
{
  let _global = undefined;
  if( typeof _global_ !== 'undefined' && _global_._global_ === _global_ )
  _global = _global_;
  else if( typeof globalThis !== 'undefined' && globalThis.globalThis === globalThis )
  _global = globalThis;
  else if( typeof Global !== 'undefined' && Global.Global === Global )
  _global = Global;
  else if( typeof global !== 'undefined' && global.global === global )
  _global = global;
  else if( typeof window !== 'undefined' && window.window === window )
  _global = window;
  else if( typeof self   !== 'undefined' && self.self === self )
  _global = self;
  return _global;
}

//

function _new( name, global )
{

  if( _realGlobal_._globals_[ name ] )
  throw Error( `Global namespace::${name} already exists!` );

  let global2 = _realGlobal_._globals_[ name ] = Object.create( global || _realGlobal_ );
  global2.__GLOBAL_NAME__ = name;
  global2.wTools = Object.create( null );
  global2.wTools.global = Object.create( null );
  global2.wTools.global.current = global2;
  global2.wTools.module = Object.create( null );
  global2.wTools.module.nativeFilesMap = Object.create( null );

  for( let name in ModuleFileNative._cache )
  {
    if( filePathIsBin( name ) )
    global2.wTools.module.nativeFilesMap[ name ] = ModuleFileNative._cache[ name ];
  }

  return global2;
}

//

function open( name )
{

  if( !_global_.wTools.global.current )
  throw Error( 'Global namespace is not setup' );
  if( !_global_.wTools.module.nativeFilesMap )
  throw Error( 'Global namespace is not setup' );

  if( !_globals_[ name ] )
  throw Error( `Global namespace::${name} deos not exist!` );
  if( !_global_.__GLOBAL_NAME__ )
  throw Error( `Current global namespace deos not have name!` );
  if( _global_.wTools.module.nativeFilesMap !== ModuleFileNative._cache )
  throw Error( `Current global have native module files map of different global` );

  _realGlobal_.wTools.global._stack.push
  ({
    name : _global_.__GLOBAL_NAME__,
    global : _global_,
    moduleNativeFilesMap : ModuleFileNative._cache,
  });

  let global2 = _globals_[ name ];
  _realGlobal_._global_ = global2;
  ModuleFileNative._cache = global2.wTools.module.nativeFilesMap;

  return global2;
}

//

function makeAndOpen( module, name )
{
  const _global = __.global.new( name, _global_ );
  __.global.open( name );
  __.module.fileSetEnvironment( module, name );
  return _global;
}

//

function close( name )
{

  if( name !== _global_.__GLOBAL_NAME__ )
  throw Error( `Current global is ${_global_.__GLOBAL_NAME__}, not ${name}` );
  if( _global_.wTools.module.nativeFilesMap !== ModuleFileNative._cache )
  throw Error( `Current global have native module files map of different global` );
  if( !_realGlobal_.wTools.global._stack.length )
  throw Error( `Nothing to close` );

  let was = _realGlobal_.wTools.global._stack.pop();
  ModuleFileNative._cache = was.moduleNativeFilesMap;
  _realGlobal_._global_ = was.global;
}

//

function fileSetEnvironment( moduleFile, name )
{
  let moduleNativeFile = __.module.fileNativeFrom( moduleFile );
  let global2 = _globals_[ name ];

  if( name === null )
  {
    moduleNativeFile._virtualEnvironment = null;
    return;
  }

  if( !!moduleNativeFile._virtualEnvironment )
  throw Error( `Module already have virtual environment ${moduleNativeFile._virtualEnvironment.name}` );
  if( !_globals_[ name ] )
  throw Error( `Global namespace::${name} deos not exist!` );
  if( !global2.wTools.module.nativeFilesMap )
  throw Error( `Global namespace::${name} deos not have defined module.nativeFilesMap!` );

  let env = moduleNativeFile._virtualEnvironment = Object.create( null );
  env.name = global2.__GLOBAL_NAME__;
  env.global = global2;
  env.moduleNativeFilesMap = global2.wTools.module.nativeFilesMap;

  // /* yyy */
  // debugger;

  // let moduleFileName = moduleNativeFile.filename || moduleNativeFile.id;
  // if( global2.wTools.module.nativeFilesMap[ moduleFileName ] && global2.wTools.module.nativeFilesMap[ moduleFileName ] !== moduleNativeFile )
  // throw Error( `Namespace::${name} already has native module file :: ${moduleFileName} in nativeFilesMap` );
  // global2.wTools.module.nativeFilesMap[ moduleFileName ] = moduleNativeFile;

  // if( global2.wTools.module.filesMap && moduleNativeFile.universal && global2.wTools.path && global2.wTools.path.canonize )
  // {
  //   let moduleFileName2 = global2.wTools.path.canonize( moduleFileName );
  //   if( global2.wTools.module.filesMap[ moduleFileName2 ] && global2.wTools.module.filesMap[ moduleFileName2 ] !== moduleNativeFile.universal )
  //   throw Error( `Namespace::${name} already has universal module file :: ${moduleFileName2} in filesMap` );
  //   global2.wTools.module.filesMap[ moduleFileName2 ] = moduleNativeFile;
  // }

}

//

function fileResetEnvironment( moduleFile, name )
{
  let moduleNativeFile = __.module.fileNativeFrom( moduleFile );

  if( !moduleNativeFile._virtualEnvironment )
  throw Error( `Module deos not have virtual environment` );
  if( moduleNativeFile._virtualEnvironment.name !== name )
  throw Error( `Not global::${name} is not associated global` )

  delete moduleNativeFile._virtualEnvironment;

}

//

function setup( global, name )
{

  if( !name )
  throw Error( 'Expects name of the global' );
  if( Object.hasOwnProperty.call( global, '__GLOBAL_NAME__' ) && global.__GLOBAL_NAME__ !== name )
  throw Error( `The global have name ${global.__GLOBAL_NAME__}, not ${name}` );
  global.__GLOBAL_NAME__ = Object.hasOwnProperty.call( global, '__GLOBAL_NAME__' ) ? global.__GLOBAL_NAME__ : name;

  global.wTools = Object.hasOwnProperty.call( global, 'wTools' ) ? global.wTools : Object.create( null );

  global.wTools.global = global.wTools.global || Object.create( null );
  if( global.wTools.global.current && global.wTools.global.current !== global )
  throw Error( 'The global refers to different global. Something wrong!' );
  global.wTools.global.current = global.wTools.global.current || global;

  global.wTools.module = global.wTools.module || Object.create( null );
  if( typeof module !== 'undefined' )
  if( typeof module !== 'undefined' )
  global.wTools.module.nativeFilesMap = global.wTools.module.nativeFilesMap || require( 'module' )._cache;

  if( !global.wTools.module.rootFileNative )
  {
    let rootFileNative = global.wTools.module.rootFileNative = module;
    while( __.module.fileNativeParent( rootFileNative ) )
    rootFileNative = __.module.fileNativeParent( rootFileNative );
    global.wTools.module.rootFileNative = rootFileNative;
  }

  const ModuleFileNative = require( 'module' );
  if( !global.wTools.module.nativeFilesMap )
  global.wTools.module.nativeFilesMap = ModuleFileNative._cache;

}

//

/* qqq xxx : cover */
function fileNativeIs( src )
{
  if( !src )
  return false;
  if( !ModuleFileNative )
  return true;
  return src instanceof ModuleFileNative;
}

//

/* qqq xxx : cover */
function fileUniversalIs( src )
{
  if( !src )
  return false;
  if( Reflect.hasOwnProperty( src, 'constructor' ) )
  return false;
  return src[ ModuleFileSymbol ] === true;
}

//

function fileNativeFrom( src )
{
  if( __.module.fileNativeIs( src ) )
  return src;
  if( __.module.fileUniversalIs( src ) )
  return src.moduleNativeFile || undefined;
  return undefined;
}

//

function fileNativeParent( file )
{
  if( file.parent && file.parent.id !== undefined )
  return file.parent;
}

//

function filePathIsBin( filePath )
{
  const regexp = /\.node$/;
  return regexp.test( filePath );
}

//

const ModuleFileSymbol = Symbol.for( 'ModuleFile' );
const ModuleFileNative = typeof module !== 'undefined' ? require( 'module' ) : null;
const __ = _realGlobal_.wTools = _realGlobal_.wTools || Object.create( null );
__.global = __.global || Object.create( null );
__.module = __.module || Object.create( null );

__.global._stack = __.global._stack || [];
__.global.get = __.global.get || get;
__.global.new = __.global.new || _new;
__.global.open = __.global.open || open;
__.global.makeAndOpen = __.global.makeAndOpen || makeAndOpen;
__.global.close = __.global.close || close;
__.global.setup = __.global.setup || setup;

__.module.fileSetEnvironment = __.module.fileSetEnvironment || fileSetEnvironment;
__.module.fileResetEnvironment = __.module.fileResetEnvironment || fileResetEnvironment;
__.module.fileNativeIs = __.module.fileNativeIs || fileNativeIs;
__.module.fileUniversalIs = __.module.fileUniversalIs || fileUniversalIs;
__.module.fileNativeFrom = __.module.fileNativeFrom || fileNativeFrom;
__.module.fileNativeParent = __.module.fileNativeParent || fileNativeParent;
__.module.filePathIsBin = __.module.filePathIsBin || filePathIsBin;

if( _global_ === _realGlobal_ )
__.global.setup( _realGlobal_, 'real' );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l0/l0/Global.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l0/l0' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Global_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Global_s */ })();

/* */  /* begin of file Config_s */ ( function Config_s() { function Config_s_naked() { ( function _Config_s_()
{

'use strict';

// real global

if( !_realGlobal_.Config )
_realGlobal_.Config = { debug : true }
if( _realGlobal_.Config.debug === undefined )
_realGlobal_.Config.debug = true;
if( _realGlobal_.Config.interpreter === undefined )
if( ( ( typeof module !== 'undefined' ) && ( typeof process !== 'undefined' ) ) )
_realGlobal_.Config.interpreter = 'njs';
else
_realGlobal_.Config.interpreter = 'browser';
if( _realGlobal_.Config.isWorker === undefined )
if( typeof self !== 'undefined' && self.self === self && typeof importScripts !== 'undefined' )
_realGlobal_.Config.isWorker = true;
else
_realGlobal_.Config.isWorker = false;

// current global

if( !_global_.Config )
_global_.Config = Object.create( _realGlobal_.Config )
if( _global_.Config.debug === undefined )
_global_.Config.debug = true;
if( _global_.Config.interpreter === undefined )
_global_.Config.interpreter = _realGlobal_.Config.interpreter;
if( _global_.Config.isWorker === undefined )
_global_.Config.isWorker = _realGlobal_.Config.isWorker

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l0/l3/Config.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Config_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Config_s */ })();

/* */  /* begin of file Predefined_s */ ( function Predefined_s() { function Predefined_s_naked() { ( function _Predefined_s_()
{

'use strict';

// global

const _global = _global_;

// verification

if( _global_.__GLOBAL_NAME__ === 'real' )
{
  if( _global_.wTools && _global_.wTools.Module )
  {
    debugger;
    throw new Error( 'module::wTools was included several times' );
  }
}

// setup current global namespace

if( !_global.__GLOBAL_NAME__ )
throw Error( 'Current global does not have name. Something wrong!' );

const Self = _global.wTools;
let _ = Self;
Self.__GLOBAL_NAME__ = _global.__GLOBAL_NAME__;
Self.tools = Self;

// name conflict

// if( _global_.__GLOBAL_NAME__ === 'real' )
// if( _global_._ )
// {
//   _global_.Underscore = _global_._;
//   delete _global_._;
// }

// special tokens

Self.def = Symbol.for( 'def' );
Self.null = Symbol.for( 'null' );
Self.undefined = Symbol.for( 'undefined' );
Self.void = Symbol.for( 'void' );
Self.nothing = Symbol.for( 'nothing' );
Self.anything = Symbol.for( 'anything' );
Self.maybe = Symbol.for( 'maybe' );
Self.unknown = Symbol.for( 'unknown' );
Self.dont = Symbol.for( 'dont' );
// Self.unroll = Symbol.for( 'unroll' ); /* xxx : qqq : ask */
Self.self = Symbol.for( 'self' );
Self.optional = Symbol.for( 'optional' );

// type aliases

_realGlobal_.U64x = BigUint64Array;
_realGlobal_.U32x = Uint32Array;
_realGlobal_.U16x = Uint16Array;
_realGlobal_.U8x = Uint8Array;
_realGlobal_.U8xClamped = Uint8ClampedArray;
_realGlobal_.Ux = _realGlobal_.U32x;

_realGlobal_.I64x = BigInt64Array;
_realGlobal_.I32x = Int32Array;
_realGlobal_.I16x = Int16Array;
_realGlobal_.I8x = Int8Array;
_realGlobal_.Ix = _realGlobal_.I32x;

_realGlobal_.F64x = Float64Array;
_realGlobal_.F32x = Float32Array;
_realGlobal_.Fx = _realGlobal_.F32x;

if( typeof Buffer !== 'undefined' )
_realGlobal_.BufferNode = Buffer;
_realGlobal_.BufferRaw = ArrayBuffer;
if( typeof SharedArrayBuffer !== 'undefined' )
_realGlobal_.BufferRawShared = SharedArrayBuffer;
_realGlobal_.BufferView = DataView;

_realGlobal_.HashMap = Map;
_realGlobal_.HashMapWeak = WeakMap;

// --
// export
// --

// _global[ 'wTools' ] = Self;
_global.wTools = Self;
// _global.wBase = Self;

// if( typeof module !== 'undefined' )
// module[ 'exports' ] = Self;

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l0/l3/Predefined.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Predefined_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Predefined_s */ })();

/* */  /* begin of file Setup_s */ ( function Setup_s() { function Setup_s_naked() { ( function _Setup_s_()
{

'use strict';

/**
  Collection of general purpose tools for solving problems. Fundamentally extend JavaScript without spoiling namespace, so may be used solely or in conjunction with another module of such kind. Tools contain hundreds of routines to operate effectively with Array, SortedArray, Map, RegExp, Buffer, Time, String, Number, Routine, Error and other fundamental types. The module provides advanced tools for diagnostics and errors handling. Use it to have a stronger foundation for the application.
  @module Tools/base/Fundamental
*/

/**
 * wTools - Generic purpose tools of base level for solving problems in Java Script.
 * @namespace Tools
 * @module Tools/base/Fundamental
 */

const _global = _global_;
const _ = _global.wTools;
const Self = _.setup = _.setup || Object.create( null );

_.error = _.error || Object.create( null );
_.process = _.process || Object.create( null );

// --
// setup
// --

function _handleUncaught1()
{

  debugger;
  let args = _.error._handleUncaughtHead( arguments );
  let result = _.error._handleUncaught2.apply( this, args );

  if( _.error._handleUncaught0 )
  _.error._handleUncaught0.apply( this, arguments );

  return result;
}

//

function _handleUncaughtPromise1( err, promise )
{
  let o = Object.create( null );
  o.promise = promise;
  o.err = err;
  o.origination = 'uncaught promise error';
  let result = _.error._handleUncaught2.call( this, o );
  return result;
}

//

function _handleUncaught2( o )
{
  return _.error._handleUncaught2Minimal( o );
}

//

function _handleUncaught2Minimal( o )
{
  if( !o.origination )
  o.origination = 'uncaught error';
  o.prefix = `--------------- ${o.origination} --------------->\n`;
  o.postfix = `--------------- ${o.origination} ---------------<\n`;
  let errStr = o.err.toString();

  try
  {
    errStr = o.err.toString();
  }
  catch( err2 )
  {
    debugger;
    console.error( err2 );
  }

  console.error( o.prefix );
  console.error( errStr );
  console.error( '' );
  console.error( `_realGlobal_._setupUncaughtErrorHandlerDone : ${_realGlobal_._setupUncaughtErrorHandlerDone}` );
  console.error( '' );
  console.error( o.err ? o.err.stack : '' );
  console.error( o.postfix );

  processExit();

  /* */

  function processExit()
  {
    try
    {
      if( _global.process )
      {
        if( !process.exitCode )
        process.exitCode = -1;
      }
    }
    catch( err2 )
    {
    }
  }

}

//

function _setupUncaughtErrorHandler2()
{

  if( _realGlobal_._setupUncaughtErrorHandlerDone )
  return;

  _realGlobal_._setupUncaughtErrorHandlerDone = 1;

  if( _realGlobal_.process && typeof _realGlobal_.process.on === 'function' )
  {

    _realGlobal_.process.on( 'uncaughtException', _.error._handleUncaught1 );
    _realGlobal_.process.on( 'unhandledRejection', _.error._handleUncaughtPromise1 );
    _.error._handleUncaughtHead = _handleUncaughtHeadNode;
    if( Config.interpreter === 'browser' )
    _.error._handleUncaughtHead = _handleUncaughtHeadBrowser;
  }
  else if( Object.hasOwnProperty.call( _realGlobal_, 'onerror' ) )
  {
    _.error._handleUncaught0 = _realGlobal_.onerror;
    _realGlobal_.onerror = _.error._handleUncaught1;
    _.error._handleUncaughtHead = _handleUncaughtHeadBrowser;
  }

  /* */

  function _handleUncaughtHeadBrowser( args )
  {
    debugger;
    let [ message, sourcePath, lineno, colno, error ] = args;
    let err = error || message;
    return [ { err : new Error( args[ 0 ] ), args } ];
  }

  /* */

  function _handleUncaughtHeadNode( args )
  {
    return [ { err : args[ 0 ], args } ];
  }

  /* */

}

//

function _setup2()
{

  _.error._setupUncaughtErrorHandler2();

}

// --
// extend
// --

let ErrorExtension =
{

  _handleUncaughtHead : null,
  _handleUncaught0 : null,
  _handleUncaught1,
  _handleUncaughtPromise1,
  _handleUncaught2,
  _handleUncaught2Minimal,

  _setupUncaughtErrorHandler2,
  _setup2,

}

let SetupExtension =
{

}

Object.assign( _.error, ErrorExtension );
Object.assign( _.setup, SetupExtension );

_.error._setup2();

if( typeof module !== 'undefined' )
module[ 'exports' ] = _;

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l0/l5/Setup.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Setup_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Setup_s */ })();

/* */  /* begin of file _1Diagnostic_s */ ( function _1Diagnostic_s() { function _1Diagnostic_s_naked() { ( function _l1_1Diagnostic_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.diagnostic = _.diagnostic || Object.create( null );

// --
//
// --

function _err()
{
  return new Error( ... arguments );
}

// --
// surer
// --

/* xxx : solve problem exporting routines using __boolLike */
function __boolLike( src )
{
  let type = Object.prototype.toString.call( src );
  return type === '[object Boolean]' || type === '[object Number]';
}

//

function _sureDebugger( condition )
{
  if( !_.error.breakpointOnAssertEnabled )
  return;
  debugger; /* eslint-disable-line no-debugger */
}

//

function sure( condition, ... args )
{

  if( !condition || !__boolLike( condition ) )
  {
    _sureDebugger( condition );
    if( !_._err )
    throw Error( ... args );
    if( arguments.length === 1 )
    throw _._err
    ({
      args : [ 'Assertion fails' ],
      level : 2,
    });
    else if( arguments.length === 2 )
    throw _._err
    ({
      args : [ arguments[ 1 ] ],
      level : 2,
    });
    else
    throw _._err
    ({
      args : Array.prototype.slice.call( arguments, 1 ),
      level : 2,
    });
  }

  return;
}

//

function sureBriefly( condition, ... args )
{

  if( !condition || !__boolLike( condition ) )
  {
    _sureDebugger( condition );
    if( !_._err )
    throw Error( ... args );
    if( arguments.length === 1 )
    throw _._err
    ({
      args : [ 'Assertion fails' ],
      level : 2,
      brief : 1,
    });
    else if( arguments.length === 2 )
    throw _._err
    ({
      args : [ arguments[ 1 ] ],
      level : 2,
      brief : 1,
    });
    else
    throw _._err
    ({
      args : Array.prototype.slice.call( arguments, 1 ),
      level : 2,
      brief : 1,
    });
  }

  return;
}

//

function sureWithoutDebugger( condition, ... args )
{

  if( !condition || !__boolLike( condition ) )
  {
    if( !_._err )
    throw Error( ... args );
    if( arguments.length === 1 )
    throw _._err
    ({
      args : [ 'Assertion fails' ],
      level : 2,
    });
    else if( arguments.length === 2 )
    throw _._err
    ({
      args : [ arguments[ 1 ] ],
      level : 2,
    });
    else
    throw _._err
    ({
      args : Array.prototype.slice.call( arguments, 1 ),
      level : 2,
    });
  }

  return;
}

// --
//
// --

/**
 * Checks condition passed by argument( condition ). Works only in debug mode. Uses StackTrace level 2.
 *
 * @see {@link wTools.err err}
 *
 * If condition is true routine returns without exceptions, otherwise routine generates and throws exception. By default generates error with message 'Assertion fails'.
 * Also generates error using message(s) or existing error object(s) passed after first argument.
 *
 * @param {*} condition - condition to check.
 * @param {String|Error} [ msgs ] - error messages for generated exception.
 *
 * @example
 * let x = 1;
 * _.assert( _.strIs( x ), 'incorrect variable type->', typeof x, 'Expects string' );
 *
 * // log
 * // caught eval (<anonymous>:2:8)
 * // incorrect variable type-> number expects string
 * // Error
 * //   at _err (file:///.../wTools/staging/Base.s:3707)
 * //   at assert (file://.../wTools/staging/Base.s:4041)
 * //   at add (<anonymous>:2)
 * //   at <anonymous>:1
 *
 * @example
 * function add( x, y )
 * {
 *   _.assert( arguments.length === 2, 'incorrect arguments count' );
 *   return x + y;
 * }
 * add();
 *
 * // log
 * // caught add (<anonymous>:3:14)
 * // incorrect arguments count
 * // Error
 * //   at _err (file:///.../wTools/staging/Base.s:3707)
 * //   at assert (file://.../wTools/staging/Base.s:4035)
 * //   at add (<anonymous>:3:14)
 * //   at <anonymous>:6
 *
 * @example
 *   function divide ( x, y )
 *   {
 *      _.assert( y != 0, 'divide by zero' );
 *      return x / y;
 *   }
 *   divide( 3, 0 );
 *
 * // log
 * // caught     at divide (<anonymous>:2:29)
 * // divide by zero
 * // Error
 * //   at _err (file:///.../wTools/staging/Base.s:1418:13)
 * //   at wTools.errLog (file://.../wTools/staging/Base.s:1462:13)
 * //   at divide (<anonymous>:2:29)
 * //   at <anonymous>:1:1
 * @throws {Error} If passed condition( condition ) fails.
 * @function assert
 * @namespace Tools
 */

//

function assert( condition, ... args )
{

  if( Config.debug === false )
  return true;

  if( condition !== true )
  {
    _assertDebugger( condition, arguments );
    if( !_._err )
    throw Error( ... args );
    if( arguments.length === 1 )
    throw _._err
    ({
      args : [ 'Assertion fails' ],
      level : 2,
    });
    else if( arguments.length === 2 )
    throw _._err
    ({
      args : [ arguments[ 1 ] ],
      level : 2,
    });
    else
    throw _._err
    ({
      args : Array.prototype.slice.call( arguments, 1 ),
      level : 2,
    });
  }

  return true;

  function _assertDebugger( condition, args )
  {
    if( !_.error.breakpointOnAssertEnabled )
    return;
    debugger; /* eslint-disable-line no-debugger */
  }

}

//

function assertWithoutBreakpoint( condition, ... args )
{

  if( Config.debug === false )
  return true;

  if( !condition || !__boolLike( condition ) )
  {
    if( !_._err )
    throw Error( ... args );
    if( arguments.length === 1 )
    throw _._err
    ({
      args : [ 'Assertion fails' ],
      level : 2,
    });
    else if( arguments.length === 2 )
    throw _._err
    ({
      args : [ arguments[ 1 ] ],
      level : 2,
    });
    else
    throw _._err
    ({
      args : Array.prototype.slice.call( arguments, 1 ),
      level : 2,
    });
  }

  return;
}

//

function assertNotTested( src )
{
  _.assert( false, 'not tested : ' + stack( 1 ) );
}

//

/**
 * If condition failed, routine prints warning messages passed after condition argument
 * @example
 * function checkAngles( a, b, c )
 * {
 *    _.assertWarn( (a + b + c) === 180, 'triangle with that angles does not exists' );
 * };
 * checkAngles( 120, 23, 130 );
 *
 * // log 'triangle with that angles does not exists'
 *
 * @param condition Condition to check.
 * @param messages messages to print.
 * @function assertWarn
 * @namespace Tools
 */

function assertWarn( condition )
{

  if( Config.debug )
  return;

  if( !condition || !__boolLike( condition ) )
  {
    console.warn.apply( console, [].slice.call( arguments, 1 ) );
  }

}

// --
// declare
// --

if( Config.debug )
Object.defineProperty( _, 'debugger',
{
  enumerable : false,
  configurable : true,
  set : function( val )
  {
    let debuggerSymbol = Symbol.for( 'debugger' );
    if( _[ debuggerSymbol ] === val )
    return;
    _[ debuggerSymbol ] = val;
    for( let k in _globals_ )
    if( _globals_[ k ].wTools[ debuggerSymbol ] !== val )
    _globals_[ k ].wTools[ debuggerSymbol ] = val;
  },
  get : function()
  {
    let debuggerSymbol = Symbol.for( 'debugger' );
    let val = _[ debuggerSymbol ];
    if( val )
    debugger; /* eslint-disable-line no-debugger */
    return val;
  },
});

// --
// diagnostic extension
// --

let DiagnosticExtension =
{

  // sure

  sure,
  sureBriefly,
  sureWithoutDebugger,

  // assert

  assert,
  assertWithoutBreakpoint,
  assertNotTested,
  assertWarn,

}

//

Object.assign( _.diagnostic, DiagnosticExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  //

  _err,

  // sure

  sure,
  sureBriefly,
  sureWithoutDebugger,

  // assert

  assert,
  assertWithoutBreakpoint,
  assertNotTested,
  assertWarn,

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/1Diagnostic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _1Diagnostic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _1Diagnostic_s */ })();

/* */  /* begin of file _2Long_s */ ( function _2Long_s() { function _2Long_s_naked() { ( function _l1_Long_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( _.long === undefined );
_.assert( _.withLong === undefined );
_.long = _.long || Object.create( null );
_.long.namespaces = _.long.namespaces || Object.create( null );
_.long.toolsNamespacesByType = _.long.toolsNamespacesByType || Object.create( null );
_.long.toolsNamespacesByName = _.long.toolsNamespacesByName || Object.create( null );
_.long.toolsNamespaces = _.long.toolsNamespacesByName;
_.withLong = _.long.toolsNamespacesByType;

// --
// dichotomy
// --

/**
 * The routine longIs() determines whether the passed value is an array-like or an Array.
 * Imortant : longIs returns false for Object, even if the object has length field.
 *
 * If {-srcMap-} is an array-like or an Array, true is returned,
 * otherwise false is.
 *
 * @param { * } src - The object to be checked.
 *
 * @example
 * _.longIs( [ 1, 2 ] );
 * // returns true
 *
 * @example
 * _.longIs( 10 );
 * // returns false
 *
 * @example
 * let isArr = ( function() {
 *   return _.longIs( arguments );
 * } )( 'Hello there!' );
 * // returns true
 *
 * @returns { boolean } Returns true if {-srcMap-} is an array-like or an Array.
 * @function longIs.
 * @namespace Tools
 */

// function is( src )
// {
//   if( Array.isArray( src ) )
//   return true
//   if( _.bufferTyped.is( src ) )
//   return true;
//   if( Object.prototype.toString.call( src ) === '[object Arguments]' )
//   return true;
//
//   return false;
// }

function is_functor()
{
  let result;
  const TypedArray = Object.getPrototypeOf( Int8Array );
  //const iteratorSymbol = Symbol.iterator;

  if( _global_.BufferNode )
  result = isNjs;
  else
  result = isBrowser;
  result.functor = is_functor;
  return result;

  function isNjs( src )
  {
    if( Array.isArray( src ) )
    return true

    if( src instanceof TypedArray )
    {
      if( src instanceof BufferNode )
      return false;
      return true;
    }
    isNjs.functor = is_functor;

    // if( arguments[ iteratorSymbol ] === undefined )
    // return false;
    if( Object.prototype.toString.call( src ) === '[object Arguments]' )
    return true;

    return false;
  }

  function isBrowser( src )
  {
    if( Array.isArray( src ) )
    return true

    if( src instanceof TypedArray )
    return true;

    // if( arguments[ iteratorSymbol ] === undefined )
    // return false;
    if( Object.prototype.toString.call( src ) === '[object Arguments]' )
    return true;

    return false;
  }
  isBrowser.functor = is_functor;

}

const is = is_functor();

//

function isOld( src )
{

  if( _.primitive.is( src ) )
  return false;
  if( !_.class.methodIteratorOf( src ) )
  return false;

  if( _.argumentsArray.like( src ) )
  return true;
  if( _.bufferTyped.is( src ) )
  return true;

  return false;
}

//

function isCompact( src )
{
  if( _.argumentsArray.like( src ) )
  return true;
  if( _.bufferTyped.is( src ) )
  return true;

  return false;
}

//

function isUnfolded( src )
{
  if( Object.prototype.toString.call( src ) === '[object Arguments]' )
  return true;
  if( Array.isArray( src ) )
  return true
  if( _.bufferTyped.is( src ) )
  return true;

  return false;
}

//

function isUnfoldedSmartOrder( src )
{
  if( Array.isArray( src ) )
  return true
  if( _.bufferTyped.is( src ) )
  return true;
  // if( !arguments[ Symbol.iterator ] )
  // return false;
  if( Object.prototype.toString.call( src ) === '[object Arguments]' )
  return true;

  return false;
}

//

function isUnfoldedSmarter_functor()
{

  const TypedArray = Object.getPrototypeOf( Int8Array );
  //const iteratorSymbol = Symbol.iterator;

  if( _global_.BufferNode )
  return isUnfoldedSmarterNjs;
  return isUnfoldedSmarterBrowser;

  function isUnfoldedSmarterNjs( src )
  {
    if( Array.isArray( src ) )
    return true

    if( src instanceof TypedArray )
    {
      if( src instanceof BufferNode )
      return false;
      return true;
    }

    // if( arguments[ iteratorSymbol ] === undefined )
    // return false;
    if( Object.prototype.toString.call( src ) === '[object Arguments]' )
    return true;

    return false;
  }

  function isUnfoldedSmarterBrowser( src )
  {
    if( Array.isArray( src ) )
    return true

    if( src instanceof TypedArray )
    return true;

    // if( arguments[ iteratorSymbol ] === undefined )
    // return false;
    if( Object.prototype.toString.call( src ) === '[object Arguments]' )
    return true;

    return false;
  }

}

const isUnfoldedSmarter = isUnfoldedSmarter_functor();

// function is( src )
// {
//
//   if( _.primitive.is( src ) )
//   return false;
//   if( _.argumentsArray.like( src ) )
//   return true;
//   if( _.bufferTypedIs( src ) )
//   return true;
//
//   return false;
// }

//

function isEmpty( src )
{
  if( !_.long.is( src ) )
  return false;
  return src.length === 0;
}

//

function isPopulated( src )
{
  if( !_.long.is( src ) )
  return false;
  return src.length > 0;
}

//

function like( src ) /* qqq : cover */
{
  if( _.primitive.is( src ) )
  return false;
  return _.long.is( src );
}

//

function isResizable( src )
{
  if( _.array.is( src ) )
  return true;
  return false;
  // return this.is( src );
}

//

function IsResizable()
{
  return this.default.IsResizable();
}

// --
// maker
// --

function _makeEmpty( src )
{
  if( arguments.length === 1 )
  {
    if( _.argumentsArray.is( src ) )
    return _.argumentsArray._makeEmpty( 0 );
    else if( _.unroll.is( src ) )
    return _.unroll._makeEmpty();
    if( _.routine.is( src ) )
    {
      let result = new src( 0 );
      _.assert( _.long.is( result ) );
      return result;
    }
    if( this.is( src ) )
    return new src.constructor();
  }

  return this.tools.long.default._makeEmpty();
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  {
    _.assert( _.countable.is( src ) || _.routine.is( src ) );
    // _.assert( this.like( src ) || _.routine.is( src ) ); /* Dmytro : for compatibility with ContainerAdapters source instance should be a Vector, not simple Long */
    return this._makeEmpty( src );
  }

  return this._makeEmpty();
}

//

function _makeUndefined( src, length )
{
  if( arguments.length === 2 )
  {
    if( !_.number.is( length ) )
    {
      if( _.number.is( length.length ) )
      length = length.length;
      else
      length = [ ... length ].length;
    }

    if( src === null )
    return this.tools.long.default._makeUndefined( length );
    if( _.argumentsArray.is( src ) )
    return _.argumentsArray._makeUndefined( src, length );
    if( _.unroll.is( src ) )
    return _.unroll._makeUndefined( src, length );
    if( _.routine.is( src ) )
    {
      let result = new src( length );
      _.assert( _.long.is( result ) );
      return result;
    }
    return new src.constructor( length );
  }
  else if( arguments.length === 1 )
  {
    let constructor;
    if( this.like( src ) )
    {
      if( _.argumentsArray.is( src ) )
      return _.argumentsArray._makeUndefined( src );
      if( _.unroll.is( src ) )
      return _.unroll._makeUndefined( src );
      constructor = src.constructor;
      length = src.length;
    }
    else
    {
      return this.tools.long.default._makeUndefined( src );
    }
    return new constructor( length );
  }

  return this.tools.long.default._makeUndefined();
}

//

function makeUndefined( src, length )
{
  // _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  _.assert( 0 <= arguments.length && arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routine.is( src ) );
    _.assert( _.number.is( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.number.is( src ) || this.like( src ) || _.countable.is( src ) || _.routine.is( src ) );
  }
  return this._makeUndefined( ... arguments );
}

//

function _makeZeroed( src, length )
{
  if( arguments.length === 2 )
  {
    if( !_.number.is( length ) )
    {
      if( _.number.is( length.length ) )
      length = length.length;
      else
      length = [ ... length ].length;
    }

    if( src === null )
    return this.tools.long.default._makeZeroed( length );
    if( _.argumentsArray.is( src ) )
    return _.argumentsArray._makeZeroed( src, length );
    if( _.unroll.is( src ) )
    return _.unroll._makeZeroed( src, length );
    if( _.routine.is( src ) )
    {
      let result = fill( new src( length ) );
      _.assert( _.long.is( result ) );
      return result;
    }
    return fill( new src.constructor( length ) );
  }
  else if( arguments.length === 1 )
  {
    let constructor;
    if( this.like( src ) )
    {
      if( _.argumentsArray.is( src ) )
      return _.argumentsArray._makeZeroed( src );
      if( _.unroll.is( src ) )
      return _.unroll._makeZeroed( src );
      constructor = src.constructor;
      length = src.length;
    }
    else
    {
      return this.tools.long.default._makeZeroed( src );
    }
    return fill( new constructor( length ) );
  }

  return this.tools.long.default._make();

  /* */

  function fill( dst )
  {
    let l = dst.length;
    for( let i = 0 ; i < l ; i++ )
    dst[ i ] = 0;
    return dst;
  }
}

//

function makeZeroed( src, length )
{
  // _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  _.assert( 0 <= arguments.length && arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routine.is( src ) );
    _.assert( _.number.is( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.number.is( src ) || this.like( src ) || _.countable.is( src ) || _.routine.is( src ) );
  }
  return this._makeZeroed( ... arguments );
}

//

function _makeFilling( type, value, length )
{
  if( arguments.length === 2 )
  {
    value = arguments[ 0 ];
    length = arguments[ 1 ];

    if( this.like( length ) )
    type = length;
    else
    type = null;
  }

  if( !_.number.is( length ) )
  // if( _.long.is( length ) )
  if(  length.length )
  length = length.length;
  else if( _.countable.is( length ) )
  length = [ ... length ].length;

  let result = this._make( type, length );
  for( let i = 0 ; i < length ; i++ )
  result[ i ] = value;

  return result;
}

//

function makeFilling( type, value, length )
{
  if( arguments.length === 2 )
  {
    _.assert( _.number.is( value ) || _.countable.is( value ) );
    _.assert( type !== undefined );
  }
  else if( arguments.length === 3 )
  {
    _.assert( value !== undefined );
    _.assert( _.number.is( length ) || _.countable.is( length ) );
    _.assert( type === null || this.like( type ) || _.routine.is( type ) );
  }
  else
  {
    _.assert( 0, 'Expects 2 or 3 arguments' );
  }

  return this._makeFilling( ... arguments );
}

//

function _make( src, length )
{
  if( arguments.length === 2 )
  {
    let data = length;
    if( _.number.is( length ) )
    {
      data = src;
    }
    else
    {
      if( _.number.is( length.length ) )
      {
        length = length.length;
      }
      else
      {
        data = [ ... length ];
        length = data.length;
      }
    }
    if( _.argumentsArray.is( src ) )
    return fill( _.argumentsArray._make( length ), data );
    if( _.unroll.is( src ) )
    return fill( _.unroll._make( length ), data );
    if( src === null )
    return fill( this.tools.long.default._make( length ), data );
    let result;
    if( _.routine.is( src ) )
    result = fill( new src( length ), data )
    else if( src.constructor )
    result = fill( new src.constructor( length ), data );
    _.assert( _.long.is( result ), 'Not clear how to make such long' );
    return result;
  }
  else if( src !== undefined && src !== null )
  {
    if( _.number.is( src ) )
    return this.tools.long.default._make( src );
    if( _.unroll.is( src ) )
    return _.unroll._make( src );
    if( _.argumentsArray.is( src ) )
    return _.argumentsArray._make( src );
    if( src.constructor === Array )
    return [ ... src ];
    if( _.buffer.typedIs( src ) )
    return new src.constructor( src );
    if( _.countable.is( src ) )
    return this.tools.long.default._make( src );
    if( _.routine.is( src ) )
    {
      let result = new src();
      _.assert( this.is( result ), 'Expects long as returned instance' );
      return result;
    }
  }

  return this.tools.long.default.make();

  /* */

  function fill( dst, data )
  {
    if( data === null || data === undefined )
    return dst;
    let l = Math.min( length, data.length );
    for( let i = 0 ; i < l ; i++ )
    dst[ i ] = data[ i ];
    return dst;
  }
}

//

function make( src, length )
{
  _.assert( arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routine.is( src ) );
    _.assert( _.number.is( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.number.is( src ) || _.long.is( src ) || _.countable.is( src ) || _.routine.is( src ) );
  }
  return this._make( ... arguments );
}

//

function _cloneShallow( src )
{
  if( _.argumentsArray.is( src ) )
  return _.argumentsArray.make( src );
  if( _.unroll.is( src ) )
  return _.unroll.make( src );
  // if( _.number.is( src ) ) /* Dmytro : wrong branch, public interface forbids numbers as argument */
  // return this.tools.long.default.make( src );
  if( src.constructor === Array )
  return [ ... src ];
  else
  return new src.constructor( src );
}

//

function cloneShallow( src )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length === 1 );
  return this._cloneShallow( src );
}

//

function from( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( this.is( src ) )
  return src;
  if( src === null )
  return this.make( null );
  return this.make( null, src );
}

// --
// long sequential search
// --

function leftIndex( /* arr, ins, evaluator1, evaluator2 */ )
{
  let arr = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let fromIndex = 0;

  if( _.number.is( arguments[ 2 ] ) )
  {
    fromIndex = arguments[ 2 ];
    evaluator1 = arguments[ 3 ];
    evaluator2 = arguments[ 4 ];
  }

  _.assert( 2 <= arguments.length && arguments.length <= 5, 'Expects 2-5 arguments: source array, element, and optional evaluator / equalizer' );
  _.assert( _.longLike( arr ), 'Expect a Long' );
  _.assert( _.number.is( fromIndex ) );
  _.assert( !evaluator1 || evaluator1.length === 1 || evaluator1.length === 2 || evaluator1.length === 3 );
  _.assert( !evaluator1 || _.routine.is( evaluator1 ) );
  _.assert( !evaluator2 || evaluator2.length === 1 );
  _.assert( !evaluator2 || _.routine.is( evaluator2 ) );

  if( !evaluator1 )
  {
    _.assert( !evaluator2 );
    return Array.prototype.indexOf.call( arr, ins, fromIndex );
  }
  else if( evaluator1.length === 1 ) /* equalizer */
  {

    if( evaluator2 )
    ins = evaluator2( ins );
    else
    ins = evaluator1( ins );

    if( arr.findIndex && fromIndex === 0 )
    {
      return arr.findIndex( ( val ) => evaluator1( val ) === ins );
    }
    else
    {
      for( let a = fromIndex; a < arr.length ; a++ )
      {
        if( evaluator1( arr[ a ] ) === ins )
        return a;
      }
    }

  }
  else /* evaluator */
  {
    _.assert( !evaluator2 );
    for( let a = fromIndex ; a < arr.length ; a++ )
    {
      if( evaluator1( arr[ a ], ins ) )
      return a;
    }
  }

  return -1;
}

//

function rightIndex( /* arr, ins, evaluator1, evaluator2 */ )
{
  let arr = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let fromIndex = arr.length-1;

  if( _.number.is( arguments[ 2 ] ) )
  {
    fromIndex = arguments[ 2 ];
    evaluator1 = arguments[ 3 ];
    evaluator2 = arguments[ 4 ];
  }

  _.assert( 2 <= arguments.length && arguments.length <= 5, 'Expects 2-5 arguments: source array, element, and optional evaluator / equalizer' );
  _.assert( _.number.is( fromIndex ) );
  _.assert( !evaluator1 || evaluator1.length === 1 || evaluator1.length === 2 || evaluator1.length === 3 );
  _.assert( !evaluator1 || _.routine.is( evaluator1 ) );
  _.assert( !evaluator2 || evaluator2.length === 1 );
  _.assert( !evaluator2 || _.routine.is( evaluator2 ) );

  if( !evaluator1 )
  {
    _.assert( !evaluator2 );
    return Array.prototype.lastIndexOf.call( arr, ins, fromIndex );
  }
  else if( evaluator1.length === 1 ) /* equalizer */
  {

    if( evaluator2 )
    ins = evaluator2( ins );
    else
    ins = evaluator1( ins );

    for( let a = fromIndex ; a >= 0 ; a-- )
    {
      if( evaluator1( arr[ a ] ) === ins )
      return a;
    }

  }
  else /* evaluator */
  {
    _.assert( !evaluator2 );
    for( let a = fromIndex ; a >= 0 ; a-- )
    {
      if( evaluator1( arr[ a ], ins ) )
      return a;
    }
  }

  return -1;
}

//

/**
 * The routine longLeft() returns a new object containing the properties, (index, element),
 * corresponding to a found value {-ins-} from a Long {-arr-}.
 * If element is not founded, then routine return new object with property (index), which value is -1.
 *
 * @param { Long } arr - A Long to check.
 * @param { * } ins - An element to locate in the {-arr-}.
 * @param { Number } fromIndex - An index from which routine starts search left to right.
 * If {-fromIndex-} not defined, then routine starts search from the first index.
 * @param { Function } evaluator1 - It's a callback. If the routine has two parameters,
 * it is used as an equalizer, and if it has only one, then routine is used as the evaluator.
 * @param { Function } onEvaluate2 - The second part of evaluator. Accepts the {-ins-} to search.
 *
 * @example
 * _.longLeft( [ 1, 2, false, 'str', 2, 5 ], 2 );
 * // returns { index : 1, element : 2 }
 *
 * @example
 * _.longLeft( [ 1, 2, false, 'str', 2, 5 ], [ 2 ] );
 * // returns { index : -1 }
 *
 * @example
 * _.longLeft( [ 1, 2, false, 'str', 2, 5 ], 2, 3 );
 * // returns { index : 4, element : 2 }
 *
 * @example
 * _.longLeft( [ 1, 2, false, 'str', 2, 5 ], [ 2 ], ( val ) => val[ 0 ] );
 * // returns { index : -1 }
 *
 * @example
 * _.longLeft( [ 1, [ 2 ], false, 'str', 2, 5 ], [ 2 ], ( val ) => val[ 0 ] );
 * // returns { index : 1, element : [ 2 ] }
 *
 * @example
 * _.longLeft( [ 1, [ 2 ], false, 'str', 2, 5 ], [ 2 ], ( val ) => val - 3, ( ins ) => ins[ 0 ] );
 * // returns { index : 5, element : 5 }
 *
 * @example
 * _.longLeft( [ 1, [ 2 ], false, 'str', 2, 5 ], [ 2 ], 3, ( val ) => val + 1, ( ins ) => ins[ 0 ] );
 * // returns { index : 5, element : 5 }
 *
 * @example
 * _.longLeft( [ 1, 2, false, 'str', 2, 5 ], 2, ( val, ins ) => val === ins );
 * // returns { index : 1, element : 2 }
 *
 * @returns { Object } Returns a new object containing the properties, (index, element),
 * corresponding to the found value {-ins-} from the array {-arr-}.
 * Otherwise, it returns the object with property (index), which value is -1.
 * @function longLeft
 * @throws { Error } If arguments.length is less then two or more then five.
 * @throws { Error } If {-fromIndex-} is not a number.
 * @throws { Error } If {-onEvaluate1-} is not a routine.
 * @throws { Error } If {-onEvaluate1-} is undefines and onEvaluate2 provided.
 * @throws { Error } If {-onEvaluate1-} is evaluator and accepts less or more then one parameter.
 * @throws { Error } If {-onEvaluate1-} is equalizer and onEvaluate2 provided.
 * @throws { Error } If {-onEvaluate2-} is not a routine.
 * @throws { Error } If {-onEvaluate2-} accepts less or more then one parameter.
 * @namespace Tools
 */

function left( /* arr, ins, fromIndex, evaluator1, evaluator2 */ )
{
  let arr = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let fromIndex = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result = Object.create( null );
  let i = _.longLeftIndex( arr, ins, fromIndex, evaluator1, evaluator2 );

  _.assert( 2 <= arguments.length && arguments.length <= 5 );

  result.index = i;

  if( i >= 0 )
  result.element = arr[ i ];

  return result;
}

//

/**
 * The routine longRight() returns a new object containing the properties, (index, element),
 * corresponding to a found value {-ins-} from a Long {-arr-}.
 * If element is not founded, then routine return new object with property (index), which value is -1.
 *
 * @param { Long } arr - A Long to check.
 * @param { * } ins - An element to locate in the {-arr-}.
 * @param { Number } fromIndex - An index from which routine starts search right to left.
 * If {-fromIndex-} not defined, then routine starts search from the last index.
 * @param { Function } evaluator1 - It's a callback. If the routine has two parameters,
 * it is used as an equalizer, and if it has only one, then routine is used as the evaluator.
 * @param { Function } onEvaluate2 - The second part of evaluator. Accepts the {-ins-} to search.
 *
 * @example
 * _.longRight( [ 1, 2, false, 'str', 2, 5 ], 2 );
 * // returns { index : 4, element : 2 }
 *
 * @example
 * _.longRight( [ 1, 2, false, 'str', 2, 5 ], [ 2 ] );
 * // returns { index : -1 }
 *
 * @example
 * _.longRight( [ 1, 2, false, 'str', 2, 5 ], 2, 3 );
 * // returns { index : 1, element : 2 }
 *
 * @example
 * _.longRight( [ 1, 2, false, 'str', 2, 5 ], [ 2 ], ( val ) => val[ 0 ] );
 * // returns { index : -1 }
 *
 * @example
 * _.longRight( [ 1, [ 2 ], false, 'str', 2, 5 ], [ 2 ], ( val ) => val[ 0 ] );
 * // returns { index : 1, element : [ 2 ] }
 *
 * @example
 * _.longRight( [ 1, [ 2 ], false, 'str', 2, 5 ], [ 2 ], ( val ) => val - 3, ( ins ) => ins[ 0 ] );
 * // returns { index : 5, element : 5 }
 *
 * @example
 * _.longRight( [ 1, [ 2 ], false, 'str', 2, 5 ], [ 2 ], 4, ( val ) => val - 3, ( ins ) => ins[ 0 ] );
 * // returns { index : -1 }
 *
 * @example
 * _.longRight( [ 1, 2, false, 'str', 2, 5 ], 2, ( val, ins ) => val === ins );
 * // returns { index : 4, element : 2 }
 *
 * @returns { Object } Returns a new object containing the properties, (index, element),
 * corresponding to the found value {-ins-} from the array {-arr-}.
 * Otherwise, it returns the object with property (index), which value is -1.
 * @function longRight
 * @throws { Error } If arguments.length is less then two or more then five.
 * @throws { Error } If {-fromIndex-} is not a number.
 * @throws { Error } If {-onEvaluate1-} is not a routine.
 * @throws { Error } If {-onEvaluate1-} is undefines and onEvaluate2 provided.
 * @throws { Error } If {-onEvaluate1-} is evaluator and accepts less or more then one parameter.
 * @throws { Error } If {-onEvaluate1-} is equalizer and onEvaluate2 provided.
 * @throws { Error } If {-onEvaluate2-} is not a routine.
 * @throws { Error } If {-onEvaluate2-} accepts less or more then one parameter.
 * @namespace Tools
 */

function right( /* arr, ins, fromIndex, evaluator1, evaluator2 */ )
{
  let arr = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let fromIndex = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result = Object.create( null );
  let i = _.longRightIndex( arr, ins, fromIndex, evaluator1, evaluator2 );

  _.assert( 2 <= arguments.length && arguments.length <= 5 );

  result.index = i;

  if( i >= 0 )
  result.element = arr[ i ];

  return result;
}

//

/**
 * The routine longLeftDefined() returns a new object containing the properties, (index, element),
 * of first left element in a Long {-arr-}, which value is not equal to undefined.
 * If element is not founded, then routine return new object with property (index), which value is -1.
 *
 * @param { Long } arr - A Long to check.
 *
 * @example
 * _.longLeftDefined( [ undefined, undefined, undefined, undefined, undefined ] );
 * // returns { index : -1 }
 *
 * @example
 * _.longLeftDefined( [ 1, undefined, 2, false, 'str', 2, undefined, 5 ] );
 * // returns { index : 0, element : 1 }
 *
 * @example
 * _.longLeftDefined( [ undefined, undefined, 2, false, 'str', 2 ] );
 * // returns { index : 2, element : 2 }
 *
 * @returns { Object } Returns a new object containing the properties, (index, element),
 * of first left element in a Long {-arr-}, which value is not equal to undefined.
 * Otherwise, it returns the object with property (index), which value is -1.
 * @function longRight
 * @throws { Error } If arguments.length is less then or more then one.
 * @namespace Tools
 */

function leftDefined( arr )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  return _.longLeft( arr, true, function( val ){ return val !== undefined; } );
}

//

/**
 * The routine longRightDefined() returns a new object containing the properties, (index, element),
 * of first right element in a Long {-arr-}, which value is not equal to undefined.
 * If element is not founded, then routine return new object with property (index), which value is -1.
 *
 * @param { Long } arr - A Long to check.
 *
 * @example
 * _.longRightDefined( [ undefined, undefined, undefined, undefined, undefined ] );
 * // returns { index : -1 }
 *
 * @example
 * _.longRightDefined( [ 1, 2, false, 'str', 2, undefined, 5 ] );
 * // returns { index : 6, element : 5 }
 *
 * @example
 * _.longRightDefined( [ 1, 2, false, 'str', 2, undefined, undefined ] );
 * // returns { index : 4, element : 2 }
 *
 * @returns { Object } Returns a new object containing the properties, (index, element),
 * of first right element in a Long {-arr-}, which value is not equal to undefined.
 * Otherwise, it returns the object with property (index) which, value is -1.
 * @function longRight
 * @throws { Error } If arguments.length is less then or more then one.
 * @namespace Tools
 */

function rightDefined( arr )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  return _.longRight( arr, true, function( val ){ return val !== undefined; } );
}

// --
// meta
// --

// function _namespaceRegister( namespace )
// {
//   let aggregatorNamespace = this;
//   if( !aggregatorNamespace )
//   aggregatorNamespace = _.long;
//
//   if( Config.debug )
//   verify();
//
//   aggregatorNamespace.namespaces[ namespace.NamespaceName ] = namespace;
//
//   _.assert( !!namespace.IsResizable );
//   _.assert( namespace.IsLong === undefined || namespace.IsLong === true );
//   namespace.IsLong = true;
//
//   namespace.asDefault = aggregatorNamespace._asDefaultGenerate( namespace );
//
//   /* */
//
//   function verify()
//   {
//     _.assert( !!namespace.NamespaceName );
//     _.assert( aggregatorNamespace.namespaces[ namespace.Name ] === undefined );
//     _.assert( _[ namespace.NamespaceName ] === namespace );
//     _.assert( _select( _global_, namespace.NamespaceQname ) === namespace );
//   }
//
//   /* */
//
//   function _select( src, selector )
//   {
//     selector = selector.split( '/' );
//     while( selector.length && !!src )
//     {
//       src = src[ selector[ 0 ] ];
//       selector.splice( 0, 1 )
//     }
//     return src;
//   }
//
//   /* */
//
// }
//
// //
//
// function _asDefaultGenerate( namespace )
// {
//   let aggregatorNamespace = this;
//
//   _.assert( !!namespace );
//   _.assert( !!namespace.TypeName );
//
//   let result = aggregatorNamespace.toolsNamespacesByType[ namespace.TypeName ];
//   if( result )
//   return result;
//
//   result = aggregatorNamespace.toolsNamespacesByType[ namespace.TypeName ] = Object.create( _ );
//
//   aggregatorNamespace.toolsNamespacesByName[ namespace.NamespaceName ] = result;
//
//   /* xxx : introduce map _.namespaces */
//   for( let name in aggregatorNamespace.namespaces )
//   {
//     let namespace = aggregatorNamespace.namespaces[ name ];
//     result[ namespace.TypeName ] = Object.create( namespace );
//     result[ namespace.TypeName ].tools = result;
//   }
//
//   result[ aggregatorNamespace.NamespaceName ] = Object.create( aggregatorNamespace );
//   result[ aggregatorNamespace.NamespaceName ].tools = result;
//   result[ aggregatorNamespace.NamespaceName ].default = namespace;
//
//   return result;
// }

function _namespaceRegister( namespace )
{
  let aggregatorNamespace = this;
  if( !aggregatorNamespace )
  aggregatorNamespace = _.long;

  if( Config.debug )
  verify();

  // if( namespace.NamespaceName === 'u32x' )
  // debugger;

  namespace.NamespaceNames.forEach( ( name ) =>
  {
    _.assert( aggregatorNamespace.namespaces[ name ] === undefined );
    aggregatorNamespace.namespaces[ name ] = namespace;
  });

  _.assert( !!namespace.IsResizable );
  _.assert( namespace.IsLong === undefined || namespace.IsLong === true );
  namespace.IsLong = true;

  namespace.asDefault = aggregatorNamespace._asDefaultGenerate( namespace );

  /* */

  function verify()
  {
    _.assert( !!namespace.NamespaceName );
    _.assert( aggregatorNamespace.namespaces[ namespace.Name ] === undefined );
    _.assert( _[ namespace.NamespaceName ] === namespace );
    _.assert( _select( _global_, namespace.NamespaceQname ) === namespace );
  }

  /* */

  function _select( src, selector )
  {
    selector = selector.split( '/' );
    while( selector.length && !!src )
    {
      src = src[ selector[ 0 ] ];
      selector.splice( 0, 1 )
    }
    return src;
  }

  /* */

}

//

function _asDefaultGenerate( namespace )
{
  let aggregatorNamespace = this;

  _.assert( !!namespace );
  _.assert( !!namespace.TypeName );

  let result = aggregatorNamespace.toolsNamespacesByType[ namespace.TypeName ];
  if( result )
  return result;

  result = aggregatorNamespace.toolsNamespacesByType[ namespace.TypeName ] = Object.create( _ );
  namespace.TypeNames.forEach( ( name ) =>
  {
    _.assert
    (
         aggregatorNamespace.toolsNamespacesByType[ name ] === undefined
      || aggregatorNamespace.toolsNamespacesByType[ name ] === result
    );
    aggregatorNamespace.toolsNamespacesByType[ name ] = result;
  });

  /* xxx : introduce map _.namespaces */
  for( let name in aggregatorNamespace.namespaces )
  {
    let namespace2 = aggregatorNamespace.namespaces[ name ];
    let namespace3 = result[ namespace2.TypeName ] = Object.create( namespace2 );
    namespace3.tools = result;
    namespace3.TypeNames.forEach( ( name ) =>
    {
      result[ name ] = namespace3;
    });
  }

  let namespace2 = result[ aggregatorNamespace.NamespaceName ] = Object.create( aggregatorNamespace );
  namespace2.tools = result;
  namespace2.default = namespace;
  aggregatorNamespace.NamespaceNames.forEach( ( name ) =>
  {
    result[ name ] = namespace2;
  });

  return result;
}

//

/* qqq : optimize */
function namespaceOf( src )
{

  if( _.unroll.is( src ) )
  return _.unroll;
  if( _.array.is( src ) )
  return _.array;
  if( _.argumentsArray.is( src ) )
  return _.argumentsArray;

  let result = _.bufferTyped.namespaceOf( src );
  if( result )
  return result;

  if( _.long.is( src ) )
  return _.long;

  // if( _.vector.is( src ) )
  // return _.vector;
  // if( _.countable.is( src ) )
  // return _.countable;

  return null;
}

//

function namespaceWithDefaultOf( src )
{
  if( src === null )
  debugger;
  if( src === null )
  return this.default;
  return this.namespaceOf( src );
}

//

function _functor_functor( methodName, typer, which )
{
  _.assert( !!( methodName ) );
  if( !typer )
  typer = 'namespaceOf';
  if( !which )
  which = 0;
  if( which === 0 )
  return end( _functor0 );
  if( which === 1 )
  return end( _functor1 );
  _.assert( 0 );

  function _functor0( container )
  {
    _.assert( arguments.length === 1 );
    _.assert( _.routine.is( this[ typer ] ), () => `No routine::${typer} in the namesapce::${this.NamespaceName}` );
    const namespace = this[ typer ]( container );
    _.assert( _.routine.is( namespace[ methodName ] ), `No routine::${methodName} in the namesapce::${namespace.NamespaceName}` );
    return namespace[ methodName ].bind( namespace, container );
  }

  function _functor1( container )
  {
    _.assert( arguments.length === 1 );
    _.assert( _.routine.is( this[ typer ] ), () => `No routine::${typer} in the namesapce::${this.NamespaceName}` );
    const namespace = this[ typer ]( container );
    _.assert( _.routine.is( namespace[ methodName ] ), `No routine::${methodName} in the namesapce::${namespace.NamespaceName}` );
    const routine0 = namespace[ methodName ];
    return routine1.bind( namespace );
    function routine1( arg1, ... args )
    {
      return routine0.call( this, arg1, container, ... args );
    }
  }

  function end( result )
  {
    result.functor = new Function( `return _.long._functor_functor( '${methodName}', '${typer}', ${which} )` );
    return result;
  }

}

// --
// long extension
// --

let LongExtension =
{

  //

  NamespaceName : 'long',
  NamespaceNames : [ 'long' ],
  NamespaceQname : 'wTools/long',
  MoreGeneralNamespaceName : 'long',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'Long',
  TypeNames : [ 'Long' ],
  InstanceConstructor : null,
  IsLong : true,
  tools : _,

  // dichotomy

  is,
  isOld, /* xxx : remove later */
  isCompact,
  isUnfolded,
  isUnfoldedSmartOrder,
  isUnfoldedSmarter,
  isEmpty,
  isPopulated,
  like,
  isResizable,
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _makeZeroed,
  makeZeroed, /* qqq : for junior : cover */
  _makeFilling,
  makeFilling,
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow, /* qqq : for junior : cover */
  from, /* qqq : for junior : cover */

  // long sequential search

  leftIndex,
  rightIndex,

  left,
  right,

  leftDefined,
  rightDefined,

  // meta

  _namespaceRegister,
  _asDefaultGenerate,

  // meta

  namespaceOf,
  namespaceWithDefaultOf,
  _functor_functor,

}

//

Object.assign( _.long, LongExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  // dichotomy

  longIs : is.bind( _.long ),
  longIsEmpty : isEmpty.bind( _.long ),
  longIsPopulated : isPopulated.bind( _.long ),
  longLike : like.bind( _.long ),

  // maker

  longMakeEmpty : makeEmpty.bind( _.long ),
  longMakeUndefined : makeUndefined.bind( _.long ),
  longMakeZeroed : makeZeroed.bind( _.long ),
  longMakeFilling : makeFilling.bind( _.long ),
  longMake : make.bind( _.long ),
  longCloneShallow : cloneShallow.bind( _.long ),
  longFrom : from.bind( _.long ),

  // long sequential search

  longLeftIndex : leftIndex,
  longRightIndex : rightIndex,

  longLeft : left,
  longRight : right,

  longLeftDefined : leftDefined,
  longRightDefined : rightDefined,

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/2Long.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _2Long_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _2Long_s */ })();

/* */  /* begin of file _2Props_s */ ( function _2Props_s() { function _2Props_s_naked() { ( function _l1_2Props_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.props = _.props || Object.create( null );
const prototypeSymbol = Symbol.for( 'prototype' );
const constructorSymbol = Symbol.for( 'constructor' );

// --
// dichotomy
// --

function is( src )
{
  if( src === null )
  return false;
  if( src === undefined )
  return false;
  return true;
}

//

function like( src )
{
  return _.props.is( src );
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return true;
}

// --
// maker
// --

function _makeEmpty( src )
{
  if( _.map.is( src ) )
  return _.map._makeEmpty( src );
  if( _.aux.is( src ) )
  return _.aux._makeEmpty( src );
  if( _.object.isBasic( src ) )
  return _.object._makeEmpty( src );

  _.assert( 0, `Not clear how to make ${ _.strType( src ) }` );
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 1 );
  return this._makeEmpty( ... arguments );
}

//

function _makeUndefined( src, length )
{
  if( _.map.is( src ) )
  return _.map._makeUndefined( src );
  if( _.aux.is( src ) )
  return _.aux._makeUndefined( src );
  if( _.object.isBasic( src ) )
  return _.object._makeUndefined( src );

  _.assert( 0 );

  return new src.constructor();
}

//

function makeUndefined( src, length )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return this._makeUndefined( ... arguments );
}

//

function _make( src )
{
  if( _.map.is( src ) )
  return _.map._make( src );
  if( _.aux.is( src ) )
  return _.aux._make( src );
  if( _.object.isBasic( src ) )
  return _.object._make( src );

  _.assert( 0 );

  let method = _.class.methodCloneShallowOf( src );
  if( method )
  return method.call( src );
  return new src.constructor( src );
}

//

function make( src, length )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return this._make( ... arguments );
}

//

function _cloneShallow( src )
{
  if( _.map.is( src ) )
  return _.map._cloneShallow( src );
  if( _.aux.is( src ) )
  return _.aux._cloneShallow( src );
  if( _.object.isBasic( src ) )
  return _.object._cloneShallow( src );

  let method = _.class.methodCloneShallowOf( src );
  if( method )
  return method.call( src );
  return new src.constructor( src );

  // _.assert( 0, `Not clear how to clone ${ _.strType( src ) }` );
}

//

function cloneShallow( src )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length === 1 );
  return this._cloneShallow( src );
}

//

function from( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( this.is( src ) )
  return src;
  return this.make( src );
}

// --
// amender
// --

// //
//
// function supplementStructureless( dstMap, srcMap )
// {
//   if( dstMap === null && arguments.length === 2 )
//   return Object.assign( Object.create( null ), srcMap );
//
//   if( dstMap === null )
//   dstMap = Object.create( null );
//
//   for( let a = 1 ; a < arguments.length ; a++ )
//   {
//     srcMap = arguments[ a ];
//     for( let s in srcMap )
//     {
//       if( dstMap[ s ] !== undefined )
//       continue;
//
//       if( Config.debug )
//       if( _.object.like( srcMap[ s ] ) || _.argumentsArray.like( srcMap[ s ] ) )
//       if( !_.regexpIs( srcMap[ s ] ) && !_.date.is( srcMap[ s ] ) )
//       throw Error( `Source map should have only primitive elements, but ${ s } is ${ srcMap[ s ] }` );
//
//       dstMap[ s ] = srcMap[ s ];
//     }
//   }
//
//   return dstMap;
// }

//

function _extendWithHashmap( dstMap, src )
{
  for( let [ key, val ] of src )
  dstMap[ key ] = val;
  return dstMap;
}

//

function _extendWithSet( dstMap, src )
{
  for( let key of src )
  dstMap[ key ] = key;
  return dstMap;
}

//

function _extendWithCountable( dstMap, src )
{
  for( let e of src )
  {
    _.assert( e.length === 2 );
    dstMap[ e[ 0 ] ] = e[ 1 ];
  }
  return dstMap;
}

//

function _extendWithProps( dstMap, src )
{
  for( let k in src )
  dstMap[ k ] = src[ k ];
  return dstMap;
}

//

function _extendUniversal( dstMap, srcMap )
{

  _.assert( !_.primitive.is( srcMap ), 'Expects non-primitive' );

  let srcProto = Object.getPrototypeOf( srcMap );
  if( srcProto === null || srcProto === Object.prototype )
  Object.assign( dstMap, srcMap );
  else if( _.hashMap.like( srcMap ) )
  this._extendWithHashmap( dstMap, srcMap ); /* qqq : cover */
  else if( _.set.like( srcMap ) )
  this._extendWithSet( dstMap, srcMap ); /* qqq : cover */
  else if( _.long.like( srcMap ) )
  this._extendWithCountable( dstMap, srcMap ); /* qqq : cover */
  else
  this._extendWithProps( dstMap, srcMap ); /* qqq : cover */

  return dstMap;
}

//

function extendUniversal( dstMap, srcMap )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  if( arguments.length === 2 )
  {
    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    return Object.assign( dstMap, srcMap );
  }

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    let srcMap = arguments[ a ];
    _.assert( !_.primitive.is( srcMap ), 'Expects non-primitive' );

    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    Object.assign( dstMap, srcMap );
    else
    this._extendUniversal( dstMap, srcMap );

  }

  return dstMap;
}

//

/**
 * The extend() is used to copy the values of all properties
 * from one or more source objects to a target object.
 *
 * It takes first object (dstMap)
 * creates variable (result) and assign first object.
 * Checks if arguments equal two or more and if (result) is an object.
 * If true,
 * it extends (result) from the next objects.
 *
 * @param{ objectLike } dstMap - The target object.
 * @param{ ...objectLike } arguments[] - The source object(s).
 *
 * @example
 * _.map.extend( { a : 7, b : 13 }, { c : 3, d : 33 }, { e : 77 } );
 * // returns { a : 7, b : 13, c : 3, d : 33, e : 77 }
 *
 * @returns { objectLike } It will return the target object.
 * @function extend
 * @throws { Error } Will throw an error if ( arguments.length < 2 ),
 * if the (dstMap) is not an Object.
 * @namespace Tools/props
 */

function extend( dstMap, srcMap )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  if( arguments.length === 2 )
  {
    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    return Object.assign( dstMap, srcMap );
  }

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    let srcMap = arguments[ a ];

    _.assert( !_.primitive.is( srcMap ), 'Expects non-primitive' );

    let srcProto = Object.getPrototypeOf( srcMap );
    if( srcProto === null || srcProto === Object.prototype )
    Object.assign( dstMap, srcMap );
    else
    this._extendWithProps( dstMap, srcMap );

  }

  return dstMap;
}

//

function _supplementWithHashmap( dstMap, src )
{
  for( let [ key, val ] of src )
  if( !( key in dstMap ) )
  dstMap[ key ] = val;
  return dstMap;
}

//

function _supplementWithSet( dstMap, src )
{
  for( let key of src )
  if( !( key in dstMap ) )
  dstMap[ key ] = key;
  return dstMap;
}

//

function _supplementWithCountable( dstMap, src )
{
  for( let e of src )
  {
    _.assert( e.length === 2 );
    if( !( e[ 0 ] in dstMap ) )
    dstMap[ e[ 0 ] ] = e[ 1 ];
  }
  return dstMap;
}

//

function _supplementWithProps( dstMap, src )
{
  for( let k in src )
  if( !( k in dstMap ) )
  dstMap[ k ] = src[ k ];
  return dstMap;
}

//

function _supplementUniversal( dstMap, srcMap )
{

  _.assert( !_.primitive.is( srcMap ), 'Expects non-primitive' );

  let srcProto = Object.getPrototypeOf( srcMap );
  if( srcProto === null || srcProto === Object.prototype )
  Object.assign( dstMap, srcMap );
  else if( _.hashMap.like( srcMap ) )
  this._supplementWithHashmap( dstMap, srcMap ); /* qqq : cover */
  else if( _.set.like( srcMap ) )
  this._supplementWithSet( dstMap, srcMap ); /* qqq : cover */
  else if( _.long.like( srcMap ) )
  this._supplementWithCountable( dstMap, srcMap ); /* qqq : cover */
  else
  this._supplementWithProps( dstMap, srcMap ); /* qqq : cover */

  return dstMap;
}

//

function supplementUniversal( dstMap, srcMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );

  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    srcMap = arguments[ a ];
    this._supplementWithProps( dstMap, srcMap );
  }

  return dstMap
}

//

/**
 * The supplement() supplement destination map by source maps.
 * Pairs of destination map are not overwritten by pairs of source maps if any overlap.
 * Routine rewrite pairs of destination map which has key === undefined.
 *
 * @param { ...objectLike } arguments[] - The source object(s).
 *
 * @example
 * _.map.supplement( { a : 1, b : 2 }, { a : 1, c : 3 } );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @returns { objectLike } Returns an object with unique [ key, value ].
 * @function supplement
 * @namespace Tools/props
 */

function supplement( dstMap, srcMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  _.assert( this.like( dstMap ), () => `Expects dstMap::${this.NamespaceName} as the first argument` );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    srcMap = arguments[ a ];
    this._supplementWithProps( dstMap, srcMap );
  }

  return dstMap
}

// --
// properties
// --

function _keys( o )
{
  let result = [];

  _.routine.options( _keys, o );

  let srcMap = o.srcMap;
  let selectFilter = o.selectFilter;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this.like( srcMap ) );
  _.assert( selectFilter === null || _.routine.is( selectFilter ) );

  /* */

  if( o.onlyEnumerable )
  {
    let result1 = [];

    if( o.onlyOwn )
    {
      for( let k in srcMap )
      if( Object.hasOwnProperty.call( srcMap, k ) )
      result1.push( k );
    }
    else
    {
      for( let k in srcMap )
      result1.push( k );
    }

    filter( srcMap, result1 );

  }
  else
  {

    if( o.onlyOwn  )
    {
      filter( srcMap, Object.getOwnPropertyNames( srcMap ) );
    }
    else
    {
      let proto = srcMap;
      result = [];
      do
      {
        filter( proto, Object.getOwnPropertyNames( proto ) );
        proto = Object.getPrototypeOf( proto );
      }
      while( proto );
    }

  }

  return result;

  /* */

  function filter( srcMap, keys )
  {

    if( !selectFilter )
    {
      /* qqq : for junior : rewrite without arrayAppend and without duplicating array */
      arrayAppendArrayOnce( result, keys );
    }
    else for( let k = 0 ; k < keys.length ; k++ )
    {
      let e = selectFilter( srcMap, keys[ k ] );
      if( e !== undefined )
      arrayAppendOnce( result, e );
      /* qqq : for junior : rewrite without arrayAppend and without duplicating array */
    }

  }

  /* */

  function arrayAppendOnce( dst, element )
  {
    let i = dst.indexOf( element );
    if( i === -1 )
    dst.push( element );
    return dst;
  }

  /* */

  function arrayAppendArrayOnce( dst, src )
  {
    src.forEach( ( element ) =>
    {
      let i = dst.indexOf( element );
      if( i === -1 )
      dst.push( element );
    });
    return dst;
  }

  /* */

}

_keys.defaults =
{
  srcMap : null,
  onlyOwn : 0,
  onlyEnumerable : 1,
  selectFilter : null,
}

//

/**
 * This routine returns an array of a given objects onlyEnumerable properties,
 * in the same order as that provided by a for...in loop.
 * Accept single object. Each element of result array is unique.
 * Unlike standard [Object.keys]{@https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys}
 * which accept object only props.keys accept any object-like entity.
 *
 * @see {@link wTools.props.onlyOwnKeys} - Similar routine taking into account own elements only.
 * @see {@link wTools.props.vals} - Similar routine returning values.
 *
 * @example
 * _.props.keys({ a : 7, b : 13 });
 * // returns [ "a", "b" ]
 *
 * @example
 * let o = { onlyOwn : 1, onlyEnumerable : 0 };
 * _.props.keys.call( o, { a : 1 } );
 * // returns [ "a" ]
 *
 * @param { objectLike } srcMap - object of interest to extract keys.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s own properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 * @return { array } Returns an array with unique string elements.
 * corresponding to the onlyEnumerable properties found directly upon object or empty array
 * if nothing found.
 * @function keys
 * @throws { Exception } Throw an exception if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/props
 */

function keys( srcMap, o )
{
  let result;

  // _.assert( this === _.object );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( keys, o || null );
  // _.assert( !_.primitive.is( srcMap ) );

  o.srcMap = srcMap;

  result = this._keys( o );

  return result;
}

keys.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The props.onlyOwnKeys() returns an array of a given object`s own enumerable properties,
 * in the same order as that provided by a for...in loop. Each element of result array is unique.
 *
 * @param { objectLike } srcMap - The object whose properties keys are to be returned.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.onlyOwnKeys({ a : 7, b : 13 });
 * // returns [ "a", "b" ]
 *
 * @example
 * let o = { onlyEnumerable : 0 };
 * _.props.onlyOwnKeys.call( o, { a : 1 } );
 * // returns [ "a" ]

 *
 * @return { array } Returns an array whose elements are strings
 * corresponding to the own onlyEnumerable properties found directly upon object or empty
 * array if nothing found.
 * @function onlyOwnKeys
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/props
*/

function onlyOwnKeys( srcMap, o )
{
  let result;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyOwnKeys, o || null );
  _.assert( this.like( srcMap ) );

  o.srcMap = srcMap;
  o.onlyOwn = 1;

  result = this._keys( o );

  if( !o.onlyEnumerable )
  debugger;

  return result;
}

onlyOwnKeys.defaults =
{
  onlyEnumerable : 1,
}

//

function onlyEnumerableKeys( srcMap, o )
{
  let result;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyEnumerableKeys, o || null );
  _.assert( this.like( srcMap ) );

  o.srcMap = srcMap;
  o.onlyEnumerable = 1;

  result = this._keys( o );

  return result;
}

onlyEnumerableKeys.defaults =
{
  onlyOwn : 0,
}

//

/**
 * The props.allKeys() returns all properties of provided object as array,
 * in the same order as that provided by a for...in loop. Each element of result array is unique.
 *
 * @param { objectLike } srcMap - The object whose properties keys are to be returned.
 *
 * @example
 * let x = { a : 1 };
 * let y = { b : 2 };
 * Object.setPrototypeOf( x, y );
 * _.props.allKeys( x );
 * // returns [ "a", "b", "__defineGetter__", ... "isPrototypeOf" ]
 *
 * @return { array } Returns an array whose elements are strings
 * corresponding to the all properties found on the object.
 * @function allKeys
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @namespace Tools/props
*/

function allKeys( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( allKeys, o || null );

  o.srcMap = srcMap;

  let result = this._keys( o );

  return result;
}

/* qqq : write test routine for each option */
/* qqq : do the same for similar routines */
/* qqq : adjust similar routine if they handle options no like routine allKeys */
allKeys.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 0,
}

//

function _vals( o )
{

  _.routine.options( _vals, o );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( o.selectFilter === null || _.routine.is( o.selectFilter ) );
  _.assert( o.selectFilter === null );

  let result = this._keys( o );

  for( let k = 0 ; k < result.length ; k++ )
  {
    result[ k ] = o.srcMap[ result[ k ] ];
  }

  return result;
}

_vals.defaults =
{
  srcMap : null,
  onlyOwn : 0,
  onlyEnumerable : 1,
  selectFilter : null,
}

//

/**
 * The props.vals() routine returns an array of a given object's
 * onlyEnumerable property values, in the same order as that provided by a for...in loop.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns an array of values,
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - The object whose property values are to be returned.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s own properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.vals( { a : 7, b : 13 } );
 * // returns [ "7", "13" ]
 *
 * @example
 * let o = { onlyOwn : 1 };
 * let a = { a : 7 };
 * let b = { b : 13 };
 * Object.setPrototypeOf( a, b );
 * _.props.vals.call( o, a )
 * // returns [ 7 ]
 *
 * @returns { array } Returns an array whose elements are strings.
 * corresponding to the onlyEnumerable property values found directly upon object.
 * @function vals
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/props
 */

function vals( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( vals, o || null );
  o.srcMap = srcMap;

  let result = this._vals( o );

  return result;
}

vals.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The props.onlyOwnVals() routine returns an array of a given object's
 * own onlyEnumerable property values,
 * in the same order as that provided by a for...in loop.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns an array of values,
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - The object whose property values are to be returned.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.onlyOwnVals( { a : 7, b : 13 } );
 * // returns [ "7", "13" ]
 *
 * @example
 * let o = { onlyEnumerable : 0 };
 * let a = { a : 7 };
 * Object.defineProperty( a, 'x', { onlyEnumerable : 0, value : 1 } )
 * _.props.onlyOwnVals.call( o, a )
 * // returns [ 7, 1 ]
 *
 * @returns { array } Returns an array whose elements are strings.
 * corresponding to the onlyEnumerable property values found directly upon object.
 * @function onlyOwnVals
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/props
 */

function onlyOwnVals( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyOwnVals, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 1;

  let result = this._vals( o );

  return result;
}

onlyOwnVals.defaults =
{
  onlyEnumerable : 1,
}

//

function onlyEnumerableVals( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyEnumerableVals, o || null );

  o.srcMap = srcMap;
  o.onlyEnumerable = 1;

  let result = this._vals( o );

  return result;
}

onlyEnumerableVals.defaults =
{
  onlyOwn : 0,
}

//

/**
 * The props.allVals() returns values of all properties of provided object as array,
 * in the same order as that provided by a for...in loop.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns an array of values,
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - The object whose property values are to be returned.
 *
 * @example
 * _.props.allVals( { a : 7, b : 13 } );
 * // returns [ "7", "13", function __defineGetter__(), ... function prototype.isPrototypeFor() ]
 *
 * @returns { array } Returns an array whose elements are strings.
 * corresponding to the onlyEnumerable property values found directly upon object.
 * @function allVals
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @namespace Tools/props
 */

function allVals( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( allVals, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 0;
  o.onlyEnumerable = 0;

  let result = this._vals( o );

  debugger;
  return result;
}

allVals.defaults =
{
}

//

function _pairs( o )
{

  _.routine.options( _pairs, o );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( o.selectFilter === null || _.routine.is( o.selectFilter ) );
  _.assert( this.like( o.srcMap ) );

  let selectFilter = o.selectFilter;

  if( o.selectFilter )
  debugger;

  if( !o.selectFilter )
  o.selectFilter = function selectFilter( srcMap, k )
  {
    return [ k, srcMap[ k ] ];
  }

  let result = this._keys( o );

  return result;
}

_pairs.defaults =
{
  srcMap : null,
  onlyOwn : 0,
  onlyEnumerable : 1,
  selectFilter : null,
}

//

/**
 * The map.pairs() converts an object into a list of unique [ key, value ] pairs.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns a list of [ key, value ] pairs if they exist,
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - Object to get a list of [ key, value ] pairs.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s own properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.map.pairs( { a : 7, b : 13 } );
 * // returns [ [ "a", 7 ], [ "b", 13 ] ]
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.map.pairs.call( { onlyOwn : 1 }, a );
 * // returns [ [ "a", 1 ] ]
 *
 * @returns { array } A list of [ key, value ] pairs.
 * @function pairs
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/props
 */

function pairs( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( pairs, o || null );

  o.srcMap = srcMap;

  let result = this._pairs( o );

  return result;
}

pairs.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The props.pairs() converts an object's own properties into a list of [ key, value ] pairs.
 *
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns a list of [ key, value ] pairs of object`s own properties if they exist,
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - Object to get a list of [ key, value ] pairs.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.pairs( { a : 7, b : 13 } );
 * // returns [ [ "a", 7 ], [ "b", 13 ] ]
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.props.pairs( a );
 * // returns [ [ "a", 1 ] ]
 *
 * @example
 * let a = { a : 1 };
 * _.props.pairs.call( { onlyEnumerable : 0 }, a );
 *
 * @returns { array } A list of [ key, value ] pairs.
 * @function onlyOwnPairs
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/props
 */

function onlyOwnPairs( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyOwnPairs, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 1;

  let result = this._pairs( o );

  debugger;
  return result;
}

onlyOwnPairs.defaults =
{
  onlyEnumerable : 1,
}

//

function onlyEnumerablePairs( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyEnumerablePairs, o || null );

  o.srcMap = srcMap;
  o.onlyEnumerable = 1;

  let result = this._pairs( o );

  debugger;
  return result;
}

onlyEnumerablePairs.defaults =
{
  onlyOwn : 0,
}

//

/**
 * The props.allPairs() converts all properties of the object {-srcMap-} into a list of unique [ key, value ] pairs.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns a list of [ key, value ] pairs that repesents all properties of provided object{-srcMap-},
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - Object to get a list of [ key, value ] pairs.
 *
 * @example
 * _.props.allPairs( { a : 7, b : 13 } );
 * // returns [ [ "a", 7 ], [ "b", 13 ], ... [ "isPrototypeOf", function prototype.isPrototypeFor() ] ]
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.props.allPairs( a );
 * // returns [ [ "a", 1 ], [ "b", 2 ], ... [ "isPrototypeOf", function prototype.isPrototypeFor() ]  ]
 *
 * @returns { array } A list of [ key, value ] pairs.
 * @function allPairs
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @namespace Tools/props
 */

function allPairs( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( allPairs, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 0;
  o.onlyEnumerable = 0;

  let result = this._pairs( o );

  return result;
}

allPairs.defaults =
{
}

// --
//
// --

function _ofAct( o )
{
  let result = Object.create( null );

  _.routine.options( _ofAct, o );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this === _.props );
  _.assert( this.like( o.srcMap ) );

  let keys = this._keys( o );

  for( let k = 0 ; k < keys.length ; k++ )
  {
    result[ keys[ k ] ] = o.srcMap[ keys[ k ] ];
  }

  return result;
}

_ofAct.defaults =
{
  srcMap : null,
  onlyOwn : 0,
  onlyEnumerable : 1,
  selectFilter : null,
}

//

/**
 * Routine property.of() gets onlyEnumerable properties of the object{-srcMap-} and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies unique onlyEnumerable properties of the provided object to the new map using
 * their original name/value and returns the result,
 * otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Object to get a map of onlyEnumerable properties.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s onlyOwn properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.of( { a : 7, b : 13 } );
 * // returns { a : 7, b : 13 }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.props.of( a );
 * // returns { a : 1, b : 2 }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.props.of.conlyExplicit( { onlyOwn : 1 }, a )
 * // returns { a : 1 }
 *
 * @returns { object } A new map with unique onlyEnumerable properties from source{-srcMap-}.
 * @function of
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */

function _of( srcMap, o )
{
  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( _of, o || null );

  o.srcMap = srcMap;

  let result = _.props._ofAct( o );
  return result;
}

_of.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The onlyOwn() gets the object's {-srcMap-} onlyOwn onlyEnumerable properties and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies object's onlyOwn onlyEnumerable properties to the new map using
 * their original name/value and returns the result,
 * otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Source to get a map of object`s onlyOwn onlyEnumerable properties.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.onlyOwn( { a : 7, b : 13 } );
 * // returns { a : 7, b : 13 }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.props.onlyOwn( a );
 * // returns { a : 1 }
 *
 * @example
 * let a = { a : 1 };
 * Object.defineProperty( a, 'b', { onlyEnumerable : 0, value : 2 } );
 * _.props.onlyOwn.conlyExplicit( { onlyEnumerable : 0 }, a )
 * // returns { a : 1, b : 2 }
 *
 * @returns { object } A new map with source {-srcMap-} onlyOwn onlyEnumerable properties.
 * @function onlyOwn
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */

function onlyOwn( srcMap, o )
{

  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyOwn, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 1;

  let result = _.props._ofAct( o );
  return result;
}

onlyOwn.defaults =
{
  onlyEnumerable : 1,
}

//

/**
 * The onlyExplicit() gets onlyExplicit properties from provided object {-srcMap-} and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies onlyExplicit unique object's properties to the new map using
 * their original name/value and returns the result,
 * otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Source to get a map of onlyExplicit object`s properties.
 *
 * @example
 * _.props.onlyExplicit( { a : 7, b : 13 } );
 * // returns { a : 7, b : 13, __defineGetter__ : function...}
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.props.onlyExplicit( a );
 * // returns { a : 1, b : 2, __defineGetter__ : function...}
 *
 * @returns { object } A new map with onlyExplicit unique properties from source {-srcMap-}.
 * @function onlyExplicit
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */

function onlyExplicit( srcMap, o )
{

  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyExplicit, o || null );

  o.srcMap = srcMap;
  let result = _.props._ofAct( o );

  return result;
}

onlyExplicit.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 0,
}

//

/**
 * The routines() gets onlyEnumerable properties that contains routines as value from the object {-srcMap-} and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies unique onlyEnumerable properties that holds routines from source {-srcMap-} to the new map using
 * original name/value of the property and returns the result, otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Source to get a map of object`s properties.
 * @param { objectLike } o - routine options, can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s onlyOwn properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.routines( { a : 7, b : 13, f : function(){} } );
 * // returns { f : function(){} }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2, f : function(){} };
 * Object.setPrototypeOf( a, b );
 * _.props.routines( a )
 * // returns { f : function(){} }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2, f : function(){} };
 * Object.setPrototypeOf( a, b );
 * _.props.routines.conlyExplicit( { onlyOwn : 1 }, a )
 * // returns {}
 *
 * @returns { object } A new map with unique onlyEnumerable routine properties from source {-srcMap-}.
 * @function routines
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */


function routines( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( this === _.props );
  o = _.routine.options( routines, o || null );

  o.srcMap = srcMap;
  o.selectFilter = function selectRoutine( srcMap, k )
  {
    debugger;
    if( _.routine.is( srcMap[ k ] ) )
    return k;
    debugger;
  }

  debugger;
  let result = _.props._ofAct( o );
  return result;
}

routines.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The onlyOwnRoutines() gets object`s {-srcMap-} onlyOwn onlyEnumerable properties that contains routines as value and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies object`s {-srcMap-} onlyOwn unique onlyEnumerable properties that holds routines to the new map using
 * original name/value of the property and returns the result, otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Source to get a map of object`s properties.
 * @param { objectLike } o - routine options, can be provided through routine`s context.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.onlyOwnRoutines( { a : 7, b : 13, f : function(){} } );
 * // returns { f : function(){} }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2, f : function(){} };
 * Object.setPrototypeOf( a, b );
 * _.props.onlyOwnRoutines( a )
 * // returns {}
 *
 * @example
 * let a = { a : 1 };
 * Object.defineProperty( a, 'b', { onlyEnumerable : 0, value : function(){} } );
 * _.props.onlyOwnRoutines.conlyExplicit( { onlyEnumerable : 0 }, a )
 * // returns { b : function(){} }
 *
 * @returns { object } A new map with unique object`s onlyOwn onlyEnumerable routine properties from source {-srcMap-}.
 * @function onlyOwnRoutines
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */

function onlyOwnRoutines( srcMap, o )
{

  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyOwnRoutines, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 1;
  o.selectFilter = function selectRoutine( srcMap, k )
  {
    debugger;
    if( _.routine.is( srcMap[ k ] ) )
    return k;
    debugger;
  }

  debugger;
  let result = _.props._ofAct( o );
  return result;
}

onlyOwnRoutines.defaults =
{
  onlyEnumerable : 1,
}

//

/**
 * The onlyExplicitRoutines() gets onlyExplicit properties of object {-srcMap-} that contains routines as value and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies onlyExplicit unique properties of source {-srcMap-} that holds routines to the new map using
 * original name/value of the property and returns the result, otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Source to get a map of object`s properties.
 *
 * @example
 * _.props.onlyExplicitRoutines( { a : 7, b : 13, f : function(){} } );
 * // returns { f : function, __defineGetter__ : function...}
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2, f : function(){} };
 * Object.setPrototypeOf( a, b );
 * _.props.onlyExplicitRoutines( a )
 * // returns { f : function, __defineGetter__ : function...}
 *
 * @returns { object } A new map with onlyExplicit unique object`s {-srcMap-} properties that are routines.
 * @function onlyExplicitRoutines
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */

function onlyExplicitRoutines( srcMap, o )
{

  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyExplicitRoutines, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 0;
  o.onlyEnumerable = 0;
  o.selectFilter = function selectRoutine( srcMap, k )
  {
    if( _.routine.is( srcMap[ k ] ) )
    return k;
  }

  let result = _.props._ofAct( o );
  return result;
}

onlyExplicitRoutines.defaults =
{
}

//

/**
 * The fields() gets onlyEnumerable fields( onlyExplicit properties except routines ) of the object {-srcMap-} and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies unique onlyEnumerable properties of the provided object {-srcMap-} that are not routines to the new map using
 * their original name/value and returns the result, otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Object to get a map of onlyEnumerable properties.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s onlyOwn properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.fields( { a : 7, b : 13, c : function(){} } );
 * // returns { a : 7, b : 13 }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2, c : function(){} };
 * Object.setPrototypeOf( a, b );
 * _.props.fields( a );
 * // returns { a : 1, b : 2 }
 *
 * @example
 * let a = { a : 1, x : function(){} };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.props.fields.conlyExplicit( { onlyOwn : 1 }, a )
 * // returns { a : 1 }
 *
 * @returns { object } A new map with unique onlyEnumerable fields( onlyExplicit properties except routines ) from source {-srcMap-}.
 * @function fields
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */

function fields( srcMap, o )
{

  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( fields, o || null );

  o.srcMap = srcMap;
  o.selectFilter = function selectRoutine( srcMap, k )
  {
    if( !_.routine.is( srcMap[ k ] ) )
    return k;
  }

  let result = _.props._ofAct( o );
  return result;
}

fields.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The onlyOwnFields() gets object`s {-srcMap-} onlyOwn onlyEnumerable fields( onlyExplicit properties except routines ) and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies object`s onlyOwn onlyEnumerable properties that are not routines to the new map using
 * their original name/value and returns the result, otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Object to get a map of onlyEnumerable properties.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.onlyOwnFields( { a : 7, b : 13, c : function(){} } );
 * // returns { a : 7, b : 13 }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2, c : function(){} };
 * Object.setPrototypeOf( a, b );
 * _.props.onlyOwnFields( a );
 * // returns { a : 1 }
 *
 * @example
 * let a = { a : 1, x : function(){} };
 * Object.defineProperty( a, 'b', { onlyEnumerable : 0, value : 2 } )
 * _.props.fields.conlyExplicit( { onlyEnumerable : 0 }, a )
 * // returns { a : 1, b : 2 }
 *
 * @returns { object } A new map with object`s {-srcMap-} onlyOwn onlyEnumerable fields( onlyExplicit properties except routines ).
 * @function onlyOwnFields
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */

function onlyOwnFields( srcMap, o )
{

  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyOwnFields, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 1;
  o.selectFilter = function selectRoutine( srcMap, k )
  {
    if( !_.routine.is( srcMap[ k ] ) )
    return k;
  }

  let result = _.props._ofAct( o );
  return result;
}

onlyOwnFields.defaults =
{
  onlyEnumerable : 1,
}

//

/**
 * The onlyExplicitFields() gets onlyExplicit object`s {-srcMap-} fields( properties except routines ) and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies onlyExplicit object`s properties that are not routines to the new map using
 * their original name/value and returns the result, otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Object to get a map of onlyExplicit properties.
 *
 * @example
 * _.props.onlyExplicitFields( { a : 7, b : 13, c : function(){} } );
 * // returns { a : 7, b : 13, __proto__ : Object }
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2, c : function(){} };
 * Object.setPrototypeOf( a, b );
 * _.props.onlyExplicitFields( a );
 * // returns { a : 1, b : 2, __proto__ : Object }
 *
 * @example
 * let a = { a : 1, x : function(){} };
 * Object.defineProperty( a, 'b', { onlyEnumerable : 0, value : 2 } )
 * _.props.onlyExplicitFields( a );
 * // returns { a : 1, b : 2, __proto__ : Object }
 *
 * @returns { object } A new map with onlyExplicit fields( properties except routines ) from source {-srcMap-}.
 * @function onlyExplicitFields
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools
 */

function onlyExplicitFields( srcMap, o )
{

  _.assert( this === _.props );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( onlyExplicitFields, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 0;
  o.onlyEnumerable = 0;
  o.selectFilter = function selectRoutine( srcMap, k )
  {
    if( !_.routine.is( srcMap[ k ] ) )
    return k;
  }

  if( _.routine.is( srcMap ) )
  o.selectFilter = function selectRoutine( srcMap, k )
  {
    if( _.longHas( [ 'arguments', 'conlyExpliciter' ], k ) )
    return;
    if( !_.routine.is( srcMap[ k ] ) )
    return k;
  }

  let result = _.props._ofAct( o );
  return result;
}

onlyExplicitFields.defaults =
{
}

//

function own( src, key )
{
  // if( src === null )
  // return false;
  // if( src === undefined )
  // return false;
  if( _.primitive.is( src ) )
  return false;
  return Object.hasOwnProperty.call( src, key );
}

//

function has( src, key )
{
  if( _.primitive.is( src ) )
  return false;
  if( !Reflect.has( src, key ) )
  return false;
  return true;
}

//

function ownEnumerable( src, key )
{
  if( _.primitive.is( src ) )
  return false;

  let descriptor = Object.getOwnPropertyDescriptor( src, key );

  if( !descriptor )
  return false;

  debugger;

  return !!descriptor.enumerable
}

//

function hasEnumerable( src, key )
{
  if( _.primitive.is( src ) )
  return false;

  let found = _.props.descriptorOf( src, key );

  debugger;

  if( !found.descriptor )
  return false;

  return !!found.descriptor.enumerable
}

//

function descriptorActiveOf( object, name )
{
  let result = Object.create( null );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !!object, 'No object' );

  do
  {
    let descriptor = Object.getOwnPropertyDescriptor( object, name );
    if( descriptor && !( 'value' in descriptor ) )
    {
      result.descriptor = descriptor;
      result.object = object;
      return result;
    }
    object = Object.getPrototypeOf( object );
  }
  while( object );

  return result;
}

//

function descriptorOf( object, name )
{
  let result = Object.create( null );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  do
  {
    let descriptor = Object.getOwnPropertyDescriptor( object, name );
    if( descriptor )
    {
      result.descriptor = descriptor;
      result.object = object;
      return result;
    }
    object = Object.getPrototypeOf( object );
  }
  while( object );

  return result;
}

//

function descriptorOwnOf( object, name )
{
  return Object.getOwnPropertyDescriptor( object, name );
}

// --
// meta
// --

/* qqq : optimize */
function namespaceOf( src )
{

  if( _.map.is( src ) )
  return _.map;
  if( _.aux.is( src ) )
  return _.aux;
  if( _.object.is( src ) )
  return _.object;
  if( _.props.is( src ) )
  return _.props;

  return null;
}

// --
// props extension
// --

let PropsExtension =
{

  //

  NamespaceName : 'props',
  NamespaceNames : [ 'props' ],
  NamespaceQname : 'wTools/props',
  MoreGeneralNamespaceName : 'props',
  MostGeneralNamespaceName : 'props',
  TypeName : 'Props',
  TypeNames : [ 'Props', 'Properties' ],
  // SecondTypeName : 'Properties',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is,
  like,
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow, /* qqq : for junior : cover */
  from,

  // amender

  _extendWithHashmap,
  _extendWithSet,
  _extendWithCountable,
  _extendWithProps,
  _extendUniversal,
  extendUniversal,
  extend,

  _supplementWithHashmap,
  _supplementWithSet,
  _supplementWithCountable,
  _supplementWithProps,
  _supplementUniversal,
  supplementUniversal,
  supplement,

  // properties

  _keys,
  keys, /* qqq : for junior : cover */
  onlyOwnKeys, /* qqq : for junior : cover */
  onlyEnumerableKeys, /* qqq : for junior : implement and cover properly */
  allKeys, /* qqq : for junior : cover */

  _vals,
  vals, /* qqq : for junior : cover */
  onlyOwnVals, /* qqq : for junior : cover */
  onlyEnumerableVals, /* qqq : for junior : implement and cover properly */
  allVals, /* qqq : for junior : cover */

  _pairs, /* qqq : for junior : cover */
  pairs, /* qqq : for junior : cover */
  onlyOwnPairs, /* qqq : for junior : cover */
  onlyEnumerablePairs, /* qqq : for junior : implement and cover properly */
  allPairs, /* qqq : for junior : cover */

  _ofAct,
  of : _of,
  onlyOwn,
  onlyExplicit,

  routines,
  onlyOwnRoutines,
  onlyExplicitRoutines,

  fields,
  onlyOwnFields,
  onlyExplicitFields,

  own, /* qqq : cover please */
  has, /* qqq : cover please */
  ownEnumerable, /* qqq : cover please */
  hasEnumerable, /* qqq : cover please */

  // propertyDescriptorActiveGet,
  // propertyDescriptorGet,
  descriptorActiveOf, /* qqq : cover please */
  descriptorOf, /* qqq : cover please */
  descriptorOwnOf,

  // meta

  namespaceOf,
  namespaceWithDefaultOf : _.long.namespaceWithDefaultOf,
  _functor_functor : _.long._functor_functor,

}

//

Object.assign( _.props, PropsExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  // dichotomy

  propsIs : is.bind( _.props ),
  propsLike : like.bind( _.props ),

  // maker

  propsMakeEmpty : makeEmpty.bind( _.props ),
  propsMakeUndefined : makeUndefined.bind( _.props ),
  propsMake : make.bind( _.props ),
  propsCloneShallow : cloneShallow.bind( _.props ),
  propsFrom : from.bind( _.props ),

  // amender

  propsExtend : extend.bind( _.props ),
  propsSupplement : supplement.bind( _.props ),

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/2Props.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _2Props_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _2Props_s */ })();

/* */  /* begin of file _3Blank_s */ ( function _3Blank_s() { function _3Blank_s_naked() { ( function _l1_3Blank_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.blank = _.blank || Object.create( null );

// --
// blank
// --

function is( src )
{
  return true;
}

//

function like( src )
{
  return this.is( src );
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return false;
}

// --
// maker
// --

function _makeEmpty( src )
{
  return src;
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  return src;
}

//

function _makeUndefined( src )
{
  return src;
}

//

function makeUndefined( src, length )
{
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  return src;
}

//

function _make( src )
{
  return src;
}

//

function make( src )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length === 1 );
  return this._make( src );
}

//

function _cloneShallow( src )
{
  return src;
}

// --
// meta
// --

/* qqq : optimize */
function namespaceOf( src )
{
  return this;
}

//

function namespaceWithDefaultOf( src )
{
  return this;
}

// --
// extension
// --

let ToolsExtension =
{

  // dichotomy

  blankIs : is.bind( _.blank ),
  blankLike : like.bind( _.blank ),

}

Object.assign( _, ToolsExtension );

//

let BlankExtension =
{

  //

  NamespaceName : 'blank',
  NamespaceNames : [ 'blank' ],
  NamespaceQname : 'wTools/blank',
  MoreGeneralNamespaceName : 'blank',
  MostGeneralNamespaceName : 'blank',
  TypeName : 'Blank',
  TypeNames : [ 'Blank' ],
  // SecondTypeName : 'Blank',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is,
  like,
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow : _.props.cloneShallow, /* qqq : for junior : cover */
  from : _.props.from, /* qqq : for junior : cover */

  // meta

  namespaceOf,
  namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

Object.assign( _.blank, BlankExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/3Blank.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _3Blank_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _3Blank_s */ })();

/* */  /* begin of file _5ArgumentsArray_s */ ( function _5ArgumentsArray_s() { function _5ArgumentsArray_s_naked() { ( function _l1_5ArgumentsArray_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.argumentsArray = _.argumentsArray || Object.create( null );

// --
// dichotomy
// --

function is( src )
{
  return Object.prototype.toString.call( src ) === '[object Arguments]';
}

//

function isOld( src )
{
  return Object.prototype.toString.call( src ) === '[object Arguments]';
}

//

function isIterator( src )
{
  if( !src || !src[ Symbol.iterator ] )
  return false;
  return Object.prototype.toString.call( src ) === '[object Arguments]';
}

//

/* qqq : for Rahul : bad : useless variant */
// function isUsingFunctor_functor( src )
// {
//   let argumentObject = '[object Arguments]';
//   return isUsingFunctor;
//
//   function isUsingFunctor( src )
//   {
//     return Object.prototype.toString.call( src ) === argumentObject;
//   }
// }
//
// let isUsingFunctor = isUsingFunctor_functor();

//

function like( src )
{
  if( Array.isArray( src ) )
  return true;
  if( Object.prototype.toString.call( src ) === '[object Arguments]' )
  return true;
  return false;
}

//

function likeOld( src )
{
  if( _.array.is( src ) )
  return true;
  if( _.argumentsArray.is( src ) )
  return true;
  return false;
}

//

function likeUnfolded( src )
{
  if( Array.isArray( src ) )
  return true;
  if( Object.prototype.toString.call( src ) === '[object Arguments]' )
  return true;
  return false;
}

//

/* qqq : for Rahul : bad : misleading name, this is not functor! */
// function likeUsingIsFunctor( src )
// {
//   if( _.argumentsArray.isUsingFunctor( src ) )
//   return true;
//   if( _.array.is( src ) )
//   return true;
//   return false;
// }

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return false;
}

// --
// maker
// --

function _makeAct()
{
  return arguments;
}

//

function _make( src, length )
{
  if( arguments.length === 2 )
  {
    let data = length;
    if( _.number.is( length ) )
    data = src;
    if( _.countable.is( length ) )
    length = length.length;

    const dst = _.argumentsArray._makeAct.apply( _, _.number.is( length ) ? Array( length ) : [ ... length ] );
    return fill( dst, data );
  }
  else if( arguments.length === 1 )
  {
    if( _.numberIs( src ) )
    return _.argumentsArray._makeAct.apply( _, Array( src ) );
    if( _.countable.is( src ) )
    return _.argumentsArray._makeAct.apply( _, [ ... src ] );
  }
  return _.argumentsArray._makeAct.apply( _, [] );

  /* */

  function fill( dst, data )
  {
    if( data === null || data === undefined )
    return dst;
    let l = Math.min( length, data.length );
    for( let i = 0 ; i < l ; i++ )
    dst[ i ] = data[ i ];
    return dst;
  }

}

//

function make( src, length )
{
  // if( !( arguments.length === 0 || src === null || _.countable.is( src ) || _.numberIs( src ) ) )
  // debugger;
  _.assert( arguments.length === 0 || src === null || _.countable.is( src ) || _.numberIs( src ) );
  _.assert( length === undefined || !_.number.is( src ) || !_.number.is( length ) );
  _.assert( arguments.length < 2 || _.number.is( length ) || _.countable.is( length ) );
  _.assert( arguments.length <= 2 );
  return this._make( ... arguments );
}

//

function _makeEmpty()
{
  return this._make( 0 );
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || src === null || this.like( src ) || _.countable.is( src ) );
  _.assert( arguments.length <= 1 );
  return this._makeEmpty( src );
}

//

function _makeUndefined( src, length )
{
  if( arguments.length === 0 )
  return this._make( 0 );

  if( length === undefined )
  length = src;
  if( length && !_.number.is( length ) )
  {
    if( length.length )
    length = length.length;
    else
    length = [ ... length ].length;
  }
  return this._make( length );
}

//

function makeUndefined( src, length )
{
  _.assert( 0 <= arguments.length && arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routineIs( src ) );
    _.assert( _.numberIs( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.numberIs( src ) || _.countable.is( src ) || _.routineIs( src ) );
  }
  return this._makeUndefined( ... arguments );
}

//

function _makeZeroed( src, length )
{
  return this._makeFilling.call( this, 0, ... arguments );
}

//

function makeZeroed( src, length )
{
  _.assert( 0 <= arguments.length && arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routine.is( src ) );
    _.assert( _.number.is( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.numberIs( src ) || _.long.is( src ) || _.countable.is( src ) ||  _.routine.is( src ) );
  }
  return this._makeZeroed( ... arguments );
}

//

function _makeFilling( type, value, length )
{
  if( arguments.length === 2 )
  {
    value = arguments[ 0 ];
    length = arguments[ 1 ];
  }

  if( !_.number.is( length ) )
  // if( _.long.is( length ) )
  if(  length.length )
  length = length.length;
  else if( _.countable.is( length ) )
  length = [ ... length ].length;

  let result = this._make( length );
  for( let i = 0 ; i < length ; i++ )
  result[ i ] = value;

  return result;
}

//

function makeFilling( type, value, length )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( arguments.length === 2 )
  {
    _.assert( _.number.is( value ) || _.countable.is( value ) );
    _.assert( type !== undefined );
  }
  else
  {
    _.assert( value !== undefined );
    _.assert( _.number.is( length ) || _.countable.is( length ) );
    _.assert( type === null || _.routine.is( type ) || _.long.is( type ) );
  }

  return this._makeFilling( ... arguments );
}

//

function _cloneShallow( src )
{
  return this._makeAct( ... src );
}

//

function cloneShallow( src )
{
  _.assert( this.is( src ) );
  _.assert( arguments.length === 1 );
  return this._cloneShallow( src );
}

//

function from( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( this.is( src ) )
  return src;
  return this.make( src );
}

// --
// extension
// --

var ToolsExtension =
{

  // dichotomy

  argumentsArrayIs : is.bind( _.argumentsArray ),
  argumentsArrayLike : like.bind( _.argumentsArray ),

  // maker

  argumentsArrayMakeEmpty : makeEmpty.bind( _.argumentsArray ),
  argumentsArrayMakeUndefined : makeUndefined.bind( _.argumentsArray ),
  argumentsArrayMake : make.bind( _.argumentsArray ),
  argumentsArrayCloneShallow : cloneShallow.bind( _.argumentsArray ),
  argumentsArrayFrom : from.bind( _.argumentsArray ),

}

//

Object.assign( _, ToolsExtension );

//

var ArgumentsArrayExtension =
{

  //

  NamespaceName : 'argumentsArray',
  NamespaceNames : [ 'argumentsArray' ],
  NamespaceQname : 'wTools/argumentsArray',
  MoreGeneralNamespaceName : 'long',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'ArgumentsArray',
  TypeNames : [ 'ArgumentsArray', 'Arguments' ],
  // SecondTypeName : 'Arguments',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is, /* qqq : cover */
  isOld,
  isIterator,
  // isUsingFunctor,
  like, /* qqq : cover */
  likeOld,
  likeUnfolded,
  // likeUsingIsFunctor,
  IsResizable,

  // maker

  _makeAct,
  _make,
  make, /* qqq : for junior : cover */
  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _makeZeroed,
  makeZeroed, /* qqq : for junior : cover */
  _makeFilling,
  makeFilling,
  _cloneShallow,
  cloneShallow, /* qqq : for junior : cover */
  from, /* qqq : for junior : cover */

  // meta

  namespaceOf : _.blank.namespaceOf,
  namespaceWithDefaultOf : _.blank.namespaceWithDefaultOf,
  _functor_functor : _.blank._functor_functor,

}

Object.assign( _.argumentsArray, ArgumentsArrayExtension );
_.long._namespaceRegister( _.argumentsArray );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/5ArgumentsArray.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _5ArgumentsArray_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _5ArgumentsArray_s */ })();

/* */  /* begin of file _5BufferTyped_s */ ( function _5BufferTyped_s() { function _5BufferTyped_s_naked() { ( function _l1_5BufferTyped_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.buffer = _.buffer || Object.create( null );
_.bufferTyped = _.bufferTyped || Object.create( null );
_.bufferTyped.namespaces = _.bufferTyped.namespaces || Object.create( null );

// --
// implementation
// --

function is( src )
{
  if( !( src instanceof Object.getPrototypeOf( Int8Array ) ) )
  return false;
  if( _.buffer.nodeIs( src ) )
  return false;
  return true;
}

//

function isSlow( src )
{
  let type = Object.prototype.toString.call( src );
  if( !/\wArray/.test( type ) )
  return false;
  if( type === '[object SharedArrayBuffer]' )
  return false;
  if( _.buffer.nodeIs( src ) )
  return false;
  return true;
}

//

// /*qqq: Same as is. Should We Keep it?
function isUsingGetPrototype( src )
{
  if( !( src instanceof Object.getPrototypeOf( Int8Array ) ) )
  return false;
  if( _.buffer.nodeIs( src ) )
  return false;
  return true;
}

//

function isUsingGetPrototypeWithFunctor_functor()
{
  let TypedArray = Object.getPrototypeOf( Int8Array );
  return isUsingGetPrototypeWithFunctor;
  function isUsingGetPrototypeWithFunctor( src )
  {
    if( !( src instanceof TypedArray ) )
    return false;
    if( _.buffer.nodeIs( src ) )
    return false;
    return true;
  }
}

let isUsingGetPrototypeWithFunctor = isUsingGetPrototypeWithFunctor_functor();

//

function isUsingExistenceOfField_functor()
{
  let TypedArray = Object.getPrototypeOf( Int8Array );
  return isUsingExistenceOfField;
  function isUsingExistenceOfField( src )
  {
    if( !src )
    return false;
    if( !( src.buffer ) )
    return false;
    if( !( src instanceof TypedArray ) )
    return false;
    if( _.buffer.nodeIs( src ) )
    return false;
    return true;
  }
}

let isUsingExistenceOfField = isUsingExistenceOfField_functor();

//

function alternateSet_functor()
{
  let typedArraysSet = new Set();
  typedArraysSet.add( '[object BigUint64Array]' );
  typedArraysSet.add( '[object Uint32Array]' );
  typedArraysSet.add( '[object Uint16Array]' );
  typedArraysSet.add( '[object Uint8Array]' );
  typedArraysSet.add( '[object Uint8ClampedArray]' );
  typedArraysSet.add( '[object BigInt64Array]' );
  typedArraysSet.add( '[object Int32Array]' );
  typedArraysSet.add( '[object Int16Array]' );
  typedArraysSet.add( '[object Int8Array]' );
  typedArraysSet.add( '[object Float64Array]' );
  typedArraysSet.add( '[object Float32Array]' );
  return alternateSet;

  function alternateSet( src )
  {
    if( !( typedArraysSet.has( Object.prototype.toString.call( src ) ) ) )
    return false;
    if( _.buffer.nodeIs( src ) )
    return false;
    return true;
  }
}

let isUsingSet = alternateSet_functor();

//

function isUsingHashMap_functor()
{
  let typedArraysMap = new Map();
  typedArraysMap.set( '[object BigUint64Array]', '[object BigUint64Array]' );
  typedArraysMap.set( '[object Uint32Array]', '[object Uint32Array]' );
  typedArraysMap.set( '[object Uint16Array]', '[object Uint16Array]' );
  typedArraysMap.set( '[object Uint8Array]', '[object Uint8Array]' );
  typedArraysMap.set( '[object Uint8ClampedArray]', '[object Uint8ClampedArray]' );
  typedArraysMap.set( '[object BigInt64Array]', '[object BigInt64Array]' );
  typedArraysMap.set( '[object Int32Array]', '[object Int32Array]' );
  typedArraysMap.set( '[object Int16Array]', '[object Int16Array]' );
  typedArraysMap.set( '[object Int8Array]', '[object Int8Array]' );
  typedArraysMap.set( '[object Float64Array]', '[object Float64Array]' );
  typedArraysMap.set( '[object Float32Array]', '[object Float32Array]' );
  return isUsingHashMap;

  function isUsingHashMap( src )
  {
    if( !( typedArraysMap.has( Object.prototype.toString.call( src ) ) ) )
    return false;
    if( _.buffer.nodeIs( src ) )
    return false;
    return true;
  }
}

let isUsingHashMap = isUsingHashMap_functor();

//

function isUsingMap_functor()
{
  let typedArraysMap = Object.create( null );
  typedArraysMap[ '[object BigUint64Array]' ] = '[object BigUint64Array]';
  typedArraysMap[ '[object Uint32Array]' ] = '[object Uint32Array]';
  typedArraysMap[ '[object Uint16Array]' ] = '[object Uint16Array]';
  typedArraysMap[ '[object Uint8Array]' ] = '[object Uint8Array]';
  typedArraysMap[ '[object Uint8ClampedArray]' ] = '[object Uint8ClampedArray]';
  typedArraysMap[ '[object BigInt64Array]' ] = '[object BigInt64Array]';
  typedArraysMap[ '[object Int32Array]' ] = '[object Int32Array]';
  typedArraysMap[ '[object Int16Array]' ] = '[object Int16Array]';
  typedArraysMap[ '[object Int8Array]' ] = '[object Int8Array]';
  typedArraysMap[ '[object Float64Array]' ] = '[object Float64Array]';
  typedArraysMap[ '[object Float32Array]' ] = '[object Float32Array]';
  return isUsingMap;

  function isUsingMap( src )
  {
    if( !typedArraysMap[ Object.prototype.toString.call( src ) ] )
    return false;
    if( _.buffer.nodeIs( src ) )
    return false;
    return true;
  }
}

let isUsingMap = isUsingMap_functor();

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return false;
}

//

function _make( src, length )
{
  if( arguments.length === 2 )
  {
    let data = length;
    if( _.number.is( length ) )
    {
      data = src;
    }
    else if( length.length )
    // else if( _.long.is( length ) )
    {
      length = length.length;
    }
    if( _.countable.is( length ) )
    {
      data = [ ... length ];
      length = data.length;
    }


    if( this.like( src ) )
    return fill( new src.constructor( length ), data );
    return fill( this.tools.bufferTyped.default.make( length ), data );
  }
  else if( arguments.length === 1 )
  {
    if( this.like( src ) )
    return new src.constructor( src );
    return this.tools.bufferTyped.default.make( src );
  }
  return this.tools.bufferTyped.default.make( 0 );

  /* */

  function fill( dst, data )
  {
    if( data === null || data === undefined )
    return dst;
    let l = Math.min( length, data.length );
    for( let i = 0 ; i < l ; i++ )
    dst[ i ] = data[ i ];
    return dst;
  }
}

//

function _makeEmpty( src )
{
  if( arguments.length === 1 )
  {
    if( _.routine.is( src ) )
    {
      let result = new src( 0 );
      _.assert( this.like( result ) );
      return result;
    }
    if( this.like( src ) )
    return new src.constructor();
  }
  return this.tools.bufferTyped.default.make();
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || this.like( src ) || _.countable.is( src ) || _.routine.is( src ) );
  _.assert( arguments.length <= 1 );
  // _.assert( arguments.length === 0 || arguments.length === 1 );
  // if( arguments.length === 1 )
  // _.assert( this.like( src ) || _.countable.is( src ) || _.routine.is( src ) );

  return this._makeEmpty( ... arguments );
}

//

function _makeUndefined( src, length )
{
  if( arguments.length === 0 )
  return this.make( 0 );

  if( length === undefined )
  length = src;
  if( length && !_.number.is( length ) )
  {
    if( length.length )
    length = length.length;
    else
    length = [ ... length ].length;
  }
  if( this.like( src ) )
  return new src.constructor( length );
  return this._make( length );
}

//

function _makeFilling( type, value, length )
{
  if( arguments.length === 2 )
  {
    value = arguments[ 0 ];
    length = arguments[ 1 ];
    if( this.like( length ) )
    type = length;
    else
    type = null;
  }

  if( !_.number.is( length ) )
  // if( _.long.is( length ) )
  if(  length.length )
  length = length.length;
  else if( _.countable.is( length ) )
  length = [ ... length ].length;

  let result = this._make( type, length );
  for( let i = 0 ; i < length ; i++ )
  result[ i ] = value;

  return result;
}

//

function _cloneShallow( src )
{
  return src.slice( 0 );
  // if( _.buffer.rawIs( src ) )
  // return bufferRawCopy( src );
  // if( _.buffer.viewIs( src ) )
  // return new BufferView( bufferRawCopy( src ) );
  // if( _.buffer.typedIs( src ) )
  // return src.slice( 0 );
  // if( _.buffer.nodeIs( src ) )
  // return src.copy();
  //
  // /* */
  //
  // function bufferRawCopy( src )
  // {
  //   var dst = new BufferRaw( src.byteLength );
  //   new U8x( dst ).set( new U8x( src ) );
  //   return dst;
  // }
}

// --
// meta
// --

function _namespaceRegister( namespace, defaultNamespaceName )
{

  namespace.NamespaceNames.forEach( ( name ) =>
  {
    _.assert( _.bufferTyped.namespaces[ name ] === undefined );
    _.bufferTyped.namespaces[ name ] = namespace;
  });

  _.assert( namespace.IsTyped === undefined || namespace.IsTyped === true );
  namespace.IsTyped = true;

  return _.long._namespaceRegister( ... arguments );
}

//

/* qqq : optimize */
function namespaceOf( src )
{

  if( _.f32x.is( src ) )
  return _.f32x;
  if( _.f64x.is( src ) )
  return _.f64x;

  if( _.i8x.is( src ) )
  return _.i8x;
  if( _.i16x.is( src ) )
  return _.i16x;
  if( _.i32x.is( src ) )
  return _.i32x;

  if( _.u8x.is( src ) )
  return _.u8x;
  if( _.u8xClamped.is( src ) )
  return _.u8xClamped;
  if( _.u16x.is( src ) )
  return _.u16x;
  if( _.u32x.is( src ) )
  return _.u32x;

  return null;
}

// --
// declaration
// --

let BufferTypedExtension =
{

  //

  NamespaceName : 'bufferTyped',
  NamespaceNames : [ 'bufferTyped' ],
  NamespaceQname : 'wTools/bufferTyped',
  MoreGeneralNamespaceName : 'long',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'BufferTyped',
  TypeNames : [ 'BufferTyped' ],
  // SecondTypeName : 'ArrayTyped',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  // typedIs : is,
  is : is,
  like : is,
  IsResizable,
  isSlow, /* xxx : remove later */
  isUsingGetPrototype,
  isUsingGetPrototypeWithFunctor,
  isUsingExistenceOfField,
  isUsingSet,
  isUsingHashMap,
  isUsingMap,

  // maker

  _make, /* qqq : cover */
  make : _.long.make,
  _makeEmpty,
  makeEmpty,
  _makeUndefined, /* qqq : implement */
  makeUndefined : _.argumentsArray.makeUndefined,
  _makeZeroed : _makeUndefined,
  makeZeroed : _.argumentsArray.makeZeroed, /* qqq : for junior : cover */
  _makeFilling,
  makeFilling : _.argumentsArray.makeFilling, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow : _.argumentsArray.cloneShallow, /* qqq : for junior : cover */
  from : _.argumentsArray.from, /* qqq : for junior : cover */

  // meta

  _namespaceRegister,

  namespaceOf,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

Object.assign( _.bufferTyped, BufferTypedExtension );

//

let BufferExtension =
{

  // dichotomy

  typedIs : is.bind( _.buffer ),

}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{

  // dichotomy

  bufferTypedIs : is.bind( _.buffer ),

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/5BufferTyped.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _5BufferTyped_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _5BufferTyped_s */ })();

/* */  /* begin of file Array_s */ ( function Array_s() { function Array_s_naked() { ( function _l1_Array_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.array = _.array || Object.create( null );
_.countable = _.countable || Object.create( null );
_.vector = _.vector || Object.create( null );

_.assert( !!_.argumentsArray.make, 'Expects routine _.argumentsArray.make' );

// --
// array
// --

/**
 * The is() routine determines whether the passed value is an Array.
 *
 * If the {-srcMap-} is an Array, true is returned,
 * otherwise false is.
 *
 * @param { * } src - The object to be checked.
 *
 * @example
 * _.array.is( [ 1, 2 ] );
 * // returns true
 *
 * @example
 * _.array.is( 10 );
 * // returns false
 *
 * @returns { boolean } Returns true if {-srcMap-} is an Array.
 * @function is
 * @namespace Tools
 */

function is( src )
{
  return Array.isArray( src );
  // return Object.prototype.toString.call( src ) === '[object Array]';
}

//

function isEmpty( src )
{
  if( !_.array.is( src ) )
  return false;
  return src.length === 0;
}

//

function isPopulated( src )
{
  if( !_.array.is( src ) )
  return false;
  return src.length > 0;
}

//

function likeResizable( src )
{
  return _.array.is( src );
}

//

function like( src ) /* qqq : cover */
{
  return this.is( src );
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return true;
}

// --
// maker
// --

function _make( src, length )
{
  if( arguments.length === 2 )
  {
    let data = length;
    if( _.number.is( length ) )
    {
      data = src;
    }
    else if( length.length )
    {
      length = length.length;
    }
    if( _.countable.is( length ) )
    {
      data = [ ... length ];
      length = data.length;
    }

    return fill( new Array( length ), data );
  }
  else if( arguments.length === 1 )
  {
    if( _.number.is( src ) )
    return new Array( src );
    if( _.countable.is( src ) )
    return [ ... src ];
  }
  return [];

  /* */

  function fill( dst, data )
  {
    if( data === null || data === undefined )
    return dst;
    let l = Math.min( length, data.length );
    for( let i = 0 ; i < l ; i++ )
    dst[ i ] = data[ i ];
    return dst;
  }

}

//

function _cloneShallow( srcArray )
{
  return srcArray.slice();
}

//

/**
 * The as() routine copies passed argument to the array.
 *
 * @param { * } src - The source value.
 *
 * @example
 * _.array.as( false );
 * // returns [ false ]
 *
 * @example
 * _.array.as( { a : 1, b : 2 } );
 * // returns [ { a : 1, b : 2 } ]
 *
 * @returns { Array } - If passed null or undefined than return the empty array. If passed an array then return it.
 * Otherwise return an array which contains the element from argument.
 * @function as
 * @namespace Tools/array
 */

function as( src )
{
  _.assert( arguments.length === 1 );
  _.assert( src !== undefined );

  //src === undefined check below conflicts with above assert
  // if( src === null || src === undefined )
  if( src === null )
  return [];
  else if( _.array.is( src ) )
  return src;
  else if( _.countable.like( src ) )
  return [ ... src ];
  else
  return [ src ];

}

// //
//
// function asTest( src )
// {
//   _.assert( arguments.length === 1 );
//   _.assert( src !== undefined );
//
//   if( src === null )
//   return [];
//   if( src[ Symbol.iterator ] && !_.str.is( src ) )
//   return [ ... src ];
//
//   return [ src ];
// }

//

function asShallow( src )
{
  _.assert( arguments.length === 1 );
  _.assert( src !== undefined );

  if( src === null )
  return [];
  else if( _.longLike( src ) )
  return _.array.slice( src );
  else
  return [ src ];

}

// --
// array extension
// --

let ArrayExtension =
{

  // fields

  NamespaceName : 'array',
  NamespaceNames : [ 'array' ],
  NamespaceQname : 'wTools/array',
  MoreGeneralNamespaceName : 'long',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'Array',
  TypeNames : [ 'Array' ],
  // SecondTypeName : 'Array',
  InstanceConstructor : Array,
  tools : _,

  // dichotomy

  is,
  isEmpty,
  isPopulated,
  likeResizable,
  like,
  IsResizable,

  // maker

  _makeEmpty : _.argumentsArray._makeEmpty,
  makeEmpty : _.argumentsArray.makeEmpty, /* qqq : for junior : cover */
  _makeUndefined : _.argumentsArray._makeUndefined,
  makeUndefined : _.argumentsArray.makeUndefined, /* qqq : for junior : cover */
  _makeZeroed : _.argumentsArray._makeZeroed,
  makeZeroed : _.argumentsArray.makeZeroed, /* qqq : for junior : cover */
  _makeFilling : _.argumentsArray._makeFilling,
  makeFilling : _.argumentsArray.makeFilling,
  _make,
  make : _.argumentsArray.make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow : _.argumentsArray.cloneShallow, /* qqq : for junior : cover */
  from : _.argumentsArray.from, /* qqq : for junior : cover */
  as,
  // asTest,
  asShallow,

  // meta

  namespaceOf : _.blank.namespaceOf,
  namespaceWithDefaultOf : _.blank.namespaceWithDefaultOf,
  _functor_functor : _.blank._functor_functor,

}

//

Object.assign( _.array, ArrayExtension );

_.long._namespaceRegister( _.array );
_.assert( _.long.default === undefined );
_.long.default = _.array;

_.assert( _.countable.default === undefined );
_.countable.default = _.array;

_.assert( _.vector.default === undefined );
_.vector.default = _.array;

// --
// tools extension
// --

/* qqq : for junior : duplicate routines on all levels */
let ToolsExtension =
{

  // dichotomy

  arrayIs : is.bind( _.array ),
  arrayIsEmpty : isEmpty.bind( _.array ),
  arrayIsPopulated : isPopulated.bind( _.array ),
  arrayLikeResizable : likeResizable.bind( _.array ),
  arrayLike : like.bind( _.array ),

  // maker

  arrayMakeEmpty : _.argumentsArray.makeEmpty.bind( _.array ),
  // arrayMakeEmpty : makeEmpty.bind( _.array ),
  arrayMakeUndefined : _.argumentsArray.makeUndefined.bind( _.array ),
  arrayMake : _.argumentsArray.make.bind( _.array ),
  arrayCloneShallow : _.argumentsArray.cloneShallow.bind( _.array ),
  arrayFrom : _.argumentsArray.from.bind( _.array ),

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Array.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Array_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Array_s */ })();

/* */  /* begin of file ArraySet_s */ ( function ArraySet_s() { function ArraySet_s_naked() { ( function _l1_ArraySet_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.arraySet = _.arraySet || Object.create( null );

// --
// array set
// --

// --
// extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

//

let Extension =
{

}

Object.assign( _.arraySet, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/ArraySet.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ArraySet_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ArraySet_s */ })();

/* */  /* begin of file Auxiliary_s */ ( function Auxiliary_s() { function Auxiliary_s_naked() { ( function _l1_Auxiliary_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.aux = _.aux || Object.create( null );

_.assert( !!_.props.keys, 'Expects routine _.props.keys' );
_.assert( !!_.props._extendWithHashmap, 'Expects routine _.props._extendWithHashmap' );

// --
// dichotomy
// --

function is( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return true;

  if( proto === Object.prototype )
  {
    if( src[ Symbol.iterator ] )
    return Object.prototype.toString.call( src ) !== '[object Arguments]';
    return true;
  }

  if( _.routineIs( proto[ Symbol.iterator ] ) )
  return false;

  if( !_.primitive.is( proto ) )
  if( !Reflect.has( proto, 'constructor' ) || proto.constructor === Object.prototype.constructor )
  return true;

  return false;
}

// function is( src )
// {
//
//   if( !src )
//   return false;
//
//   if( src[ Symbol.iterator ] )
//   return false;
//
//   let proto = Object.getPrototypeOf( src );
//
//   if( proto === null )
//   return true;
//
//   if( proto === Object.prototype )
//   return true;
//
//   if( !_.primitive.is( proto ) )
//   if( !Reflect.has( proto, 'constructor' ) || proto.constructor === Object.prototype.constructor )
//   return true;
//
//   return false;
// }

//

function like( src )
{
  return _.aux.is( src );
}
//

function isPrototyped( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return false;

  if( proto === Object.prototype )
  return false;

  if( _.routineIs( proto[ Symbol.iterator ] ) )
  return false;

  if( !_.primitive.is( proto ) )
  if( !Reflect.has( proto, 'constructor' ) || proto.constructor === Object.prototype.constructor )
  return true;

  return false;
}

//

function isPure( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return true;

  if( proto.constructor === Object )
  return false;

  if( _.routineIs( proto[ Symbol.iterator ] ) )
  return false;

  if( !_.primitive.is( proto ) )
  if( !Reflect.has( proto, 'constructor' ) )
  return true;

  return false;
}

//

function isPolluted( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return false;

 if( proto === Object.prototype )
 {
   if( src[ Symbol.iterator ] )
   return Object.prototype.toString.call( src ) !== '[object Arguments]';
   return true;
 }

  if( _.routineIs( proto[ Symbol.iterator ] ) )
  return false;

  if( proto.constructor === Object )
  return true;

  return false;
}

// //
//
// function isPrototyped( src )
// {
//
//   if( !src )
//   return false;
//
//   if( src[ Symbol.iterator ] )
//   return false;
//
//   let proto = Object.getPrototypeOf( src );
//
//   if( proto === null )
//   return false;
//
//   if( proto === Object.prototype )
//   return false;
//
//   if( !_.primitive.is( proto ) )
//   if( !Reflect.has( proto, 'constructor' ) || proto.constructor === Object.prototype.constructor )
//   return true;
//
//   return false;
// }
//
// //
//
// function isPure( src )
// {
//
//   if( !src )
//   return false;
//
//   if( src[ Symbol.iterator ] )
//   return false;
//
//   let proto = Object.getPrototypeOf( src );
//
//   if( proto === null )
//   return true;
//
//   if( proto.constructor === Object )
//   return false;
//
//   if( !_.primitive.is( proto ) )
//   if( !Reflect.has( proto, 'constructor' ) )
//   return true;
//
//   return false;
// }
//
// //
//
// function isPolluted( src )
// {
//
//   if( !src )
//   return false;
//
//   if( src[ Symbol.iterator ] )
//   return false;
//
//   let proto = Object.getPrototypeOf( src );
//
//   if( proto === null )
//   return false;
//
//   if( proto.constructor === Object )
//   return true;
//
//   return false;
// }

//

function isEmpty( src )
{
  if( !this.like( src ) )
  return false;
  return this.keys( src ).length === 0;
}

//

function isPopulated( src )
{
  if( !this.like( src ) )
  return false;
  return this.keys( src ).length > 0;
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return true;
}

// --
// maker
// --

function _makeEmpty( src )
{
  let result = Object.create( null );
  let src2 = _.prototype.of( src );
  while( src2 && src2 !== Object.prototype )
  {
    result = Object.create( result );
    src2 = _.prototype.of( src2 );
  }
  return result;
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  _.assert( this.like( src ) );
  return this._makeEmpty( src );
}

//

function _makeUndefined( src, length )
{
  let result = Object.create( null );
  return result;
}

//

function makeUndefined( src, length )
{
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 2 )
  {
    _.assert( this.like( src ) );
    _.assert( _.number.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( _.number.is( src ) || this.like( src ) );
  }

  return this._makeUndefined( src );
}

//

function _make( src )
{
  if( src )
  {
    if( this.like( src ) )
    return this._cloneShallow( src );
    else
    return this.extendUniversal( Object.create( null ), src );
  }
  return Object.create( null );
}

//

function make( src, length )
{
  _.assert( arguments.length === 0 || src === null || !_.primitive.is( src ) );
  _.assert( length === undefined || length === 0 );
  _.assert( arguments.length <= 2 );
  return this._make( ... arguments );
}

//

function _cloneShallow( src )
{
  let dst = Object.create( null );
  let prototypes = _.prototype.each( src );
  let c = 1;

  for( let i = 1, l = prototypes.length ; i < l ; i++ )
  {
    let prototype = prototypes[ i ];
    if( prototype && prototype !== Object.prototype )
    {
      dst = Object.create( dst );
      c += 1;
    }
  }

  let result = dst;

  while( c > 0 )
  {
    copy( dst, src );
    dst = _.prototype.of( dst );
    src = _.prototype.of( src );
    c -= 1;
  }

  return result;

  function copy( dst, src )
  {
    let keys = _.props.onlyOwnKeys( src );
    for( let k = 0 ; k < keys.length ; k++ )
    dst[ keys[ k ] ] = src[ keys[ k ] ];
  }

}

// --
// meta
// --

/* qqq : optimize */
function namespaceOf( src )
{

  if( _.map.is( src ) )
  return _.map;
  if( _.aux.is( src ) )
  return _.aux;

  return null;
}

// --
// extension
// --

let ToolsExtension =
{

  // dichotomy

  auxIs : is.bind( _.aux ),
  auxIsPure : isPure.bind( _.aux ),
  auxIsPolluted : isPolluted.bind( _.aux ),
  auxIsEmpty : isEmpty.bind( _.aux ),
  auxIsPopulated : isPopulated.bind( _.aux ),
  auxLike : like.bind( _.aux ),

  // maker

  auxMakeEmpty : makeEmpty.bind( _.aux ),
  auxMakeUndefined : makeUndefined.bind( _.aux ),
  auxMake : make.bind( _.aux ),
  auxCloneShallow : _.props.cloneShallow.bind( _.aux ),
  auxFrom : _.props.from.bind( _.aux ),

  // amender

  auxExtend : _.props.extend.bind( _.aux ),
  auxSupplement : _.props.supplement.bind( _.aux ),

}

Object.assign( _, ToolsExtension );

//

var AuxiliaryExtension =
{

  //

  NamespaceName : 'aux',
  NamespaceNames : [ 'aux' ],
  NamespaceQname : 'wTools/aux',
  MoreGeneralNamespaceName : 'props',
  MostGeneralNamespaceName : 'props',
  TypeName : 'Aux',
  TypeNames : [ 'Aux', 'Auxiliary' ],
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is,
  like,
  isPrototyped,
  isPure,
  isPolluted,

  isEmpty, /* qqq : cover */
  isPopulated, /* qqq : cover */
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow : _.props.cloneShallow, /* qqq : for junior : cover */
  from : _.props.from, /* qqq : for junior : cover */

  // properties

  _keys : _.props._keys,
  keys : _.props.keys, /* qqq : for junior : cover */
  onlyOwnKeys : _.props.onlyOwnKeys, /* qqq : for junior : cover */
  onlyEnumerableKeys : _.props.onlyEnumerableKeys, /* qqq : for junior : implement and cover properly */
  allKeys : _.props.allKeys, /* qqq : for junior : cover */

  _vals : _.props._vals,
  vals : _.props.vals, /* qqq : for junior : cover */
  onlyOwnVals : _.props.onlyOwnVals, /* qqq : for junior : cover */
  onlyEnumerableVals : _.props.onlyEnumerableVals, /* qqq : for junior : implement and cover properly */
  allVals : _.props.allVals, /* qqq : for junior : cover */

  _pairs : _.props._pairs,
  pairs : _.props.pairs, /* qqq : for junior : cover */
  onlyOwnPairs : _.props.onlyOwnPairs, /* qqq : for junior : cover */
  onlyEnumerablePairs : _.props.onlyEnumerablePairs, /* qqq : for junior : implement and cover properly */
  allPairs : _.props.allPairs, /* qqq : for junior : cover */

  // amender

  _extendWithHashmap : _.props._extendWithHashmap,
  _extendWithSet : _.props._extendWithSet,
  _extendWithCountable : _.props._extendWithCountable,
  _extendWithProps : _.props._extendWithProps,
  _extendUniversal : _.props._extendUniversal,
  extendUniversal : _.props.extendUniversal,
  extend : _.props.extend,

  _supplementWithHashmap : _.props._supplementWithHashmap,
  _supplementWithSet : _.props._supplementWithSet,
  _supplementWithCountable : _.props._supplementWithCountable,
  _supplementWithProps : _.props._supplementWithProps,
  _supplementUniversal : _.props._supplementUniversal,
  supplementUniversal : _.props.supplementUniversal,
  supplement : _.props.supplement,

  // meta

  namespaceOf,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

Object.assign( _.aux, AuxiliaryExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Auxiliary.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Auxiliary_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Auxiliary_s */ })();

/* */  /* begin of file BigInt_s */ ( function BigInt_s() { function BigInt_s_naked() { ( function _l1_BigInt_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.bigInt = _.bigInt || Object.create( null );
_.bigInts = _.bigInt.s = _.bigInts || _.bigInt.s || Object.create( null );

// --
// implementation
// --

function is( src )
{
  let result = Object.prototype.toString.call( src ) === '[object BigInt]';
  return result;
}

//

function exportStringCodeShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.bigInt.is( src ) );

  return `${String( src )}n`;
}

// --
// big int extension
// --

let BigIntExtension =
{

  //

  is,

  // exporter

  exportString : exportStringCodeShallow,
  exportStringCodeShallow,
  exportStringDiagnosticShallow : exportStringCodeShallow,

}

Object.assign( _.bigInt, BigIntExtension );

// --
// extension
// --

let ToolsExtension =
{

  bigIntIs : is,

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/BigInt.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BigInt_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BigInt_s */ })();

/* */  /* begin of file Bool_s */ ( function Bool_s() { function Bool_s_naked() { ( function _l1_Bool_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.bool = _.bool || Object.create( null );
_.bools = _.bool.s = _.bools || _.bool.s || Object.create( null );

// --
// bool
// --

/**
 * Returns true if entity ( src ) is a Boolean values - true and false.
 * @function is
 * @param { * } src - An entity to check.
 * @namespace Tools
 *
 * @example
 * var got = _.bool.is( '' );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.bool.is( 1 );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.bool.is( true );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.bool.is( false );
 * console.log( got )
 * // log true
 *
 */

function is( src )
{
  return src === true || src === false;
}

//

/**
 * Routine like() returns true if entity ( src ) is a Boolean values - true and false or Numbers 1 and 0.
 * @function like
 * @param { * } src - An entity to check.
 * @namespace Tools
 *
 * @example
 * var got = _.bool.like( false );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.bool.like( true );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.bool.like( 1 );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.bool.like( 0 );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.bool.like( '0' );
 * console.log( got )
 * // log false
 *
 */

function like( src )
{
  return src === true || src === false || src === 0 || src === 1;
  // let type = Object.prototype.toString.call( src );
  // return type === '[object Boolean]' || src === 0 || src === 1;
}

//

/**
 * Returns true if entity ( src ) is Boolean value - false or Number - 0.
 * @function likeFalse
 * @param { * } src - An entity to check.
 * @namespace Tools
 *
 * @example
 * var got = _.bool.likeFalse( 0 );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.bool.likeFalse( 1 );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.bool.likeFalse( false );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.bool.likeFalse( true );
 * console.log( got )
 * // log false
 *
 */

function likeFalse( src )
{
  if( !_.bool.like( src ) )
  return false;
  return !src;
}

//

/**
 * Returns true if entity ( src ) is Boolean value - true or Number - 1.
 * @function likeTrue
 * @param { * } src - An entity to check.
 * @namespace Tools
 *
 * @example
 * var got = _.bool.likeTrue( 0 );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.bool.likeTrue( 1 );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.bool.likeTrue( false );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.bool.likeTrue( true );
 * console.log( got )
 * // log true
 *
 */

function likeTrue( src )
{
  if( !_.bool.like( src ) )
  return false;
  return !!src;
}

// --
// bool extension
// --

let BoolExtension =
{

  is,
  like,
  likeFalse,
  likeTrue,

}

Object.assign( _.bool, BoolExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  boolIs : is,
  boolLike : like,
  boolLikeFalse : likeFalse,
  boolLikeTrue : likeTrue,

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Bool.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Bool_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Bool_s */ })();

/* */  /* begin of file Buffer_s */ ( function Buffer_s() { function Buffer_s_naked() { ( function _l1_Buffer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.buffer = _.buffer || Object.create( null );

// --
// implementation
// --

function anyIs( src )
{
  if( src instanceof ArrayBuffer )
  return true;
  if( _global.BufferRawShared && src instanceof SharedArrayBuffer )
  return true;
  if( ArrayBuffer.isView( src ) )
  return true;
  return false;
}

// //
//
// function anyIsOld( src )
// {
//   if( !src )
//   return false;
//   if( typeof src !== 'object' )
//   return false;
//   //{ byteLength: 6 } will pass the below check
//   if( !Reflect.has( src, 'byteLength' ) )
//   return false;
//   // return src.byteLength >= 0;
//   // return typedIs( src ) || viewIs( src )  || rawIs( src ) || nodeIs( src );
//   return true;
// }
//
// //
//
// function anyIsUsingInstanceOf( src )
// {
//   if( src instanceof ArrayBuffer )
//   return true;
//   if( src instanceof SharedArrayBuffer )
//   return true;
//   if( ArrayBuffer.isView( src ) )
//   return true;
//   return false;
// }

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return false;
}

// --
// maker
// --

function _make_functor( onMake )
{

  return function _bufferMake( src, ins )
  {
    let result;

    /* */

    let length = ins;

    // if( _.longIs( length ) || _.bufferNodeIs( length ) )
    if( _.countable.is( length ) || _.bufferNodeIs( length ) )
    {
      if( length.length )
      {
        length = length.length;
      }
      else
      {
        ins = [ ... length ];
        length = ins.length;
      }
    }
    else if( _.bufferRawIs( length ) || _.bufferViewIs( length ) )
    {
      length = length.byteLength;
      ins = _.bufferViewIs( ins ) ? new U8x( ins.buffer ) : new U8x( ins );
    }
    else if( length === undefined || length === null )
    {
      if( src === null ) /* Dmytro : Does module has default buffer type? */
      {
        length = 0;
      }
      else if( _.longIs( src ) || _.bufferNodeIs( src ) )
      {
        length = src.length;
        ins = src;
        // src = null;
      }
      else if( _.bufferRawIs( src ) )
      {
        length = src.byteLength;
        ins = new U8x( src );
        // src = null;
      }
      else if( _.bufferViewIs( src ) )
      {
        length = src.byteLength;
        ins = new U8x( src.buffer );
        // src = null;
      }
      else if( _.number.is( src ) )
      {
        length = src;
        src = null;
      }
      else if( _.routine.is( src ) )
      {
        _.assert( 0, 'Unknown length of buffer' );
      }
      else if( arguments.length === 0 )
      {
        length = 0;
        src = null;
      }
      else _.assert( 0 );
    }
    else if( !_.number.is( length ) )
    {
      _.assert( 0, 'Unknown length of buffer' );
    }

    if( !length )
    length = 0;

    /* */

    if( _.number.is( ins ) )
    {
      if( _.bufferRawIs( src ) )
      ins = new U8x( src );
      else if( _.bufferViewIs( src ) )
      ins = new U8x( src.buffer )
      else if( _.longIs( src ) || _.bufferNodeIs( src ) )
      ins = src;
      else
      ins = null;
    }

    /* */

    let minLength;
    if( ins )
    minLength = Math.min( ins.length, length );
    else
    minLength = 0;

    /* */

    if( _.argumentsArray.is( src ) )
    src = _.routine.join( this.tools.bufferTyped.default, this.tools.bufferTyped.default.make );
    // src = _.routine.join( this.tools.long.default, this.tools.long.default.make );

    if( src === null )
    src = _.routine.join( this.tools.bufferTyped.default, this.tools.bufferTyped.default.make );
    // src = _.routine.join( this.tools.long.default, this.tools.long.default.make );

    _.assert( 0 <= arguments.length && arguments.length <= 2 );
    // _.assert( arguments.length === 1 || arguments.length === 2 );
    _.assert( _.number.isFinite( length ) );
    _.assert( _.routine.is( src ) || _.longIs( src ) || _.bufferAnyIs( src ), 'unknown type of array', _.entity.strType( src ) );

    result = onMake.call( this, src, ins, length, minLength );

    _.assert( _.bufferAnyIs( result ) || _.longLike( result ) );

    return result;
  }
}

//

/**
 * The routine make() returns a new buffer with the same type as source buffer {-src-}. New buffer fills by content of insertion buffer {-ins-}. If {-ins-} is
 * a number, the buffer fills by {-src-} content. The length of resulted buffer is equal to {-ins-}. If {-ins-} is not defined, then routine makes default Long type,
 * length of returned container defines from {-src-}.
 *
 * @param { BufferAny|Long|Function|Number|Null } src - Instance of any buffer, Long or constructor, defines type of returned buffer. If {-src-} is null,
 * then routine returns instance of default Long.
 * @param { Number|Long|Buffer|Null|Undefined } ins - Defines length and content of new buffer. If {-ins-} is null or undefined, then routine makes new container
 * with default Long type and fills it by {-src-} content.
 *
 * Note. Default Long type defines by descriptor {-longDescriptor-}. If descriptor not provided directly, then it is Array descriptor.
 *
 * @example
 * let got = _.make();
 * // returns []
 *
 * @example
 * let got = _.make( null );
 * // returns []
 *
 * @example
 * let got = _.make( null, null );
 * // returns []
 *
 * @example
 * let got = _.make( 3 );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * let got = _.make( 3, null );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * let got = _.make( new U8x( [ 1, 2, 3 ] ) );
 * // returns [ 1, 2, 3 ];
 * _.bufferTypedIs( got );
 * // log false
 *
 * @example
 * let got = _.make( new I16x( [ 1, 2, 3 ] ), null );
 * // returns [ 1, 2, 3 ];
 * _.bufferTypedIs( got );
 * // log false
 *
 * @example
 * _.make( new BufferRaw( 4 ), 6 );
 * // returns ArrayBuffer { [Uint8Contents]: <00 00 00 00 00 00>, byteLength: 6 }
 *
 * @example
 * _.make( new BufferRaw( 4 ), [ 1, 2, 3 ] );
 * // returns ArrayBuffer { [Uint8Contents]: <01 02 03>, byteLength: 3 }
 *
 * @example
 * _.make( F64x, [ 1, 2, 3 ] );
 * // returns Float64Array [ 1, 2, 3 ]
 *
 * @returns { BufferAny|Long }  Returns a buffer with source buffer {-src-} type filled by insertion container {-ins-} content.
 * If {-ins-} is not defined, then routine makes default Long type container and fills it by {-src-} content.
 * @function make
 * @throws { Error } If arguments.length is more than two.
 * @throws { Error } If {-src-} is not a Long, not a buffer, not a Number, not a constructor, not null.
 * @throws { Error } If {-src-} is constructor and second argument {-src-} is not provided.
 * @throws { Error } If {-src-} is constructor that returns not a Long, not a buffer value.
 * @throws { Error } If {-ins-} is not a number, not a Long, not a buffer, not null, not undefined.
 * @throws { Error } If {-ins-} or src.length has a not finite value.
 * @namespace Tools
 */

function _make( src, length )
{
  if( length === undefined )
  length = src;
  let data = length;

  if( _.number.is( length ) )
  {
    data = src;
  }
  else if( length )
  {
    if( _.number.is( length.length ) )
    {
      length = length.length;
    }
    else if( _.number.is( length.byteLength ) )
    {
      length = length.byteLength;
    }
    else
    {
      data = [ ... length ];
      length = data.length;
    }
  }

  if( arguments.length === 2 )
  {
    if( src === null )
    return fill( this.tools.bufferTyped.make( length ), data );
    if( _.buffer.rawIs( src ) )
    return fill( new BufferRaw( length ), data );
    if( _.buffer.viewIs( src ) )
    return new BufferView( fill( new BufferRaw( length ), data ) );
    if( _.buffer.typedIs( src ) )
    return fill( new src.constructor( length ), data );
    if( _.buffer.nodeIs( src ) )
    return fill( BufferNode.alloc( length ), data );
    if( _.long.is( src ) )
    return fill( this.tools.bufferTyped.make( length ), data );

    let result;
    if( _.routineIs( src ) )
    result = fill( new src( length ), data )
    _.assert( _.buffer.is( result ), 'Not clear how to make such buffer' );
    return result;
  }
  else if( arguments.length === 1 )
  {
    if( src === null || _.number.is( src ) )
    return this.tools.bufferTyped.make( src );
    if( _.buffer.rawIs( src ) )
    return fill( new BufferRaw( length ), data );
    if( _.buffer.viewIs( src ) )
    return new BufferView( fill( new BufferRaw( length ), data ) );
    if( _.buffer.typedIs( src ) )
    return fill( new src.constructor( src ) );
    if( _.buffer.nodeIs( src ) )
    return fill( BufferNode.from( src ) );
    if( _.countable.is( src ) )
    return this.tools.bufferTyped.make( src );
  }

  return this.tools.bufferTyped.make();

  /* */

  function fill( dst, data )
  {
    if( data === null || data === undefined )
    return dst;

    let dstTyped = dst;
    if( _.bufferRawIs( dst ) )
    dstTyped = new U8x( dst );
    if( _.bufferViewIs( dst ) )
    dstTyped = new U8x( dst.buffer );

    let dataTyped = data;
    if( _.bufferRawIs( data ) )
    dataTyped = new U8x( data );
    if( _.bufferViewIs( data ) )
    dataTyped = new U8x( data.buffer );

    let l = Math.min( length, dataTyped.length );
    for( let i = 0 ; i < l ; i++ )
    dstTyped[ i ] = dataTyped[ i ];

    return dst;
  }
}

//

function make( src, length )
{
  _.assert( arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || this.is( src ) || _.long.is( src ) || _.routineIs( src ) );
    _.assert( _.number.is( length ) || this.is( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.number.is( src ) || this.is( src ) || _.long.is( src ) || _.routineIs( src ) );
  }
  return this._make( ... arguments );
}

// let make = _make_functor( function( /* src, ins, length, minLength */ )
// {
//   let src = arguments[ 0 ];
//   let ins = arguments[ 1 ];
//   let length = arguments[ 2 ];
//   let minLength = arguments[ 3 ];
//
//   /* */
//
//   let resultTyped;
//   /* qqq : for Dmytro : bad solution! */
//   if( _.routine.is( src ) )
//   {
//     if( src.name === 'make' || src.name === 'bound make' )
//     resultTyped = src( length );
//     else
//     resultTyped = new src( length );
//   }
//   else if( _.bufferNodeIs( src ) )
//   resultTyped = BufferNode.alloc( length );
//   else if( _.bufferViewIs( src ) )
//   resultTyped = new BufferView( new BufferRaw( length ) );
//   else if( _.unrollIs( src ) )
//   resultTyped = _.unroll.make( length );
//   else
//   resultTyped = new src.constructor( length );
//
//   let result = resultTyped;
//   if( _.bufferRawIs( result ) )
//   resultTyped = new U8x( result );
//   if( _.bufferViewIs( result ) )
//   resultTyped = new U8x( result.buffer );
//
//   for( let i = 0 ; i < minLength ; i++ )
//   resultTyped[ i ] = ins[ i ];
//
//   return result;
// });

//

function _makeEmpty( src )
{
  if( arguments.length === 1 )
  {
    if( _.routineIs( src ) )
    {
      let result = new src( 0 );
      _.assert( this.like( result ) );
      return result;
    }
    if( this.like( src ) )
    {
      if( _.buffer.viewIs( src ) )
      return new src.constructor( new BufferRaw() );
      else if( _.buffer.nodeIs( src ) )
      return BufferNode.alloc( 0 );
      else
      return new src.constructor();
    }
  }
  return this.tools.bufferTyped.default.make();
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  _.assert( this.like( src ) || _.countable.is( src ) || _.routineIs( src ) );

  return this._makeEmpty( ... arguments );
}

//

/**
 * The routine makeUndefined() returns a new buffer with the same type as source buffer {-src-}. The length of resulted buffer is equal to {-ins-}.
 * If {-ins-} is not defined, then routine makes default Long type, length of returned container defines from {-src-}.
 *
 * @param { BufferAny|Long|Function|Number|Null } src - Instance of any buffer, Long or constructor, defines type of returned buffer. If {-src-} is null,
 * then routine returns instance of default Long.
 * @param { Number|Long|Buffer|Null|Undefined } ins - Defines length of new buffer. If {-ins-} is null or undefined, then routine makes new container
 * with default Long type and length defined by {-src-}.
 *
 * Note. Default Long type defines by descriptor {-longDescriptor-}. If descriptor not provided directly, then it is Array descriptor.
 *
 * @example
 * let got = _.makeUndefined();
 * // returns []
 *
 * @example
 * let got = _.makeUndefined( null );
 * // returns []
 *
 * @example
 * let got = _.makeUndefined( null, null );
 * // returns []
 *
 * @example
 * let got = _.makeUndefined( 3 );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * let got = _.makeUndefined( 3, null );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * let got = _.makeUndefined( new U8x( [ 1, 2, 3 ] ) );
 * // returns [ undefined, undefined, undefined ];
 * _.bufferTypedIs( got );
 * // log false
 *
 * @example
 * let got = _.makeUndefined( new I16x( [ 1, 2, 3 ] ), null );
 * // returns [ undefined, undefined, undefined ];
 * _.bufferTypedIs( got );
 * // log false
 *
 * @example
 * _.makeUndefined( new BufferRaw( 4 ), 6 );
 * // returns ArrayBuffer { [Uint8Contents]: <00 00 00 00 00 00>, byteLength: 6 }
 *
 * @example
 * _.makeUndefined( new BufferRaw( 4 ), [ 1, 2, 3 ] );
 * // returns ArrayBuffer { [Uint8Contents]: <00 00 00>, byteLength: 3 }
 *
 * @example
 * _.makeUndefined( F64x, [ 1, 2, 3 ] );
 * // returns Float64Array [ 0, 0, 0 ]
 *
 * @returns { BufferAny|Long }  Returns a buffer with source buffer {-src-} type filled by insertion container {-ins-} content.
 * If {-ins-} is not defined, then routine makes default Long type container and fills it by {-src-} content.
 * @function makeUndefined
 * @throws { Error } If arguments.length is more than two.
 * @throws { Error } If {-src-} is not a Long, not a buffer, not a Number, not a constructor, not null.
 * @throws { Error } If {-src-} is constructor and second argument {-src-} is not provided.
 * @throws { Error } If {-src-} is constructor that returns not a Long, not a buffer value.
 * @throws { Error } If {-ins-} is not a number, not a Long, not a buffer, not null, not undefined.
 * @throws { Error } If {-ins-} or src.length has a not finite value.
 * @namespace Tools
 */

function _makeUndefined( src, length )
{
  if( length === undefined )
  length = src;

  if( length && !_.number.is( length ) )
  {
    if( _.number.is( length.length ) )
    length = length.length;
    else if( _.number.is( length.byteLength ) )
    length = length.byteLength;
    else
    length = [ ... length ].length;
  }

  if( src === null || _.number.is( src ) )
  return this.tools.bufferTyped.make( length );
  if( _.buffer.rawIs( src ) )
  return new BufferRaw( length );
  if( _.buffer.viewIs( src ) )
  return new BufferView( new BufferRaw( length ) );
  if( _.buffer.typedIs( src ) )
  return new src.constructor( length );
  if( _.buffer.nodeIs( src ) )
  return BufferNode.alloc( length );
  if( _.countable.is( src ) )
  return this.tools.bufferTyped.make( length );

  if( _.routineIs( src ) )
  {
    _.assert( arguments.length === 2 );
    let result = new src( length );
    _.assert( _.buffer.is( result ), 'Not clear how to make such buffer' );
    return result;
  }

  return this.tools.bufferTyped.make();
}

//

function makeUndefined( src, length )
{
  _.assert( 0 <= arguments.length && arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || this.like( src ) || _.long.is( src ) || _.routineIs( src ) );
    _.assert( _.number.is( length ) || this.like( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.number.is( src ) || this.like( src ) || _.long.is( src ) || _.routineIs( src ) );
  }
  return this._makeUndefined( ... arguments );
}

// let makeUndefined = _make_functor( function( /* src, ins, length, minLength */ )
// {
//   let src = arguments[ 0 ];
//   let ins = arguments[ 1 ];
//   let length = arguments[ 2 ];
//   let minLength = arguments[ 3 ];
//
//   /* */
//
//   let result;
//   /* qqq : for Dmytro : bad solution! */
//   if( _.routine.is( src ) )
//   {
//     if( src.name === 'make' || src.name === 'bound make' )
//     result = src( length );
//     else
//     result = new src( length );
//   }
//   else if( _.bufferNodeIs( src ) )
//   result = BufferNode.alloc( length );
//   else if( _.bufferViewIs( src ) )
//   result = new BufferView( new BufferRaw( length ) );
//   else if( _.unrollIs( src ) )
//   result = _.unroll.make( length );
//   else
//   result = new src.constructor( length );
//
//   return result;
// });

//

function _makeFilling( type, value, length )
{
  if( arguments.length === 2 )
  {
    type = null;
    value = arguments[ 0 ];
    length = arguments[ 1 ];
  }

  if( !_.number.is( length ) )
  if(  length.length )
  length = length.length;
  else if(  length.byteLength )
  length = length.byteLength;
  else if( _.countable.is( length ) )
  length = [ ... length ].length;

  let result = this._make( type, length );
  let resultTyped = result;
  if( !resultTyped.length )
  {
    if( _.buffer.viewIs( resultTyped ) )
    resultTyped = new U8x( resultTyped.buffer );
    else
    resultTyped = new U8x( resultTyped );
  }
  for( let i = 0 ; i < length ; i++ )
  resultTyped[ i ] = value;

  return result;
}

//

function makeFilling( type, value, length )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( arguments.length === 2 )
  {
    _.assert( _.number.is( value ) || _.countable.is( value ) || this.like( length ) );
    _.assert( type !== undefined );
  }
  else
  {
    _.assert( value !== undefined );
    _.assert( _.number.is( length ) || _.countable.is( length ) || this.like( length ) );
    _.assert( type === null || _.long.is( type ) || this.like( type ) || _.routine.is( type ) );
  }

  return this._makeFilling( ... arguments );
}

//

function _cloneShallow( src )
{
  if( _.buffer.rawIs( src ) )
  return bufferRawCopy( src );
  if( _.buffer.viewIs( src ) )
  return new BufferView( bufferRawCopy( src ) );
  if( _.buffer.typedIs( src ) )
  return src.slice( 0 );
  if( _.buffer.nodeIs( src ) )
  return BufferNode.from( src );

  /* */

  function bufferRawCopy( src )
  {
    const dst = new BufferRaw( src.byteLength );
    const buffer = src.buffer || src;
    const offset = src.byteOffset || 0;
    new U8x( dst ).set( new U8x( buffer, offset, src.byteLength ) );
    return dst;
  }
}

//

function bufferFromArrayOfArray( array, options )
{

  if( _.object.isBasic( array ) )
  {
    options = array;
    array = options.buffer;
  }

  options = options || Object.create( null );
  array = options.buffer = array || options.buffer;

  /* */

  if( options.BufferType === undefined ) options.BufferType = F32x;
  if( options.sameLength === undefined ) options.sameLength = 1;
  if( !options.sameLength )
  throw _.err( '_.bufferFromArrayOfArray :', 'different length of arrays is not implemented' );

  if( !array.length )
  return new options.BufferType();

  let scalarsPerElement = _.number.is( array[ 0 ].length ) ? array[ 0 ].length : array[ 0 ].len;

  if( !_.number.is( scalarsPerElement ) )
  throw _.err( '_.bufferFromArrayOfArray :', 'cant find out element length' );

  let length = array.length * scalarsPerElement;
  let result = new options.BufferType( length );
  let i = 0;

  for( let a = 0 ; a < array.length ; a++ )
  {
    let element = array[ a ];

    for( let e = 0 ; e < scalarsPerElement ; e++ )
    {
      result[ i ] = element[ e ];
      i += 1;
    }
  }

  return result;
}

//

/**
 * The bufferRawFromTyped() routine returns a new BufferRaw from (buffer.byteOffset) to the end of an BufferRaw of a typed array (buffer)
 * or returns the same BufferRaw of the (buffer), if (buffer.byteOffset) is not provided.
 *
 * @param { typedArray } buffer - Entity to check.
 *
 * @example
 * let buffer1 = new BufferRaw( 10 );
 * let view1 = new I8x( buffer1 );
 * _.bufferRawFromTyped( view1 );
 * // returns [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]
 *
 * @example
 * let buffer2 = new BufferRaw( 10 );
 * let view2 = new I8x( buffer2, 2 );
 * _.bufferRawFromTyped( view2 );
 * // returns [ 0, 0, 0, 0, 0, 0 ]
 *
 * @returns { BufferRaw } Returns a new or the same BufferRaw.
 * If (buffer) is instance of '[object ArrayBuffer]', it returns buffer.
 * @function bufferRawFromTyped
 * @throws { Error } Will throw an Error if (arguments.length) is not equal to the 1.
 * @throws { Error } Will throw an Error if (buffer) is not a typed array.
 * @namespace Tools
 */

function bufferRawFromTyped( buffer )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.bufferTypedIs( buffer ) || _.bufferRawIs( buffer ) );

  if( _.bufferRawIs( buffer ) )
  return buffer;

  let result = buffer.buffer;

  if( buffer.byteOffset || buffer.byteLength !== result.byteLength )
  result = result.slice( buffer.byteOffset || 0, buffer.byteLength );

  _.assert( _.bufferRawIs( result ) );

  return result;
}

//

function bufferRawFrom( buffer )
{
  let result;

  /*
  aaa : should do not copying when possible! |
  aaa Dmytro : not copying if it possible
  zzz
  */

  _.assert( arguments.length === 1, 'Expects single argument' );

  if( buffer instanceof BufferRaw )
  return buffer;

  if( _.bufferNodeIs( buffer ) || _.arrayIs( buffer ) )
  {

    // result = buffer.buffer;
    result = new U8x( buffer ).buffer;

  }
  else if( _.bufferTypedIs( buffer ) || _.bufferViewIs( buffer ) )
  {

    result = buffer.buffer;
    if( buffer.byteOffset || buffer.byteLength !== result.byteLength )
    // Dmytro : works not correctly, offset + length = right bound of new bufferRaw
    // result = result.slice( buffer.byteOffset || 0, buffer.byteLength );
    result = result.slice( buffer.byteOffset, buffer.byteOffset + buffer.byteLength );

  }
  else if( _.strIs( buffer ) )
  {

    if( _global_.BufferNode )
    {
      result = _.bufferRawFrom( BufferNode.from( buffer, 'utf8' ) );
    }
    else
    {
      result = _.encode.utf8ToBuffer( buffer ).buffer;
    }

  }
  else if( _global.File && buffer instanceof File )
  {
    let fileReader = new FileReaderSync();
    result = fileReader.readAsArrayBuffer( buffer );
    _.assert( 0, 'not tested' );
  }
  else _.assert( 0, () => 'Unknown type of source ' + _.entity.strType( buffer ) );

  _.assert( _.bufferRawIs( result ) );

  return result;
}

//

function bufferBytesFrom( buffer )
{
  let result;

  // Dmytro : missed
  if( _.bufferBytesIs( buffer ) )
  return buffer;

  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.bufferNodeIs( buffer ) )
  {

    _.assert( _.bufferRawIs( buffer.buffer ) )
    result = new U8x( buffer.buffer, buffer.byteOffset, buffer.byteLength );

  }
  else if( _.bufferRawIs( buffer ) )
  {

    result = new U8x( buffer, 0, buffer.byteLength );

  }
  else if( _.bufferTypedIs( buffer ) )
  {

    result = new U8x( buffer.buffer, buffer.byteOffset, buffer.byteLength );

  }
  else if( _.bufferViewIs( buffer ) )
  {

    result = new U8x( buffer.buffer, buffer.byteOffset, buffer.byteLength );

  }
  else
  {

    return _.bufferBytesFrom( _.bufferRawFrom( buffer ) );

  }

  _.assert( _.bufferBytesIs( result ) );

  return result;
}

//

function bufferBytesFromNode( src ) /* Dmytro : what does this code do? */
{
  _.assert( _.bufferNodeIs( src ) );
  let result = new U8x( buffer );
  return result;
}

//

function bufferNodeFrom( buffer )
{
  if( _.bufferNodeIs( buffer ) )
  return buffer;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.bufferAnyIs( buffer ) || _.strIs( buffer ) || _.arrayIs( buffer ), 'Expects buffer, string of array, but got', _.entity.strType( buffer ) );

  /* */

  let result;

  if( buffer.length === 0 || buffer.byteLength === 0 )
  {
    result = BufferNode.from([]);
  }
  else if( _.strIs( buffer ) )
  {
    result = _.bufferNodeFrom( _.bufferRawFrom( buffer ) );
  }
  else if( buffer.buffer )
  {
    result = BufferNode.from( buffer.buffer, buffer.byteOffset, buffer.byteLength );
  }
  else
  {
    result = BufferNode.from( buffer );
  }

  _.assert( _.bufferNodeIs( result ) );

  return result;
}

// --
// meta
// --

/* qqq : optimize */
function namespaceOf( src )
{

  if( _.bufferRaw.is( src ) )
  return _.bufferRaw;
  if( _.bufferView.is( src ) )
  return _.bufferView;
  if( _.bufferNode.is( src ) )
  return _.bufferNode;

  return _.bufferTyped.namespaceOf( src );
}

// --
// declaration
// --

let BufferExtension =
{

  //

  NamespaceName : 'buffer',
  NamespaceNames : [ 'buffer' ],
  NamespaceQname : 'wTools/buffer',
  TypeName : 'Buffer',
  TypeNames : [ 'Buffer', 'BufferAny' ],
  // SecondTypeName : 'BufferAny',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  anyIs,
  // anyIsOld,
  // anyIsUsingInstanceOf,
  is : anyIs,
  like : anyIs,
  IsResizable,

  // maker

  _make_functor, /* aaa : remove maybe */ /* Dmytro : implemented */
  _make, /* aaa : implement */ /* Dmytro : implemented */
  make,
  _makeEmpty,
  makeEmpty,
  _makeUndefined, /* aaa : implement */ /* Dmytro : implemented */
  makeUndefined,
  _makeZeroed : _makeUndefined, /* aaa : implement */ /* Dmytro : implemented */
  makeZeroed : makeUndefined,
  _makeFilling,
  makeFilling,

  _cloneShallow,
  cloneShallow : _.argumentsArray.cloneShallow, /* qqq : for junior : cover */
  from : _.argumentsArray.from, /* qqq : for junior : cover */

  // meta

  namespaceOf,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{

  // dichotomy

  bufferAnyIs : anyIs.bind( _.buffer ),
  bufferIs : anyIs.bind( _.buffer ),

  // maker

  /* qqq : attention is needed. ask */
  bufferMake : make.bind( _.buffer ),
  bufferMakeEmpty : makeEmpty.bind( _.buffer ),
  bufferMakeUndefined : makeUndefined.bind( _.buffer ),
  bufferMakeZeroed : _.buffer.makeZeroed.bind( _.buffer ),

  bufferFromArrayOfArray,
  bufferRawFromTyped, /* xxx : qqq : for Dmytro : move corresponding namespace and tests */
  bufferRawFrom, /* xxx : qqq : for Dmytro : move corresponding namespace and tests */
  bufferBytesFrom, /* xxx : qqq : for Dmytro : move corresponding namespace and tests */
  bufferBytesFromNode, /* xxx : qqq : for Dmytro : move corresponding namespace and tests */
  bufferNodeFrom, /* xxx : qqq : for Dmytro : move corresponding namespace and tests */

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Buffer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Buffer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Buffer_s */ })();

/* */  /* begin of file BufferBytes_s */ ( function BufferBytes_s() { function BufferBytes_s_naked() { ( function _l1_BufferBytes_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.assert( _.bufferBytes === undefined );
_.assert( _.u8x === undefined );
_.bufferBytes = _.u8x = _.bufferBytes || _.u8x || Object.create( null );

// --
// implementation
// --

function is( src )
{
  if( _.buffer.nodeIs( src ) )
  return false;
  return src instanceof U8x;
}

// --
// declaration
// --

let BufferBytesExtension =
{

  //

  NamespaceName : 'u8x',
  NamespaceNames : [ 'u8x', 'bufferBytes' ],
  NamespaceQname : 'wTools/u8x',
  TypeName : 'U8x',
  TypeNames : [ 'U8x', 'Uint8Array', 'BufferBytes',  ],
  InstanceConstructor : U8x,
  tools : _,

  // dichotomy

  // bytesIs,
  is,
  like : is,

  // maker

  // _make : _.buffer._make, /* qqq : cover */
  // make : _.buffer.make,
  // _makeEmpty : _.buffer._makeEmpty,
  // makeEmpty : _.buffer.makeEmpty,
  // _makeUndefined : _.buffer._makeUndefined, /* qqq : implement */
  // makeUndefined : _.buffer.makeUndefined,
  // _makeZeroed : _.buffer._makeZeroed,
  // makeZeroed : _.buffer.makeZeroed, /* qqq : for junior : cover */
  // _cloneShallow : _.buffer._cloneShallow,
  // cloneShallow : _.buffer.cloneShallow, /* qqq : for junior : cover */
  // from : _.buffer.from, /* qqq : for junior : cover */
  // qqq : implement

}

Object.assign( _.bufferBytes, BufferBytesExtension );

//

let BufferExtension =
{

  // dichotomy

  bytesIs : is.bind( _.bufferBytes ),

}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{

  // dichotomy

  bufferBytesIs : is.bind( _.bufferBytes ),
  bufferBytesLike : is.bind( _.bufferBytes ),

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/BufferBytes.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BufferBytes_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BufferBytes_s */ })();

/* */  /* begin of file BufferNode_s */ ( function BufferNode_s() { function BufferNode_s_naked() { ( function _l1_BufferNode_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.bufferNode = _.bufferNode || Object.create( null );

// --
// implementation
// --

/* qqq : for Rahul : write performance test and optimize */
function nodeIs( src )
{
  // if( typeof BufferNode !== 'undefined' )
  if( _global_.BufferNode )
  return src instanceof BufferNode;
  return false;
}

// --
// declaration
// --

let BufferNodeExtension =
{

  //

  NamespaceName : 'bufferNode',
  NamespaceNames : [ 'bufferNode' ],
  NamespaceQname : 'wTools/bufferNode',
  TypeName : 'BufferNode',
  TypeNames : [ 'BufferNode' ],
  // SecondTypeName : 'ArrayNode',
  InstanceConstructor : _global.BufferNode,
  tools : _,

  // dichotomy

  nodeIs,
  is : nodeIs,
  like : nodeIs,

  // maker

  _make : _.buffer._make, /* qqq : cover */
  make : _.buffer.make,
  _makeEmpty : _.buffer._makeEmpty,
  makeEmpty : _.buffer.makeEmpty,
  _makeUndefined : _.buffer._makeUndefined, /* qqq : implement */
  makeUndefined : _.buffer.makeUndefined,
  // _makeZeroed : _.buffer._makeZeroed,
  // makeZeroed : _.buffer.makeZeroed, /* qqq : for junior : cover */
  // _cloneShallow : _.buffer._cloneShallow,
  // cloneShallow : _.buffer.cloneShallow, /* qqq : for junior : cover */
  // from : _.buffer.from, /* qqq : for junior : cover */
  // qqq : implement

}

Object.assign( _.bufferNode, BufferNodeExtension );

//

let BufferExtension =
{

  // dichotomy

  nodeIs : nodeIs.bind( _.buffer ),

}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{

  // dichotomy

  bufferNodeIs : nodeIs.bind( _.buffer ),

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/BufferNode.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BufferNode_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BufferNode_s */ })();

/* */  /* begin of file BufferRaw_s */ ( function BufferRaw_s() { function BufferRaw_s_naked() { ( function _l1_BufferRaw_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.bufferRaw = _.bufferRaw || Object.create( null );

// --
// implementation
// --

function rawIs( src )
{
  let type = Object.prototype.toString.call( src );
  // let result = type === '[object ArrayBuffer]';
  // return result;
  if( type === '[object ArrayBuffer]' || type === '[object SharedArrayBuffer]' )
  return true;
  return false;
}

// --
// declaration
// --

let BufferRawExtension =
{

  //

  NamespaceName : 'bufferRaw',
  NamespaceNames : [ 'bufferRaw' ],
  NamespaceQname : 'wTools/bufferRaw',
  TypeName : 'BufferRaw',
  TypeNames : [ 'BufferRaw', 'ArrayBuffer' ],
  // SecondTypeName : 'ArrayRaw',
  InstanceConstructor : ArrayBuffer,
  tools : _,

  // dichotomy

  rawIs,
  is : rawIs,
  like : rawIs,

  // maker

  _make : _.buffer._make, /* qqq : cover */
  make : _.buffer.make,
  _makeEmpty : _.buffer._makeEmpty,
  makeEmpty : _.buffer.makeEmpty,
  _makeUndefined : _.buffer._makeUndefined, /* qqq : implement */
  makeUndefined : _.buffer.makeUndefined,
  // _makeZeroed : _.buffer._makeZeroed,
  // makeZeroed : _.buffer.makeZeroed, /* qqq : for junior : cover */
  // _cloneShallow : _.buffer._cloneShallow,
  // cloneShallow : _.buffer.cloneShallow, /* qqq : for junior : cover */
  // from : _.buffer.from, /* qqq : for junior : cover */
  // qqq : implement

}

Object.assign( _.bufferRaw, BufferRawExtension );

//

let BufferExtension =
{

  // dichotomy

  rawIs : rawIs.bind( _.buffer ),

}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{

  // dichotomy

  bufferRawIs : rawIs.bind( _.buffer ),

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/BufferRaw.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BufferRaw_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BufferRaw_s */ })();

/* */  /* begin of file BuffersTyped_s */ ( function BuffersTyped_s() { function BuffersTyped_s_naked() { ( function _l1_BuffersTyped_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

function _functor( fo )
{

  _.assert( !!_.bufferTyped );
  _[ fo.name ] = _[ fo.name ] || Object.create( null );
  fo.names.forEach( ( name ) =>
  {
    _[ name ] = _[ fo.name ];
  });

  // --
  // dichotomy
  // --

  function is( src )
  {
    return src instanceof this.InstanceConstructor;
  }

  //

  function like( src ) /* qqq : cover */
  {
    let type = Object.prototype.toString.call( src );
    if( !/\wArray/.test( type ) )
    return false;
    if( type === '[object SharedArrayBuffer]' )
    return false;
    if( _.bufferNodeIs( src ) )
    return false;
    return true;
  }

  //

  function IsResizable()
  {
    _.assert( arguments.length === 0 );
    return false;
  }

  // --
  // maker
  // --

  function _makeEmpty( src )
  {
    return new this.InstanceConstructor( 0 );
  }

  //

  // function makeEmpty( src )
  // {
  //   if( arguments.length === 1 )
  //   _.assert( this.like( src ) );
  //   else
  //   _.assert( arguments.length === 0 );
  //
  //   return this._makeEmpty( ... arguments );
  //
  //   // _.assert( arguments.length === 0 || arguments.length === 1 );
  //   // if( arguments.length === 1 )
  //   // {
  //   //   _.assert( this.like( src ) );
  //   //   return [];
  //   // }
  //   // else
  //   // {
  //   //   return [];
  //   // }
  // }

  //

  function _makeUndefined( src, length )
  {
    // if( arguments.length === 2 )
    // {
    //   if( _.long.is( length ) )
    //   length = length.length;
    //   return new this.InstanceConstructor( length );
    // }
    // else if( arguments.length === 1 )
    // {
    //   length = src;
    //   if( _.long.is( length ) )
    //   length = length.length;
    //   if( length === null )
    //   return new this.InstanceConstructor();
    //   else
    //   return new this.InstanceConstructor( length );
    // }

    if( length === undefined )
    length = src;
    if( length && !_.number.is( length ) )
    {
      if( length.length )
      length = length.length;
      else
      length = [ ... length ].length;
    }
    return new this.InstanceConstructor( length );
  }

  //

  // function makeUndefined( src, length )
  // {
  //   _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  //   if( arguments.length === 2 )
  //   {
  //     _.assert( src === null || _.long.is( src ) );
  //     _.assert( _.number.is( length ) || _.long.is( length ) );
  //   }
  //   else if( arguments.length === 1 )
  //   {
  //     _.assert( _.number.is( src ) || _.long.is( src ) || src === null );
  //   }
  //
  //   return this._makeUndefined( ... arguments );
  //
  //   // _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  //   // if( arguments.length === 2 )
  //   // {
  //   //   _.assert( src === null || _.long.is( src ) );
  //   //   _.assert( _.number.is( length ) || _.long.is( length ) );
  //   //   return this._makeUndefined( src, length );
  //   // }
  //   // else if( arguments.length === 1 )
  //   // {
  //   //   _.assert( _.number.is( src ) || _.long.is( src ) || src === null );
  //   //   return this._makeUndefined( src );
  //   // }
  //   // else
  //   // {
  //   //   return [];
  //   // }
  // }

  //

  // function _makeZeroed( src, length )
  // {
  //   if( length === undefined )
  //   length = src;
  //   if( this.like( length ) )
  //   length = length.length;
  //   return new this.InstanceConstructor( length );
  // }

  //

  // function _makeFilling( type, value, length )
  // {
  //   if( arguments.length === 2 )
  //   {
  //     value = arguments[ 0 ];
  //     length = arguments[ 1 ];
  //     if( _.longIs( length ) )
  //     {
  //       if( _.argumentsArray.is( length ) )
  //       type = length;
  //       else if( _.number.is( length ) )
  //       type = null;
  //       else
  //       type = length;
  //     }
  //     else
  //     {
  //       type = null;
  //     }
  //   }
  //
  //   if( _.longIs( length ) )
  //   length = length.length;
  //
  //   let result = this._make( type, length );
  //   for( let i = 0 ; i < length ; i++ )
  //   result[ i ] = value;
  //
  //   return result;
  // }

  //

  // function makeFilling( type, value, length )
  // {
  //   _.assert( arguments.length === 2 || arguments.length === 3 );
  //
  //   if( arguments.length === 2 )
  //   {
  //     _.assert( _.number.is( value ) || _.countable.is( value ) );
  //     _.assert( type !== undefined );
  //   }
  //   else
  //   {
  //     _.assert( value !== undefined );
  //     _.assert( _.number.is( length ) || _.countable.is( length ) );
  //     _.assert( type === null || _.routine.is( type ) || _.longIs( type ) );
  //   }
  //
  //   return this._makeFilling( ... arguments );
  // }

  //

  function _make( src, length )
  {
    if( arguments.length === 2 )
    {
      let data = length;
      if( _.number.is( length ) )
      {
        data = src;
      }
      else if( length.length )
      {
        length = length.length;
      }
      else if( _.countable.is( length ) )
      {
        data = [ ... length ];
        length = data.length;
      }
      return fill( new this.InstanceConstructor( length ), data );
    }
    else if( arguments.length === 1 )
    {
      return new this.InstanceConstructor( src );
    }
    return new this.InstanceConstructor( 0 );

  /* */

  function fill( dst, data )
  {
    if( data === null || data === undefined )
    return dst;
    let l = Math.min( length, data.length );
    for( let i = 0 ; i < l ; i++ )
    dst[ i ] = data[ i ];
    return dst;
  }

    // if( _.numberIs( length ) )
    // return new this.InstanceConstructor( length );
    // if( _.numberIs( src ) )
    // return new this.InstanceConstructor( src );
    // if( src )
    // return new this.InstanceConstructor( src );
    // return new this.InstanceConstructor( 0 );
  }

  //

  // function make( src, length )
  // {
  //   _.assert( arguments.length === 0 || src === null || _.countable.is( src ) || _.numberIs( src ) );
  //   _.assert( length === undefined || !_.number.is( src ) || !_.number.is( length ) );
  //   // _.assert( arguments.length < 2 || _.number.is( length ) );
  //   _.assert( arguments.length < 2 || _.number.is( length ) || _.countable.is( length ) );
  //   _.assert( arguments.length <= 2 );
  //   return this._make( ... arguments );
  // }

  //

  function _cloneShallow( srcArray )
  {
    return srcArray.slice();
  }

  //

  function cloneShallow( srcArray )
  {
    _.assert( this.like( srcArray ) );
    _.assert( arguments.length === 1 );
    return this._cloneShallow( srcArray );
  }

  //

  function from( src )
  {
    _.assert( arguments.length === 1, 'Expects single argument' );
    if( this.is( src ) )
    return src;
    return this.make( src );
  }

  // --
  // declare
  // --

  let ToolsExtension =
  {

    /* xxx : binding will cause problem with changing default long type */

    // dichotomy

    [ fo.name + 'Is' ] : is.bind( _[ fo.name ] ),
    [ fo.name + 'Like' ] : like.bind( _[ fo.name ] ),

    // maker

    [ fo.name + 'MakeEmpty' ] : _.argumentsArray.makeEmpty.bind( _[ fo.name ] ),
    // [ fo.name + 'MakeEmpty' ] : makeEmpty.bind( _[ fo.name ] ),
    [ fo.name + 'MakeUndefined' ] : _.argumentsArray.makeUndefined.bind( _[ fo.name ] ),
    // [ fo.name + 'MakeUndefined' ] : makeUndefined.bind( _[ fo.name ] ),
    [ fo.name + 'Make' ] : _.argumentsArray.make.bind( _[ fo.name ] ),
    // [ fo.name + 'Make' ] : make.bind( _[ fo.name ] ),
    [ fo.name + 'CloneShallow' ] : cloneShallow.bind( _[ fo.name ] ),
    [ fo.name + 'From' ] : from.bind( _[ fo.name ] ),

  }

  _.props.supplement( _, ToolsExtension );

  //

  let BufferTypedExtension =
  {

    //

    NamespaceName : fo.name,
    NamespaceNames : fo.names,
    NamespaceQname : `wTools/${fo.name}`,
    MoreGeneralNamespaceName : 'bufferTyped',
    MostGeneralNamespaceName : 'countable',
    TypeName : fo.typeName,
    TypeNames : fo.typeNames,
    // TypeNames : [ fo.typeName, fo.secondTypeName ],
    // SecondTypeName : fo.secondTypeName,
    InstanceConstructor : fo.instanceConstructor,
    IsTyped : true,
    tools : _,

    // dichotomy

    is,
    like,
    IsResizable,

    // maker

    _makeEmpty,
    makeEmpty : _.argumentsArray.makeEmpty, /* qqq : for junior : cover */
    _makeUndefined,
    makeUndefined : _.argumentsArray.makeUndefined, /* qqq : for junior : cover */
    _makeZeroed : _makeUndefined,
    makeZeroed : _.argumentsArray.makeUndefined,
    // makeZeroed : makeUndefined,
    _makeFilling : _.argumentsArray.makeFilling,
    makeFilling : _.argumentsArray.makeFilling,
    _make,
    make : _.argumentsArray.make, /* qqq : for junior : cover */
    // make, /* qqq : for junior : cover */
    _cloneShallow,
    cloneShallow, /* qqq : for junior : cover */
    from, /* qqq : for junior : cover */

    // meta

    namespaceOf : _.blank.namespaceOf,
    namespaceWithDefaultOf : _.blank.namespaceWithDefaultOf,
    _functor_functor : _.blank._functor_functor,

  }

  //

  _.props.supplement( _[ fo.name ], BufferTypedExtension );
  _.bufferTyped._namespaceRegister( _[ fo.name ] );

}

_functor({ name : 'u32x', names : [ 'u32x', 'ux' ], typeName : 'U32x', typeNames : [ 'U32x', 'Uint32Array', 'Ux' ], instanceConstructor : U32x });
_functor({ name : 'u16x', names : [ 'u16x' ], typeName : 'U16x', typeNames : [ 'U16x', 'Uint16Array' ], instanceConstructor : U16x });
_functor({ name : 'u8x', names : [ 'u8x' ], typeName : 'U8x', typeNames : [ 'U8x', 'Uint8Array' ], instanceConstructor : U8x });
_functor({ name : 'u8xClamped', names : [ 'u8xClamped' ], typeName : 'U8xClamped', typeNames : [ 'U8xClamped', 'Uint8ClampedArray' ], instanceConstructor : U8xClamped });

_functor({ name : 'i32x', names : [ 'i32x', 'ix' ], typeName : 'I32x', typeNames : [ 'I32x', 'Int32Array', 'Ix' ], instanceConstructor : I32x });
_functor({ name : 'i16x', names : [ 'i16x' ], typeName : 'I16x', typeNames : [ 'I16x', 'Int16Array' ], instanceConstructor : I16x });
_functor({ name : 'i8x', names : [ 'i8x' ], typeName : 'I8x', typeNames : [ 'I8x', 'Int8Array' ], instanceConstructor : I8x });

_functor({ name : 'f64x', names : [ 'f64x' ], typeName : 'F64x', typeNames : [ 'F64x', 'Float64Array' ], instanceConstructor : F64x });
_functor({ name : 'f32x', names : [ 'f32x', 'fx' ], typeName : 'F32x', typeNames : [ 'F32x', 'Float32Array', 'Fx' ], instanceConstructor : F32x });

_.assert( !!_.fx );
_.assert( _.bufferTyped.default === undefined );
_.bufferTyped.default = _.fx;

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/BuffersTyped.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BuffersTyped_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BuffersTyped_s */ })();

/* */  /* begin of file BufferView_s */ ( function BufferView_s() { function BufferView_s_naked() { ( function _l1_BufferView_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.bufferView = _.bufferView || Object.create( null );

// --
// implementation
// --

function viewIs( src )
{
  let type = Object.prototype.toString.call( src );
  let result = type === '[object DataView]';
  return result;
}

// --
// declaration
// --

let BufferViewExtension =
{

  //

  NamespaceName : 'bufferView',
  NamespaceNames : [ 'bufferView' ],
  NamespaceQname : 'wTools/bufferView',
  TypeName : 'BufferView',
  TypeNames : [ 'BufferView', 'DataView' ],
  // SecondTypeName : 'DataView',
  InstanceConstructor : DataView,
  tools : _,

  // dichotomy

  viewIs,
  is : viewIs,
  like : viewIs,

  // maker

  _make : _.buffer._make, /* qqq : cover */
  make : _.buffer.make,
  _makeEmpty : _.buffer._makeEmpty,
  makeEmpty : _.buffer.makeEmpty,
  _makeUndefined : _.buffer._makeUndefined, /* qqq : implement */
  makeUndefined : _.buffer.makeUndefined,
  // _makeZeroed : _.buffer._makeZeroed,
  // makeZeroed : _.buffer.makeZeroed, /* qqq : for junior : cover */
  // _cloneShallow : _.buffer._cloneShallow,
  // cloneShallow : _.buffer.cloneShallow, /* qqq : for junior : cover */
  // from : _.buffer.from, /* qqq : for junior : cover */
  // qqq : implement

}

Object.assign( _.bufferView, BufferViewExtension );

//

let BufferExtension =
{

  // dichotomy

  viewIs : viewIs.bind( _.buffer ),

}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{

  // dichotomy

  bufferViewIs : viewIs.bind( _.buffer ),

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/BufferView.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BufferView_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BufferView_s */ })();

/* */  /* begin of file Class_s */ ( function Class_s() { function Class_s_naked() { ( function _l1_Class_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.class = _.class || Object.create( null );

// --
// container
// --

function methodIteratorOf( src )
{
  if( !src )
  return;
  if( _.routine.like( src[ iteratorSymbol ] ) )
  return src[ iteratorSymbol ];
  return;
}

//

/* qqq : for junior : cover */
function methodEqualOf( src )
{
  if( !src )
  return;
  if( _.routine.is( src[ equalAreSymbol ] ) )
  return src[ equalAreSymbol ];
  if( _.routine.is( src.equalAre ) )
  return src.equalAre;
  return;
}

//

/* qqq : for junior : cover */
function methodExportStringOf( src )
{
  if( !src )
  return;
  if( _.routine.is( src[ exportStringSymbol ] ) )
  return src[ exportStringSymbol ];
  if( _.routine.is( src.exportString ) )
  return src.exportString;
  return;
}

//

function methodAscendOf( src )
{
  if( !src )
  return;
  if( _.routine.is( src[ ascendSymbol ] ) )
  return src[ ascendSymbol ];
  if( _.routine.is( src.ascend ) )
  return src.ascend;
  return;
}

//

/* qqq : for junior : cover */
function methodCloneShallowOf( src )
{
  if( !src )
  return;
  if( _.routine.is( src[ cloneShallowSymbol ] ) )
  return src[ cloneShallowSymbol ];
  if( _.routine.is( src.cloneShallow ) )
  return src.cloneShallow;
  return
}

//

/* qqq : for junior : cover */
function methodCloneDeepOf( src )
{
  if( !src )
  return;
  if( _.routine.is( src[ cloneDeepSymbol ] ) )
  return src[ cloneDeepSymbol ];
  if( _.routine.is( src.cloneDeep ) )
  return src.cloneDeep;
  return
}

//

function methodElementWithKeySetOf( src )
{
  if( !src )
  return;
  if( _.routine.is( src[ elementWithKeySetSymbol ] ) )
  return src[ elementWithKeySetSymbol ];
  return;
}

//

function methodElementSetOf( src )
{
  if( !src )
  return;
  if( _.routine.is( src[ elementSetSymbol ] ) )
  return src[ elementSetSymbol ];
  if( _.routine.is( src.eSet ) )
  return src.eSet;
  return;
}

//

function methodMakeEmptyOf( src )
{
  if( _.routine.is( src.makeEmpty ) )
  return src.makeEmpty;
  if( _.routine.is( src.MakeEmpty ) )
  return src.MakeEmpty;
  return;
}

//

function methodMakeUndefinedOf( src )
{
  if( _.routine.is( src.makeUndefined ) )
  return src.makeUndefined;
  if( _.routine.is( src.MakeUndefined ) )
  return src.MakeUndefined;
  return;
}

//

function declareBasic( o )
{

  for( let e in o )
  {
    if( declareBasic.defaults[ e ] === undefined )
    {
      throw Error( `Unknown option::${e}` );
    }
  }

  for( let e in declareBasic.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = declareBasic.defaults[ e ];
  }

  _.assert( routineIs( o.constructor ) && o.constructor !== Object.constructor && o.constructor !== Object );
  _.assert( strDefined( o.constructor.name ) && o.constructor.name !== 'Object' );
  _.assert( arguments.length === 1 );
  _.assert( o.iterate === undefined );

  o.exportString = o.exportString || exportString;
  o.cloneShallow = o.cloneShallow || cloneShallow;
  o.cloneDeep = o.cloneDeep || o.cloneShallow;
  o.equalAre = o.equalAre || equalAre;

  // debugger;
  // Object.setPrototypeOf( o.constructor.prototype, null );
  o.constructor.prototype = Object.create( o.prototype );
  if( o.iterator )
  o.constructor.prototype[ iteratorSymbol ] = o.iterator;
  o.constructor.prototype[ exportPrimitiveSymbol ] = exportStringIgnoringArgs;
  o.constructor.prototype[ exportStringNjsSymbol ] = exportStringIgnoringArgs;
  o.constructor.prototype[ exportStringSymbol ] = o.exportString;
  o.constructor.prototype[ cloneShallowSymbol ] = o.cloneShallow; /* xxx : reimplement? */
  o.constructor.prototype[ cloneDeepSymbol ] = o.cloneDeep; /* xxx : implement */
  o.constructor.prototype[ equalAreSymbol ] = o.equalAre; /* qqq : cover */
  o.constructor.prototype.constructor = o.constructor;

  Object.defineProperty( o.constructor.prototype, exportTypeNameGetterSymbol,
  {
    enumerable : false,
    configurable : false,
    get : TypeNameGet,
  });

  /* - */

  function TypeNameGet()
  {
    return this.constructor.name;
  }

  /* - */

  function cloneShallow()
  {
    _.assert( !( this instanceof cloneShallow ) );
    return this;
  }

  /* - */

  function equalAre( it )
  {
    let self = this;
    _.assert( arguments.length === 1 );
    debugger;
    if( it.src !== it.src2 )
    return it.stop( false );
  }

  /* - */

  function exportString()
  {
    return `{- ${this.constructor.name} -}`;
  }

  /* - */

  function exportStringIgnoringArgs()
  {
    return this[ exportStringSymbol ]();
  }

  /* - */

  function strDefined( src )
  {
    if( !src )
    return;
    let result = Object.prototype.toString.call( src ) === '[object String]';
    return result;
  }

  /* - */

  function routineIs( src )
  {
    let typeStr = Object.prototype.toString.call( src );
    return typeStr === '[object Function]' || typeStr === '[object AsyncFunction]';
  }

  /* - */

}

declareBasic.defaults =
{
  constructor : null,
  prototype : null,
  parent : null,
  exportString : null,
  cloneShallow : null,
  cloneDeep : null,
  equalAre : null,
  iterator : null,
}

// --
// tools extension
// --

let ToolsExtension =
{
}

//

Object.assign( _, ToolsExtension );

// --
// class extension
// --

const iteratorSymbol = Symbol.iterator;
const exportTypeNameGetterSymbol = Symbol.toStringTag;
const exportPrimitiveSymbol = Symbol.toPrimitive;
const exportStringNjsSymbol = Symbol.for( 'nodejs.util.inspect.custom' );
const exportStringSymbol = Symbol.for( 'exportString' );
const ascendSymbol = Symbol.for( 'ascend' );
const equalAreSymbol = Symbol.for( 'equalAre' );
const cloneShallowSymbol = Symbol.for( 'cloneShallow' );
const cloneDeepSymbol = Symbol.for( 'cloneDeep' );
const elementWithKeySetSymbol = Symbol.for( 'elementWithKeySet' );
const elementSetSymbol = Symbol.for( 'elementSet' );

//

let ClassExtension =
{

  methodIteratorOf,
  methodEqualOf, /* xxx : qqq : add other similar routines */
  methodExportStringOf,
  methodAscendOf,
  methodCloneShallowOf,
  methodCloneDeepOf,
  methodElementWithKeySetOf,
  methodElementSetOf,
  methodMakeEmptyOf,
  methodMakeUndefinedOf,

  declareBasic,

  // fields

  tools : _,
  iteratorSymbol,
  exportTypeNameGetterSymbol,
  exportPrimitiveSymbol,
  exportStringNjsSymbol,
  exportStringSymbol,
  ascendSymbol,
  equalAreSymbol,
  cloneShallowSymbol,
  cloneDeepSymbol,
  elementSetSymbol,

}

//

Object.assign( _.class, ClassExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Class.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Class_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Class_s */ })();

/* */  /* begin of file Constructible_s */ ( function Constructible_s() { function Constructible_s_naked() { ( function _l1_Constructible_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.constructible = _.constructible || Object.create( null );

// --
// dichotomy
// --

function is( src ) /* xxx qqq : optimize */
{
  if( _.primitive.is( src ) )
  return false;

  let proto = Object.getPrototypeOf( src );
  if( proto === null )
  return false;

  if( !Reflect.has( proto, 'constructor' ) )
  return false;
  if( proto.constructor === Object )
  return false;

  if( _.aux.is( src ) ) /* xxx : remove? */
  return false;
  if( _.vector.is( src ) )
  return false;
  if( _.set.is( src ) )
  return false;
  if( _.hashMap.is( src ) )
  return false;

  return true;
}

//

function like( src )
{
  return _.constructibleIs( src );
}

// --
// extension
// --

let ToolsExtension =
{

  // dichotomy

  constructibleIs : is, /* qqq : cover and move */
  constructibleLike : like, /* qqq : cover and move */

}

//

let Extension =
{

  // dichotomy

  is, /* qqq : cover and move */
  like, /* qqq : cover and move */

}

//

Object.assign( _, ToolsExtension );
Object.assign( _.constructible, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Constructible.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Constructible_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Constructible_s */ })();

/* */  /* begin of file Container_s */ ( function Container_s() { function Container_s_naked() { ( function _l1_Container_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const _functor_functor = _.props._functor_functor;

// --
// implementation
// --

/* xxx : adjust */
/* qqq : cover is and like by test routine dichotomy */
function is( src )
{
  if( _.countable.like( src ) )
  return true;
  if( _.aux.is( src ) )
  return true;
  return false;
}

// function is( src )
// {
//   if( _.longLike( src ) )
//   return true;
//   if( _.aux.is( src ) )
//   return true;
//   if( _.hashMap.like( src ) )
//   return true;
//   if( _.set.like( src ) )
//   return true;
//   return false;
// }

//

function like( src )
{
  return _.container.is( src );
}

// --
// maker
// --

function cloneShallow( container ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 );
  return cloneShallow.functor.call( this, container )();
}

cloneShallow.functor = _functor_functor( 'cloneShallow' );

//

function make( container, ... args ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return make.functor.call( this, container )( ... args );
}

make.functor = _functor_functor( 'make' );

//

function makeEmpty( container ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 );
  return makeEmpty.functor.call( this, container )();
}

makeEmpty.functor = _functor_functor( 'makeEmpty' );

//

function makeUndefined( container, ... args ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return makeUndefined.functor.call( this, container )( ... args );
}

makeUndefined.functor = _functor_functor( 'makeUndefined' );

// --
// meta
// --

function namespaceForIterating( src ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 );

  if( _.primitive.is( src ) )
  return _.blank;
  if( _.hashMap.like( src ) )
  return _.hashMap;
  if( _.set.like( src ) )
  return _.set;
  if( _.longIs( src ) )
  return _.long;
  if( _.countableIs( src ) )
  return _.countable;
  if( _.auxIs( src ) )
  return _.aux;

  return _.blank;
}

//

function namespaceForExporting( src )
{
  if( _.primitive.is( src ) )
  return _.primitive;
  if( _.date.is( src ) )
  return _.date;
  if( _.regexp.is( src ) )
  return _.regexp;
  if( _.set.like( src ) )
  return _.set;
  if( _.hashMap.like( src ) )
  return _.hashMap;
  if( _.routine.is( src ) )
  return _.routine;
  if( _.buffer.like( src ) )
  return _.buffer;
  if( _.long.like( src ) )
  return _.long;
  if( _.vector.like( src ) )
  return _.vector;
  if( _.countable.like( src ) )
  return _.countable;
  if( _.aux.like( src ) )
  return _.aux;
  if( _.object.like( src ) )
  return _.object;

  return null;
}

// --
// declare type
// --

class Container
{
  static[ Symbol.hasInstance ]( instance )
  {
    return is( instance );
  }
}

let Handler =
{
  construct( original, args )
  {
    return Container.make( ... args );
  }
};

const Self = new Proxy( Container, Handler );
Self.original = Container;

// --
// extend container
// --

let ContainerExtension =
{

  NamespaceName : 'container',
  NamespaceNames : [ 'container' ],
  NamespaceQname : 'wTools/container',
  TypeName : 'Container',
  TypeNames : [ 'Container' ],
  // SecondTypeName : 'Container',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is, /* qqq : cover please */
  like,

  // maker

  cloneShallow, /* qqq : cover */
  make, /* qqq : cover */
  makeEmpty, /* qqq : cover */
  makeUndefined, /* qqq : cover */

  // meta

  namespaceForIterating,
  namespaceForExporting,
  namespaceOf : namespaceForIterating,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

//

_.container = Self;

Object.assign( Self, ContainerExtension );

// --
// extend tools
// --

let ToolsExtension =
{

  containerIs : is.bind( _.container ),
  containerLike : like.bind( _.container ),

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Container.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Container_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Container_s */ })();

/* */  /* begin of file ContainerAdapter_s */ ( function ContainerAdapter_s() { function ContainerAdapter_s_naked() { ( function _l1_ContainerAdapter_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// exporter
// --

// function is( src )
// {
//   if( !src )
//   return false;
//   return src instanceof ContainerAdapterAbstract;
// }

//

function is( src )
{
  // if( _.primitive.is( src ) )
  // return false;
  if( !src )
  return false;
  if( !_.containerAdapter.Abstract )
  return false;
  return src instanceof _.containerAdapter.Abstract;
}

//

function like( src )
{
  return this.is( src );
}

//

function isContainer( src )
{
  if( _.set.like( src ) )
  return true;
  if( _.long.like( src ) )
  return true;
  if( _.containerAdapter.is( src ) )
  return true;
  return false;
}

//

// function adapterLike( src )
function setLike( src )
{
  if( !src )
  return false;
  if( _.set.like( src ) )
  return true;
  if( !_.containerAdapter || !_.containerAdapter.Set )
  return false;
  if( src instanceof _.containerAdapter.Set )
  return true;
  return false;
}

//

function longLike( src )
{
  if( !src )
  return false;
  if( _.long.like( src ) )
  return true;
  if( !_.containerAdapter || !_.containerAdapter.Array )
  return false;
  if( src instanceof _.containerAdapter.Array )
  return true;
  return false;
}

// --
//
// --

class ContainerAdapterNamespace
{
  static[ Symbol.hasInstance ]( instance )
  {
    return is( instance );
  }
}

let Handler =
{
  construct( original, args )
  {
    return ContainerAdapterNamespace.make( ... args );
  }
};

const Self = new Proxy( ContainerAdapterNamespace, Handler );
Self.original = ContainerAdapterNamespace;
_.assert( _.containerAdapter === undefined );
_.containerAdapter = Self;

// --
// container adapter extension
// --

let ContainerAdapterExtension =
{

  is,
  like,
  isContainer,
  setLike,
  longLike,

}

Object.assign( _.containerAdapter, ContainerAdapterExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  is : is.bind( _.containerAdapter ),
  like : like.bind( _.containerAdapter ),

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/ContainerAdapter.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ContainerAdapter_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ContainerAdapter_s */ })();

/* */  /* begin of file Countable_s */ ( function Countable_s() { function Countable_s_naked() { ( function _l1_Countable_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.countable = _.countable || Object.create( null );

// --
// dichotomy
// --

/* qqq : for Junior : cover please */
function is( src )
{

  if( _.arrayIs( src ) )
  return true;

  if( _.primitive.is( src ) )
  return false;

  // if( _.routine.like( _.class.methodIteratorOf( src ) ) )
  // if( !_.mapIs( src ) )
  if( _.class.methodIteratorOf( src ) !== undefined ) /* qqq : for Junior : cover please */
  return true;

  return false;
}

//

function like( src )
{
  return _.countable.is( src );
}

//

function isResizable( src )
{
  if( _.array.is( src ) )
  return true;
  return false;
  // return this.is( src );
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return this.default.IsResizable();
}

// --
// maker
// --

function _makeEmpty( src )
{
  if( arguments.length === 0 || src === null || _.long.is( src ) )
  return _.long._makeEmpty( ... arguments );
  return _.object.makeEmpty( ... arguments );
}

//

/* qqq2 : for junior : cover please */
function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  {
    _.assert( this.like( src ) || _.routineIs( src ) );
    return this._makeEmpty( src );
  }
  else
  {
    return this._makeEmpty();
  }
}

//

function _makeUndefined( src, length )
{
  if( _.long.is( src ) )
  return _.long._makeUndefined( ... arguments );
  return _.object.makeUndefined( ... arguments );
}

//

/* qqq2 : for junior : cover please */
function makeUndefined( src, length )
{
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routineIs( src ) );
    _.assert( _.numberIs( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.numberIs( src ) || this.like( src ) || _.routineIs( src ) );
  }
  return this._makeUndefined( ... arguments );
}

//

function _makeZeroed( src, length )
{
  if( _.long.is( src ) )
  return _.long._makeZeroed( ... arguments );
  return _.object.make( ... arguments );
}

//

/* qqq2 : for junior : cover please */
/* qqq : for junior : extend with test cases with countable in 2nd arg */
function makeZeroed( src, length )
{
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.long.is( src ) || _.routineIs( src ) );
    _.assert( _.numberIs( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.numberIs( src ) || this.like( src ) || _.routineIs( src ) );
  }
  return this._makeZeroed( ... arguments );
}

//

function _make( src, length )
{
  if( _.long.is( src ) )
  return _.long._make( ... arguments );
  return _.object.make( ... arguments );
}

//

/* qqq2 : for junior : full implementation and coverage are required */
/* qqq : for junior : extend with test cases with countable in 2nd arg */
function make( src, length )
{
  _.assert( arguments.length <= 2 );
  if( arguments.length === 2 )
  {
    _.assert( src === null || _.countable.is( src ) || _.routineIs( src ) );
    _.assert( _.numberIs( length ) || _.countable.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( src === null || _.numberIs( src ) || this.like( src ) || _.routineIs( src ) );
  }
  return this._make( ... arguments );
}

//

/* qqq2 : for junior : full implementation and coverage are required */
function _cloneShallow( src )
{
  if( _.long.is( src ) )
  return _.long._cloneShallow( src );
  return _.object.cloneShallow( src );
}

//

function cloneShallow( srcArray )
{
  _.assert( this.like( srcArray ) );
  _.assert( arguments.length === 1 );
  return this._cloneShallow( srcArray );
}

//

function from( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( this.is( src ) )
  return src;
  if( src === null )
  return this.make( null );
  return this.make( null, src );
}

// --
// meta
// --

/* qqq : optimize */
function namespaceOf( src )
{
  if( !this.is( src ) )
  return null;

  let result = _.long.namespaceOf( src );
  if( result )
  return result;

  return this;
}

// --
// extension
// --

var ToolsExtension =
{

  // dichotomy

  countableIs : is.bind( _.countable ),
  countableLike : like.bind( _.countable ),

}

Object.assign( _, ToolsExtension );

//

var CountableExtension =
{

  //

  NamespaceName : 'countable',
  NamespaceNames : [ 'countable' ],
  NamespaceQname : 'wTools/countable',
  MoreGeneralNamespaceName : 'countable',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'Countable',
  TypeNames : [ 'Countable' ],
  // SecondTypeName : 'Countable',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is, /* qqq : cover here and in the module::MathVector */
  like, /* qqq : cover here and in the module::MathVector */
  isResizable,
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _makeZeroed,
  makeZeroed, /* qqq : for junior : cover */
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow, /* qqq : for junior : cover */
  from, /* qqq : for junior : cover */

  // meta

  namespaceOf,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

Object.assign( _.countable, CountableExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Countable.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Countable_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Countable_s */ })();

/* */  /* begin of file Ct_s */ ( function Ct_s() { function Ct_s_naked() { ( function _l1_Ct_s_()
{

'use strict';

//

const _global = _global_;
const _ = _global_.wTools;
_.ct = _.ct || Object.create( null );

// --
// implementation
// --

// --
// declare
// --

let Extension =
{
}

Object.assign( _.ct, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Ct.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Ct_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Ct_s */ })();

/* */  /* begin of file Date_s */ ( function Date_s() { function Date_s_naked() { ( function _l1_Date_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.date = _.date || Object.create( null );

// --
// dichotomy
// --

function is( src )
{
  return Object.prototype.toString.call( src ) === '[object Date]';
}

//

function identicalShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );


  if( !_.date.is( src1 ) )
  return false;
  if( !_.date.is( src2 ) )
  return false;

  return _.date._identicalShallow( src1, src2 );
}

//

function _identicalShallow( src1, src2 )
{
  src1 = src1.getTime();
  src2 = src2.getTime();

  return src1 === src2;
}

//

function exportStringDiagnosticShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.date.is( src ) );

  return src.toISOString();
}

//

function exportStringCodeShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.date.is( src ) );

  return `new Date( '${src.toISOString()}' )`;
}

// --
// extension
// --

let ToolsExtension =
{
  dateIs : is,
  datesAreIdentical : identicalShallow,
}

//

let Extension =
{
  is,
  identicalShallow,
  _identicalShallow,
  areIdentical : identicalShallow,
  equivalentShallow : identicalShallow,

  // exporter

  exportString : exportStringDiagnosticShallow,
  // exportStringDiagnosticShallow : exportStringDiagnosticShallow,
  exportStringCodeShallow,
  exportStringDiagnosticShallow,
  // exportStringDiagnostic : exportStringDiagnosticShallow,
  // exportStringCode : exportStringCodeShallow
}

//

Object.assign( _, ToolsExtension );
Object.assign( _.date, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Date.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Date_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Date_s */ })();

/* */  /* begin of file Entity_s */ ( function Entity_s() { function Entity_s_naked() { ( function _l1_Entity_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.entity = _.entity || Object.create( null );

// --
// dichotomy
// --

function is( src )
{
  return true;
}

//

function like( src )
{
  return _.entity.is( src );
}

// --
// exporter
// --

function strPrimitive( src )
{
  let result = '';

  _.assert( arguments.length === 1, 'Expects exactly one argument' );

  if( src === null || src === undefined )
  return;

  if( _.primitive.is( src ) )
  return String( src );

  return;
}

//

/**
 * Return primitive type of src.
 *
 * @example
 * let str = _.entity.strTypeSecondary( 'testing' );
 *
 * @param {*} src
 *
 * @return {string}
 * string name of type src
 * @function strTypeSecondary
 * @namespace Tools
 */

function strTypeSecondary( src )
{

  let name = Object.prototype.toString.call( src );
  let result = /\[(\w+) (\w+)\]/.exec( name );
  _.assert( !!result, 'unknown type', name );
  return result[ 2 ];
}

//

/**
 * Return type of src.
 *
 * @example
 * let str = _.entity.strType( 'testing' );
 *
 * @param {*} src
 *
 * @return {string}
 * string name of type src
 * @function strType
 * @namespace Tools
 */

/* qqq for junior : jsdoc */
/* xxx : optimize later */
/* xxx : move to namesapce type? */
function strTypeWithTraits( src )
{

  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.aux.is( src ) )
  {

    if( _.mapIsPure( src ) )
    return end( 'Map.pure' );
    else if( _.mapIsPolluted( src ) )
    return end( 'Map.polluted' );
    else if( _.aux.isPure( src ) && _.aux.isPrototyped( src ) )
    return end( 'Aux.pure.prototyped' );
    else if( _.aux.isPolluted( src ) && _.aux.isPrototyped( src ) )
    return end( 'Aux.polluted.prototyped' );
    else _.assert( 0, 'undexpected' );

  }

  if( _.primitive.is( src ) )
  return end( _.entity.strTypeSecondary( src ) );

  let proto = Object.getPrototypeOf( src );
  if( proto && proto.constructor && proto.constructor !== Object && proto.constructor.name )
  return end( proto.constructor.name );

  return end( _.entity.strTypeSecondary( src ) );

  function end( result )
  {
    let translated = _.entity.TranslatedTypeMap[ result ];
    if( translated )
    result = translated;

    if( !_.entity.StandardTypeSet.has( result ) )
    {
      if( _.countableIs( src ) )
      result += '.countable';
      if( _.constructibleIs( src ) )
      result += '.constructible';
    }

    return result;
  }

}

//

/* qqq for junior : jsdoc */
function strTypeWithoutTraits( src )
{

  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.aux.is( src ) )
  {
    if( _.mapIs( src ) )
    return 'Map';
    else
    return 'Aux';
  }

  if( _.primitive.is( src ) )
  return end( _.entity.strTypeSecondary( src ) );

  let proto = Object.getPrototypeOf( src );
  if( proto && proto.constructor && proto.constructor !== Object && proto.constructor.name )
  return end( proto.constructor.name );

  return end( _.entity.strTypeSecondary( src ) );

  function end( result )
  {
    let translated = _.entity.TranslatedTypeMap[ result ];
    if( translated )
    result = translated;
    return result;
  }

}

// --
// meta
// --

function namespaceForIterating( src ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 );

  if( src === undefined )
  return _.blank;
  if( _.primitive.is( src ) )
  return _.itself;
  if( _.hashMap.like( src ) )
  return _.hashMap;
  if( _.set.like( src ) )
  return _.set;
  if( _.long.is( src ) )
  return _.long;
  if( _.buffer.like( src ) )
  return _.buffer;
  if( _.countable.is( src ) )
  return _.object;
  if( _.aux.is( src ) )
  return _.aux;
  if( _.object.is( src ) )
  return _.object;

  return _.props;
}

// --
// entity extension
// --

let TranslatedTypeMap =
{

  'BigUint64Array' : 'U64x',
  'Uint32Array' : 'U32x',
  'Uint16Array' : 'U16x',
  'Uint8Array' : 'U8x',
  'Uint8ClampedArray' : 'U8xClamped',

  'BigInt64Array' : 'I64x',
  'Int32Array' : 'I32x',
  'Int16Array' : 'I16x',
  'Int8Array' : 'I8x',

  'Float64Array' : 'F64x',
  'Float32Array' : 'F32x',

  'Buffer' : 'BufferNode',
  'ArrayBuffer' : 'BufferRaw',
  'SharedArrayBuffer' : 'BufferRawShared',
  'Map' : 'HashMap',
  'WeakMap' : 'HashMapWeak',
  'Function' : 'Routine',
  'Arguments' : 'ArgumentsArray',

}

let StandardTypeSet = new Set
([

  'U64x',
  'U32x',
  'U16x',
  'U8x',
  'U8xClamped',
  'I64x',
  'I32x',
  'I16x',
  'I8x',
  'F64x',
  'F32x',

  'BufferNode',
  'BufferRaw',
  'BufferRawShared',
  'HashMap',
  'HashMapWeak',

  'ArgumentsArray',
  'Array',
  'Set',
  'Routine',
  'Global',

]);

//

let EntityExtension =
{

  // fields

  NamespaceName : 'entity',
  NamespaceNames : [ 'entity' ],
  NamespaceQname : 'wTools/entity',
  TypeName : 'Entity',
  TypeNames : [ 'Entity' ],
  // SecondTypeName : 'Entity',
  InstanceConstructor : null,
  tools : _,
  TranslatedTypeMap,
  StandardTypeSet,

  // dichotmoy

  is,
  like,

  // maker

  // _cloneShallow : _.container._cloneShallow, /* xxx : implement? */
  cloneShallow : _.container.cloneShallow, /* qqq : cover */
  // _make : _.container._make, /* qqq : implement */
  make : _.container.make, /* xxx : implement? */
  // _makeEmpty : _.container._makeEmpty, /* qqq : implement */
  makeEmpty : _.container.makeEmpty, /* xxx : implement? */
  // _makeUndefined : _.container._makeUndefined, /* qqq : implement */
  makeUndefined : _.container.makeUndefined, /* xxx : implement? */

  // exporter

  strPrimitive,
  strTypeSecondary,
  strType : strTypeWithTraits,
  strTypeWithTraits,
  strTypeWithoutTraits,

  // meta

  namespaceForIterating,
  namespaceForExporting : _.container.namespaceForExporting,
  namespaceOf : namespaceForIterating,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

//

Object.assign( _.entity, EntityExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  entityIs : is.bind( _.entity ),
  entityLike : like.bind( _.entity ),

  strType : strTypeWithTraits,

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Entity.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Entity_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Entity_s */ })();

/* */  /* begin of file Escape_s */ ( function Escape_s() { function Escape_s_naked() { ( function _l1_Escape_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.escape = _.escape || Object.create( null );

// --
// implement
// --

// --
// declare
// --

var Extension =
{
}

Object.assign( _.escape, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Escape.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Escape_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Escape_s */ })();

/* */  /* begin of file Event_s */ ( function Event_s() { function Event_s_naked() { ( function _l1_Event_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.event = _.event || Object.create( null );

// --
//
// --


// --
// declare
// --

let Extension =
{
};

Object.assign( _.event, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Event.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Event_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Event_s */ })();

/* */  /* begin of file Functional_s */ ( function Functional_s() { function Functional_s_naked() { ( function _l1_Functional_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _global_.wTools;

// --
// implementation
// --

// --
// declaration
// --

let ToolsExtension =
{
}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Functional.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Functional_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Functional_s */ })();

/* */  /* begin of file Functor_s */ ( function Functor_s() { function Functor_s_naked() { ( function _l1_Functor_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.functor = _.functor || Object.create( null );

// --
// implementation
// --

/*
qqq : for Dmytro : add support and coverage of Set. discuss
*/

function vectorize_head( routine, args )
{
  let o = args[ 0 ];

  if( args.length === 2 )
  o = { routine : args[ 0 ], select : args[ 1 ] }
  else if( _.routine.is( o ) || _.strIs( o ) )
  o = { routine : args[ 0 ] }

  _.routine.options( routine, o );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.routine.is( o.routine ) || _.strIs( o.routine ) || _.strsAreAll( o.routine ), () => 'Expects routine {-o.routine-}, but got ' + o.routine );
  _.assert( args.length === 1 || args.length === 2 );
  _.assert( o.select >= 1 || _.strIs( o.select ) || _.argumentsArray.like( o.select ), () => 'Expects {-o.select-} as number >= 1, string or array, but got ' + o.select );

  return o;
}

function vectorize_body( o )
{

  _.routine.assertOptions( vectorize_body, arguments );

  if( _.argumentsArray.like( o.routine ) && o.routine.length === 1 )
  o.routine = o.routine[ 0 ];

  let routine = o.routine;
  let propertyCondition = o.propertyCondition;
  let bypassingFilteredOut = o.bypassingFilteredOut;
  let bypassingEmpty = o.bypassingEmpty;
  let vectorizingArray = o.vectorizingArray;
  let vectorizingMapVals = o.vectorizingMapVals;
  let vectorizingMapKeys = o.vectorizingMapKeys;
  let vectorizingContainerAdapter = o.vectorizingContainerAdapter;
  let unwrapingContainerAdapter = o.unwrapingContainerAdapter;
  let head = null;
  let select = o.select === null ? 1 : o.select;
  let selectAll = o.select === Infinity;
  let multiply = select > 1 ? multiplyReally : multiplyNo;

  routine = routineNormalize( routine );

  _.assert( _.routine.is( routine ), () => 'Expects routine {-o.routine-}, but got ' + routine );

  /* */

  let resultRoutine = vectorizeArray;

  if( _.number.is( select ) )
  {

    if( !vectorizingArray && !vectorizingMapVals && !vectorizingMapKeys )
    resultRoutine = routine;
    else if( propertyCondition )
    resultRoutine = vectorizeWithFilters;
    else if( vectorizingMapKeys )
    {

      if( vectorizingMapVals )
      {
        _.assert( select === 1, 'Only single argument is allowed if {-o.vectorizingMapKeys-} and {-o.vectorizingMapVals-} are enabled.' );
        resultRoutine = vectorizeMapWithKeysOrArray;
      }
      else
      {
        resultRoutine = vectorizeKeysOrArray;
      }

    }
    else if( !vectorizingArray || vectorizingMapVals )
    resultRoutine = vectorizeMapOrArray;
    else if( multiply === multiplyNo )
    resultRoutine = vectorizeArray;
    else
    resultRoutine = vectorizeArrayMultiplying;

  }
  else
  {
    _.assert( multiply === multiplyNo );
    if( routine.head )
    {
      head = routine.head;
      routine = routine.body;
    }
    if( propertyCondition )
    {
      _.assert( 0, 'not implemented' );
    }
    else if( vectorizingArray || !vectorizingMapVals )
    {
      if( _.strIs( select ) )
      resultRoutine = vectorizeForOptionsMap;
      else
      resultRoutine = vectorizeForOptionsMapForKeys;
    }
    else _.assert( 0, 'not implemented' );
  }

  /* */

  resultRoutine.vectorized = o;

  /* */

  _.routine.extend( resultRoutine, routine );
  return resultRoutine;

  /*
    vectorizeWithFilters : multiply + array/map vectorizing + filter
    vectorizeArray : array vectorizing
    vectorizeArrayMultiplying :  multiply + array vectorizing
    vectorizeMapOrArray :  multiply +  array/map vectorizing
  */

  /* - */

  function routineNormalize( routine )
  {

    if( _.strIs( routine ) )
    {
      return function methodCall()
      {
        _.assert( _.routine.is( this[ routine ] ), () => 'Context ' + _.entity.exportStringDiagnosticShallow( this ) + ' does not have routine ' + routine );
        return this[ routine ].apply( this, arguments );
      }
    }
    else if( _.argumentsArray.like( routine ) )
    {
      _.assert( routine.length === 2 );
      return function methodCall()
      {
        let c = this[ routine[ 0 ] ];
        _.assert( _.routine.is( c[ routine[ 1 ] ] ), () => 'Context ' + _.entity.exportStringDiagnosticShallow( c ) + ' does not have routine ' + routine );
        return c[ routine[ 1 ] ].apply( c, arguments );
      }
    }

    return routine;
  }

  /* - */

  function multiplyNo( args )
  {
    return args;
  }

  /* - */

  function multiplyReally( args )
  {
    let length, keys;

    args = [ ... args ];

    if( selectAll )
    select = args.length;

    _.assert( args.length === select, () => 'Expects ' + select + ' arguments, but got ' + args.length );

    for( let d = 0 ; d < select ; d++ )
    {
      if( vectorizingArray && _.argumentsArray.like( args[ d ] ) )
      {
        length = args[ d ].length;
        break;
      }
      else if( vectorizingArray && _.set.like( args[ d ] ) )
      {
        length = args[ d ].size;
        break;
      }
      else if( vectorizingContainerAdapter && _.containerAdapter.is( args[ d ] ) )
      {
        length = args[ d ].length;
        break;
      }
      else if( vectorizingMapVals && _.aux.is( args[ d ] ) )
      {
        keys = _.props.onlyOwnKeys( args[ d ] );
        break;
      }
    }

    if( length !== undefined )
    {
      for( let d = 0 ; d < select ; d++ )
      {
        if( vectorizingMapVals )
        _.assert( !_.mapIs( args[ d ] ), () => 'Arguments should have only arrays or only maps, but not both. Incorrect argument : ' + args[ d ] );
        else if( vectorizingMapKeys && _.mapIs( args[ d ] ) )
        continue;
        args[ d ] = _.multiple( args[ d ], length );
      }

    }
    else if( keys !== undefined )
    {
      for( let d = 0 ; d < select ; d++ )
      if( _.mapIs( args[ d ] ) )
      {
        _.assert( _.arraySet.identical( _.props.onlyOwnKeys( args[ d ] ), keys ), () => 'Maps should have same keys : ' + keys );
      }
      else
      {
        if( vectorizingArray )
        _.assert( !_.argumentsArray.like( args[ d ] ), () => 'Arguments should have only arrays or only maps, but not both. Incorrect argument : ' + args[ d ] );
        let arg = Object.create( null );
        _.mapSetWithKeys( arg, keys, args[ d ] );
        args[ d ] = arg;
      }
    }

    return args;
  }

  /* - */

  function vectorizeArray()
  {
    if( bypassingEmpty && !arguments.length )
    return [];

    let args = arguments;
    let src = args[ 0 ];

    if( _.arrayIs( src ) ) /* Dmytro : arrayLike returns true for instances of containerAdapter */
    {
      let args2 = [ ... args ];
      let result = _.long.makeEmpty( src );
      let append = _.long.appender( result );
      let each = _.long.eacher( src );
      each( ( e ) =>
      {
        args2[ 0 ] = e;
        append( routine.apply( this, args2 ) );
      });
      return result;
    }
    else if( _.set.like( src ) ) /* qqq : cover please */
    {
      let args2 = [ ... args ];
      let result = new Set;
      for( let e of src )
      {
        args2[ 0 ] = e;
        result.add( routine.apply( this, args2 ) );
      }
      return result;
    }
    else if( vectorizingContainerAdapter && _.containerAdapter.is( src ) )
    {
      let args2 = [ ... args ];
      let result = src.filter( ( e ) =>
      {
        args2[ 0 ] = e;
        return routine.apply( this, args2 );
      });
      if( unwrapingContainerAdapter )
      return result.original;
      else
      return result;
    }

    return routine.apply( this, args );
  }

  /* - */

  function vectorizeArrayMultiplying()
  {
    if( bypassingEmpty && !arguments.length )
    return [];

    let args = multiply( arguments );
    let src = args[ 0 ];

    if( _.argumentsArray.like( src ) )
    {

      let args2 = [ ... args ];
      let result = _.long.makeEmpty( src );
      let append = _.long.appender( result );
      let each = _.long.eacher( src );
      each( ( e, r ) =>
      {
        for( let m = 0 ; m < select ; m++ )
        args2[ m ] = args[ m ][ r ]; /* zzz qqq : use _.long.get */
        append( routine.apply( this, args2 ) );
      });
      return result;
    }

    return routine.apply( this, args );
  }

  /* - */

  function vectorizeForOptionsMap( srcMap )
  {
    if( bypassingEmpty && !arguments.length )
    return [];

    let src = srcMap[ select ];
    let args = [ ... arguments ];
    _.assert( arguments.length === 1, 'Expects single argument' );

    if( _.argumentsArray.like( src ) )
    {
      if( head )
      {
        args = head( routine, args );
        _.assert( _.arrayLikeResizable( args ) );
      }

      let result = _.long.makeEmpty( src );
      let append = _.long.appender( result );
      let each = _.long.eacher( src );
      each( ( e ) =>
      {
        args[ 0 ] = _.props.extend( null, srcMap );
        args[ 0 ][ select ] = e;
        append( routine.apply( this, args ) );
      });
      return result;

    }
    else if( _.set.like( src ) ) /* qqq : cover */
    {
      if( head )
      {
        args = head( routine, args );
        _.assert( _.arrayLikeResizable( args ) );
      }
      let result = new Set;
      for( let e of src )
      {
        args[ 0 ] = _.props.extend( null, srcMap );
        args[ 0 ][ select ] = e;
        result.add( routine.apply( this, args ) );
      }
      return result;
    }
    else if( vectorizingContainerAdapter && _.containerAdapter.is( src ) ) /* qqq : cover */
    {
      if( head )
      {
        args = head( routine, args );
        _.assert( _.arrayLikeResizable( args ) );
      }
      result = src.filter( ( e ) =>
      {
        args[ 0 ] = _.props.extend( null, srcMap );
        args[ 0 ][ select ] = e;
        return routine.apply( this, args );
      });
      if( unwrapingContainerAdapter )
      return result.original;
      else
      return result;
    }

    return routine.apply( this, arguments );
  }

  /* - */

  function vectorizeForOptionsMapForKeys()
  {
    let result = [];

    if( bypassingEmpty && !arguments.length )
    return result;

    for( let i = 0; i < o.select.length; i++ )
    {
      select = o.select[ i ];
      result[ i ] = vectorizeForOptionsMap.apply( this, arguments );
    }
    return result;
  }

  /* - */

  function vectorizeMapOrArray()
  {
    if( bypassingEmpty && !arguments.length )
    return [];

    let args = multiply( arguments );
    let src = args[ 0 ];

    if( vectorizingArray && _.argumentsArray.like( src ) )
    {

      let args2 = [ ... args ];
      let result = _.long.makeEmpty( src );
      let append = _.long.appender( result );
      let each = _.long.eacher( src );
      each( ( e, r ) =>
      {

        for( let m = 0 ; m < select ; m++ )
        args2[ m ] = args[ m ][ r ]; /* qqq zzz : use _.long.get? */

        append( routine.apply( this, args2 ) );
      });
      return result;
    }
    else if( vectorizingMapVals && _.mapIs( src ) )
    {
      let args2 = [ ... args ];
      let result = Object.create( null );
      for( let r in src )
      {
        for( let m = 0 ; m < select ; m++ )
        args2[ m ] = args[ m ][ r ];

        result[ r ] = routine.apply( this, args2 );
      }
      return result;
    }

    return routine.apply( this, arguments );
  }

  /* - */

  function vectorizeMapWithKeysOrArray()
  {
    if( bypassingEmpty && !arguments.length )
    return [];

    let args = multiply( arguments );
    let srcs = args[ 0 ];

    _.assert( args.length === select, () => 'Expects ' + select + ' arguments but got : ' + args.length );

    if( vectorizingMapKeys && vectorizingMapVals &&_.mapIs( srcs ) )
    {
      let result = Object.create( null );
      for( let s in srcs )
      {
        let val = routine.call( this, srcs[ s ] );
        let key = routine.call( this, s );
        result[ key ] = val;
      }
      return result;
    }
    else if( vectorizingArray && _.argumentsArray.like( srcs ) )
    {
      let result = [];
      for( let s = 0 ; s < srcs.length ; s++ )
      result[ s ] = routine.call( this, srcs[ s ] );
      return result;
    }

    return routine.apply( this, arguments );
  }

  /* - */

  function vectorizeWithFilters( src )
  {

    _.assert( 0, 'not tested' ); /* qqq : cover please */
    _.assert( arguments.length === 1, 'Expects single argument' );

    let args = multiply( arguments );

    if( vectorizingArray && _.argumentsArray.like( src ) )
    {
      args = [ ... args ];
      throw _.err( 'not tested' ); /* cover please */

      let result = _.long.makeEmpty( src );
      let append = _.long.appender( result );
      let each = _.long.eacher( src );
      each( ( e, r ) =>
      {
        if( propertyCondition( e, r, src ) )
        {
          args[ 0 ] = e;
          append( routine.apply( this, args ) );
        }
        else if( bypassingFilteredOut )
        {
          append( e );
        }

        args2[ 0 ] = e;
        append( routine.apply( this, args2 ) );
      });
      return result;

    }
    else if( vectorizingMapVals && _.mapIs( src ) )
    {
      args = [ ... args ];
      let result = Object.create( null );
      throw _.err( 'not tested' ); /* qqq : cover please */
      for( let r in src )
      {
        if( propertyCondition( src[ r ], r, src ) )
        {
          args[ 0 ] = src[ r ];
          result[ r ] = routine.apply( this, args );
        }
        else if( bypassingFilteredOut )
        {
          result[ r ] = src[ r ];
        }
      }
      return result;
    }

    return routine.call( this, src );
  }

  /* - */

  function vectorizeKeysOrArray()
  {
    if( bypassingEmpty && !arguments.length )
    return [];

    // let args = multiply( _.originalsFromAdaptersInplace( arguments ) );
    let args = multiply( arguments );
    let src = args[ 0 ];
    let args2, result, map, mapIndex, arr;

    _.assert( args.length === select, () => 'Expects ' + select + ' arguments but got : ' + args.length );

    if( vectorizingMapKeys )
    {
      for( let d = 0; d < select; d++ )
      {
        if( vectorizingArray && _.argumentsArray.like( args[ d ] ) )
        arr = args[ d ];
        else if( _.mapIs( args[ d ] ) )
        {
          _.assert( map === undefined, () => 'Arguments should have only single map. Incorrect argument : ' + args[ d ] );
          map = args[ d ];
          mapIndex = d;
        }
      }
    }

    if( map )
    {
      result = Object.create( null );
      args2 = [ ... args ];

      if( vectorizingArray && _.argumentsArray.like( arr ) )
      {
        for( let i = 0; i < arr.length; i++ )
        {
          for( let m = 0 ; m < select ; m++ )
          args2[ m ] = args[ m ][ i ];

          for( let k in map )
          {
            args2[ mapIndex ] = k;
            let key = routine.apply( this, args2 );
            result[ key ] = map[ k ];
          }
        }
      }
      else
      {
        for( let k in map )
        {
          args2[ mapIndex ] = k;
          let key = routine.apply( this, args2 );
          result[ key ] = map[ k ];
        }
      }

      return result;
    }
    else if( vectorizingArray && _.argumentsArray.like( src ) )
    {

      let args2 = [ ... args ];
      let result = _.long.makeEmpty( src );
      let append = _.long.appender( result );
      let each = _.long.eacher( src );
      each( ( e, r ) =>
      {
        for( let m = 0 ; m < select ; m++ )
        args2[ m ] = args[ m ][ r ]; /* qqq zzz : use _.long.get */
        append( routine.apply( this, args2 ) );
      });
      return result;

    }

    return routine.apply( this, arguments );
  }

}

/* qqq : implement options combination vectorizingMapVals : 1, vectorizingMapKeys : 1, vectorizingArray : [ 0, 1 ] */
/* qqq : cover it */

/* qqq : implement bypassingEmpty for all combinations of options */
/* qqq : options bypassingEmpty of routine _.vectorize requires good coverage */

vectorize_body.defaults =
{
  routine : null,
  propertyCondition : null,
  bypassingFilteredOut : 1,
  bypassingEmpty : 0,
  vectorizingArray : 1, /* qqq2 : for Dmytro : add option vectorizingCountable : 1. discuss */
  vectorizingMapVals : 0,
  vectorizingMapKeys : 0,
  vectorizingContainerAdapter : 0,
  unwrapingContainerAdapter : 0,
  select : 1,
}

//

function vectorize()
{
  let o = vectorize.head.call( this, vectorize, arguments );
  let result = vectorize.body.call( this, o );
  return result;
}

vectorize.head = vectorize_head;
vectorize.body = vectorize_body;
vectorize.defaults = { ... vectorize_body.defaults };

//

function vectorizeAll_body( o )
{
  _.routine.assertOptions( vectorize, arguments );

  let routine1 = _.vectorize.body.call( this, o );

  _.routine.extend( all, o.routine );

  return all;

  function all()
  {
    let result = routine1.apply( this, arguments );
    return _.all( result );
  }

}

vectorizeAll_body.defaults = { ... vectorize_body.defaults };

//

function vectorizeAll()
{
  let o = vectorizeAll.head.call( this, vectorizeAll, arguments );
  let result = vectorizeAll.body.call( this, o );
  return result;
}

vectorizeAll.head = vectorize_head;
vectorizeAll.body = vectorizeAll_body;
vectorizeAll.defaults = { ... vectorizeAll_body.defaults };

//

function vectorizeAny_body( o )
{
  _.routine.assertOptions( vectorize, arguments );

  let routine1 = _.vectorize.body.call( this, o );
  _.routine.extend( any, o.routine );

  return any;

  function any()
  {
    let result = routine1.apply( this, arguments );
    return !!_.any( result );
  }

}

vectorizeAny_body.defaults = { ... vectorize_body.defaults };

//

function vectorizeAny()
{
  let o = vectorizeAny.head.call( this, vectorizeAny, arguments );
  let result = vectorizeAny.body.call( this, o );
  return result;
}

vectorizeAny.head = vectorize_head;
vectorizeAny.body = vectorizeAny_body;
vectorizeAny.defaults = { ... vectorizeAny_body.defaults };

//

function vectorizeNone_body( o )
{
  _.routine.assertOptions( vectorize, arguments );

  let routine1 = _.vectorize.body.call( this, o );
  _.routine.extend( none, o.routine );

  return none;

  function none()
  {
    let result = routine1.apply( this, arguments );
    return _.none( result );
  }

}

vectorizeNone_body.defaults = { ... vectorize_body.defaults };

//

function vectorizeNone()
{
  let o = vectorizeNone.head.call( this, vectorizeNone, arguments );
  let result = vectorizeNone.body.call( this, o );
  return result;
}

vectorizeNone.head = vectorize_head;
vectorizeNone.body = vectorizeNone_body;
vectorizeNone.defaults = { ... vectorizeNone_body.defaults };

//

/**
 * The routine vectorizeAccess() creates proxy object for each element of passed vector {-vector-}.
 * Proxy object provides access to existed properties of {-vector-} elements uses only get()
 * and set() handlers.
 * If get() handler is used, then routine returns new proxy object with vector of property values.
 * If a property is a routine, then its routines can be applied to a set of arguments. The result is
 * a new proxy with vector of returned values.
 * To get original vector uses property `$`.
 * If set() handler is used, then property of each proxy element is assigned to one value.
 *
 * @param { Long } vector - The vector of objects and vectors to get proxy access to properties.
 *
 * @example
 * let obj1 = { a : 1, b : 2, c : 3 };
 * let obj2 = { a : 5, b : 6 };
 * let vector = _.vectorizeAccess( [ obj1, obj2 ] );
 * console.log( vector );
 * // log Proxy [
 * //       [ { a : 1, b : 2, c : 3 }, { a : 5, b : 6 } ],
 * //       { get: [Function: get], set: [Function: set] }
 * //     ]
 * console.log( vector[ '$' ] );
 * // log [ { a : 1, b : 2, c : 3 }, { a : 5, b : 6 } ]
 * let vectorA = vector.a; // or vector[ 'a' ]
 * console.log( vectorA );
 * // log Proxy [ [ 1, 5 ], { get: [Function: get], set: [Function: set] } ]
 *
 * @example
 * let cb1 = ( e ) => Math.pow( e, 2 );
 * let cb2 = ( e ) => Math.sqrt( e, 2 );
 * let obj1 = { callback : cb1, name : 'obj1' };
 * let obj2 = { callback : cb2, name : 'obj2' };
 * let vector = _.vectorizeAccess( [ obj1, obj2 ] );
 * let result = vector.callback( 4 );
 * console.log( result );
 * // log Proxy [ [ 16, 2 ], { get: [Function: get], set: [Function: set] } ]
 *
 * @example
 * let v1 = [ 1, 2, 3 ];
 * let v2 = [ 5, 6 ];
 * let vector = _.vectorizeAccess( [ v1, v2 ] );
 * vector[ 1 ] = 10;
 * console.log( vector[ '$' ] );
 * // log [ [ 1, 10, 3 ], [ 5, 10 ] ]
 *
 * @returns { Proxy } - Proxy object, which provides access to existed properties in elements of vector.
 * @function vectorizeAccess
 * @throws { Error } If arguments.length is less or more then one.
 * @throws { Error } If {-vector-} is not a Long.
 * @namespace Tools
 */

function vectorizeAccess( vector )
{

  _.assert( _.longIs( vector ) );
  _.assert( arguments.length === 1 );

  let handler =
  {
    get,
    set,
  };

  let proxy = new Proxy( vector, handler );

  return proxy;

  /* */

  function set( /* back, key, val, context */ )
  {
    let back = arguments[ 0 ];
    let key = arguments[ 1 ];
    let val = arguments[ 2 ];
    let context = arguments[ 3 ];

    vector.map( ( scalar ) =>
    {
      _.assert( scalar[ key ] !== undefined, `One or several element(s) of vector does not have ${key}` );
    });

    vector.map( ( scalar ) =>
    {
      scalar[ key ] = val;
    });

    return true;
  }

  /* */

  function get( back, key, context )
  {
    if( key === '$' )
    {
      return vector;
    }

    let routineIs = vector.some( ( scalar ) => _.routine.is( scalar[ key ] ) );

    if( !routineIs )
    if( _.all( vector, ( scalar ) => scalar[ key ] === undefined ) )
    return;

    vector.map( ( scalar ) =>
    {
      _.assert( scalar[ key ] !== undefined, `One or several element(s) of vector does not have ${String( key )}` );
    });

    if( routineIs )
    return function()
    {
      let self = this;
      let args = arguments;
      let revectorizing = false;
      let result = vector.map( ( scalar ) =>
      {
        let r = scalar[ key ].apply( scalar, args );
        if( r !== scalar )
        revectorizing = true;
        return r; // Dmytro : it returns result in vector, if it not exists, then result has only undefined => [ undefined, undefined, undefined ]
      });
      if( revectorizing )
      {
        return vectorizeAccess( result );
      }
      else
      {
        return proxy;
      }
    }

    let result = vector.map( ( scalar ) =>
    {
      return scalar[ key ];
    });

    return vectorizeAccess( result );
  }

}

// --
// implementation
// --

let ToolsExtension =
{

  routineVectorize_functor : vectorize,
  vectorize,
  vectorizeAll,
  vectorizeAny,
  vectorizeNone,

  vectorizeAccess,

}

Object.assign( _, ToolsExtension );

//

let FunctorExtension =
{

  vectorize,
  vectorizeAll,
  vectorizeAny,
  vectorizeNone,

  vectorizeAccess,

}

Object.assign( _.functor, FunctorExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Functor.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Functor_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Functor_s */ })();

/* */  /* begin of file Fuzzy_s */ ( function Fuzzy_s() { function Fuzzy_s_naked() { ( function _l1_Fuzzy_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.fuzzy = _.fuzzy || Object.create( null );

// --
// fuzzy
// --

/**
 * Returns true if entity ( src ) is a Boolean values - true and false or Symbol(maybe).
 * @function is
 * @param { * } src - An entity to check.
 * @namespace Tools
 *
 * @example
 * var got = _.fuzzy.is( true );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.is( false );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.is( _.maybe );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.is( '1' );
 * console.log( got )
 * // log false
 *
 */

function is( src )
{
  return src === true || src === false || src === _.maybe;
}

//

/**
 * Returns true if entity ( src ) is a Boolean or a Number or Symbol(maybe).
 * @function fuzzyLike
 * @param { * } src - An entity to check.
 * @namespace Tools
 *
 * @example
 * var got = _.fuzzy.like( true );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.like( false );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.like( _.maybe );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.like( 1 );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.like( '1' );
 * console.log( got )
 * // log false
 */

function like( src )
{
  if( src === _.maybe )
  return true;
  return src === true || src === false || src === 0 || src === 1;
  // let type = Object.prototype.toString.call( src );
  // return type === '[object Boolean]' || type === '[object Number]';
}

//

/**
 * Returns true if entity ( src ) is false or 0.
 * @function likeFalse
 * @param { * } src - An entity to check.
 * @namespace Tools
 *
 * @example
 * var got = _.fuzzy.likeFalse( true );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.fuzzy.likeFalse( false );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.likeFalse( _.maybe );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.fuzzy.likeFalse( 0 );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.likeFalse( '1' );
 * console.log( got )
 * // log false
 *
 */

function likeFalse( src )
{
  if( !_.fuzzy.like( src ) )
  return false;
  return !src;
}

//

/**
 * Returns true if entity ( src ) is true or a Number which is not 0.
 * @function likeTrue
 * @param { * } src - An entity to check.
 * @namespace Tools
 *
 *  @example
 * var got = _.fuzzy.likeTrue( true );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.likeTrue( false );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.fuzzy.likeTrue( _.maybe );
 * console.log( got )
 * // log true
 *
 * @example
 * var got = _.fuzzy.likeTrue( 0 );
 * console.log( got )
 * // log false
 *
 * @example
 * var got = _.fuzzy.likeTrue( 10 );
 * console.log( got )
 * // log true
 *
 */

function likeTrue( src )
{
  if( !_.fuzzy.like( src ) )
  return false;
  if( src === _.maybe )
  return false;
  return !!src;
}

// --
// extension
// --

let ToolsExtension =
{

  fuzzyIs : is,
  fuzzyLike : like,
  fuzzyLikeFalse : likeFalse,
  fuzzyLikeTrue : likeTrue,

}

//

let Extension =
{

  is,
  like,
  likeFalse,
  likeTrue,

}

Object.assign( _, ToolsExtension );
Object.assign( _.fuzzy, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Fuzzy.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Fuzzy_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Fuzzy_s */ })();

/* */  /* begin of file Global_s */ ( function Global_s() { function Global_s_naked() { ( function _l1_Global_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const __ = _realGlobal_.wTools;
const Self = _.global = _.global || Object.create( null );

// --
// implementation
// --

/* xxx : qqq : for junior : dicuss tests */
function is( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.primitive.is( src ) )
  return false;

  // if( src === _global_ )
  // return true;

  if( _.prototype.has( src, _global_ ) )
  return true;

  return false;
}

//

function isReal( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  // if( _.primitive.is( src ) )
  // return false;

  if( src === _realGlobal_ )
  return true;
  return false;
}

//

function isDerivative( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  // if( _.primitive.is( src ) )
  // return false;

  if( _.global.is( src ) && !_.global.isReal( src ) )
  return true;
  return false;
}

// --
// extension
// --

var Extension =
{

  is,
  isReal,
  isDerivative,

  get : __.global.get,
  new : __.global.new,
  open : __.global.open,
  close : __.global.close,
  openForChildren : __.global.openForChildren,
  closeForChildren : __.global.closeForChildren,
  setup : __.global.setup,

  _stack : __.global._stack,

}

//

Object.assign( _.global, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Global.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Global_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Global_s */ })();

/* */  /* begin of file HashMap_s */ ( function HashMap_s() { function HashMap_s_naked() { ( function _l1_HashMap_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.hashMap = _.hashMap || Object.create( null );

// --
// dichotomy
// --

function is( src )
{
  if( !src )
  return false;
  return src instanceof HashMap || src instanceof HashMapWeak;
}

//

function like( src )
{
  return _.hashMap.is( src );
}

//

function isEmpty()
{
  if( !this.like( src ) )
  return false;
  return !src.size;
}

//

function isPopulated()
{
  if( !this.like( src ) )
  return false;
  return !!src.size;
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return true;
}

// --
// maker
// --

function _makeEmpty( src )
{
  return new HashMap();
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  _.assert( this.like( src ) );
  return new HashMap();
}

//

function _makeUndefined( src, length )
{
  return new HashMap();
}

//

function makeUndefined( src, length )
{
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 2 )
  {
    _.assert( this.like( src ) );
    _.assert( _.number.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( _.number.is( src ) || this.like( src ) );
  }

  return new HashMap();
}

//

function _make( src, length )
{
  let result = new HashMap();
  if( src && length !== 0 )
  {
    if( _.hashMap.is( src ) )
    for( let [ key, val ] of src )
    result.set( key, val );
    else if( _.aux.is( src ) )
    for( let key of src )
    result.set( key, src[ key ] );
    else _.assert( 0 );
  }
  return result;
}

//

/* qqq : for junior : cover */
function make( src, length )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length <= 2 );
  _.assert( arguments.length === 1 || _.hashMap.is( src ) || _.auxIs( src ) ); /* qqq : for junior : cover aux case */
  _.assert( arguments.length < 2 || length === 0 );
  return this._make( src, length );
}

//

function _cloneShallow( src )
{
  let result = new HashMap();
  for( let [ key, val ] of src )
  result.set( key, val );
  return result;
}

//

function cloneShallow( src )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length === 1 );
  return this._cloneShallow( src );
}

//

function _empty( dst )
{
  dst.clear();
  return dst;
}

//

function empty( dst )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this.like( dst ) );
  return this._empty( dst );
}

//

function fromProps( dstMap, srcMap )
{
  if( arguments.length === 1 )
  {
    srcMap = arguments[ 0 ];
    dstMap = null;
  }

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( !_.primitive.is( srcMap ) );
  _.assert( dstMap === null || _.hashMap.is( dstMap ) );

  if( dstMap === null )
  dstMap = new HashMap;

  for( let k in srcMap )
  {
    dstMap.set( k, srcMap[ k ] );
  }

  return dstMap;
}

//

function from( src )
{
  _.assert( arguments.length === 1 );
  if( this.is( src ) )
  return src;
  if( _.aux.is( src ) )
  return this.fromProps( null, src );
  _.assert( 0, `Not clear how to convert ${_.strType( src )} to HashMap` );
}

// --
// properties
// --

function _keys( src )
{
  return [ ... src.keys() ];
}

//

function keys( src )
{
  _.assert( this.like( src ) );
  return this._keys( src );
}

//

function _vals( src )
{
  return [ ... src.values() ];
}

//

function vals( src )
{
  _.assert( this.like( src ) );
  return this._vals( src );
}

//

function _pairs( src )
{
  return [ ... src.entries() ];
}

//

function pairs( src )
{
  _.assert( this.like( src ) );
  return this._pairs( src );
}

// --
// extension
// --

let ToolsExtension =
{

  // dichotomy

  hashMapIs : is.bind( _.hashMap ),
  hashMapIsEmpty : isEmpty.bind( _.hashMap ),
  hashMapIsPopulated : isPopulated.bind( _.hashMap ),
  hashMapLike : like.bind( _.hashMap ),

  // maker

  hashMapMakeEmpty : makeEmpty.bind( _.hashMap ),
  hashMapMakeUndefined : makeUndefined.bind( _.hashMap ),
  hashMapMake : make.bind( _.hashMap ),
  hashMapCloneShallow : cloneShallow.bind( _.hashMap ),
  hashMapFrom : from.bind( _.hashMap ),

}

Object.assign( _, ToolsExtension );

//

let Extension =
{

  //

  NamespaceName : 'hashMap',
  NamespaceNames : [ 'hashMap' ],
  NamespaceQname : 'wTools/hashMap',
  MoreGeneralNamespaceName : 'hashMap',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'HashMap',
  SecondTypeName : 'Map',
  InstanceConstructor : HashMap,
  tools : _,

  // dichotomy

  is,
  like,
  isEmpty,
  isPopulated,
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow, /* qqq : for junior : cover */
  fromProps, /* qqq : for junior : cover */
  from, /* qqq : for junior : cover */

  // properties

  _keys,
  keys, /* qqq : for junior : cover */
  _vals,
  vals, /* qqq : for junior : cover */
  _pairs,
  pairs, /* qqq : for junior : cover */

  // meta

  namespaceOf : _.blank.namespaceOf,
  namespaceWithDefaultOf : _.blank.namespaceWithDefaultOf,
  _functor_functor : _.blank._functor_functor,

}

Object.assign( _.hashMap, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/HashMap.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, HashMap_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file HashMap_s */ })();

/* */  /* begin of file Interval_s */ ( function Interval_s() { function Interval_s_naked() { ( function _l1_Interval_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _global_.wTools;

// --
// range
// --

function intervalIs( range )
{
  _.assert( arguments.length === 1 );
  if( !_.number.s.areAll( range ) )
  return false;
  if( range.length !== 2 )
  return false;
  return true;
}

//

function intervalIsValid( range )
{
  _.assert( arguments.length === 1 );
  if( !_.intervalIs( range ) )
  return false;
  if( !_.intIs( range[ 0 ] ) )
  return false;
  if( !_.intIs( range[ 1 ] ) )
  return false;
  return true;
}

// --
// implementation
// --

let ToolsExtension =
{

  /* zzz : review and rearrange */

  // range

  intervalIs,
  intervalIsValid, /* xxx : remove later */
  intervalDefined : intervalIsValid, /* xxx : remove later */

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Interval.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Interval_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Interval_s */ })();

/* */  /* begin of file Intervalc_s */ ( function Intervalc_s() { function Intervalc_s_naked() { ( function _l1_Intervalc_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.cinterval = _.cinterval || Object.create( null );

// --
//
// --

// --
// implementation
// --

let Extension =
{
};

//

Object.assign( _.cinterval, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Intervalc.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervalc_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervalc_s */ })();

/* */  /* begin of file Intervall_s */ ( function Intervall_s() { function Intervall_s_naked() { ( function _l1_Intervall_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.linterval = _.linterval || Object.create( null );

// --
//
// --

// --
//
// --

let Extension =
{
};

//

Object.assign( _.linterval, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Intervall.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervall_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervall_s */ })();

/* */  /* begin of file Intervalo_s */ ( function Intervalo_s() { function Intervalo_s_naked() { ( function _l1_Intervalo_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.ointerval = _.ointerval || Object.create( null );

// --
//
// --

// --
// implementation
// --

let Extension =
{
};

//

Object.assign( _.ointerval, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Intervalo.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervalo_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervalo_s */ })();

/* */  /* begin of file Introspector_s */ ( function Introspector_s() { function Introspector_s_naked() { ( function _l1_Introspector_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.introspector = _.introspector || Object.create( null );

// --
// relation
// --

let Location =
{
  original : null,
  filePath : null,
  routineName : null,
  routineAlias : null,
  internal : null,
  abstraction : null,
  line : null,
  col : null,
  filePathLineCol : null,
  routineFilePathLineCol : null,
  fileName : null,
  fileNameLineCol : null,
}

// --
// implementation
// --

/* qqq : for junior : write performance test for this
let basePath = _.path.dir( _.introspector.location({ level : 2 }).filePath )
qqq : make it super optimal
qqq : implement routine _.introspector.dirPathOf( 2 );
qqq : implement routine _.introspector.filePathOf( 2 );
dont forget about performance test and optimization
*/

function location( o )
{
  if( _.number.is( o ) )
  o = { level : o }
  else if( _.strIs( o ) )
  o = { stack : o, level : 0 }
  else if( _.error.is( o ) )
  o = { error : o, level : 0 }
  else if( o === undefined )
  o = { stack : _.introspector.stack([ 1, Infinity ]) };

  /* */

  if( location.defaults )
  for( let e in o )
  {
    if( location.defaults[ e ] === undefined )
    throw Error( 'Unknown option ' + e );
  }

  if( location.defaults )
  for( let e in location.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = location.defaults[ e ];
  }

  if( !( arguments.length === 0 || arguments.length === 1 ) )
  throw Error( 'Expects single argument or none' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  if( !o.level )
  o.level = 0;

  /* */

  if( !o.location )
  o.location = Object.create( null );

  /* */

  if( o.error )
  {
    let location2 = o.error.location || Object.create( null );

    var args0 =
    [
      location2.filePath,
      o.location.filePath,
      o.error.filename,
      o.error.fileName
    ];
    o.location.filePath = _.longLeftDefined( args0 ).element;

    var args1 =
    [
      location2.line,
      o.location.line,
      o.error.line,
      o.error.linenumber,
      o.error.lineNumber,
      o.error.lineNo,
      o.error.lineno
    ];
    o.location.line = _.longLeftDefined( args1 ).element;

    var args2 =
    [
      location2.col,
      o.location.col,
      o.error.col,
      o.error.colnumber,
      o.error.colNumber,
      o.error.colNo,
      o.error.colno
    ];
    o.location.col = _.longLeftDefined( args2 ).element;

  }

  /* */

  if( !o.stack )
  {
    if( o.error )
    {
      o.stack = _.introspector.stack( o.error, undefined );
    }
    else
    {
      o.stack = _.introspector.stack();
      o.level += 1;
    }
  }

  if( o.stack === null || o.stack === undefined )
  return o.location;

  _.assert( _.strIs( o.stack ) || _.arrayIs( o.stack ) );

  let stack = o.stack;
  if( _.strIs( stack ) )
  stack = stack.split( '\n' );
  let stackFrame = stack[ o.level ];

  return _.introspector.locationFromStackFrame({ stackFrame, location : o.location });
}

location.defaults =
{
  level : 0,
  stack : null,
  error : null,
  location : null,
}

//

function location_( o )
{

  if( _.number.is( o ) )
  o = { level : o }
  else if( _.strIs( o ) )
  o = { stack : o, level : 0 }
  else if( _.error.is( o ) )
  o = { error : o, level : 0 }
  else if( o === undefined )
  o = { stack : _.introspector.stack([ 1, Infinity ]) };

  /* */

  if( location_.defaults )
  for( let e in o )
  {
    if( location_.defaults[ e ] === undefined )
    throw Error( 'Unknown option ' + e );
  }

  if( location_.defaults )
  for( let e in location_.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = location_.defaults[ e ];
  }

  if( !( arguments.length === 0 || arguments.length === 1 ) )
  throw Error( 'Expects single argument or none' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  if( !o.level )
  o.level = 0;

  /* */

  if( !o.location )
  o.location = Object.create( null );

  /* */

  if( o.error )
  {
    let location2 = o.error.location || Object.create( null );

    var args0 =
    [
      location2.filePath,
      o.location.filePath,
      o.error.filename,
      o.error.fileName
    ];
    o.location.filePath = _.longLeftDefined( args0 ).element;

    var args1 =
    [
      location2.line,
      o.location.line,
      o.error.line,
      o.error.linenumber,
      o.error.lineNumber,
      o.error.lineNo,
      o.error.lineno
    ];
    o.location.line = _.longLeftDefined( args1 ).element;

    var args2 =
    [
      location2.col,
      o.location.col,
      o.error.col,
      o.error.colnumber,
      o.error.colNumber,
      o.error.colNo,
      o.error.colno
    ];
    o.location.col = _.longLeftDefined( args2 ).element;

  }

  /* */

  if( !o.stack )
  {
    if( o.error )
    {
      o.stack = _.introspector.stack( o.error, undefined );
    }
    else
    {
      o.stack = _.introspector.stack();
      o.level += 1;
    }
  }

  if( o.stack === null || o.stack === undefined )
  return o.location;

  _.assert( _.strIs( o.stack ) || _.arrayIs( o.stack ) );

  let stack = o.stack;
  if( _.strIs( stack ) )
  stack = stack.split( '\n' );
  let stackFrame = stack[ o.level ];

  // return _.introspector.locationFromStackFrame({ stackFrame, location : o.location });

  o.location.original = stackFrame;
  _.introspector.locationNormalize( o.location );
  return o.location;

}

location_.defaults =
{
  level : 0,
  stack : null,
  error : null,
  location : null,
}

//

function locationFromStackFrame( o )
{

  if( _.strIs( o ) )
  o = { stackFrame : o };

  if( !( arguments.length === 1 ) )
  throw Error( 'Expects single argument' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  /* */

  if( locationFromStackFrame.defaults ) /* Dmytro : maybe it is the redundant condition, the routine has defaults */
  for( let e in o )
  {
    if( locationFromStackFrame.defaults[ e ] === undefined )
    throw Error( 'Unknown option : ' + e );
  }

  if( locationFromStackFrame.defaults ) /* Dmytro : maybe it is the redundant condition, the routine has defaults */
  for( let e in locationFromStackFrame.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = locationFromStackFrame.defaults[ e ];
  }

  /* */

  if( !( _.strIs( o.stackFrame ) ) )
  throw Error( `Expects string {- stackFrame -}, but fot ${_.entity.strType( o.stackFrame )}` );

  if( o.location && !_.mapIs( o.location ) )
  throw Error( 'Expects map option::location' );

  /* */

  if( !o.location )
  o.location = Object.create( null );
  o.location.original = o.stackFrame;
  _.introspector.locationNormalize( o.location );
  return o.location;
}

locationFromStackFrame.defaults =
{
  stackFrame : null,
  location : null,
};

//

function locationNormalize( o )
{

  if( !( arguments.length === 1 ) )
  throw Error( 'Expects single argument' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  /* */

  if( locationNormalize.defaults )
  for( let e in o )
  {
    if( locationNormalize.defaults[ e ] === undefined )
    throw Error( 'Unknown option ' + e );
  }

  if( locationNormalize.defaults )
  for( let e in locationNormalize.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = locationNormalize.defaults[ e ];
  }

  /* */

  let hadPath = !!o.filePath;
  if( !o.filePath )
  o.filePath = pathFromStack();

  pathCanonize();
  routineFromStack();
  routineAliasFromStack();
  internalForm();
  abstractionForm();

  // if( !_.strIs( o.filePath ) )
  // return end();

  if( !_.number.defined( o.line ) || !_.number.defined( o.col ) )
  o.filePath = lineColFromPath( o.filePath );

  if( !_.number.is( o.line ) && hadPath )
  {
    let path = pathFromStack();
    if( path )
    lineColFromPath( path );
  }

  return end();

  /* */

  function end()
  {
    let path = o.filePath;

    /* filePathLineCol */

    o.filePathLineCol = path || '';
    if( _.number.defined( o.line ) )
    {
      o.filePathLineCol += ':' + o.line;
      if( _.number.defined( o.col ) )
      o.filePathLineCol += ':' + o.col;
    }

    /* routineFilePathLineCol */

    if( o.routineName )
    o.routineFilePathLineCol = o.routineName + ' @ ' + o.filePathLineCol;

    /* fileName */

    if( path )
    {
      let fileName = path;
      _.assert( _.routine.is( fileName.lastIndexOf ) );
      let i1 = fileName.lastIndexOf( '/' );
      let i2 = fileName.lastIndexOf( '\\' );
      let i = Math.max( i1, i2 );
      if( i !== -1 )
      fileName = fileName.substr( i+1 );
      o.fileName = fileName;
    }

    /* fileNameLineCol */

    o.fileNameLineCol = o.fileName || '';
    if( _.number.defined( o.line ) )
    {
      o.fileNameLineCol += ':' + o.line;
      if( _.number.defined( o.col ) )
      o.fileNameLineCol += ':' + o.col;
    }

    return o;
  }

  /* */

  function pathCanonize()
  {
    if( !o.filePath )
    return;

    if( _.path && _.path.canonize )
    o.filePath = _.path.canonize( o.filePath );
  }

  /* */

  function routineFromStack()
  {
    let routineName;

    if( o.routineName )
    return o.routineName;
    if( !o.original )
    return o.routineName;

    routineName = o.original;

    // if( !_.strIs( routineName ) ) // xxx /* Dmytro : deprecated comment, delete with label, please */
    // return '{-anonymous-}';
    if( !_.strIs( routineName ) ) // xxx /* Dmytro : deprecated comment, delete with label, please */
    {
      routineName = '{-anonymous-}';
    }
    else
    {
      routineName = routineName.replace( /at eval \(eval at/, '' );
      let t = /^\s*(?:at\s+)?([\w.<>]+)\s*.+/;
      let executed = t.exec( routineName );
      if( executed )
      routineName = executed[ 1 ] || '';

      routineName = routineName.replace( /<anonymous>/gm, '{-anonymous-}' );

      if( _.strEnds( routineName, '.' ) )
      routineName += '{-anonymous-}';
    }

    o.routineName = routineName;
    return o.routineName;
  }

  /* */

  function routineAliasFromStack()
  {
    let routineAlias;

    if( o.routineAlias )
    return o.routineAlias;
    if( !o.original )
    return o.routineAlias;

    routineAlias = null;

    let t = /\[as ([^\]]*)\]/;
    let executed = t.exec( o.original );
    if( executed )
    routineAlias = executed[ 1 ] || null;

    if( routineAlias )
    routineAlias = routineAlias.replace( /<anonymous>/gm, '{-anonymous-}' );

    o.routineAlias = routineAlias;
    return o.routineAlias;
  }

  /* */

  function internalForm()
  {

    if( _.number.defined( o.internal ) )
    return;

    o.internal = 0;

    if( o.filePath )
    {
      if( o.internal < 2 )
      if( _.strBegins( o.filePath, 'internal/' ) )
      o.internal = 2;

      if( o.internal < 2 )
      if( _.strBegins( o.filePath, 'node:internal/' ) )
      o.internal = 2;

    }

  }

  /* */

  function abstractionForm()
  {

    if( _.number.defined( o.abstraction ) )
    return;

    o.abstraction = 0;

    if( o.routineName )
    {
      if( o.abstraction < 2 )
      if( _.strBegins( o.routineName, '__' ) || o.routineName.indexOf( '.__' ) !== -1 )
      o.abstraction = 2;
      if( o.abstraction < 1 )
      if( _.strBegins( o.routineName, '_' ) || o.routineName.indexOf( '._' ) !== -1 )
      o.abstraction = 1;
    }

    if( o.routineAlias )
    {
      if( o.abstraction < 2 )
      if( _.strBegins( o.routineAlias, '__' ) || o.routineAlias.indexOf( '.__' ) !== -1 )
      o.abstraction = 2;
      if( o.abstraction < 1 )
      if( _.strBegins( o.routineAlias, '_' ) || o.routineAlias.indexOf( '._' ) !== -1 )
      o.abstraction = 1;
    }

  }

  /* */

  function pathFromStack()
  {
    let path = o.original;

    if( !_.strIs( path ) )
    return;

    path = path.replace( /^\s+/, '' );
    path = path.replace( /^\w+@/, '' );
    path = path.replace( /^at/, '' );
    path = path.replace( /^\s+/, '' );
    path = path.replace( /\s+$/, '' );

    let regexp = /^.*\(([^)]*)\).*$/;
    var parsed = regexp.exec( path );
    if( parsed )
    path = parsed[ 1 ];

    return path;
  }

  /* line / col number from path */

  function lineColFromPath( path )
  {
    if( !path )
    {
      if( o.line )
      o.line = numberFromToInt( o.line );
      if( o.col )
      o.col = numberFromToInt( o.col )
    }
    else
    {
      let lineNumber, colNumber;
      let postfix = /(.+?):(\d+)(?::(\d+))?[^:/]*$/;
      let parsed = postfix.exec( path );

      if( parsed )
      {
        path = parsed[ 1 ];
        lineNumber = parsed[ 2 ];
        colNumber = parsed[ 3 ];
      }

      lineNumber = numberFromToInt( lineNumber );
      colNumber = numberFromToInt( colNumber );

      if( !_.number.defined( o.line ) )
      if( _.number.defined( lineNumber ) )
      o.line = lineNumber;

      if( !_.number.defined( o.col ) )
      if( _.number.defined( colNumber ) )
      o.col = colNumber;
    }

    if( !_.number.defined( o.line ) )
    o.line = null;
    if( !_.number.defined( o.col ) )
    o.col = null;

    return path;
  }

  /* */

  function numberFromToInt( src )
  {
    if( _.strIs( src ) )
    src = parseInt( src );
    else
    src = Math.floor( Number( src ) );

    return src;
  }

}

locationNormalize.defaults =
{
  ... Location,
}

//

function locationToStack( o )
{
  if( !( arguments.length === 1 ) )
  throw Error( 'Expects single argument' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects options map' );

  /* */

  // _.map.assertHasOnly( o, locationToStack.defaults );
  if( Config.debug )
  {
    let extraKeys = mapButKeys( o, locationToStack.defaults );
    _.assert( extraKeys.length === 0, () => `Routine "locationToStack" does not expect options: ${ keysQuote( extraKeys ) }` );
  }

  _.introspector.locationNormalize( o );

  if( !o.filePathLineCol )
  return null;

  // if( o.routineFilePathLineCol )
  // {
  //   _.assert( 0, 'not tested' );
  // }

  if( o.routineName )
  return `at ${o.routineName} (${o.filePathLineCol})`;
  else
  return `at (${o.filePathLineCol})`;

  /*
    at Object.locationToStack (http://127.0.0.1:5000//builder/include/wtools/abase/l0/l3/Introspector.s:723:10)
  */

  /* */

  function mapButKeys( srcMap, butMap )
  {
    let result = [];

    for( let s in srcMap )
    if( !( s in butMap ) )
    result.push( s );

    return result;
  }

  /* */

  function keysQuote( keys )
  {
    let result = `"${ keys[ 0 ] }"`;
    for( let i = 1 ; i < keys.length ; i++ )
    result += `, "${ keys[ i ] }"`;
    return result.trim();
  }
}

locationToStack.defaults =
{
  ... Location,
}

//

/**
 * Routine stack() returns stack trace from provided argument {-stack-} as a string. If {-stack-} is not provided,
 * then routine returns stack trace at a current position of code.
 *
 * @param { String|Array|Unroll|Error } stack - A stack to trace. If {-stack-} is not provided, then routine generates
 * stack trace at a current code position.
 * @param { Range } range - A range of lines selected from stack trace. If {-range-} is undefined, then routine returns
 * full stack trace. If range[ 0 ] < 0, then routine counts lines from the end of stack trace. If stack[ 1 ] < 0, then
 * routine counts end line from the end of stack trace.
 *
 * @example
 * let stack;
 * function function1()
 * {
 *   function2();
 * }
 *
 * function function2()
 * {
 *   function3();
 * }
 *
 * function function3()
 * {
 *   stack = _.introspector.stack();
 * }
 *
 * function1();
 * console.log( stack );
 * // log
 * //"  at function3 (<anonymous>:10:17)
 * //   at function2 (<anonymous>:6:2)
 * //   at function1 (<anonymous>:2:2)
 * //   at <anonymous>:1:1"
 *
 * @example
 * let stack;
 * function function1()
 * {
 *   function2();
 * }
 *
 * function function2()
 * {
 *   function3();
 * }
 *
 * function function3()
 * {
 *   stack = _.introspector.stack( [ 0, 1 ] );
 * }
 *
 * function1();
 * console.log( stack );
 * // log
 * //"  at function3 (<anonymous>:10:17)
 *
 * @returns { String } - Return stack trace from call point.
 * @function stack
 * @throws { Error } If arguments.length is more than two.
 * @throws { Error } If {-range-} is not a Range.
 * @namespace Tools
 * @module Tools/base/Fundamental
 */

function stack( stack, range )
{

  if( arguments.length === 1 )
  {
    if( !_.error.is( stack ) )
    if( !_.strIs( stack ) )
    {
      range = arguments[ 0 ];
      stack = undefined;
    }
  }

  if( stack === undefined || stack === null )
  {
    stack = new Error();
    if( range === undefined )
    {
      range = [ 1, Infinity ];
    }
    else
    {
      if( _.number.is( range[ 0 ] ) ) /* Dmytro : previous implementation affects range - not a number value + number => NaN, so assertion does not word properly */
      range[ 0 ] += 1;
      if( _.number.is( range[ 1 ] ) && range[ 1 ] >= 0 )
      range[ 1 ] += 1;
    }
  }

  if( range === undefined )
  range = [ 0, Infinity ];

  if( arguments.length !== 0 && arguments.length !== 1 && arguments.length !== 2 )
  {
    debugger;
    throw Error( 'stack : expects one or two or none arguments' );
  }

  if( !_.intervalIs( range ) )
  {
    debugger;
    throw Error( 'stack : expects range but, got ' + _.entity.strType( range ) );
  }

  let first = range[ 0 ];
  let last = range[ 1 ];

  // if( !_.number.is( first ) ) // Dmytro : it's unnecessary assertions, _.intervalIs checks number value in passed array
  // {
  //   debugger;
  //   throw Error( 'stack : expects number range[ 0 ], but got ' + _.entity.strType( first ) );
  // }
  //
  // if( !_.number.is( last ) )
  // {
  //   debugger;
  //   throw Error( 'stack : expects number range[ 0 ], but got ' + _.entity.strType( last ) );
  // }

  let errIs = 0;
  if( _.error.is( stack ) )
  {
    stack = _.error.originalStack( stack );
    errIs = 1;
  }

  if( !stack )
  return '';

  if( !_.arrayIs( stack ) && !_.strIs( stack ) )
  return;

  // if( !_.arrayIs( stack ) && !_.strIs( stack ) ) // Dmytro : previous condition is almost identical
  // {
  //   debugger;
  //   throw Error( 'stack expects array or string' );
  // }

  if( !_.arrayIs( stack ) )
  stack = stack.split( '\n' );

  // debugger;

  /* remove redundant lines */

  while( stack.length )
  {
    let splice = 0;
    splice |= ( _.strHas( stack[ 0 ], /(^| )at / ) === false && stack[ 0 ].indexOf( '@' ) === -1 );
    splice |= stack[ 0 ].indexOf( '(vm.js:' ) !== -1;
    splice |= stack[ 0 ].indexOf( '(module.js:' ) !== -1;
    splice |= stack[ 0 ].indexOf( '(internal/module.js:' ) !== -1;
    if( splice )
    stack.splice( 0, 1 );
    else break;
  }

  if( stack[ 0 ] )
  if( stack[ 0 ].indexOf( 'at ' ) === -1 && stack[ 0 ].indexOf( '@' ) === -1 ) // Dmytro : it's dubious - while loop removes all strings if stack[ 0 ] has not 'at ' or '@'
  {
    console.error( 'stack : failed to parse stack' );
    debugger;
  }

  stack = stack.map( ( line ) => line.trim() );
  stack = stack.filter( ( line ) => line );

  /* */

  first = first === undefined ? 0 : first;
  last = last === undefined ? stack.length : last;

  // if( _.number.is( first ) ) // Dmytro : first and last - is always some numbers, see above about assertions
  if( first < 0 )
  first = stack.length + first;

  // if( _.number.is( last ) )
  if( last < 0 )
  last = stack.length + last + 1;

  /* */

  if( first !== 0 || last !== stack.length )
  {
    stack = stack.slice( first || 0, last );
  }

  /* */

  stack = String( stack.join( '\n' ) );

  return stack;
}

//

function stackRelative( stack, delta )
{
  _.assert( delta === undefined || _.number.is( delta ) );
  _.assert( stack === undefined || stack === null || _.bool.is( stack ) || _.number.is( stack ) || _.strIs( stack ) );
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );

  if( _.strIs( stack ) )
  return stack;
  if( stack === false )
  return '';

  if( stack === undefined || stack === null || stack === true )
  stack = 1;
  else if( _.number.is( stack ) )
  stack += 1;

  if( delta )
  stack += delta;
  if( _.number.is( stack ) )
  stack = _.introspector.stack([ stack, Infinity ]);

  _.assert( _.strIs( stack ) );

  return stack;
}

//

function stackRemoveLeft( stack, include, exclude )
{
  if( arguments.length !== 3 )
  throw Error( 'Expects three arguments' );
  if( !_.regexpIs( include ) && include !== null )
  throw Error( 'Expects regexp either null as the second argument' );
  if( !_.regexpIs( exclude ) && exclude !== null )
  throw Error( 'Expects regexp either null as the third argument' );

  if( !_.strIs( stack ) )
  return stack;

  stack = stack.split( '\n' );

  for( let s = stack.length-1 ; s >= 0 ; s-- )
  {
    let line = stack[ s ];
    if( include && include.test( line ) )
    {
      stack.splice( s, 1 );
      continue;
    }
    if( exclude && exclude.test( line ) )
    {
      stack.splice( s, 1 );
      continue;
    }
  }

  return stack.join( '\n' );
}

//

function stackCondense( stack )
{

  if( arguments.length !== 1 )
  throw Error( 'Expects single arguments' );

  if( !_.strIs( stack ) )
  {
    debugger;
    throw Error( 'Expects string' );
  }

  stack = stack.split( '\n' );

  for( let s = stack.length-1 ; s >= 0 ; s-- )
  {
    let line = stack[ s ];
    if( s > 0 )
    if( /(\W|^)__\w+/.test( line ) )
    {
      stack.splice( s, 1 );
      continue;
    }
    if( _.strHas( line, '.test.' ) )
    line += ' *';
    stack[ s ] = line;
  }

  return stack.join( '\n' );
}

//

function stackFilter( stack, onEach )
{
  let result = [];

  if( _.routine.is( stack ) )
  {
    onEach = stack;
    stack = undefined;
  }

  if( !_.strIs( stack ) )
  stack = _.introspector.stack( stack, undefined ); // Dmytro : missed second argument, which has influence on the result

  _.assert( _.strIs( stack ) );
  _.assert( _.routine.is( onEach ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  stack = stack.split( '\n' );

  stack.forEach( ( stackFrame, k ) =>
  {
    let location = _.introspector.locationFromStackFrame( stackFrame );
    let r = onEach( location, k );
    if( r === undefined )
    return;
    if( _.strIs( r ) )
    {
      result.push( r );
      return;
    }
    _.assert( _.object.isBasic( r ) );
    _.assert( _.strIs( r.original ) );
    result.push( r.original );
  });

  return result.join( '\n' );
}

//

function code()
{
  return undefined;
}

// --
//
// --

let Extnesion =
{

  Location,

  location,
  location_,
  locationFromStackFrame,
  locationNormalize, /* aaa for Dmytro : write good test */ /* Dmytro : covered */
  locationToStack,

  stack,
  stackRelative,
  stackRemoveLeft,
  stackCondense,
  stackFilter,

  code,

}

//

Object.assign( _.introspector, Extnesion );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Introspector.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Introspector_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Introspector_s */ })();

/* */  /* begin of file Itself_s */ ( function Itself_s() { function Itself_s_naked() { ( function _l1_Itself_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.itself = _.itself || Object.create( null );

_.assert( !!_.blank.make, 'Expects routine _.blank.make' );

// --
// implementation
// --

function is( src )
{
  return true;
}

//

function like( src )
{
  return true;
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return false;
}

// --
// extension
// --

let ToolsExtension =
{

  // dichotomy

  itselfIs : is.bind( _.itself ),
  itselfLike : like.bind( _.itself ),

}

Object.assign( _, ToolsExtension );

//

let ItselfExtension =
{

  // fields

  NamespaceName : 'itself',
  NamespaceNames : [ 'itself' ],
  NamespaceQname : 'wTools/itself',
  MoreGeneralNamespaceName : 'itself',
  MostGeneralNamespaceName : 'itself',
  TypeName : 'Itself',
  TypeNames : [ 'Itself' ],
  // SecondTypeName : 'Itself',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is,
  like,
  IsResizable,

  // maker

  _makeEmpty : _.blank._makeEmpty,
  makeEmpty : _.blank.makeEmpty, /* qqq : for junior : cover */
  _makeUndefined : _.blank._makeUndefined,
  makeUndefined : _.blank.makeUndefined, /* qqq : for junior : cover */
  _make : _.blank._make,
  make : _.blank.make, /* qqq : for junior : cover */
  _cloneShallow : _.blank._cloneShallow,
  cloneShallow : _.blank.cloneShallow, /* qqq : for junior : cover */
  from : _.blank.from, /* qqq : for junior : cover */

  // meta

  namespaceOf : _.blank.namespaceOf,
  namespaceWithDefaultOf : _.blank.namespaceWithDefaultOf,
  _functor_functor : _.blank._functor_functor,

}

Object.assign( _.itself, ItselfExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Itself.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Itself_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Itself_s */ })();

/* */  /* begin of file Logger_s */ ( function Logger_s() { function Logger_s_naked() { ( function _l1_Logger_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.logger = _.logger || Object.create( null );

// --
// implementation
// --

function consoleIs( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( console.Console )
  if( src && src instanceof console.Console )
  return true;

  if( src !== console )
  return false;

  let result = Object.prototype.toString.call( src );
  if( result === '[object Console]' || result === '[object Object]' )
  return true;

  return false;
}

//

function is( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( !_.Logger )
  return false;

  if( src instanceof _.Logger )
  return true;

  return false;
}

//

function like( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.printer.is( src ) )
  return true;

  if( _.consoleIs( src ) )
  return true;

  if( src === _global_.logger )
  return true;

  return false;
}

//

function fromStrictly( src )
{
  let result = src;

  _.assert( result === null || _.boolIs( result ) || _.numberIs( result ) || _.logger.is( result ) );

  if( result === null )
  {
    result = new _.Logger({ output : _global_.logger, verbosity : 1 });
  }
  else if( _.boolIs( result ) )
  {
    result = new _.Logger({ output : _global_.logger, verbosity : result ? 1 : 0 });
  }
  else if( _.numberIs( result ) )
  {
    result = new _.Logger({ output : _global_.logger, verbosity : result });
  }
  else if( _.logger.is( result ) )
  {
  }
  else _.assert( 0 );

  return result;
}

//

function maybe( src )
{
  let result = src;

  _.assert( result === null || _.boolIs( result ) || _.numberIs( result ) || _.logger.like( result ) );

  if( result === null )
  {
    result = new _.Logger({ output : _global_.logger, verbosity : 1 });
  }
  else if( _.boolIs( result ) )
  {
    if( result )
    result = new _.Logger({ output : _global_.logger, verbosity : 1 });
    else
    result = 0;
  }
  else if( _.numberIs( result ) )
  {
    if( result > 0 )
    result = new _.Logger({ output : _global_.logger, verbosity : result });
    else
    result = 0;
  }
  else if( _.logger.like( result ) )
  {
  }
  else _.assert( 0 );

  return result;
}

//

function relativeMaybe( src, delta )
{
  let result = src;

  _.assert( result === null || _.boolIs( result ) || _.numberIs( result ) || _.logger.is( result ) );
  _.assert( delta === undefined || _.numberDefined( delta ) || _.logger.like( delta ) );

  if( _.logger.like( delta ) )
  return delta;

  delta = delta || 0;

  if( result === null )
  {
    result = new _.Logger({ output : _global_.logger, verbosity : 1 + delta });
  }
  else if( _.boolIs( result ) )
  {
    if( result )
    result = new _.Logger({ output : _global_.logger, verbosity : 1 + delta });
    else if( delta > 0 )
    result = new _.Logger({ output : _global_.logger, verbosity : delta });
    else
    result = 0;
  }
  else if( _.numberIs( result ) )
  {
    result += delta;
    if( result > 0 )
    result = new _.Logger({ output : _global_.logger, verbosity : result });
    else
    result = 0;
  }
  else if( _.logger.is( result ) )
  {
    if( delta !== 0 )
    result = new _.Logger({ output : result, verbosity : result.verbosity + delta });
  }
  else _.assert( 0 );

  return result;
}

//

function absoluteMaybe( src, verbosity )
{
  let result = src;

  _.assert( result === null || _.boolIs( result ) || _.numberIs( result ) || _.logger.is( result ) );
  _.assert( verbosity === undefined || verbosity === null || _.boolIs( verbosity ) || _.numberDefined( verbosity ) || _.logger.like( verbosity ) );

  if( _.logger.like( verbosity ) )
  return verbosity;

  if( verbosity !== null && verbosity !== undefined )
  {
    if( verbosity === 0 || verbosity === false )
    {
      if( _.logger.is( src ) )
      {
        src.verbosity = 0;
        return src;
      }
      return 0;
    }
    _.assert( _.numberIs( verbosity ) || _.boolIs( verbosity ) );
  }

  if( result === null )
  {
    result = new _.Logger({ output : _global_.logger, verbosity : verbosityGet() });
  }
  else if( _.boolIs( result ) )
  {
    result = new _.Logger({ output : _global_.logger, verbosity : verbosityGet() });
  }
  else if( _.numberIs( result ) )
  {
    result = new _.Logger({ output : _global_.logger, verbosity : verbosityGet() });
  }
  else if( _.logger.is( result ) )
  {
    if( _.numberIs( verbosity ) )
    result.verbosity = verbosity;
  }
  else _.assert( 0 );

  return result;

  function verbosityGet()
  {
    if( verbosity === undefined || verbosity === null || verbosity === true )
    return 1;
    if( verbosity === false )
    return 0;
    _.assert( _.numberIs( verbosity ) );
    return verbosity;
  }

}

//

function verbosityFrom( src )
{
  let result = src;

  _.assert( _.boolIs( result ) || _.numberIs( result ) );
  _.assert( arguments.length === 1 );

  if( _.boolIs( result ) )
  {
    result = result ? 1 : 0;
  }

  return result;
}

//

function verbosityRelative( src, delta )
{
  let result = src;

  _.assert( _.boolIs( result ) || _.numberIs( result ) );
  _.assert( delta === undefined || _.numberDefined( delta ) );

  delta = delta || 0;

  if( _.boolIs( result ) )
  {
    if( result )
    result = 1 + delta;
    else
    result = delta;
  }
  else if( _.numberIs( result ) )
  {
    result += delta;
  }

  return result;
}

// --
// tools extension
// --

let ToolsExtension =
{
  consoleIs,
  loggerIs : is,
  loggerLike : like,
}

//

Object.assign( _, ToolsExtension );

// --
// logger extension
// --

let LoggerExtension =
{
  is,
  like,
  fromStrictly, /* qqq : cover */
  maybe, /* qqq : cover */
  relativeMaybe, /* qqq : cover */
  absoluteMaybe, /* qqq : cover */
  verbosityFrom, /* qqq : cover */
  verbosityRelative, /* qqq : cover */
}

//

Object.assign( _.logger, LoggerExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Logger.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Logger_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Logger_s */ })();

/* */  /* begin of file Logic_s */ ( function Logic_s() { function Logic_s_naked() { ( function _l1_Logic_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.logic = _.logic || Object.create( null );

// --
// logic
// --

function is( src )
{
  if( src === true || src === false || src === _.maybe )
  return true;
  if( !src )
  return false;
  if( src instanceof _.logic.node.Abstract )
  return true;
  return false;
}

//

function like( src )
{
  return this.is( src );
}

//

function isNode( src )
{
  if( src instanceof _.logic.node.Abstract )
  return true;
  return false;
}

// --
// extension
// --

let LogicExtension =
{

  is,
  like,
  isNode

}

Object.assign( _.logic, LogicExtension );

//

let ToolsExtension =
{

  logicIs : is.bind( _.logic ),
  logicLike : like.bind( _.logic ),
  logicIsNode : isNode.bind( _.logic ),

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Logic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Logic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Logic_s */ })();

/* */  /* begin of file LogicNode_s */ ( function LogicNode_s() { function LogicNode_s_naked() { ( function _l1_LogicNode_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.logic = _.logic || Object.create( null );
_.logic.node = _.logic.node || Object.create( null );

// --
// implement
// --

// --
// declare
// --

var Extension =
{
}

Object.assign( _.logic.node, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/LogicNode.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, LogicNode_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file LogicNode_s */ })();

/* */  /* begin of file Map_s */ ( function Map_s() { function Map_s_naked() { ( function _l1_Map_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.map = _.map || Object.create( null );

_.assert( !!_.props.extend, 'Expects routine _.props.exportString' );

// --
// dichotomy
// --

/**
 * The is() routine determines whether the passed value is an Object,
 * and not inherits through the prototype chain.
 *
 * If the {-srcMap-} is an Object, true is returned,
 * otherwise false is.
 *
 * @param { * } src - Entity to check.
 *
 * @example
 * _.map.is( { a : 7, b : 13 } );
 * // returns true
 *
 * @example
 * _.map.is( 13 );
 * // returns false
 *
 * @example
 * _.map.is( [ 3, 7, 13 ] );
 * // returns false
 *
 * @returns { Boolean } Returns true if {-srcMap-} is an Object, and not inherits through the prototype chain.
 * @function is
 * @namespace Tools/map
 */

function is( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return true;

  if( proto === Object.prototype )
  {
    if( src[ Symbol.iterator ] )
    return Object.prototype.toString.call( src ) !== '[object Arguments]';
    return true;
  }

  return false;
}

//

function isPure( src )
{
  if( !src )
  return false;

  if( Object.getPrototypeOf( src ) === null )
  return true;

  return false;
}

//

function isPolluted( src )
{

  if( !src )
  return false;

  let proto = Object.getPrototypeOf( src );

  if( proto === null )
  return false;

  if( proto === Object.prototype )
  {
    if( src[ Symbol.iterator ] )
    return Object.prototype.toString.call( src ) !== '[object Arguments]';
    return true;
  }

  return false;
}

// function is( src )
// {
//
//   if( !src )
//   return false;
//
//   if( src[ Symbol.iterator ] )
//   return false;
//
//   let proto = Object.getPrototypeOf( src );
//
//   if( proto === null )
//   return true;
//
//   if( proto === Object.prototype )
//   return true;
//
//   return false;
// }
//
// //
//
// function isPure( src )
// {
//   if( !src )
//   return false;
//
//   if( src[ Symbol.iterator ] )
//   return false;
//
//   if( Object.getPrototypeOf( src ) === null )
//   return true;
//
//   return false;
// }
//
// //
//
// function isPolluted( src )
// {
//
//   if( !src )
//   return false;
//
//   if( src[ Symbol.iterator ] )
//   return false;
//
//   let proto = Object.getPrototypeOf( src );
//
//   if( proto === null )
//   return false;
//
//   if( proto === Object.prototype )
//   return true;
//
//   return false;
// }

//

function like( src )
{
  return _.map.is( src );
}

//

function isEmpty( src )
{
  if( !this.like( src ) )
  return false;
  return this.keys( src ).length === 0;
}

//

function isPopulated( src )
{
  if( !this.like( src ) )
  return false;
  return this.keys( src ).length > 0;
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return true;
}

// --
// maker
// --

function _makeEmpty( src )
{
  return Object.create( null );
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  _.assert( this.like( src ) );
  return this._makeEmpty( src );
}

//

function _makeUndefined( src )
{
  return Object.create( null );
}

//

function makeUndefined( src, length )
{
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 2 )
  {
    _.assert( this.like( src ) );
    _.assert( _.number.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( _.number.is( src ) || this.like( src ) );
  }

  return this._makeUndefined( src );
}

//

function _make( src )
{
  let dst = Object.create( null );
  if( src )
  this.extendUniversal( dst, src );
  // if( src )
  // Object.assign( dst, src );
  return dst;
}

//

function make( src, length )
{
  _.assert( arguments.length === 0 || src === null || !_.primitive.is( src ) );
  _.assert( length === undefined || length === 0 );
  _.assert( arguments.length <= 2 );
  return this._make( ... arguments );
}

//

function _cloneShallow( src )
{
  let dst = Object.create( null );
  Object.assign( dst, src );
  return dst;
}

// --
// properties
// --

function _keys( o )
{
  let result = [];

  _.routine.options( _keys, o );

  let srcMap = o.srcMap;
  let selectFilter = o.selectFilter;

  _.assert( this === _.map );
  _.assert( arguments.length === 1, 'Expects single argument' );
  // _.assert( !( srcMap instanceof Map ), 'not implemented' );
  _.assert( selectFilter === null || _.routine.is( selectFilter ) );
  _.assert( this.is( srcMap ) );

  /* */

  if( o.onlyEnumerable )
  {
    let result1 = [];

    // _.assert( !_.primitive.is( srcMap ) );

    if( o.onlyOwn )
    {
      for( let k in srcMap )
      if( Object.hasOwnProperty.call( srcMap, k ) )
      result1.push( k );
    }
    else
    {
      for( let k in srcMap )
      result1.push( k );
    }

    filter( srcMap, result1 );

  }
  else
  {
    // _.assert( !( srcMap instanceof Map ), 'not implemented' );

    if( o.onlyOwn  )
    {
      filter( srcMap, Object.getOwnPropertyNames( srcMap ) );
    }
    else
    {
      let proto = srcMap;
      result = [];
      do
      {
        filter( proto, Object.getOwnPropertyNames( proto ) );
        proto = Object.getPrototypeOf( proto );
      }
      while( proto );
      /* qqq : for junior : map cant have prototype. rewrite */
    }

  }

  return result;

  /* */

  function filter( srcMap, keys )
  {

    if( !selectFilter )
    {
      /* qqq : for junior : rewrite without arrayAppend and without duplicating array */
      arrayAppendArrayOnce( result, keys );
    }
    else for( let k = 0 ; k < keys.length ; k++ )
    {
      let e = selectFilter( srcMap, keys[ k ] );
      if( e !== undefined )
      arrayAppendOnce( result, e );
      /* qqq : for junior : rewrite without arrayAppend and without duplicating array */
    }

  }

  /* */

  function arrayAppendOnce( dst, element )
  {
    let i = dst.indexOf( element );
    if( i === -1 )
    dst.push( element );
    return dst;
  }

  /* */

  function arrayAppendArrayOnce( dst, src )
  {
    src.forEach( ( element ) =>
    {
      let i = dst.indexOf( element );
      if( i === -1 )
      dst.push( element );
    });
    return dst;
  }

}

_keys.defaults =
{
  srcMap : null,
  onlyOwn : 0,
  onlyEnumerable : 1,
  selectFilter : null,
}

//

/**
 * This routine returns an array of a given objects onlyEnumerable properties,
 * in the same order as that provided by a for...in loop.
 * Accept single object. Each element of result array is unique.
 * Unlike standard [Object.keys]{@https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/keys}
 * which accept object only props.keys accept any object-like entity.
 *
 * @see {@link wTools.props.onlyOwnKeys} - Similar routine taking into account own elements only.
 * @see {@link wTools.props.vals} - Similar routine returning values.
 *
 * @example
 * _.props.keys({ a : 7, b : 13 });
 * // returns [ "a", "b" ]
 *
 * @example
 * let o = { onlyOwn : 1, onlyEnumerable : 0 };
 * _.props.keys.call( o, { a : 1 } );
 * // returns [ "a" ]
 *
 * @param { objectLike } srcMap - object of interest to extract keys.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s own properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 * @return { array } Returns an array with unique string elements.
 * corresponding to the onlyEnumerable properties found directly upon object or empty array
 * if nothing found.
 * @function keys
 * @throws { Exception } Throw an exception if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/map
 */

function keys( srcMap, o )
{
  let result;

  _.assert( this === _.map );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( keys, o || null );
  _.assert( this.is( srcMap ) );

  o.srcMap = srcMap;

  result = this._keys( o );

  return result;
}

keys.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The props.allKeys() returns all properties of provided object as array,
 * in the same order as that provided by a for...in loop. Each element of result array is unique.
 *
 * @param { objectLike } srcMap - The object whose properties keys are to be returned.
 *
 * @example
 * let x = { a : 1 };
 * let y = { b : 2 };
 * Object.setPrototypeOf( x, y );
 * _.props.allKeys( x );
 * // returns [ "a", "b", "__defineGetter__", ... "isPrototypeOf" ]
 *
 * @return { array } Returns an array whose elements are strings
 * corresponding to the all properties found on the object.
 * @function allKeys
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @namespace Tools/map
*/

function allKeys( srcMap, o )
{

  _.assert( this === _.map );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( allKeys, o || null );
  _.assert( this.is( srcMap ) );

  o.srcMap = srcMap;
  // o.onlyOwn = 0;
  // o.onlyEnumerable = 0;

  let result = this._keys( o );

  return result;
}

/* qqq : write test routine for each option */
/* qqq : do the same for similar routines */
/* qqq : adjust similar routine if they handle options no like routine allKeys */
allKeys.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 0,
}

//

function _vals( o )
{

  _.routine.options( _vals, o );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( o.selectFilter === null || _.routine.is( o.selectFilter ) );
  _.assert( o.selectFilter === null );
  _.assert( this === _.map );

  let result = this._keys( o );

  for( let k = 0 ; k < result.length ; k++ )
  {
    result[ k ] = o.srcMap[ result[ k ] ];
  }

  return result;
}

_vals.defaults =
{
  srcMap : null,
  onlyOwn : 0,
  onlyEnumerable : 1,
  selectFilter : null,
}

//

/**
 * The props.vals() routine returns an array of a given object's
 * onlyEnumerable property values, in the same order as that provided by a for...in loop.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns an array of values,
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - The object whose property values are to be returned.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s own properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.props.vals( { a : 7, b : 13 } );
 * // returns [ "7", "13" ]
 *
 * @example
 * let o = { onlyOwn : 1 };
 * let a = { a : 7 };
 * let b = { b : 13 };
 * Object.setPrototypeOf( a, b );
 * _.props.vals.call( o, a )
 * // returns [ 7 ]
 *
 * @returns { array } Returns an array whose elements are strings.
 * corresponding to the onlyEnumerable property values found directly upon object.
 * @function vals
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/map
 */

function vals( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( vals, o || null );
  _.assert( this.is( srcMap ) );
  _.assert( this === _.map );

  o.srcMap = srcMap;

  let result = this._vals( o );

  return result;
}

vals.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The props.allVals() returns values of all properties of provided object as array,
 * in the same order as that provided by a for...in loop.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns an array of values,
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - The object whose property values are to be returned.
 *
 * @example
 * _.props.allVals( { a : 7, b : 13 } );
 * // returns [ "7", "13", function __defineGetter__(), ... function prototype.isPrototypeFor() ]
 *
 * @returns { array } Returns an array whose elements are strings.
 * corresponding to the onlyEnumerable property values found directly upon object.
 * @function allVals
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @namespace Tools/map
 */

function allVals( srcMap, o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( allVals, o || null );
  _.assert( this.is( srcMap ) );
  _.assert( this === _.map );

  o.srcMap = srcMap;
  o.onlyOwn = 0;
  o.onlyEnumerable = 0;

  let result = this._vals( o );

  debugger;
  return result;
}

allVals.defaults =
{
}

//

function _pairs( o )
{

  _.routine.options( _pairs, o );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( o.selectFilter === null || _.routine.is( o.selectFilter ) );
  _.assert( this.like( o.srcMap ) );
  _.assert( this === _.map );

  let selectFilter = o.selectFilter;

  if( o.selectFilter )
  debugger;

  if( !o.selectFilter )
  o.selectFilter = function selectFilter( srcMap, k )
  {
    return [ k, srcMap[ k ] ];
  }

  let result = this._keys( o );

  return result;
}

_pairs.defaults =
{
  srcMap : null,
  onlyOwn : 0,
  onlyEnumerable : 1,
  selectFilter : null,
}

//

/**
 * The map.pairs() converts an object into a list of unique [ key, value ] pairs.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns a list of [ key, value ] pairs if they exist,
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - Object to get a list of [ key, value ] pairs.
 * @param { objectLike } o - routine options can be provided through routine`s context.
 * @param { boolean } [ o.onlyOwn = false ] - count only object`s own properties.
 * @param { boolean } [ o.onlyEnumerable = true ] - count only object`s onlyEnumerable properties.
 *
 * @example
 * _.map.pairs( { a : 7, b : 13 } );
 * // returns [ [ "a", 7 ], [ "b", 13 ] ]
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.map.pairs.call( { onlyOwn : 1 }, a );
 * // returns [ [ "a", 1 ] ]
 *
 * @returns { array } A list of [ key, value ] pairs.
 * @function pairs
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @throws { Error } Will throw an Error if unknown option is provided.
 * @namespace Tools/map
 */

function pairs( srcMap, o )
{

  _.assert( this === _.map );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( pairs, o || null );

  o.srcMap = srcMap;

  let result = this._pairs( o );

  return result;
}

pairs.defaults =
{
  onlyOwn : 0,
  onlyEnumerable : 1,
}

//

/**
 * The props.allPairs() converts all properties of the object {-srcMap-} into a list of unique [ key, value ] pairs.
 *
 * It takes an object {-srcMap-} creates an empty array,
 * checks if {-srcMap-} is an object.
 * If true, it returns a list of [ key, value ] pairs that repesents all properties of provided object{-srcMap-},
 * otherwise it returns an empty array.
 *
 * @param { objectLike } srcMap - Object to get a list of [ key, value ] pairs.
 *
 * @example
 * _.props.allPairs( { a : 7, b : 13 } );
 * // returns [ [ "a", 7 ], [ "b", 13 ], ... [ "isPrototypeOf", function prototype.isPrototypeFor() ] ]
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * Object.setPrototypeOf( a, b );
 * _.props.allPairs( a );
 * // returns [ [ "a", 1 ], [ "b", 2 ], ... [ "isPrototypeOf", function prototype.isPrototypeFor() ]  ]
 *
 * @returns { array } A list of [ key, value ] pairs.
 * @function allPairs
 * @throws { Error } Will throw an Error if {-srcMap-} is not an objectLike entity.
 * @namespace Tools/map
 */

function allPairs( srcMap, o )
{

  _.assert( this === _.map );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  o = _.routine.options( allPairs, o || null );

  o.srcMap = srcMap;
  o.onlyOwn = 0;
  o.onlyEnumerable = 0;

  let result = this._pairs( o );

  debugger;
  return result;
}

allPairs.defaults =
{
}

// --
// meta
// --

/* qqq : optimize */
function namespaceOf( src )
{

  if( _.map.is( src ) )
  return _.map;

  return null;
}

// --
// extension
// --

/* qqq : for junior : duplicate routines */

let ToolsExtension =
{

  // dichotomy

  mapIs : is.bind( _.map ),
  mapIsPure : isPure.bind( _.map ),
  mapIsPolluted : isPolluted.bind( _.map ),
  mapIsEmpty : isEmpty.bind( _.map ),
  mapIsPopulated : isPopulated.bind( _.map ),
  mapLike : like.bind( _.map ),

  // maker

  mapMakeEmpty : makeEmpty.bind( _.map ),
  mapMakeUndefined : makeUndefined.bind( _.map ),
  mapMake : make.bind( _.map ),
  mapCloneShallow : _.props.cloneShallow.bind( _.map ),
  mapFrom : _.props.from.bind( _.map ),

  // amender

  mapExtend : _.props.extend.bind( _.map ),
  mapSupplement : _.props.supplement.bind( _.map ),

}

Object.assign( _, ToolsExtension );

//

let ExtensionMap =
{

  //

  NamespaceName : 'map',
  NamespaceNames : [ 'map' ],
  NamespaceQname : 'wTools/map',
  MoreGeneralNamespaceName : 'aux',
  MostGeneralNamespaceName : 'props',
  TypeName : 'Map',
  TypeNames : [ 'Map' ],
  // SecondTypeName : 'Map',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is,
  isPure,
  isPolluted,
  like,

  isEmpty, /* qqq : cover */
  isPopulated, /* qqq : cover */
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow : _.props.cloneShallow, /* qqq : for junior : cover */
  from : _.props.from, /* qqq : for junior : cover */

  // properties

  _keys,
  keys, /* qqq : for junior : cover */
  // onlyEnumerableKeys, /* qqq : for junior : implement and cover properly */
  allKeys, /* qqq : for junior : cover */

  _vals,
  vals, /* qqq : for junior : cover */
  // onlyEnumerableVals, /* qqq : for junior : implement and cover properly */
  allVals, /* qqq : for junior : cover */

  _pairs,
  pairs, /* qqq : for junior : cover */
  // onlyEnumerablePairs, /* qqq : for junior : implement and cover properly */
  allPairs, /* qqq : for junior : cover */

  // amender

  _extendWithHashmap : _.props._extendWithHashmap,
  _extendWithSet : _.props._extendWithSet,
  _extendWithCountable : _.props._extendWithCountable,
  _extendWithProps : _.props._extendWithProps,
  _extendUniversal : _.props._extendUniversal,
  extendUniversal : _.props.extendUniversal,
  extend : _.props.extend,

  _supplementWithHashmap : _.props._supplementWithHashmap,
  _supplementWithSet : _.props._supplementWithSet,
  _supplementWithCountable : _.props._supplementWithCountable,
  _supplementWithProps : _.props._supplementWithProps,
  _supplementUniversal : _.props._supplementUniversal,
  supplementUniversal : _.props.supplementUniversal,
  supplement : _.props.supplement,

  // meta

  namespaceOf,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

Object.assign( _.map, ExtensionMap );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Map.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Map_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Map_s */ })();

/* */  /* begin of file Module_s */ ( function Module_s() { function Module_s_naked() { ( function _l1_Module_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const __ = _realGlobal_.wTools;
let ModuleFileNative = null;

_.module = _.module || Object.create( null );
__.module = __.module || Object.create( null );

// --
//
// --

const _toolsPath = __dirname + '/../../../../node_modules/Tools';
function toolsPathGet()
{
  return _toolsPath;
}

//

const _toolsDir = __dirname + '/../../../../wtools';
function toolsDirGet()
{
  return _toolsDir;
}

// --
// module extension
// --

var ModuleExtension =
{

  toolsPathGet,
  toolsDirGet,

}

Object.assign( _.module, ModuleExtension );

// --
// tools extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Module.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Module_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Module_s */ })();

/* */  /* begin of file Number_s */ ( function Number_s() { function Number_s_naked() { ( function _l1_Numbers_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.number = _.number || Object.create( null );
_.numbers = _.number.s = _.numbers || _.number.s || Object.create( null );

// --
// number
// --

/**
 * @summary Checks if argument( src ) is a Number.
 * @returns Returns true if ( src ) is a Number, otherwise returns false.
 *
 * @example
 * numberIs( 5 );
 * // returns true
 *
 * @example
 * numberIs( 'song' );
 * // returns false
 *
 * @param { * } src.
 * @return {Boolean}.
 * @function numberIs
 * @namespace Tools
 */

function is( src )
{
  return typeof src === 'number';
  return Object.prototype.toString.call( src ) === '[object Number]';
}

//

function like( src )
{
  return _.number.is( src ) || _.bigInt.is( src );
}

//

function isNotNan( src )
{
  return _.number.is( src ) && !isNaN( src );
}

//

function numberIsFinite( src )
{
  if( !_.number.is( src ) )
  return false;
  return isFinite( src );
}

//

function isInfinite( src )
{

  if( !_.number.is( src ) )
  return false;

  return src === +Infinity || src === -Infinity;
}

//

function intIs( src )
{

  if( !_.number.is( src ) || !_.number.isFinite( src ) )
  return false;

  return Math.floor( src ) === src;
}

//

function areAll( src )
{
  _.assert( arguments.length === 1 );

  if( _.bufferTypedIs( src ) )
  return true;

  if( _.argumentsArray.like( src ) && !_.arrayIsEmpty( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.number.is( src[ s ] ) )
    return false;

    return true;
  }

  return false;
}

//

function areFinite( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );

  if( !_.number.s.areAll( src ) )
  return false;

  if( _.longIs( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.number.isFinite( src[ s ] ) )
    return false;
  }

  return true;
}

//

function arePositive( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );

  if( !_.number.s.areAll( src ) )
  return false;

  if( _.longIs( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( src[ s ] < 0 || !_.number.isNotNan( src[ s ] ) )
    return false;
  }

  return true;
}

//

function areInt( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );

  if( !_.number.s.areAll( src ) )
  return false;

  if( _.longIs( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.intIs( src[ s ] ) )
    return false;
  }

  return true;
}

// --
// number extension
// --

let NumberExtension =
{

  is,
  like,

  isNotNan,
  isFinite : numberIsFinite,
  defined : numberIsFinite,
  isInfinite,

  intIs,

}

Object.assign( _.number, NumberExtension );

// --
// numbers
// --

let NumbersExtension =
{

  areAll,

  areFinite,
  arePositive,
  areInt,

}

Object.assign( _.numbers, NumbersExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  numberIs : is,
  numberIsNotNan : isNotNan,
  numberIsFinite,
  numberDefined : numberIsFinite,
  numberIsInfinite : isInfinite,

  intIs,

  numbersAreAll : areAll,

  numbersAreFinite : areFinite,
  numbersArePositive : arePositive,
  numbersAreInt : areInt,

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Number.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Number_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Number_s */ })();

/* */  /* begin of file Object_s */ ( function Object_s() { function Object_s_naked() { ( function _l1_Object_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.object = _.object || Object.create( null );

// --
// dichotomy
// --

/**
 * Function is checks incoming param whether it is object.
 * Returns "true" if incoming param is object. Othervise "false" returned.
 *
 * @example
 * let obj = { x : 100 };
 * _.object.isBasic(obj);
 * // returns true
 *
 * @example
 * _.object.isBasic( 10 );
 * // returns false
 *
 * @param { * } src.
 * @return { Boolean }.
 * @function is
 * @namespace Tools/object
 */

function isBasic( src )
{
  return Object.prototype.toString.call( src ) === '[object Object]';
}

//

/**
 * Function is checks incoming param whether it is object.
 * Returns "true" if incoming param is object. Othervise "false" returned.
 *
 * @example
 * let obj = { x : 100 };
 * _.object.is(obj);
 * // returns true
 *
 * @example
 * _.object.is( 10 );
 * // returns false
 *
 * @param { * } src.
 * @return { Boolean }.
 * @function is
 * @namespace Tools/object
 */

function is( src ) /* xxx : qqq : for junior : optimize */
{

  if( Object.prototype.toString.call( src ) === '[object Object]' )
  return true;

  if( _.primitive.is( src ) )
  return false;

  // if( _.vector.is( src ) )
  // return false;

  if( _.long.is( src ) )
  return false;

  if( _.set.is( src ) )
  return false;

  if( _.hashMap.is( src ) )
  return false;

  if( _.routine.isTrivial( src ) )
  return false;

  return true;
}

//

function like( src ) /* xxx : qqq : for junior : optimize */
{
  return _.object.is( src );
  // if( _.object.isBasic( src ) )
  // return true;
  //
  // if( _.primitive.is( src ) )
  // return false;
  //
  // if( _.vector.is( src ) )
  // return false;
  //
  // if( _.routine.isTrivial( src ) )
  // return false;
  //
  // if( _.set.is( src ) )
  // return false;
  //
  // if( _.hashMap.is( src ) )
  // return false;
  //
  // return true;
}

//

function likeStandard( src ) /* xxx : qqq : for junior : optimize */
{

  if( _.primitive.is( src ) )
  return false;
  if( _.vector.is( src ) )
  return false;
  if( _.routine.isTrivial( src ) )
  return false;
  if( _.set.is( src ) )
  return false;
  if( _.hashMap.is( src ) )
  return false;

  if( _.date.is( src ) )
  return true
  if( _.regexpIs( src ) )
  return true
  if( _.bufferAnyIs( src ) )
  return true

  return false;
}

//

function isEmpty( src )
{
  if( !this.like( src ) )
  return false;
  return this.keys( src ).length === 0;
}

//

function isPopulated( src )
{
  if( !this.like( src ) )
  return false;
  return this.keys( src ).length > 0;
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return true;
}

// --
// maker
// --

function _makeEmpty( src )
{
  if( src )
  {
    let method = _.class.methodMakeEmptyOf( src );
    if( method )
    return method.call( src );
  }
  return new src.constructor();
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  _.assert( this.like( src ) );
  return this._makeEmpty( src );
}

//

function _makeUndefined( src )
{
  if( src )
  {
    let method = _.class.methodMakeUndefinedOf( src );
    if( method )
    return method.call( src );
  }
  return new src.constructor();
}

//

function makeUndefined( src, length )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 2 )
  {
    _.assert( this.like( src ) );
    _.assert( _.number.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( this.like( src ) );
  }

  return this._makeUndefined( src );
}

//

function _make( src, length )
{
  if( arguments.length === 1 || ( arguments.length === 2 && length === 1 ) )
  return this._cloneShallow( src );
  if( _.aux.is( src ) )
  return _.aux._cloneShallow( src );
  if( arguments.length === 2 )
  return new src.constructor( length );
  else
  return new src.constructor( src );
}

//

function make( src, length )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length >= 1 );
  _.assert( !_.aux.is( src ) || arguments.length === 1 || ( arguments.length === 2 && length === 1) );
  return this._make( ... arguments );
}

//

function _cloneShallow( src )
{
  let method = _.class.methodCloneShallowOf( src );
  if( method )
  return method.call( src );
  if( _.aux.is( src ) )
  return _.aux._cloneShallow( src );
  return new src.constructor( src );
}

// --
// meta
// --

/* qqq : optimize */
function namespaceOf( src )
{

  if( _.object.is( src ) )
  return _.object;

  return null;
}

// --
// extension
// --

let ToolsExtension =
{

  // dichotomy

  objectIs : is.bind( _.object ),
  objectIsBasic : isBasic.bind( _.object ),
  objectIsEmpty : isEmpty.bind( _.object ),
  objectIsPopulated : isPopulated.bind( _.object ),
  objectLike : like.bind( _.object ),
  objectLikeStandard : likeStandard.bind( _.object ),

  // maker

  objectMakeEmpty : makeEmpty.bind( _.object ),
  objectMakeUndefined : makeUndefined.bind( _.object ),
  objectMake : make.bind( _.object ),
  objectCloneShallow : _.props.cloneShallow.bind( _.object ),
  objectFrom : _.props.from.bind( _.object ),

}

Object.assign( _, ToolsExtension );

//

let ObjectExtension =
{

  //

  NamespaceName : 'object',
  NamespaceNames : [ 'object' ],
  NamespaceQname : 'wTools/object',
  MoreGeneralNamespaceName : 'props',
  MostGeneralNamespaceName : 'props',
  TypeName : 'Object',
  TypeNames : [ 'Object' ],
  // SecondTypeName : 'Object',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is,
  isBasic,
  like,
  likeStandard,

  isEmpty, /* qqq : cover */
  isPopulated, /* qqq : cover */
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow : _.props.cloneShallow, /* qqq : for junior : cover */
  from : _.props.from, /* qqq : for junior : cover */

  // properties

  _keys : _.props._keys,
  keys : _.props.keys, /* qqq : for junior : cover */
  onlyOwnKeys : _.props.onlyOwnKeys, /* qqq : for junior : cover */
  onlyEnumerableKeys : _.props.onlyEnumerableKeys, /* qqq : for junior : implement and cover properly */
  allKeys : _.props.allKeys, /* qqq : for junior : cover */

  _vals : _.props._vals,
  vals : _.props.vals, /* qqq : for junior : cover */
  onlyOwnVals : _.props.onlyOwnVals, /* qqq : for junior : cover */
  onlyEnumerableVals : _.props.onlyEnumerableVals, /* qqq : for junior : implement and cover properly */
  allVals : _.props.allVals, /* qqq : for junior : cover */

  _pairs : _.props._pairs,
  pairs : _.props.pairs, /* qqq : for junior : cover */
  onlyOwnPairs : _.props.onlyOwnPairs, /* qqq : for junior : cover */
  onlyEnumerablePairs : _.props.onlyEnumerablePairs, /* qqq : for junior : implement and cover properly */
  allPairs : _.props.allPairs, /* qqq : for junior : cover */

  // amender

  _extendWithHashmap : _.props._extendWithHashmap,
  _extendWithSet : _.props._extendWithSet,
  _extendWithCountable : _.props._extendWithCountable,
  _extendWithProps : _.props._extendWithProps,
  _extendUniversal : _.props._extendUniversal,
  extendUniversal : _.props.extendUniversal,
  extend : _.props.extend,

  _supplementWithHashmap : _.props._supplementWithHashmap,
  _supplementWithSet : _.props._supplementWithSet,
  _supplementWithCountable : _.props._supplementWithCountable,
  _supplementWithProps : _.props._supplementWithProps,
  _supplementUniversal : _.props._supplementUniversal,
  supplementUniversal : _.props.supplementUniversal,
  supplement : _.props.supplement,

  // meta

  namespaceOf,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

//

Object.assign( _.object, ObjectExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Object.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Object_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Object_s */ })();

/* */  /* begin of file Pair_s */ ( function Pair_s() { function Pair_s_naked() { ( function _l1_Pair_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// range
// --

function is( src )
{
  if( !_.longIs( src ) )
  return false;
  if( src.length !== 2 )
  return false;
  return true;
}

//

function make( src )
{
  let result;
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
  if( arguments.length === 2 )
  {
    result = new Array( ... arguments );
  }
  else if( arguments.length === 1 )
  {
    if( _.routine.is( src ) )
    {
      if( src === Array )
      result = new src( undefined, undefined );
      else
      result = new src( 2 );
    }
    else if( arguments[ 0 ].length === 2 )
    result = _.entity.cloneShallow( arguments[ 0 ] );
    else if( arguments[ 0 ].length === 0 )
    result = _.entity.makeUndefined( arguments[ 0 ], 2 );
    else
    throw _.err( 'Length of pair should be 2' );
  }
  else if( arguments.length === 0 )
  {
    result = new Array( undefined, undefined );
  }
  else
  {
    _.assert( 0, `Expects 0..2 arguments, but got ${arguments.length}` );
  }
  _.assert( this.is( result ), 'Faild to make a new Pair' );
  return result;
}

// --
// define
// --

class Pair
{
  static[ Symbol.hasInstance ]( instance )
  {
    return is( instance );
  }
}

let Handler =
{
  construct( original, args )
  {
    return Pair.make( ... args );
  }
};

const Self = new Proxy( Pair, Handler );
Self.original = Pair;

//

var Extension =
{
  is,
  make,
}

//

Object.assign( Self, Extension );
_.assert( _.pair === undefined );
_.pair = Self;

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Pair.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Pair_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Pair_s */ })();

/* */  /* begin of file Path_s */ ( function Path_s() { function Path_s_naked() { ( function _l1_Path_s_()
{

'use strict';

/**
 * @summary Collection of cross-platform routines to operate paths reliably and consistently.
 * @namespace wTools.path
 * @extends Tools
 */

const _global = _global_;
const _ = _global_.wTools;
_.path = _.path || Object.create( null );

// --
// implementation
// --

// function _normalize( o )
// {
//   // let debug = 0;
//   // if( 0 )
//   // debug = 1;
//
//   // _.routine.assertOptions( _normalize, arguments );
//   _.assert( _.strIs( o.src ), 'Expects string' );
//
//   if( !o.src.length )
//   return '';
//
//   let result = o.src;
//
//   result = this.refine( result );
//
//   // if( debug )
//   // console.log( 'normalize.refined : ' + result );
//
//   /* detrailing */
//
//   if( o.tolerant )
//   {
//     /* remove "/" duplicates */
//     result = result.replace( this._delUpDupRegexp, this.upToken );
//   }
//
//   let endsWithUp = false;
//   let beginsWithHere = false;
//
//   /* remove right "/" */
//
//   if( result !== this.upToken && !_.strEnds( result, this.upToken + this.upToken ) && _.strEnds( result, this.upToken ) )
//   {
//     endsWithUp = true;
//     result = _.strRemoveEnd( result, this.upToken );
//   }
//
//   /* undoting */
//
//   while( !_.strBegins( result, this.hereUpToken + this.upToken ) && _.strBegins( result, this.hereUpToken ) )
//   {
//     beginsWithHere = true;
//     result = _.strRemoveBegin( result, this.hereUpToken );
//   }
//
//   /* remove second "." */
//
//   if( result.indexOf( this.hereToken ) !== -1 )
//   {
//
//     while( this._delHereRegexp.test( result ) )
//     result = result.replace( this._delHereRegexp, function( match, postSlash )
//     {
//       return postSlash || '';
//     });
//     if( result === '' )
//     result = this.upToken;
//
//   }
//
//   /* remove .. */
//
//   if( result.indexOf( this.downToken ) !== -1 )
//   {
//
//     while( this._delDownRegexp.test( result ) )
//     result = result.replace( this._delDownRegexp, function( /* match, notBegin, split, preSlash, postSlash */ )
//     {
//       let match = arguments[ 0 ];
//       let notBegin = arguments[ 1 ];
//       let split = arguments[ 2 ];
//       let preSlash = arguments[ 3 ];
//       let postSlash = arguments[ 4 ];
//
//       if( preSlash === '' )
//       return notBegin;
//       if( !notBegin )
//       return notBegin + preSlash;
//       else
//       return notBegin + ( postSlash || '' );
//     });
//
//   }
//
//   /* nothing left */
//
//   if( !result.length )
//   result = '.';
//
//   /* dot and trail */
//
//   if( o.detrailing )
//   if( result !== this.upToken && !_.strEnds( result, this.upToken + this.upToken ) )
//   result = _.strRemoveEnd( result, this.upToken );
//
//   if( !o.detrailing && endsWithUp )
//   if( result !== this.rootToken )
//   result = result + this.upToken;
//
//   if( !o.undoting && beginsWithHere )
//   result = this._dot( result );
//
//   // if( debug )
//   // console.log( 'normalize.result : ' + result );
//
//   return result;
// }
//
// _normalize.defaults =
// {
//   src : null,
//   tolerant : false,
//   detrailing : false,
//   undoting : false,
// }
//
// //
//
// /**
//  * Regularize a path by collapsing redundant delimeters and resolving '..' and '.' segments,so A//B,A/./B and
//     A/foo/../B all become A/B. This string manipulation may change the meaning of a path that contains symbolic links.
//     On Windows,it converts forward slashes to backward slashes. If the path is an empty string,method returns '.'
//     representing the current working directory.
//  * @example
//    let path = '/foo/bar//baz1/baz2//some/..'
//    path = wTools.normalize( path ); // /foo/bar/baz1/baz2
//  * @param {string} src path for normalization
//  * @returns {string}
//  * @function normalize
//  * @namespace Tools.path
//  */
//
// function normalize( src )
// {
//   let result = this._normalize({ src, tolerant : false, detrailing : false, undoting : false });
//
//   _.assert( _.strIs( src ), 'Expects string' );
//   _.assert( arguments.length === 1, 'Expects single argument' );
//   _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
//   _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );
//
//   if( Config.debug )
//   {
//     let i = result.lastIndexOf( this.upToken + this.downToken + this.upToken );
//     _.assert( i === -1 || !/\w/.test( result.substring( 0, i ) ) );
//   }
//
//   return result;
// }
//
// //
//
// function canonize( src )
// {
//   let result = this._normalize({ src, tolerant : false, detrailing : true, undoting : true });
//
//   _.assert( _.strIs( src ), 'Expects string' );
//   _.assert( arguments.length === 1, 'Expects single argument' );
//   _.assert( result === this.upToken || _.strEnds( result, this.upToken + this.upToken ) || !_.strEnds( result, this.upToken ) );
//   _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
//   _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );
//
//   if( Config.debug )
//   {
//     let i = result.lastIndexOf( this.upToken + this.downToken + this.upToken );
//     _.assert( i === -1 || !/\w/.test( result.substring( 0, i ) ) );
//   }
//
//   return result;
// }

// --
// extension
// --

let Extension =
{

  // _normalize,
  // normalize,
  // canonize,

}

//

Object.assign( _.path, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Path.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Path_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Path_s */ })();

/* */  /* begin of file Primitive_s */ ( function Primitive_s() { function Primitive_s_naked() { ( function _l1_Primitive_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.primitive = _.primitive || Object.create( null );

// --
// primitive
// --


function is( src )
{
  if( !src )
  return true;
  let t = Object.prototype.toString.call( src );
  return _.primitive._is( src, t );
}

//

function like( src )
{
  return _.primitive.is( src );
}

//

function _primitiveIs_functor()
{
  const is = new Set();
  is.add( '[object Symbol]' );
  is.add( '[object Number]' );
  is.add( '[object BigInt]' );
  is.add( '[object Boolean]' );
  is.add( '[object String]' );
  return _primitiveIs;

  function _primitiveIs( src, typeStr )
  {
    return is.has( typeStr );
  }

}

let _is = _primitiveIs_functor();
_is.functor = _primitiveIs_functor;

// --
// meta
// --

/* qqq2 : full implementation is required */
/* qqq2 : optimize */
function namespaceOf( src )
{

  debugger;
  if( _.str.is( src ) )
  return _.str;
  if( _.number.is( src ) )
  return _.number;
  if( _.symbol.is( src ) )
  return _.symbol;

  return null;
}

// --
// extension
// --

let PrimitiveExtension =
{

  //

  NamespaceName : 'primitive',
  NamespaceNames : [ 'primitive' ],
  NamespaceQname : 'wTools/primitive',
  MoreGeneralNamespaceName : 'primitive',
  MostGeneralNamespaceName : 'primitive',
  TypeName : 'Primitive',
  TypeNames : [ 'Primitive' ],
  // SecondTypeName : 'Primitive',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is,
  _is,
  like,

  // maker

  _makeEmpty : _.blank._makeEmpty,
  makeEmpty : _.blank.makeEmpty, /* qqq : for junior : cover */
  _makeUndefined : _.blank._makeUndefined,
  makeUndefined : _.blank.makeUndefined, /* qqq : for junior : cover */
  _make : _.blank._make,
  make : _.blank.make, /* qqq : for junior : cover */
  _cloneShallow : _.blank._cloneShallow,
  cloneShallow : _.blank.cloneShallow, /* qqq : for junior : cover */
  from : _.blank.from, /* qqq : for junior : cover */

  // meta

  namespaceOf,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

Object.assign( _.primitive, PrimitiveExtension );

//

let ToolsExtension =
{

  // dichotomy

  primitiveIs : is.bind( _.primitive ),
  primitiveLike : like.bind( _.primitive ),

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Primitive.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Primitive_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Primitive_s */ })();

/* */  /* begin of file Printer_s */ ( function Printer_s() { function Printer_s_naked() { ( function _l1_Printer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.printer = _.printer || Object.create( null );

// --
// printer
// --

function is( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( !src )
  return false;

  if( _.routine.is( src ) )
  return false;

  let prototype = Object.getPrototypeOf( src );
  if( !prototype )
  return false;

  if( src.MetaType === 'Printer' )
  return true;

  return false;
}

//

function like( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.printer.is( src ) )
  return true;

  if( _.consoleIs( src ) )
  return true;

  if( src === _global_.logger )
  return true;

  return false;
}

// --
// extension
// --

let ToolsExtension =
{
  printerIs : is,
  printerLike : like,
}

//

let Extension =
{
  is,
  like,
}

Object.assign( _.printer, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Printer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Printer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Printer_s */ })();

/* */  /* begin of file Process_s */ ( function Process_s() { function Process_s_naked() { ( function _l1_Process_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.process = _.process || Object.create( null );

// --
//
// --

// --
// extension
// --

let Extension =
{
}

//

Object.assign( _.process, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Process.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Process_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Process_s */ })();

/* */  /* begin of file PropertyTransformer_s */ ( function PropertyTransformer_s() { function PropertyTransformer_s_naked() { ( function _l1_PropertyTransformer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.props = _.props || Object.create( null );
_.props.mapper = _.props.mapper || Object.create( null );
_.props.condition = _.props.condition || Object.create( null );

// --
//
// --

// --
//
// --

let Extension =
{
}

Object.assign( _.props, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/PropertyTransformer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, PropertyTransformer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file PropertyTransformer_s */ })();

/* */  /* begin of file Prototype_s */ ( function Prototype_s() { function Prototype_s_naked() { ( function _l1_Prototype_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.prototype = _.prototype || Object.create( null );

// --
// implementation
// --

/**
 * @namespace Tools.prototype
 * @module Tools/base/Proto
 */

function _of( object )
{
  return Object.getPrototypeOf( object );
}

//

/**
 * Iterate through prototypes.
 * @param {object} proto - prototype
 * @function each
 * @namespace Tools.prototype
 */

function each( proto, onEach )
{
  let result = [];

  _.assert( _.routine.is( onEach ) || !onEach );
  _.assert( !_.primitive.is( proto ) || proto === null );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  while( proto )
  {
    if( onEach )
    onEach.call( this, proto );
    result.push( proto );
    proto = Object.getPrototypeOf( proto );
  }

  return result;
}

//

function isPrototypeFor( superPrototype, subPrototype ) /* xxx : move */
{
  _.assert( arguments.length === 2, 'Expects two arguments, probably you meant routine prototypeOf' );
  if( !superPrototype )
  return false;
  if( !subPrototype )
  return false;
  if( superPrototype === subPrototype )
  return true;
  return Object.isPrototypeOf.call( superPrototype, subPrototype );
}

//

/**
 * Return proto owning names.
 * @param {object} srcPrototype - src object to investigate proto stack.
 * @function havingProperty
 * @namespace Tools.prototype
 */

function havingProperty( srcPrototype, name ) /* yyy qqq : names could be only string */
{

  _.assert( !_.primitive.is( srcPrototype ) );
  _.assert( _.strIs( name ) );

  do
  {
    let has = true;
    if( !Object.hasOwnProperty.call( srcPrototype, name ) )
    has = false;
    if( has )
    return srcPrototype;

    srcPrototype = Object.getPrototypeOf( srcPrototype );
  }
  while( srcPrototype !== Object.prototype && srcPrototype );

  return null;
}

// //
//
// /**
//  * Does srcProto has insProto as prototype.
//  * @param {object} srcProto - proto stack to investigate.
//  * @param {object} insProto - proto to look for.
//  * @function hasPrototype
//  * @namespace Tools.prototype
//  */
//
// function hasPrototype( srcProto, insProto )
// {
//
//   while( srcProto !== null )
//   {
//     if( srcProto === insProto )
//     return true;
//     srcProto = Object.getPrototypeOf( srcProto );
//   }
//
//   return false;
// }

//

function has( superPrototype, subPrototype ) /* xxx : move */
{
  _.assert( arguments.length === 2, 'Expects two arguments' );
  // eslint-disable-next-line no-prototype-builtins
  return _.prototype.isPrototypeFor( subPrototype, superPrototype );
}

//

/**
 * Is prototype.
 * @function is
 * @param {object} src - entity to check
 * @namespace Tools
 */

function is( src ) /* xxx : move */
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( _.primitive.is( src ) )
  return false;
  if( _.routine.is( src ) )
  return false;
  return Object.hasOwnProperty.call( src, 'constructor' );
}

//

function set( dst, src )
{
  Object.setPrototypeOf( dst, src );
  return dst;
}

// --
// extension
// --

var Extension =
{

  of : _of,
  each,
  isPrototypeFor,
  havingProperty,

  // hasPrototype,
  hasPrototype : has, /* xxx : remove */
  has,
  is,

  set,

}

//

var ToolsExtension =
{

  // prototypeIsPrototypeOf : isPrototypeOf,  /* xxx : remove */
  // prototypeHas : has, /* xxx : remove */
  prototypeIs : is

}

//

Object.assign( Self, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Prototype.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Prototype_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Prototype_s */ })();

/* */  /* begin of file Regexp_s */ ( function Regexp_s() { function Regexp_s_naked() { ( function _l1_Regexp_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.regexp = _.regexp || Object.create( null );
_.regexps = _.regexp.s = _.regexps || _.regexp.s || Object.create( null );

// --
// regexp
// --

function is( src )
{
  return Object.prototype.toString.call( src ) === '[object RegExp]';
}

//

function isOld( src )
{
  return Object.prototype.toString.call( src ) === '[object RegExp]';
}

//

function isUsingInstanceOf( src )
{
  return src instanceof RegExp;
}

//

function objectIs( src )
{
  if( !_.RegexpObject )
  return false;
  return src instanceof _.RegexpObject;
}

//

function like( src )
{
  if( src instanceof RegExp || Object.prototype.toString.call( src ) === '[object String]' )
  return true;
  return false;
}

//

function likeOld( src )
{
  if( _.regexp.is( src ) || _.strIs( src ) )
  return true;
  return false;
}

//

function likeUsingisUsingInstanceOf( src )
{
  if( _.regexp.isUsingInstanceOf( src ) || _.strIs( src ) )
  return true;
  return false;
}

//

function likeUnfolded( src )
{
  if( src instanceof RegExp || Object.prototype.toString.call( src ) === '[object String]' )
  return true;
  return false;
}

// //
//
// function regexpsLike( srcs )
// {
//   if( !_.arrayIs( srcs ) )
//   return false;
//   for( let s = 0 ; s < srcs.length ; s++ )
//   if( !_.regexpLike( srcs[ s ] ) )
//   return false;
//   return true;
// }

//

function likeAll( src )
{
  _.assert( arguments.length === 1 );

  if( _.argumentsArray.like( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.regexp.like( src[ s ] ) )
    return false;
    return true;
  }

  return _.regexp.like( src );
}

//

/**
 * Escapes special characters with a slash ( \ ). Supports next set of characters : .*+?^=! :${}()|[]/\
 *
 * @example
 * _.regexp.escape( 'Hello. How are you?' );
 * // returns "Hello\. How are you\?"
 *
 * @param {String} src Regexp string
 * @returns {String} Escaped string
 * @function escape
 * @namespace Tools
 */

function escape( src )
{
  _.assert( _.strIs( src ) );
  _.assert( arguments.length === 1, 'Expects single argument' );
  return src.replace( /([.*+?^=!:${}()|\[\]\/\\])/g, '\\$1' );
}

// --
// extension
// --

let ToolsExtension =
{

  regexpIs : is,
  regexpObjectIs : objectIs,
  regexpLike : like,
  regexpsLikeAll : likeAll,

  regexpEscape : escape,

}

Object.assign( _, ToolsExtension )

//

let RegexpExtension =
{

  // regexp

  is,
  isOld,
  isUsingInstanceOf,
  objectIs,
  like,
  likeOld,
  likeUsingisUsingInstanceOf,
  likeUnfolded,

  escape,

}

Object.assign( _.regexp, RegexpExtension )

//

let RegexpExtensions =
{

  // regexps

  likeAll,

}

Object.assign( _.regexp.s, RegexpExtensions )

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Regexp.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Regexp_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Regexp_s */ })();

/* */  /* begin of file Routine_s */ ( function Routine_s() { function Routine_s_naked() { ( function _l1_Routine_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.routine = _.routine || Object.create( null );
_.routines = _.routine.s = _.routines || _.routine.s || Object.create( null );
// _.ddds = _.ddd.s = _.ddds || _.ddd.s || Object.create( null );

_.routine.chainer = _.routine.chainer || Object.create( null );
_.routine.tail = _.routine.tail || Object.create( null );

// --
// routine
// --

function __mapButKeys( srcMap, butMap )
{
  let result = [];

  for( let s in srcMap )
  if( !( s in butMap ) )
  result.push( s );

  return result;
}

//

function __mapUndefinedKeys( srcMap )
{
  let result = [];

  for( let s in srcMap )
  if( srcMap[ s ] === undefined )
  result.push( s );

  return result;
}

//

function __keysQuote( keys )
{
  let result = `"${ keys[ 0 ] }"`;
  for( let i = 1 ; i < keys.length ; i++ )
  result += `, "${ keys[ i ] }"`;
  return result.trim();
}

//

function __primitiveLike( src )
{
  if( _.primitive.is( src ) )
  return true;
  if( _.regexpIs( src ) )
  return true;
  if( _.routineIs( src ) )
  return true;
  return false;
}

//

function __strType( src )
{
  if( _.strType )
  return _.strType( src );
  return String( src );
}

//

function __mapSupplementWithoutUndefined( dstMap, srcMap )
{
  for( let k in srcMap )
  {
    if( Config.debug )
    _.assert
    (
      __primitiveLike( srcMap[ k ] ),
      () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( srcMap[ k ] ) }`
    );
    if( dstMap[ k ] !== undefined )
    continue;
    dstMap[ k ] = srcMap[ k ];
  }
}

__mapSupplementWithoutUndefined.meta = Object.create( null );
__mapSupplementWithoutUndefined.meta.locals =
{
  __primitiveLike,
  __strType,
}

//

function __mapSupplementWithUndefined( dstMap, srcMap )
{
  for( let k in srcMap )
  {
    if( Config.debug )
    _.assert
    (
      __primitiveLike( srcMap[ k ] ),
      () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( srcMap[ k ] ) }`
    );
    if( Object.hasOwnProperty.call( dstMap, k ) )
    continue;
    dstMap[ k ] = srcMap[ k ];
  }
}

__mapSupplementWithUndefined.meta = Object.create( null );
__mapSupplementWithUndefined.meta.locals =
{
  __primitiveLike,
  __strType,
}

//

function __mapSupplementWithUndefinedTollerant( dstMap, srcMap )
{
  for( let k in srcMap )
  {
    if( Object.hasOwnProperty.call( dstMap, k ) )
    continue;
    dstMap[ k ] = srcMap[ k ];
  }
}

__mapSupplementWithUndefinedTollerant.meta = Object.create( null );
__mapSupplementWithUndefinedTollerant.meta.locals =
{
}

//

function __arrayFlatten( src )
{
  let result = [];
  if( src === null )
  return result;
  if( !_.argumentsArray.like( src ) )
  result.push( src );
  else
  for( let i = 0 ; i < src.length ; i++ )
  {
    let e = src[ i ];
    if( _.array.is( e ) || _.argumentsArray.is( e ) )
    result.push( ... e );
    else
    result.push( e );
  }
  return result;
}

// --
// dichotomy
// --

function is( src )
{
  let typeStr = Object.prototype.toString.call( src );
  return _.routine._is( src, typeStr );
}

//

function _is( src, typeStr )
{
  return typeStr === '[object Function]' || typeStr === '[object AsyncFunction]';
}

//

function like( src )
{
  let typeStr = Object.prototype.toString.call( src );
  return _.routine._like( src, typeStr );
}

//

function _like( src, typeStr )
{
  return typeStr === '[object Function]' || typeStr === '[object AsyncFunction]' || typeStr === '[object GeneratorFunction]' || typeStr === '[object AsyncGeneratorFunction]';
}

//

function routineIsTrivial_functor()
{

  const syncPrototype = Object.getPrototypeOf( Function );
  const asyncPrototype = Object.getPrototypeOf( _async );
  return routineIsTrivial;

  function routineIsTrivial( src )
  {
    if( !src )
    return false;
    let prototype = Object.getPrototypeOf( src );
    if( prototype === syncPrototype )
    return true;
    if( prototype === asyncPrototype )
    return true;
    return false;
  }

  async function _async()
  {
  }

}

let isTrivial = routineIsTrivial_functor();
isTrivial.functor = routineIsTrivial_functor;

//

function isSync( src )
{
  return Object.prototype.toString.call( src ) === '[object Function]';
}

//

function isAsync( src )
{
  return Object.prototype.toString.call( src ) === '[object AsyncFunction]';
}

//

function isGenerator( src )
{
  let typeStr = Object.prototype.toString.call( src );
  return typeStr === '[object GeneratorFunction]' || typeStr === '[object AsyncGeneratorFunction]';
}

//

function isSyncGenerator( src )
{
  return Object.prototype.toString.call( src ) === '[object GeneratorFunction]';
}

//

function isAsyncGenerator( src )
{
  return Object.prototype.toString.call( src ) === '[object AsyncGeneratorFunction]';
}

//

function are( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.argumentsArray.like( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.routine.is( src[ s ] ) )
    return false;
    return true;
  }

  return _.routine.is( src );
}

//

function withName( src )
{
  if( !_.routine.like( src ) )
  return false;
  if( !src.name )
  return false;
  return true;
}

// --
// joiner
// --

/**
 * Internal implementation.
 * @param {object} object - object to check.
 * @return {object} object - name in key/value format.
 * @function _routineJoin
 * @namespace Tools
 */

function _join( o )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.bool.is( o.sealing ) );
  _.assert( _.bool.is( o.extending ) );
  _.assert( _.routine.is( o.routine ), 'Expects routine' );
  _.assert( _.longIs( o.args ) || o.args === undefined );

  let routine = o.routine;
  let args = o.args;
  let context = o.context;
  let result = act();

  if( o.extending )
  {
    _.props.extend( result, routine );

    let o2 =
    {
      value : routine,
      enumerable : false,
    };
    Object.defineProperty( result, 'originalRoutine', o2 ); /* qqq : cover */

    if( context !== undefined )
    {
      let o3 =
      {
        value : context,
        enumerable : false,
      };
      Object.defineProperty( result, 'boundContext', o3 ); /* qqq : cover */
    }

    if( args !== undefined )
    {
      let o3 =
      {
        value : args,
        enumerable : false,
      };
      Object.defineProperty( result, 'boundArguments', o3 ); /* qqq : cover */
    }

  }

  return result;

  /* */

  function act()
  {

    if( context !== undefined && args !== undefined )
    {
      if( o.sealing === true )
      {
        let name = routine.name || '__sealedContextAndArguments';
        _.assert( _.strIs( name ) );
        let __sealedContextAndArguments =
        {
          [ name ] : function()
          {
            return routine.apply( context, args );
          }
        }
        return __sealedContextAndArguments[ name ];
      }
      else
      {
        // let a = _.arrayAppendArray( [ context ], args );
        let a = [ context ]
        a.push( ... args );
        return Function.prototype.bind.apply( routine, a );
      }
    }
    else if( context !== undefined && args === undefined )
    {
      if( o.sealing === true )
      {
        let name = routine.name || '__sealedContext';
        let __sealedContext =
        {
          [ name ] : function()
          {
            return routine.call( context );
          }
        }
        return __sealedContext[ name ];
      }
      else
      {
        return Function.prototype.bind.call( routine, context );
      }
    }
    else if( context === undefined && args !== undefined )
    {
      if( o.sealing === true )
      {
        let name = routine.name || '__sealedArguments';
        _.assert( _.strIs( name ) );
        let __sealedContextAndArguments =
        {
          [ name ] : function()
          {
            return routine.apply( this, args );
          }
        }
        return __sealedContextAndArguments[ name ];
      }
      else
      {
        let name = routine.name || '__joinedArguments';
        let __joinedArguments =
        {
          [ name ] : function()
          {
            // let args2 = _.arrayAppendArrays( null, [ args, arguments ] );
            let args2 = [ ... args, ... arguments ];
            return routine.apply( this, args2 );
          }
        }
        return __joinedArguments[ name ];
      }
    }
    else if( context === undefined && args === undefined ) /* zzz */
    {
      return routine;
    }
    else _.assert( 0 );
  }

}

//

function constructorJoin( routine, args )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );

  return _.routine._join
  ({
    routine,
    context : routine,
    args : args || [],
    sealing : false,
    extending : false,
  });

}

//

/**
 * The join() routine creates a new function with its 'this' ( context ) set to the provided `context`
 * value. Argumetns `args` of target function which are passed before arguments of binded function during
 * calling of target function. Unlike bind routine, position of `context` parameter is more intuitive.
 *
 * @example
 * let o = { z: 5 };
 * let y = 4;
 * function sum( x, y )
 * {
 *   return x + y + this.z;
 * }
 * let newSum = _.routine.join( o, sum, [ 3 ] );
 * newSum( y );
 * // returns 12
 *
 * @example
 * function f1()
 * {
 *   console.log( this )
 * };
 * let f2 = f1.bind( undefined ); // context of new function sealed to undefined (or global object);
 * f2.call( o ); // try to call new function with context set to { z: 5 }
 * let f3 = _.routine.join( undefined, f1 ); // new function.
 * f3.call( o )
 * // log { z: 5 }
 *
 * @param {Object} context The value that will be set as 'this' keyword in new function
 * @param {Function} routine Function which will be used as base for result function.
 * @param {Array<*>} args Argumetns of target function which are passed before arguments of binded function during
 calling of target function. Must be wraped into array.
 * @returns {Function} New created function with preceding this, and args.
 * @throws {Error} When second argument is not callable throws error with text 'first argument must be a routine'
 * @thorws {Error} If passed arguments more than 3 throws error with text 'Expects 3 or less arguments'
 * @function join
 * @namespace Tools
 */

function join( context, routine, args )
{

  _.assert( arguments.length <= 3, 'Expects 3 or less arguments' );

  return _.routine._join
  ({
    routine,
    context,
    args,
    sealing : false,
    extending : true,
  });

}

//

/**
 * The join() routine creates a new function with its 'this' ( context ) set to the provided `context`
 * value. Argumetns `args` of target function which are passed before arguments of binded function during
 * calling of target function. Unlike bind routine, position of `context` parameter is more intuitive.
 *
 * @example
 * let o = { z: 5 };
 * let y = 4;
 * function sum( x, y )
 * {
 *   return x + y + this.z;
 * }
 * let newSum = _.routine.join( o, sum, [ 3 ] );
 * newSum( y );
 * // returns 12
 *
 * @example
 * function f1()
 * {
 *   console.log( this )
 * };
 * let f2 = f1.bind( undefined ); // context of new function sealed to undefined (or global object);
 * f2.call( o ); // try to call new function with context set to { z: 5 }
 * let f3 = _.routine.join( undefined, f1 ); // new function.
 * f3.call( o )
 * // log { z: 5 }
 *
 * @param {Object} context The value that will be set as 'this' keyword in new function
 * @param {Function} routine Function which will be used as base for result function.
 * @param {Array<*>} args Argumetns of target function which are passed before arguments of binded function during
 calling of target function. Must be wraped into array.
 * @returns {Function} New created function with preceding this, and args.
 * @throws {Error} When second argument is not callable throws error with text 'first argument must be a routine'
 * @thorws {Error} If passed arguments more than 3 throws error with text 'Expects 3 or less arguments'
 * @function routineJoin
 * @namespace Tools
 */

function join( context, routine, args )
{

  _.assert( arguments.length <= 3, 'Expects 3 or less arguments' );

  return _.routine._join
  ({
    routine,
    context,
    args,
    sealing : false,
    extending : true,
  });

}

//

/**
 * Return new function with sealed context and arguments.
 *
 * @example
 * let o = { z : 5 };
 * function sum( x, y )
 * {
 *   return x + y + this.z;
 * }
 * let newSum = _.routine.seal( o, sum, [ 3, 4 ] );
 * newSum();
 * // returns : 12
 *
 * @param { Object } context - The value that will be set as 'this' keyword in new function
 * @param { Function } routine - Function which will be used as base for result function.
 * @param { Array } args - Arguments wrapped into array. Will be used as argument to `routine` function
 * @returns { Function } - Result function with sealed context and arguments.
 * @function seal
 * @namespace Tools
 */

function seal( context, routine, args )
{

  _.assert( arguments.length <= 3, 'Expects 3 or less arguments' );

  return _.routine._join
  ({
    routine,
    context,
    args,
    sealing : true,
    extending : true,
  });

}

// --
// options
// --

// //
//
// function mapOptionsApplyDefaults( options, defaults )
// {
//
//   _.assert( arguments.length === 2 );
//   _.map.assertHasOnly( options, defaults, `Does not expect options:` );
//   _.mapSupplementStructureless( options, defaults );
//   _.map.assertHasNoUndefine( options, `Options map should have no undefined fileds, but it does have` );
//
//   return options;
// }

/* qqq : for Dmytro : bad : discuss
should be { defaults : {} } in the first argument
*/

function optionsWithoutUndefined( routine, options )
{

  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    if( options.length === 0 )
    options = Object.create( null )
    else
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  if( options === null || options === undefined )
  options = Object.create( null );

  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  // if( options === undefined ) /* qqq : for Dmytro : bad : should be error */
  // options = Object.create( null );
  // if( defaults === null )
  // defaults = Object.create( null );

  // let name = _.routineIs( defaults ) ? defaults.name : '';
  // defaults = ( _.routineIs( defaults ) && defaults.defaults ) ? defaults.defaults : defaults;
  // _.assert( _.aux.is( defaults ), 'Expects defined defaults' );

  /* */

  if( Config.debug )
  {
    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );
  }

  __mapSupplementWithoutUndefined( options, defaults );

  if( Config.debug )
  {
    let undefineKeys = __mapUndefinedKeys( options );
    _.assert
    (
      undefineKeys.length === 0,
      () => `Options map for routine "${ name }" should have no undefined fields, but it does have ${ __keysQuote( undefineKeys ) }`
    );
  }

  return options;
}

optionsWithoutUndefined.meta = Object.create( null );
optionsWithoutUndefined.meta.locals =
{
  __mapButKeys,
  __mapUndefinedKeys,
  __keysQuote,
  __mapSupplementWithoutUndefined,
}

//

function assertOptionsWithoutUndefined( routine, options )
{

  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  /* */

  if( Config.debug )
  {

    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );

    let undefineKeys = __mapUndefinedKeys( options );
    _.assert
    (
      undefineKeys.length === 0,
      () => `Options map for routine "${ name }" should have no undefined fields, but it does have ${ __keysQuote( undefineKeys ) }`
    );

    for( let k in defaults )
    {
      _.assert
      (
        __primitiveLike( defaults[ k ] ),
        () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( defaults[ k ] ) }`
      );
      _.assert
      (
        Reflect.has( options, k ),
        `Options map does not have option::${k}`
      )
    }

  }

  return options;
}

assertOptionsWithoutUndefined.meta = Object.create( null );
assertOptionsWithoutUndefined.meta.locals =
{
  __mapButKeys,
  __mapUndefinedKeys,
  __keysQuote,
  __primitiveLike,
  __strType,
}

//

function optionsWithUndefined( routine, options )
{

  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    if( options.length === 0 )
    options = Object.create( null )
    else
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  if( options === null )
  options = Object.create( null );
  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  /* */

  if( Config.debug )
  {
    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );
  }

  __mapSupplementWithUndefined( options, defaults );

  return options;
}

optionsWithUndefined.meta = Object.create( null );
optionsWithUndefined.meta.locals =
{
  __keysQuote,
  __mapSupplementWithUndefined,
}

//

function optionsWithUndefinedTollerant( routine, options )
{
  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    if( options.length === 0 )
    options = Object.create( null )
    else
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  if( options === null )
  options = Object.create( null );
  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  /* */

  if( Config.debug )
  {
    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );
  }

  __mapSupplementWithUndefinedTollerant( options, defaults );

  return options;
}

optionsWithUndefinedTollerant.meta = Object.create( null );
optionsWithUndefinedTollerant.meta.locals =
{
  __keysQuote,
  __mapSupplementWithUndefinedTollerant,
}


//

function assertOptionsWithUndefined( routine, options )
{

  if( _.argumentsArray.like( options ) )
  {
    _.assert
    (
      options.length === 0 || options.length === 1,
      `Expects single options map, but got ${options.length} arguments`
    );
    options = options[ 0 ];
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 2, 'Expects exactly 2 arguments' );
    _.assert( _.routineIs( routine ) || _.aux.is( routine ) || routine === null, 'Expects an object with options' );
    _.assert( _.object.isBasic( options ) || options === null, 'Expects an object with options' );
  }

  let name = routine.name || '';
  let defaults = routine.defaults;
  _.assert( _.aux.is( defaults ), `Expects map of defaults, but got ${_.strType( defaults )}` );

  /* */

  if( Config.debug )
  {

    let extraKeys = __mapButKeys( options, defaults );
    _.assert( extraKeys.length === 0, () => `Routine "${ name }" does not expect options: ${ __keysQuote( extraKeys ) }` );

    for( let k in defaults )
    {
      _.assert
      (
        __primitiveLike( defaults[ k ] ),
        () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( defaults[ k ] ) }`
      );
      _.assert
      (
        Reflect.has( options, k ),
        `Options map does not have option::${k}`
      )
    }

  }

  return options;
}

assertOptionsWithUndefined.meta = Object.create( null );
assertOptionsWithUndefined.meta.locals =
{
  __keysQuote,
  __primitiveLike,
  __strType,
}

//

function _verifyDefaults( defaults )
{

  for( let k in defaults )
  {
    _.assert
    (
      __primitiveLike( defaults[ k ] ),
      () => `Defaults map should have only primitive elements, but option::${ k } is ${ __strType( defaults[ k ] ) }`
    );
  }

}

_verifyDefaults.meta = Object.create( null );
_verifyDefaults.meta.locals =
{
  __primitiveLike,
  __strType,
}

// --
// amend
// --

/* qqq : for Dmytro : cover and optimize */
function _amend( o )
{
  let dst = o.dst;
  let srcs = o.srcs;
  let srcIsVector = _.vectorIs( srcs );
  let extended = false;

  _.routine.assertOptions( _amend, o );
  _.assert( arguments.length === 1 );
  _.assert( _.routine.is( dst ) || dst === null );
  _.assert( srcs === null || srcs === undefined || _.aux.is( srcs ) || _.routine.is( srcs ) || _.vector.is( srcs ) );
  _.assert( o.amending === 'extending', 'not implemented' );
  _.assert
  (
    o.strategy === 'cloning' || o.strategy === 'replacing' || o.strategy === 'inheriting',
    () => `Unknown strategy ${o.strategy}`
  );

  /* generate dst routine */

  if( dst === null ) /* qqq : for Dmytro : good coverage required */
  dst = _dstMake( srcs );

  // /* shallow clone properties of dst routine */
  //
  // if( o.strategy === 'cloning' )
  // _fieldsClone( dst );
  // else if( o.strategy === 'inheriting' )
  // _fieldsInherit( dst );

  /* extend dst routine */

  let _dstAmend;
  if( o.strategy === 'cloning' )
  _dstAmend = _dstAmendCloning;
  else if( o.strategy === 'replacing' )
  _dstAmend = _dstAmendReplacing;
  else if( o.strategy === 'inheriting' )
  _dstAmend = _dstAmendInheriting;
  else _.assert( 0, 'not implemented' );

  if( srcIsVector )
  for( let src of srcs )
  _dstAmend( dst, src );
  else
  _dstAmend( dst, srcs );

  /* qqq : for Dmytro : it should be optimal, no redundant cloning of body should happen
  check and cover it by good test, please
  */
  if( extended )
  // if( dst.body && dst.body.defaults )
  if( dst.body )
  dst.body = bodyFrom( dst.body );

  if( Config.debug )
  {
    /* qqq : for Dmytro : cover, please */
    if( _.strEnds( dst.name, '_body' ) )
    {
      _.assert( dst.body === undefined, 'Body of routine should not have its own body' );
      _.assert( dst.head === undefined, 'Body of routine should not have its own head' );
      _.assert( dst.tail === undefined, 'Body of routine should not have its own tail' );
    }
    // xxx : uncomment?
    // if( dst.defaults )
    // _.routine._verifyDefaults( dst.defaults );
  }

  return dst;

  /* */

  function _dstMake( srcs )
  {
    let dstMap = Object.create( null );

    /* qqq : option amendment influence on it */
    if( srcIsVector )
    for( let src of srcs )
    {
      if( src === null )
      continue;
      _.props.extend( dstMap, src );
    }
    else
    {
      if( srcs !== null )
      _.props.extend( dstMap, srcs );
    }

    if( dstMap.body )
    {
      // dst = _.routine.uniteCloning( dstMap.head, dstMap.body );
      dst = _.routine.unite
      ({
        head : dstMap.head || null,
        body : dstMap.body || null,
        tail : dstMap.tail || null,
        name : dstMap.name || null,
        strategy : o.strategy,
      });
    }
    else
    {
      if( srcIsVector )
      dst = dstFrom( srcs[ 0 ] );
      else
      dst = dstFrom( srcs );
    }

    _.assert( _.routineIs( dst ) );
    // _.props.extend( dst, dstMap );

    return dst;
  }

  /* */

  // function _fieldsClone( dst )
  // {
  //
  //   for( let s in dst )
  //   {
  //     let property = dst[ s ];
  //     if( _.object.isBasic( property ) )
  //     {
  //       property = _.props.extend( null, property );
  //       dst[ s ] = property;
  //     }
  //   }
  //
  // }
  //
  // /* */
  //
  // function _fieldsInherit( dst )
  // {
  //
  //   for( let s in dst )
  //   {
  //     let property = dst[ s ];
  //     if( _.object.isBasic( property ) )
  //     {
  //       property = Object.create( property );
  //       dst[ s ] = property;
  //     }
  //   }
  //
  // }

  /* */

  function _dstAmendCloning( dst, src )
  {
    _.assert( !!dst );
    _.assert( _.aux.is( src ) || _.routine.is( src ) );
    for( let s in src )
    {
      let property = src[ s ];
      if( dst[ s ] === property )
      continue;
      let d = Object.getOwnPropertyDescriptor( dst, s );
      if( d && !d.writable )
      continue;
      extended = true;
      if( _.object.isBasic( property ) )
      {
        _.assert( !_.props.own( dst, s ) || _.object.isBasic( dst[ s ] ) );

        if( dst[ s ] )
        _.props.extend( dst[ s ], property );
        else
        dst[ s ] = property = _.props.extend( null, property );

        // property = _.props.extend( null, property );
        // if( dst[ s ] )
        // _.props.supplement( property, dst[ s ] );
      }
      else
      {
        dst[ s ] = property;
      }
    }
  }

  /* */

  function _dstAmendInheriting( dst, src )
  {
    _.assert( !!dst );
    _.assert( _.aux.is( src ) || _.routine.is( src ) );
    /* qqq : for Dmytro : on extending should inherit from the last one, on supplementing should inherit from the first one
    implement, and cover in separate test
    */
    for( let s in src )
    {
      let property = src[ s ];
      if( dst[ s ] === property )
      continue;
      let d = Object.getOwnPropertyDescriptor( dst, s );
      if( d && !d.writable )
      continue;
      extended = true;
      if( _.object.isBasic( property ) )
      {
        property = Object.create( property );
        if( dst[ s ] )
        _.props.supplement( property, dst[ s ] );
      }
      dst[ s ] = property;
    }
  }

  /* */

  function _dstAmendReplacing( dst, src )
  {
    _.assert( !!dst );
    _.assert( _.aux.is( src ) || _.routine.is( src ) );
    for( let s in src )
    {
      let property = src[ s ];
      if( dst[ s ] === property )
      continue;
      let d = Object.getOwnPropertyDescriptor( dst, s );
      if( d && !d.writable )
      continue;
      extended = true;
      dst[ s ] = property;
    }
  }

  /* */

  function bodyFrom()
  {
    const body = dst.body;
    let body2 = body;
    _.assert( body.head === undefined, 'Body should not have own head' );
    _.assert( body.tail === undefined, 'Body should not have own tail' );
    _.assert( body.body === undefined, 'Body should not have own body' );
    {
      // let srcs = srcIsVector ? _.map_( null, o.srcs, ( src ) => propertiesBut( src ) ) : [ propertiesBut( o.srcs ) ];
      let srcs;
      if( srcIsVector )
      {
        // debugger;
        srcs = o.srcs.map( (src ) => propertiesBut( src ) );
      }
      else
      {
        srcs = [ propertiesBut( o.srcs ) ];
      }
      srcs.unshift( body );
      body2 = _.routine._amend
      ({
        dst : o.strategy === 'replacing' ? body2 : null,
        srcs,
        strategy : o.strategy,
        amending : o.amending,
      });
      _.assert( body2.head === undefined, 'Body should not have own head' );
      _.assert( body2.tail === undefined, 'Body should not have own tail' );
      _.assert( body2.body === undefined, 'Body should not have own body' );
    }
    return body2;
  }

  /* */

  function propertiesBut( src )
  {
    if( !src )
    return src;
    let result = _.props.extend( null, src );
    delete result.head;
    delete result.body;
    delete result.taul;
    // return src ? _.mapBut_( null, src, [ 'head', 'body', 'tail' ] ) : src;
    return result;
  }

  /* */

  /* xxx : make routine? */
  function routineClone( routine )
  {
    _.assert( _.routine.is( routine ) );
    let name = routine.name;
    // const routine2 = routine.bind();
    // _.assert( routine2 !== routine );
    const routine2 =
    ({
      [ name ] : function()
      {
        return routine.apply( this, arguments );
      }
    })[ name ];

    let o2 =
    {
      value : routine,
      enumerable : false,
    };
    Object.defineProperty( routine2, 'originalRoutine', o2 ); /* qqq : for Dmytro : cover */

    return routine2;
  }

  /* */

  function dstFrom( routine )
  {
    return routineClone( routine );
  }

  /* */

}

_amend.defaults =
{
  dst : null,
  srcs : null,
  strategy : 'cloning', /* qqq : for Dmytro : cover */
  amending : 'extending', /* qqq : for Dmytro : implement and cover */
}

//

/**
 * The routine _.routine.extendCloning() is used to copy the values of all properties
 * from source routine to a target routine.
 *
 * It takes first routine (dst), and shallow clone each destination property of type map.
 * Then it checks properties of source routine (src) and extends dst by source properties.
 * The dst properties can be owerwriten by values of source routine
 * if descriptor (writable) of dst property is set.
 *
 * If the first routine (dst) is null then
 * routine _.routine.extendCloning() makes a routine from routines head and body
 * @see {@link wTools.routine.unite} - Automatic routine generating
 * from preparation routine and main routine (body).
 *
 * @param{ routine } dst - The target routine or null.
 * @param{ * } src - The source routine or object to copy.
 *
 * @example
 * var src =
 * {
 *   head : _.routine.s.compose.head,
 *   body : _.routine.s.compose.body,
 *   someOption : 1,
 * }
 * var got = _.routine.extendCloning( null, src );
 * // returns [ routine routinesCompose ], got.option === 1
 *
 * @example
 * _.routine.extendCloning( null, _.routine.s.compose );
 * // returns [ routine routinesCompose ]
 *
 * @example
 * _.routine.extendCloning( _.routine.s.compose, { someOption : 1 } );
 * // returns [ routine routinesCompose ], routinesCompose.someOption === 1
 *
 * @example
 * _.routine.s.composes.someOption = 22;
 * _.routine.extendCloning( _.routine.s.compose, { someOption : 1 } );
 * // returns [ routine routinesCompose ], routinesCompose.someOption === 1
 *
 * @returns { routine } It will return the target routine with extended properties.
 * @function extendCloning
 * @throws { Error } Throw an error if arguments.length < 1 or arguments.length > 2.
 * @throws { Error } Throw an error if dst is not routine or not null.
 * @throws { Error } Throw an error if dst is null and src has not head and body properties.
 * @throws { Error } Throw an error if src is primitive value.
 * @namespace Tools
 */

function extendCloning( dst, ... srcs )
{

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  return _.routine._amend
  ({
    dst,
    srcs : [ ... srcs ],
    strategy : 'cloning',
    amending : 'extending',
  });

}

// qqq : for Dmytro : cover please
function extendInheriting( dst, ... srcs )
{

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  return _.routine._amend
  ({
    dst,
    srcs : [ ... srcs ],
    strategy : 'inheriting',
    amending : 'extending',
  });

}

//
/*qqq : for Dmytro : cover please */
function extendReplacing( dst, ... srcs )
{

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  return _.routine._amend
  ({
    dst,
    srcs : [ ... srcs ],
    strategy : 'replacing',
    amending : 'extending',
  });

}

//

function defaults( dst, src, defaults )
{

  if( arguments.length === 2 )
  {
    defaults = arguments[ 1 ];
    _.assert( _.aux.is( defaults ) );
    return _.routine.extend( dst, { defaults } );
  }
  else
  {
    _.assert( arguments.length === 3 );
    _.assert( _.aux.is( defaults ) );
    return _.routine.extend( dst, src, { defaults } );
  }

  // _.assert( dst === null || src === null );
  // _.assert( _.aux.is( defaults ) );
  // return _.routine.extend( dst, src, { defaults } );
}

// --
// unite
// --

function unite_head( routine, args )
{
  let o = args[ 0 ];

  if( args[ 1 ] !== undefined )
  {
    if( args.length === 3 )
    o = { head : args[ 0 ], body : args[ 1 ], tail : args[ 2 ] };
    else
    o = { head : args[ 0 ], body : ( args.length > 1 ? args[ 1 ] : null ) };
  }

  _.routine.optionsWithoutUndefined( routine, o );
  _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
  _.assert( arguments.length === 2 );
  _.assert
  (
    o.head === null || _.numberIs( o.head ) || _.routine.is( o.head ) || _.routine.s.are( o.head )
    , 'Expects either routine, routines or number of arguments {-o.head-}'
  );
  _.assert( _.routine.is( o.body ), 'Expects routine {-o.body-}' );
  _.assert( o.tail === null || _.routine.is( o.tail ), () => `Expects routine {-o.tail-}, but got ${_.entity.strType( o.tail )}` );
  _.assert( o.body.defaults !== undefined, 'Body should have defaults' );

  return o;
}

//

function unite_body( o )
{

  if( _.longIs( o.head ) )
  {
    /* xxx : deprecate compose */
    /* qqq : for Dmytro : implement without compose */
    // let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
    // {
    //   let args = arguments[ 0 ];
    //   let result = arguments[ 1 ];
    //   let op = arguments[ 2 ];
    //   let k = arguments[ 3 ];
    //   _.assert( arguments.length === 4 );
    //   _.assert( !_.unrollIs( result ) );
    //   _.assert( _.object.isBasic( result ) );
    //   return _.unrollAppend([ unitedRoutine, [ result ] ]);
    // });
    let _head = _.routine.s.compose( o.head, function( /* args, result, op, k */ )
    {
      let args = arguments[ 0 ];
      let result = arguments[ 1 ];
      let op = arguments[ 2 ];
      let k = arguments[ 3 ];
      _.assert( arguments.length === 4 );
      _.assert( !_.unrollIs( result ) );
      _.assert( _.object.isBasic( result ) );
      return _.unroll.from([ unitedRoutine, [ result ] ]);
    });
    _.assert( _.routine.is( _head ) );
    o.head = function head()
    {
      let result = _head.apply( this, arguments );
      return result[ result.length-1 ];
    }
    o.head.composed = _head.composed;
  }
  else if( _.number.is( o.head ) )
  {
    o.head = headWithNargs_functor( o.head, o.body );
  }

  if( o.head === null )
  {
    /* qqq : for Dmytro : cover please */
    if( o.body.defaults )
    o.head = headWithDefaults;
    else
    o.head = headWithoutDefaults;
  }

  if( !o.name )
  {
    _.assert( _.strDefined( o.body.name ), 'Body routine should have name' );
    o.name = o.body.name;
    if( o.name.indexOf( '_body' ) === o.name.length-5 && o.name.length > 5 )
    o.name = o.name.substring( 0, o.name.length-5 );
  }

  /* generate body */

  /* qqq : for Dmytro : cover in separate test routine */
  let body;
  if( o.strategy === 'replacing' )
  body = o.body;
  else
  body = _.routine._amend
  ({
    dst : null,
    srcs : o.body,
    strategy : o.strategy,
    amending : 'extending',
  });

  /* make routine */

  let unitedRoutine = _unite_functor( o.name, o.head, body, o.tail );

  _.assert( _.strDefined( unitedRoutine.name ), 'Looks like your interpreter does not support dynamic naming of functions. Please use ES2015 or later interpreter.' );

  /* qqq : for Dmytro : cover option::strategy */

  _.routine._amend
  ({
    dst : unitedRoutine,
    srcs : body,
    strategy : 'replacing',
    amending : 'extending',
  });

  unitedRoutine.head = o.head;
  unitedRoutine.body = body;
  if( o.tail )
  unitedRoutine.tail = o.tail;

  _.assert
  (
    unitedRoutine.defaults === body.defaults,
    'Something wrong, united routined should have same instance of defaults its body has'
  );

  return unitedRoutine;

  function headWithNargs_functor( nargs, body )
  {
    _.assert( !!o.body.defaults );
    return function headWithDefaults( routine, args )
    {
      _.assert( args.length <= nargs+1 );
      _.assert( arguments.length === 2 );
      let o = _.routine.options( routine, args[ nargs ] || Object.create( null ) );
      return _.unroll.from([ ... Array.prototype.slice.call( args, 0, nargs ), o ]);
    }
  }

  /* */

  function headWithoutDefaults( routine, args )
  {
    let o = args[ 0 ];
    _.assert( arguments.length === 2 );
    _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
    _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
    return o || null;
  }

  /* */

  function headWithDefaults( routine, args )
  {
    let o = args[ 0 ];
    _.assert( arguments.length === 2 );
    _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );
    _.assert( args.length === 0 || o === undefined || o === null || _.auxIs( o ) );
    return _.routine.options( routine, o || Object.create( null ) );
  }

  /* */

  function _unite_functor()
  {
    const name = arguments[ 0 ];
    const head = arguments[ 1 ];
    const body = arguments[ 2 ];
    const tail = arguments[ 3 ];
    let r;

    _.assert( head === null || _.routineIs( head ) );
    _.assert( body === null || _.routineIs( body ) );
    _.assert( tail === null || _.routineIs( tail ) );

    if( tail === null )
    r =
    {
      [ name ] : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        return result;
      }
    };
    else if( head === null )
    r =
    {
      [ name ] : function()
      {
        let result;
        let o = arguments[ 0 ];

        _.assert( arguments.length === 1, 'Expects single argument {-o-}.' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else if( _.mapIs( o ) )
        result = body.call( this, o );
        else
        _.assert( 0, 'Unexpected type of {-o-}, expects options map or unroll.' );

        result = tail.call( this, result, o );

        return result;
      }
    };
    else
    r =
    {
      [ name ] : function()
      {
        let result;
        let o = head.call( this, unitedRoutine, arguments );

        _.assert( !_.argumentsArray.is( o ), 'does not expect arguments array' );

        if( _.unrollIs( o ) )
        result = body.apply( this, o );
        else
        result = body.call( this, o );

        debugger;
        result = tail.call( this, result, o );

        return result;
      }
    };

    return r[ name ]
  }
}

unite_body.defaults =
{
  head : null,
  body : null,
  tail : null,
  name : null,
  strategy : null,
}

//

/* qqq : for Dmytro : write the article. it should explain why, when, what for! */
function uniteCloning()
{
  let o = uniteCloning.head.call( this, uniteCloning, arguments );
  let result = uniteCloning.body.call( this, o );
  return result;
}

uniteCloning.head = unite_head;
uniteCloning.body = unite_body;
uniteCloning.defaults = { ... unite_body.defaults, strategy : 'cloning' };

//

function uniteInheriting()
{
  let o = uniteInheriting.head.call( this, uniteInheriting, arguments );
  let result = uniteInheriting.body.call( this, o );
  return result;
}

uniteInheriting.head = unite_head;
uniteInheriting.body = unite_body;
uniteInheriting.defaults = { ... unite_body.defaults, strategy : 'inheriting' };

//

function uniteReplacing()
{
  let o = uniteReplacing.head.call( this, uniteReplacing, arguments );
  let result = uniteReplacing.body.call( this, o );
  return result;
}

uniteReplacing.head = unite_head;
uniteReplacing.body = unite_body;
uniteReplacing.defaults = { ... unite_body.defaults, strategy : 'replacing' };

//

function _compose_old_head( routine, args )
{
  let o = args[ 0 ];

  if( !_.mapIs( o ) )
  o = { bodies : args[ 0 ] };
  if( args[ 1 ] !== undefined )
  o.chainer = args[ 1 ];

  // if( o.bodies === null )
  // debugger;
  // o.bodies = _.arrayAppendArrays( [], [ o.bodies ] );
  // o.bodies = merge( o.bodies );

  o.bodies = __arrayFlatten( o.bodies );
  o.bodies = o.bodies.filter( ( e ) => e !== null );

  _.routine.options( routine, o );
  _.assert( _.routine.s.are( o.bodies ) );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( args.length === 1 || args.length === 2 );
  _.assert( args.length === 1 || !_.object.isBasic( args[ 0 ] ) );
  _.assert( _.arrayIs( o.bodies ) || _.routine.is( o.bodies ) );
  _.assert( _.routine.is( args[ 1 ] ) || args[ 1 ] === undefined || args[ 1 ] === null );
  _.assert( o.chainer === null || _.routine.is( o.chainer ) );
  _.assert( o.tail === null || _.routine.is( o.tail ) );

  return o;

  // function merge( arrays )
  // {
  //   let result = [];
  //   if( arrays === null )
  //   return result;
  //   for( let i = 0 ; i < arrays.length ; i++ )
  //   {
  //     let array = arrays[ i ];
  //     if( _.array.is( array ) || _.argumentsArray.is( array ) )
  //     result.push( ... array );
  //     else
  //     result.push( array );
  //   }
  //   return result;
  // }
}

_compose_old_head.locals =
{
  __arrayFlatten,
}

//

function _compose_old_body( o )
{

  if( o.chainer === null )
  o.chainer = _.routine.chainer.default;

  // if( o.chainer === null )
  // o.chainer = _.routine.chainer.original;
  // o.bodies = __arrayFlatten( o.bodies );

  let bodies = [];
  for( let s = 0 ; s < o.bodies.length ; s++ )
  {
    let src = o.bodies[ s ];
    _.assert( _.routine.is( src ) );
    if( src.composed )
    {
      if( src.composed.chainer === o.chainer && src.composed.tail === o.tail )
      {
        bodies.push( ... src.composed.elements );
      }
      else
      {
        bodies.push( ... src );
      }
    }
    else
    {
      bodies.push( src );
    }
  }

  o.bodies = bodies;

  let tail = o.tail;
  let chainer = o.chainer;
  let act;

  _.assert( _.routine.is( chainer ) );
  _.assert( tail === null || _.routine.is( tail ) );

  /* */

  if( bodies.length === 0 )
  act = function empty()
  {
    return [];
  }
  else act = function composition()
  {
    let result = [];
    let args = _.unroll.from( arguments );
    for( let k = 0 ; k < bodies.length ; k++ )
    {
      // _.assert( _.unrollIs( args ), () => `Expects unroll, but got ${_.entity.strType( args )}` );
      let routine = bodies[ k ];
      let r = routine.apply( this, args );
      _.assert( !_.argumentsArray.is( r ) );
      if( r !== undefined )
      _.unrollAppend( result, r );
      args = chainer( args, r, o, k );
      _.assert( args !== undefined && args !== false );
      if( args === _.dont )
      break;
      args = _.unroll.from( args );
    }
    return result;
  }

  o.act = act;
  act.composed = o;

  if( tail )
  {
    _.routine.extend( compositionSupervise, act );
    return compositionSupervise;
  }

  return act;

  function compositionSupervise()
  {
    // let result = tail( this, arguments, act, o );
    let result = tail.call( this, arguments, o );
    return result;
  }
}

_compose_old_body.defaults =
{
  bodies : null,
  chainer : null,
  tail : null,
}

//

function compose_old()
{
  let o = _.routine.s.compose_old.head( compose_old, arguments );
  let result = _.routine.s.compose_old.body( o );
  return result;
}

compose_old.head = _compose_old_head;
compose_old.body = _compose_old_body;
compose_old.defaults = Object.assign( Object.create( null ), compose_old.body.defaults );

//

function _compose_head( routine, args )
{
  let o = args[ 0 ];

  if( !_.mapIs( o ) )
  o = { bodies : args[ 0 ] };
  if( args[ 1 ] !== undefined )
  o.chainer = args[ 1 ];

  // if( o.bodies === null )
  // debugger;
  // o.bodies = _.arrayAppendArrays( [], [ o.bodies ] );
  // o.bodies = merge( o.bodies );

  // let bodies2 = __arrayFlatten( o.bodies );
  // if( bodies2.length && bodies2[ 0 ] === undefined )
  // debugger;

  o.bodies = __arrayFlatten( o.bodies );
  o.bodies = o.bodies.filter( ( e ) => e !== null );

  _.routine.options( routine, o );
  _.assert( _.routine.s.are( o.bodies ) );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( args.length === 1 || args.length === 2 );
  _.assert( args.length === 1 || !_.object.isBasic( args[ 0 ] ) );
  _.assert( _.arrayIs( o.bodies ) || _.routine.is( o.bodies ) );
  _.assert( _.routine.is( args[ 1 ] ) || args[ 1 ] === undefined || args[ 1 ] === null );
  _.assert( o.chainer === null || _.routine.is( o.chainer ) );
  _.assert( o.tail === null || _.routine.is( o.tail ) );

  return o;

  // function merge( arrays )
  // {
  //   let result = [];
  //   if( arrays === null )
  //   return result;
  //   for( let i = 0 ; i < arrays.length ; i++ )
  //   {
  //     let array = arrays[ i ];
  //     if( _.array.is( array ) || _.argumentsArray.is( array ) )
  //     result.push( ... array );
  //     else
  //     result.push( array );
  //   }
  //   return result;
  // }
}

_compose_head.locals =
{
  __arrayFlatten,
}

//

function _compose_body( o )
{

  // if( o.chainer === null )
  // o.chainer = defaultChainer;
  // o.bodies = __arrayFlatten( o.bodies );
  if( o.chainer === null )
  o.chainer = _.routine.chainer.default;

  let bodies = [];
  for( let s = 0 ; s < o.bodies.length ; s++ )
  {
    let body = o.bodies[ s ];
    _.assert( _.routine.is( body ) );
    if( body.composed )
    {
      if( body.composed.chainer === o.chainer && body.composed.tail === o.tail )
      {
        bodies.push( ... body.composed.elements );
      }
      else
      {
        bodies.push( ... body );
      }
    }
    else
    {
      bodies.push( body );
    }
  }

  o.bodies = bodies;

  let tail = o.tail;
  let chainer = o.chainer;

  _.assert( _.routine.is( chainer ) );
  _.assert( tail === null || _.routine.is( tail ) );

  /* */

  if( bodies.length === 0 )
  o.act = compositionEmpty;
  else if( bodies.length === 1 )
  o.act = compositionOfSingle;
  else
  o.act = composition;

  o.act.composed = o;

  if( tail )
  {
    _.routine.extendReplacing( routineWithTail, o.act );
    return routineWithTail;
  }

  return o.act;

  /* */

  function compositionEmpty()
  {
    return [];
  }

  function compositionOfSingle()
  {
    let result = [];
    let args = _.unroll.from( arguments );
    // _.assert( _.unrollIs( args ), () => `Expects unroll, but got ${_.entity.strType( args )}` );
    let routine = bodies[ 0 ];
    let r = routine.apply( this, args );
    _.assert( !_.argumentsArray.is( r ) );
    if( r !== undefined )
    _.unrollAppend( result, r );
    return result;
  }

  function composition()
  {
    let result = [];
    let args = _.unroll.from( arguments );
    for( let k = 0 ; k < bodies.length ; k++ )
    {
      // _.assert( _.unrollIs( args ), () => `Expects unroll, but got ${_.entity.strType( args )}` );
      let routine = bodies[ k ];
      let r = routine.apply( this, args );
      _.assert( !_.argumentsArray.is( r ) );
      if( r !== undefined )
      _.unrollAppend( result, r );
      args = chainer( args, r, o, k );
      if( args === _.dont )
      break;
      _.assert( _.unroll.is( args ) );
    }
    return result;
  }

  // function defaultChainer( /* args, result, op, k */ )
  // {
  //   let args = arguments[ 0 ];
  //   let result = arguments[ 1 ];
  //   let op = arguments[ 2 ];
  //   let k = arguments[ 3 ];
  //   if( result === _.dont )
  //   return result;
  //   return args;
  // }

  function routineWithTail()
  {
    let result = tail.call( this, arguments, o );
    return result;
  }
}

_compose_body.defaults =
{
  chainer : null,
  bodies : null,
  tail : null,
}

//

function compose()
{
  let o = _.routine.s.compose.head( compose, arguments );
  let result = _.routine.s.compose.body( o );
  return result;
}

compose.head = _compose_head;
compose.body = _compose_body;
compose.defaults = _compose_body.defaults;

// --
// chainers
// --

function defaultChainer( /* args, result, op, k */ )
{
  let args = arguments[ 0 ];
  let result = arguments[ 1 ];
  let op = arguments[ 2 ];
  let k = arguments[ 3 ];
  if( result === _.dont )
  return result;
  return args;
}

// --
// declaration
// --

let ChainerExtension =
{
  default : defaultChainer,
}

Object.assign( _.routine.chainer, ChainerExtension );

// --
// routine extension
// --

let RoutineExtension =
{

  // fields

  NamespaceName : 'routine',
  NamespaceNames : [ 'routine' ],
  NamespaceQname : 'wTools/routine',
  TypeName : 'Routine',
  TypeNames : [ 'Routine', 'Function' ],
  // SecondTypeName : 'Function',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is,
  _is,
  like,
  _like,
  isTrivial,
  isSync,
  isAsync,
  isGenerator,
  isSyncGenerator,
  isAsyncGenerator,
  withName,

  // joiner

  _join,
  constructorJoin,
  join,
  seal,

  // option

  optionsWithoutUndefined,
  assertOptionsWithoutUndefined,
  optionsWithUndefined,
  optionsWithUndefinedTollerant,
  assertOptionsWithUndefined,
  options : optionsWithUndefined,
  assertOptions : assertOptionsWithUndefined,
  options_ : optionsWithUndefined,
  optionsTollerant : optionsWithUndefinedTollerant,
  assertOptions_ : assertOptionsWithUndefined,
  _verifyDefaults,

  // options_deprecated,
  // assertOptions_deprecated,
  // optionsPreservingUndefines_deprecated,
  // assertOptionsPreservingUndefines_deprecated,

  // amend

  _amend,
  extend : extendCloning,
  extendCloning,
  extendInheriting,
  extendReplacing,
  defaults,

  // unite

  unite : uniteReplacing,
  uniteCloning,
  uniteCloning_replaceByUnite : uniteCloning,
  uniteInheriting,
  uniteReplacing,
  /* qqq : cover routines uniteReplacing, uniteInheriting, uniteCloning */

}

Object.assign( _.routine, RoutineExtension );

// --
// routines extension
// --

let RoutinesExtension =
{

  are,
  compose_old,
  compose,

}

Object.assign( _.routines, RoutinesExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  routineIs : is.bind( _.routine ),
  _routineIs : _is.bind( _.routine ),
  routineLike : like.bind( _.routine ),
  _routineLike : _like.bind( _.routine ),
  routineIsTrivial : isTrivial.bind( _.routine ),
  routineIsSync : isSync.bind( _.routine ),
  routineIsAsync : isAsync.bind( _.routine ),
  routinesAre : are.bind( _.routine ),
  routineWithName : withName.bind( _.routine ),

  routineIsGenerator : isGenerator.bind( _.routine ),
  routineIsSyncGenerator : isSyncGenerator.bind( _.routine ),
  routineIsAsyncGenerator : isAsyncGenerator.bind( _.routine ),

  _routineJoin : _join.bind( _.routine ),
  constructorJoin : constructorJoin.bind( _.routine ),
  routineJoin : join.bind( _.routine ),
  routineSeal : seal.bind( _.routine ),

  routineExtend : extendCloning.bind( _.routine ),
  routineDefaults : defaults.bind( _.routine ),

  routinesCompose : compose.bind( _.routines ), /* xxx : review */

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Routine.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Routine_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Routine_s */ })();

/* */  /* begin of file Seeker_s */ ( function Seeker_s() { function Seeker_s_naked() { ( function _l1_Seeker_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.seeker = _.seeker || Object.create( null );

// --
// implementation
// --

// --
// seeker extension
// --

let SeekerExtension =
{
}

Object.assign( _.seeker, SeekerExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Seeker.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Seeker_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Seeker_s */ })();

/* */  /* begin of file Set_s */ ( function Set_s() { function Set_s_naked() { ( function _l1_Set_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.set = _.set || Object.create( null );
_.sets = _.set.s = _.sets || _.set.s || Object.create( null );

// --
// implementation
// --

function is( src )
{
  if( !src )
  return false;
  return src instanceof Set || src instanceof WeakSet;
}

//

function like( src )
{
  return _.set.is( src );
}

//

function isEmpty()
{
  return !src.size;
}

//

function isPopulated()
{
  return !!src.size;
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return true;
}

// --
// maker
// --

function _makeEmpty( src )
{
  return new Set();
}

//

function makeEmpty( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  _.assert( this.like( src ) );
  return this._makeEmpty( src );
}

//

function _makeUndefined( src, length )
{
  return new Set();
}

//

function makeUndefined( src, length )
{
  _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 2 )
  {
    _.assert( this.like( src ) );
    _.assert( _.number.is( length ) );
  }
  else if( arguments.length === 1 )
  {
    _.assert( _.number.is( src ) || this.like( src ) );
  }

  return new Set();
}

//

function _make( src, length )
{
  if( length === 0 )
  return new Set();
  else if( _.number.is( src ) )
  return new Set();
  else
  return new Set([ ... src ]);
}

//

function make( src, length )
{
  _.assert( arguments.length === 0 || src === null || _.countable.is( src ) || src === 0 );
  _.assert( arguments.length < 2 || length === 0 );
  _.assert( arguments.length <= 2 );
  return this._make( ... arguments );
}

//

function _cloneShallow( src )
{
  return new Set([ ... src ]);
}

//

function cloneShallow( src )
{
  _.assert( _.countable.is( src ) );
  _.assert( arguments.length === 1 );
  return this._cloneShallow( src );
}

//

function from( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( this.is( src ) )
  return src;

  if( _.containerAdapter.is( src ) )
  src = src.toArray().original;

  return this.make( src );
}

// //
//
// function from( src )
// {
//   _.assert( arguments.length === 1 );
//   if( _.set.adapterLike( src ) )
//   return src;
//   if( src === null )
//   return new Set();
//   if( _.containerAdapter.is( src ) )
//   src = src.toArray().original;
//   _.assert( _.longIs( src ) );
//   return new Set([ ... src ]);
// }

//

/* qqq : for junior : cover please */
function as( src )
{
  _.assert( src !== undefined );
  if( src === null )
  return new Set;
  else if( _.set.is( src ) )
  return src;
  else if( _.countable.like( src ) )
  return new Set([ ... src ]);
  else
  return new Set([ src ]);
}

// //
//
// function asTest( src )
// {
//   if( src === null || src === undefined )
//   return new Set;
//   if( src[ Symbol.iterator ] && !_.str.is( src ) )
//   return new Set( [ ... src ] );
//   if( src instanceof WeakSet )
//   return src;
//
//   return new Set( [ src ] );
// }

// //
//
// function setsFrom( srcs )
// {
//   _.assert( arguments.length === 1 );
//   _.assert( _.longIs( srcs ) );
//   let result = [];
//   for( let s = 0, l = srcs.length ; s < l ; s++ )
//   result[ s ] = _.set.from( srcs[ s ] );
//   return result;
// }

// --
// properties
// --

function _keys( src )
{
  return [ ... src.keys() ];
}

//

function keys( src )
{
  _.assert( this.like( src ) );
  return this._keys( src );
}

//

function _vals( src )
{
  return [ ... src.values() ];
}

//

function vals( src )
{
  _.assert( this.like( src ) );
  return this._vals( src );
}

//

function _pairs( src )
{
  return [ ... src.entries() ];
}

//

function pairs( src )
{
  _.assert( this.like( src ) );
  return this._pairs( src );
}

// --
// set extension
// --

let SetExtension =
{

  //

  NamespaceName : 'set',
  NamespaceNames : [ 'set' ],
  NamespaceQname : 'wTools/set',
  MoreGeneralNamespaceName : 'set',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'Set',
  TypeNames : [ 'Set' ],
  InstanceConstructor : Set,
  tools : _,

  // dichotomy

  is,
  like,
  // adapterLike,
  isEmpty,
  isPopulated,
  IsResizable,

  // maker

  _makeEmpty,
  makeEmpty, /* qqq : for junior : cover */
  _makeUndefined,
  makeUndefined, /* qqq : for junior : cover */
  _make,
  make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow, /* qqq : for junior : cover */
  from,
  as,
  // asTest,

  // properties

  _keys,
  keys, /* qqq : for junior : cover */
  _vals,
  vals, /* qqq : for junior : cover */
  _pairs,
  pairs, /* qqq : for junior : cover */

  // meta

  namespaceOf : _.blank.namespaceOf,
  namespaceWithDefaultOf : _.blank.namespaceWithDefaultOf,
  _functor_functor : _.blank._functor_functor,

}

Object.assign( _.set, SetExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  // dichotomy

  setIs : is.bind( _.set ),
  setIsEmpty : isEmpty.bind( _.set ),
  setIsPopulated : isPopulated.bind( _.set ),
  setLike : like.bind( _.set ),

  // maker

  setMakeEmpty : makeEmpty.bind( _.set ),
  setMakeUndefined : makeUndefined.bind( _.set ),
  setMake : make.bind( _.set ),
  setCloneShallow : cloneShallow.bind( _.set ),
  setFrom : from.bind( _.set ),
  setAs : as.bind( _.set ),

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Set.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Set_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Set_s */ })();

/* */  /* begin of file Sorted_s */ ( function Sorted_s() { function Sorted_s_naked() { ( function _l1_Sorted_s_()
{

'use strict';

//

const _global = _global_;
const _ = _global_.wTools;
const Self = _.sorted = _.sorted || Object.create( null );

// --
//
// --

// --
// extension
// --

let Extension =
{
};

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Sorted.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Sorted_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Sorted_s */ })();

/* */  /* begin of file Str_s */ ( function Str_s() { function Str_s_naked() { ( function _l1_Str_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.str = _.str || Object.create( null );
_.str.lines = _.str.lines || Object.create( null );

// --
// str
// --

/**
 * Function strIs checks incoming param whether it is string.
 * Returns "true" if incoming param is string. Othervise "false" returned
 *
 * @example
 * _.strIsIs( 'song' );
 * // returns true
 *
 * @example
 * _.strIs( 5 );
 * // returns false
 *
 * @param {*} src.
 * @return {Boolean}.
 * @function strIs.
 * @namespace Tools
 */

function is( src )
{
  let result = Object.prototype.toString.call( src ) === '[object String]';
  return result;
}

//

function like( src )
{
  if( _.str.is( src ) )
  return true;
  if( _.regexp.is( src ) )
  return true;
  return false;
}

//

function strsAreAll( src )
{
  _.assert( arguments.length === 1 );

  if( _.argumentsArray.like( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.strIs( src[ s ] ) )
    return false;
    return true;
  }

  return _.strIs( src );
}

//

// function regexpLike( src )
// {
//   if( _.strIs( src ) )
//   return true;
//   if( _.regexpIs( src ) )
//   return true;
//   return false
// }
//
// //
//
// function strsLikeAll( src )
// {
//   _.assert( arguments.length === 1 );
//
//   if( _.argumentsArray.like( src ) )
//   {
//     for( let s = 0 ; s < src.length ; s++ )
//     if( !_.regexpLike( src[ s ] ) )
//     return false;
//     return true;
//   }
//
//   return regexpLike( src );
// }

//

function defined( src )
{
  if( !src )
  return false;
  let result = Object.prototype.toString.call( src ) === '[object String]';
  return result;
}

//

function strsDefined( src )
{
  if( _.argumentsArray.like( src ) )
  {
    for( let s = 0 ; s < src.length ; s++ )
    if( !_.strDefined( src[ s ] ) )
    return false;
    return true;
  }
  return false;
}

//

function has( src, ins )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), () => `Expects string, got ${_.entity.strType( src )}` );
  _.assert( _.regexpLike( ins ), () => `Expects string-like, got ${_.entity.strType( ins )}` );

  if( _.strIs( ins ) )
  return src.indexOf( ins ) !== -1;
  else
  return ins.test( src );

}

// --
// converter
// --

/**
 * Returns source string( src ) with limited number( limit ) of characters.
 * For example: src : 'string', limit : 4, result -> 'stng'.
 * Function can be called in two ways:
 * - First to pass only source string and limit;
 * - Second to pass all options map. Example: ({ src : 'string', limit : 5, delimeter : '.' }).
 *
 * @param {string|object} o - String to parse or object with options.
 * @param {string} [ o.src=null ] - Source string.
 * @param {number} [ o.limit=40 ] - Limit of characters in output.
 * @param {string} [ o.delimeter=null ] - The middle part to fill the reduced characters, if boolLikeTrue - the default ( '...' ) is used.
 * @param {function} [ o.onLength=null ] - callback function that calculates a length based on .
 * @returns {string} Returns simplified source string.
 *
 * @example
 * _.strShort_( 'string', 4 );
 * // returns o, o.result = 'stng'
 *
 * @example
 * _.strShort_( 'a\nb', 3 );
 * // returns o, o.result = 'a\nb'
 *
 * @example
 * _.strShort_( 'string', 0 );
 * // returns o, o.result = ''
 *
 * @example
 * _.strShort_({ src : 'string', limit : 4 });
 * // returns o, o.result = 'stng'
 *
 * @example
 *  _.strShort_({ src : 'string', limit : 3, cutting : 'right' });
 * // returns o, o.result = 'str'
 *
 * @example
 * _.strShort_({ src : 'st\nri\nng', limit : 1, heightLimit : 2, cutting : 'left', heightCutting : 'right' });
 * // returns o, o.result = 't\ni'
 *
 * @method short_
 * @throws { Exception } If no argument provided.
 * @throws { Exception } If( arguments.length ) is not equal 1 or 2.
 * @throws { Exception } If( o ) is extended with unknown property.
 * @throws { Exception } If( o.src ) is not a String.
 * @throws { Exception } If( o.limit ) is not a Number.
 * @throws { Exception } If( o.delimeter ) is not a String or null or boolLikeTrue.
 *
 * @namespace Tools
 *
 */

function short_( o )  /* version with binary search cutting */
{

  if( arguments.length === 2 )
  o = { src : arguments[ 0 ], widthLimit : arguments[ 1 ] };
  else if( arguments.length === 1 )
  if( _.strIs( o ) )
  o = { src : arguments[ 0 ] };

  _.routine.options( short_, o );

  _.assert( _.strIs( o.src ) );
  _.assert( _.number.is( o.widthLimit ) );
  _.assert( o.widthLimit >= 0, 'Option::o.widthLimit must be greater or equal to zero' );
  _.assert
  (
    _.number.is( o.heightLimit ) && o.heightLimit >= 0,
    'If provided option::o.heightLimit must be greater or equal to zero'
  );
  _.assert( o.delimeter === null || _.strIs( o.delimeter ) || _.bool.likeTrue( o.delimeter ));
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( !o.delimeter )
  o.delimeter = '';
  if( !o.heightDelimeter )
  o.heightDelimeter = '';
  if( o.widthLimit === 0 )
  o.widthLimit = Infinity;
  if( o.heightLimit === 0 )
  o.heightLimit = Infinity;

  if( _.bool.likeTrue( o.delimeter ) )
  o.delimeter = '...';

  if( !o.onLength )
  o.onLength = ( src ) => src.length;

  let src = o.src;

  let isOneLine = o.src.indexOf( '\n' ) === -1;

  if( isOneLine && o.onLength( o.src ) < o.widthLimit )
  {
    o.changed = false;
    o.result = o.src;

    return o;
  }

  let options = Object.create( null ); /* width cutting options */
  options.limit = o.widthLimit;
  options.delimeter = o.delimeter;
  options.onLength = o.onLength;
  options.cutting = o.cutting;

  if( isOneLine )
  {
    options.src = src;
    _.strShortWidth( options );

    o.result = options.result;
    o.changed = options.changed;

    return o;
  }
  else
  {
    let splitted = o.src.split( '\n' );

    let options2 = Object.create( null );  /* height cutting */
    options2.src = splitted;
    options2.limit = o.heightLimit;
    options2.delimeter = o.heightDelimeter;
    options2.cutting = o.heightCutting;
    _._strShortHeight( options2 );

    options.src = options2.result;

    _._strShortWidth( options );

    let result = options.result.join( '\n' );

    if( result === o.src )
    o.changed = false;
    else if( result !== o.src )
    o.changed = true;

    o.result = result;

    return o;
  }
}

short_.defaults =
{
  src : null,
  widthLimit : 40,
  heightLimit : 0,
  delimeter : null, /* xxx qqq : rename to 'widthDelimeter' */
  heightDelimeter : null,
  onLength : null,
  cutting : 'center', /* xxx qqq : rename to 'widthCutting' */
  heightCutting : 'center',
}

//

function shortWidth( o )
{

  if( arguments.length === 2 )
  o = { src : arguments[ 0 ], limit : arguments[ 1 ] };
  else if( arguments.length === 1 )
  if( _.strIs( o ) )
  o = { src : arguments[ 0 ] };

  _.routine.options( shortWidth, o );

  _.assert( _.strIs( o.src ) );
  _.assert( _.number.is( o.limit ) );
  _.assert( o.limit >= 0, 'Option::o.limit must be greater or equal to zero' );
  _.assert( o.delimeter === null || _.strIs( o.delimeter ) || _.bool.likeTrue( o.delimeter ));
  _.assert( arguments.length === 1 || arguments.length === 2 );

  let originalSrc = o.src;

  if( !o.delimeter )
  o.delimeter = '';
  if( o.limit === 0 )
  o.limit = Infinity;

  if( _.bool.likeTrue( o.delimeter ) )
  o.delimeter = '...';

  if( !o.onLength )
  o.onLength = ( src ) => src.length;

  let splitted = o.src.split( '\n' );

  o.src = splitted;
  _._strShortWidth( o );

  o.src = originalSrc;
  o.result = o.result.join( '\n' );

  return o;
}

shortWidth.defaults =
{
  src : null,
  limit : 40,
  onLength : null,
  cutting : 'center',
  delimeter : null
}

//

function _shortWidth( o )
{
  /*
    input : array of lines
    output : array of lines ( each cutted down to o.limit )
  */
  _.assert( _.arrayIs( o.src ) );
  _.routine.options( _shortWidth, o );

  let begin = '';
  let end = '';
  let fixLength = o.onLength( o.delimeter );

  o.changed = false;

  let result = o.src.map( ( el ) =>
  {
    let delimeter = o.delimeter;
    fixLength = o.onLength( o.delimeter );

    if( fixLength === o.limit )
    {
      o.changed = true;
      return o.delimeter;
    }
    else if( o.onLength( el ) + fixLength <= o.limit ) /* nothing to cut */
    {
      return el;
    }
    else
    {
      if( o.onLength( delimeter ) > o.limit )
      {
        el = delimeter;
        delimeter = '';
        fixLength = 0;
      }

      o.changed = true;

      if( o.cutting === 'left' )
      {
        return delimeter + cutLeft( el );
      }
      else if( o.cutting === 'right' )
      {
        return cutRight( el ) + delimeter;
      }
      else
      {
        let [ begin, end ] = cutMiddle( el );
        return begin + delimeter + end;
      }
    }
  });

  o.result = result;

  return o;

  /* - */

  function cutLeft( src )
  {
    let startIndex = 0;
    let endIndex = src.length - 1;
    let endLength = o.onLength( src );
    let middleIndex = src.length - o.limit - 1; /* optimize default option::onLength */

    while( endLength + fixLength > o.limit ) /* binary */
    {
      [ begin, end ] = splitInTwo( src, middleIndex + 1 );
      endLength = o.onLength( end );

      startIndex = middleIndex; /* all needed elements are in end */
      middleIndex = Math.floor( ( startIndex + endIndex ) / 2 );
    }

    while( o.onLength( end ) + fixLength <= o.limit ) /* add elements till o.limit is satisfied */
    {
      /*
        add elements and parts of element that might have been sliced,
        example : onLength considers as 1 element substring of the same characters
                  'aabbccdd' with o.limit = 2 might return 'cdd', but need 'ccdd'
      */
      end = begin[ begin.length - 1 ] + end;
      begin = begin.slice( 0, -1 );
    }

    return end.slice( 1 );
  }

  //

  function cutRight( src )
  {
    let startIndex = 0;
    let endIndex = src.length - 1;
    let beginLength = o.onLength( src );
    let middleIndex = o.limit; /* optimize default option::onLength */

    while( beginLength + fixLength > o.limit ) /* binary */
    {
      [ begin, end ] = splitInTwo( src, middleIndex );
      beginLength = o.onLength( begin );

      endIndex = middleIndex; /* all needed elements are in begin */
      middleIndex = Math.floor( ( startIndex + endIndex ) / 2 );
    }

    while( o.onLength( begin ) + fixLength <= o.limit ) /* add elements till o.limit is satisfied */
    {
      /*
        add elements and parts of element that might have been sliced,
        example : onLength considers as 1 element substring of the same characters
                  'aabbccdd' with o.limit = 2 might return 'aab', but need 'aabb'
      */
      begin += end[ 0 ];
      end = end.slice( 1 );
    }

    return begin.slice( 0, -1 );
  }

  //

  function cutMiddle( src )
  {
    let originalStr = src;
    let chunkSize, middleIndexLeft, middleIndexRight;

    if( o.limit % 2 === 0 ) /* optimize default option::onLength */
    {
      middleIndexLeft = ( o.limit / 2 ) - 1;
      middleIndexRight = ( -o.limit / 2 ) + src.length;
    }
    else
    {
      middleIndexLeft = Math.floor( ( o.limit / 2 ) );
      middleIndexRight = Math.ceil( ( -o.limit / 2 ) ) + src.length;
    }

    while( o.onLength( src ) + fixLength > o.limit ) /* binary */
    {
      if( src.length <= 5 ) /* src.length = 4 || 3 || 2, base case */
      {
        let index = Math.floor( src.length / 2 );
        begin = src.slice( 0, index );
        end = src.slice( index+1 );
      }
      else /* begin : first 1/3, end : last 1/3 */
      {
        begin = src.slice( 0, middleIndexLeft + 1 );
        end = src.slice( middleIndexRight );
      }

      /* delete middle, might delete part of the element, check later when desired length is obtained */
      src = begin + end;

      chunkSize = Math.floor( src.length / 3 ); /* split str into 3 'equal' parts, middle is to be removed */
      middleIndexLeft = chunkSize;
      middleIndexRight = chunkSize * 2;
    }

    while( o.onLength( begin + end ) + fixLength < o.limit ) /* overcut */
    {
      if( o.onLength( begin ) > o.onLength( end ) ) /* shrink middle from the right */
      {
        end = originalStr.slice( -end.length - 1 );
      }
      else                                          /* shrink middle from the left */
      {
        begin = originalStr.slice( 0, begin.length + 1 );
      }
    }

    /*
      add parts of elements that might have been sliced,
      example : onLength considers as 1 element substring of the same characters
                'aabbccdd' with o.limit = 2 might return 'ad', but need 'aadd'
    */

    let beginInitial = o.onLength( begin );
    let endInitial = o.onLength( end );

    while( o.onLength( begin ) === beginInitial ) /* try to increase begin */
    {
      begin = originalStr.slice( 0, begin.length + 1 );;
    }

    while( o.onLength( end ) === endInitial ) /* try to increase end */
    {
      end = originalStr.slice( -end.length - 1 );
    }

    return [ begin.slice( 0, -1 ), end.slice( 1 ) ];
  }

  //

  function splitInTwo( src, middle )
  {
    let begin = src.slice( 0, middle );
    let end = src.slice( middle );
    return [ begin, end ];
  }

}

_shortWidth.defaults =
{
  src : null,
  limit : 40,
  delimeter : null,
  onLength : null,
  cutting : 'center',
}

//

function shortHeight( o )
{

  if( arguments.length === 2 )
  o = { src : arguments[ 0 ], limit : arguments[ 1 ] };
  else if( arguments.length === 1 )
  if( _.strIs( o ) )
  o = { src : arguments[ 0 ] };

  _.routine.options( shortHeight, o );

  _.assert( _.strIs( o.src ) );
  _.assert
  (
    ( _.number.is( o.limit ) && o.limit >= 0 ),
    'option::o.limit must be greater or equal to zero'
  );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  let originalSrc = o.src;
  let splitted = o.src.split( '\n' );

  if( !o.delimeter )
  o.delimeter = '';

  o.src = splitted;

  _._strShortHeight( o );
  o.src = originalSrc;
  o.result = o.result.join( '\n' );

  return o;

}

shortHeight.defaults =
{
  src : null,
  limit : null,
  cutting : 'center',
  delimeter : null,
}

//

function _shortHeight( o )  /* version with binary search cutting */
{
  /*
    input : array of lines
    output : array of lines ( cutted down to o.limit )
  */

  _.assert( _.arrayIs( o.src ) );
  _.routine.options( shortHeight, o );

  o.changed = false;

  let delimeterLength = o.delimeter === '' ? 0 : 1;

  if( delimeterLength === o.limit )
  {
    o.changed = true;
    o.result = [ o.delimeter ];

    return o;
  }

  let result = cut( o.src.slice() );
  o.result = result;

  return o;

  /* - */

  function cut( src )
  {
    if( src.length + delimeterLength > o.limit )
    {
      o.changed = true;

      if( o.cutting === 'left' )
      {
        src = src.slice( - ( o.limit - delimeterLength ) );

        if( o.delimeter !== '' )
        src.unshift( o.delimeter );
      }
      else if( o.cutting === 'right' )
      {
        src = src.slice( 0, o.limit - delimeterLength );

        if( o.delimeter !== '' )
        src.push( o.delimeter );
      }
      else
      {
        let [ left, right ] = handleHeightCuttingCenter( src );
        let result = [];

        result.push( ... left );

        if( o.delimeter !== '' )
        result.push( o.delimeter );

        if( right !== undefined ) /* no right when o.limit = 2 and there is a delimeter */
        result.push( ... right );

        src = result;

      }
    }

    return src;
  }

  //

  function handleHeightCuttingCenter( src )
  {
    let indexLeft, indexRight;

    let limit = o.limit - delimeterLength;

    if( limit === 1 )
    {
      return [ src.slice( 0, 1 ) ];
    }
    else if( limit % 2 === 0 )
    {
      indexLeft = limit / 2;
      indexRight = -indexLeft;
    }
    else
    {
      indexLeft = Math.floor( ( limit / 2 ) ) + 1;
      indexRight = -indexLeft + 1;
    }

    let splittedLeft = src.slice( 0, indexLeft );
    let splittedRight = src.slice( indexRight );

    return [ splittedLeft, splittedRight ];
  }

}

_shortHeight.defaults =
{
  src : null,
  limit : null,
  cutting : 'center',
  prefix : null,
  postfix : null,
  infix : null,
}

//

/**
 * The routine concat() provides the concatenation of array of elements ( or single element )
 * into a String. Returned string can be formatted by using options in options map {-o-}.
 *
 * @example
 * _.strConcat( 'str' );
 * // returns : 'str'
 *
 * @example
 * _.strConcat( 11 );
 * // returns : '11'
 *
 * @example
 * _.strConcat([ 1, 2, 'str', [ 3, 4 ] ]);
 * // returns : '1 2 str 3,4 '
 *
 * @example
 * let options =
 * {
 *   linePrefix : '** ',
 *   linePostfix : ' **'
 * };
 * _.strConcat( [ 1, 2, 'str', [ 3, 4 ] ], options );
 * // returns : '** 1 2 str 3,4 **'
 *
 * @example
 * let options =
 * {
 *   linePrefix : '** ',
 *   linePostfix : ' **'
 * };
 * _.strConcat( [ 'a\n', 'b\n', 'c' ], options );
 * // returns :
 * // `** a **
 * // ** b **
 * // ** c **
 *
 * @example
 * let onToStr = ( src ) => String( src ) + '*';
 * let options = { onToStr };
 * _.strConcat( [ 'a', 'b', 'c' ], options );
 * // returns : 'a* b* c*'
 *
 * @example
 * let onPairWithDelimeter = ( src1, src2 ) => src1 + ' ..' + src2;
 * let options = { onPairWithDelimeter };
 * _.strConcat( [ 'a\n', 'b\n', 'c' ], options );
 * // returns :
 * // `a ..
 * // b ..
 * // c`
 *
 * @param { ArrayLike|* } srcs - ArrayLike container with elements or single element to make string.
 * If {-srcs-} is not ArrayLike, routine converts to string provided instance.
 * @param { Map } o - Options map.
 * @param { String } o.lineDelimter - The line delimeter. Default value is new line symbol '\n'.
 * If an element of array has not delimeter at the end or next element has not delimeter at the begin,
 * then routine inserts one space between this elements.
 * @param { String } o.linePrefix - The prefix, which is added to each line. Default value is empty string.
 * @param { String } o.linePostfix - The postfix, which is added to each line. Default value is empty string.
 * @param { Map } o.optionsForToStr - The options for routine _.entity.exportString that uses as default callback {-o.onToStr-}. Default value is null.
 * @param { Function } o.onToStr - The callback, which uses for conversion of each element of {-srcs-}. Accepts element {-src-} and options map {-o-}.
 * @param { Function } o.onPairWithDelimeter - The callback, which uses for concatenation of two strings.
 * The callback calls if first string {-src1-} end with line delimeter {-o.lineDelimter-} or second string {-src2-}
 * begins with line delimeter. Additionally accepts options map {-o-}.
 * @returns { String } - Returns concatenated string.
 * @function concat
 * @throws { Error } If arguments.length is less then one or greater than two.
 * @throws { Error } If options map {-o-} has unknown property.
 * @throws { Error } If property {-o.optionsForToStr-} is not a Aux.
 * @throws { Error } If routine concat does not belong module Tools.
 * @namespace Tools
 */

function concat( srcs, o )
{

  o = _.routine.options( concat, o || Object.create( null ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( this.strConcat === concat );

  if( o.onToStr === null )
  o.onToStr = onToStr;

  let defaultOptionsForToStr =
  {
    stringWrapper : '',
  };

  o.optionsForToStr = _.props.supplement( o.optionsForToStr, defaultOptionsForToStr );
  o.optionsForToStr.format = o.optionsForToStr.format || 'string.diagnostic';

  if( _.routine.is( srcs ) )
  srcs = srcs();

  if( !_.argumentsArray.like( srcs ) )
  srcs = [ srcs ];

  let result = '';
  if( !srcs.length )
  return result;

  let concatenatePairWithLineDelimeter = o.onPairWithDelimeter ? o.onPairWithDelimeter : concatenateSimple;

  /* */

  let a = 0;

  while( !result && a < srcs.length )
  {
    result = o.onToStr( srcs[ a ], o );
    ++a;
  }

  for( ; a < srcs.length ; a++ )
  {
    let src = srcs[ a ];
    src = o.onToStr( src, o );

    result = result.replace( /[^\S\n]\s*$/, '' );

    if( _.strEnds( result, o.lineDelimter ) || _.strBegins( src, o.lineDelimter ) )
    result = concatenatePairWithLineDelimeter( result, src, o );
    else
    result = `${result} ${src.replace( /^\s+/, '' )}`;
  }

  /* */

  if( o.linePrefix || o.linePostfix )
  {
    result = result.split( o.lineDelimter );
    result = o.linePrefix + result.join( o.linePostfix + o.lineDelimter + o.linePrefix ) + o.linePostfix;
  }

  /* */

  return result;

  /* */

  function onToStr( src, op )
  {
    return _.entity.exportString( src, op.optionsForToStr );
  }

  /* */

  function concatenateSimple( src1, src2 )
  {
    return src1 + src2;
  }
}

concat.defaults =
{
  linePrefix : '',
  linePostfix : '',
  lineDelimter : '\n',
  optionsForToStr : null,
  onToStr : null,
  onPairWithDelimeter : null,
}

//

function _beginOf( src, begin )
{

  // _.assert( _.strIs( src ), 'Expects string' );
  // _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.strIs( begin ) )
  {
    if( src.lastIndexOf( begin, 0 ) === 0 )
    return begin;
  }
  else if( _.regexpIs( begin ) )
  {
    let matched = begin.exec( src );
    if( matched && matched.index === 0 )
    return matched[ 0 ];
  }
  else _.assert( 0, 'Expects string-like ( string or regexp )' );

  return undefined;
}

//

function _endOf( src, end )
{

  // _.assert( _.strIs( src ), 'Expects string' );
  // _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.strIs( end ) )
  {
    if( src.indexOf( end, src.length - end.length ) !== -1 )
    return end;
  }
  else if( _.regexpIs( end ) )
  {
    // let matched = end.exec( src );
    let newEnd = RegExp( end.toString().slice(1, -1) + '$' );
    let matched = newEnd.exec( src );

    //if( matched && matched.index === 0 )
    if( matched && matched.index + matched[ 0 ].length === src.length )
    return matched[ 0 ];
  }
  else _.assert( 0, 'Expects string-like ( string or regexp )' );

  return undefined;
}

//

/**
 * Compares two strings.
 *
 * @param { String } src - Source string.
 * @param { String } begin - String to find at begin of source.
 *
 * @example
 * let scr = _.strBegins( "abc", "a" );
 * // returns true
 *
 * @example
 * let scr = _.strBegins( "abc", "b" );
 * // returns false
 *
 * @returns { Boolean } Returns true if param( begin ) is match with first chars of param( src ), otherwise returns false.
 * @function begins
 * @throws { Exception } If one of arguments is not a String.
 * @throws { Exception } If( arguments.length ) is not equal 2.
 * @namespace Tools
 */

function begins( src, begin )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( begin ) || _.regexpIs( begin ) || _.longIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( begin ) )
  {
    let result = _._strBeginOf( src, begin );
    return !( result === undefined );
    // return result === undefined ? false : true;
  }

  for( let b = 0, blen = begin.length ; b < blen; b++ )
  {
    let result = _._strBeginOf( src, begin[ b ] );
    if( result !== undefined )
    return true;
  }

  return false;
}

//

/**
 * Compares two strings.
 *
 * @param { String } src - Source string.
 * @param { String } end - String to find at end of source.
 *
 * @example
 * let scr = _.strEnds( "abc", "c" );
 * // returns true
 *
 * @example
 * let scr = _.strEnds( "abc", "b" );
 * // returns false
 *
 * @return { Boolean } Returns true if param( end ) is match with last chars of param( src ), otherwise returns false.
 * @function ends
 * @throws { Exception } If one of arguments is not a String.
 * @throws { Exception } If( arguments.length ) is not equal 2.
 * @namespace Tools
 */

function ends( src, end )
{

  _.assert( _.strIs( src ), () => `Expects argument::src of type::string, but got ${_.entity.strType( src )}` );
  _.assert( _.strIs( end ) || _.regexpIs( end ) || _.longIs( end ), 'Expects string/regexp or array of strings/regexps {-end-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( end ) )
  {
    let result = _._strEndOf( src, end );
    return !( result === undefined );
  }

  for( let b = 0, blen = end.length ; b < blen; b++ )
  {
    let result = _._strEndOf( src, end[ b ] );
    if( result !== undefined )
    return true;
  }

  return false;
}

//

/**
 * Finds occurrence of( end ) at the end of source( src ) and removes it if exists.
 * Returns begin part of a source string if occurrence was finded or empty string if arguments are equal, otherwise returns undefined.
 *
 * @param { String } src - The source string.
 * @param { String } end - String to find.
 *
 * @example
 * _.strBeginOf( 'abc', 'c' );
 * // returns 'ab'
 *
 * @example
 * _.strBeginOf( 'abc', 'x' );
 * // returns undefined
 *
 * @returns { String } Returns part of source string without tail( end ) or undefined.
 * @throws { Exception } If all arguments are not strings;
 * @throws { Exception } If ( argumets.length ) is not equal 2.
 * @function beginOf
 * @namespace Tools
 */

function beginOf( src, begin )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( begin ) || _.regexpIs( begin ) || _.longIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( begin ) )
  {
    let result = _._strBeginOf( src, begin );
    return result;
  }

  for( let b = 0, blen = begin.length ; b < blen ; b++ )
  {
    let result = _._strBeginOf( src, begin[ b ] );
    if( result !== undefined )
    return result;
  }

  return undefined;
}

//

/**
 * Finds occurrence of( begin ) at the begining of source( src ) and removes it if exists.
 * Returns end part of a source string if occurrence was finded or empty string if arguments are equal, otherwise returns undefined.
 * otherwise returns undefined.
 *
 * @param { String } src - The source string.
 * @param { String } begin - String to find.
 *
 * @example
 * _.strEndOf( 'abc', 'a' );
 * // returns 'bc'
 *
 * @example
 * _.strEndOf( 'abc', 'c' );
 * // returns undefined
 *
 * @returns { String } Returns part of source string without head( begin ) or undefined.
 * @throws { Exception } If all arguments are not strings;
 * @throws { Exception } If ( argumets.length ) is not equal 2.
 * @function endOf
 * @namespace Tools
 */

function endOf( src, end )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( end ) || _.regexpIs( end ) || _.longIs( end ), 'Expects string/regexp or array of strings/regexps {-end-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longIs( end ) )
  {
    let result = _._strEndOf( src, end );
    return result;
  }

  for( let b = 0, blen = end.length ; b < blen; b++ )
  {
    let result = _._strEndOf( src, end[ b ] );
    if( result !== undefined )
    return result;
  }

  return undefined;
}

//

/**
 * Finds substring prefix ( begin ) occurrence from the very begining of source ( src ) and removes it.
 * Returns original string if source( src ) does not have occurrence of ( prefix ).
 *
 * @param { String } src - Source string to parse.
 * @param { String } prefix - String that is to be dropped.
 * @returns { String } Returns string with result of prefix removement.
 *
 * @example
 * _.strRemoveBegin( 'example', 'exa' );
 * // returns mple
 *
 * @example
 * _.strRemoveBegin( 'example', 'abc' );
 * // returns example
 *
 * @function removeBegin
 * @throws { Exception } Throws a exception if( src ) is not a String.
 * @throws { Exception } Throws a exception if( prefix ) is not a String.
 * @throws { Exception } Throws a exception if( arguments.length ) is not equal 2.
 * @namespace Tools
 *
 */

function removeBegin( src, begin )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( begin ) || _.regexpIs( begin ), 'Expects string/regexp {-begin-}' );

  let result = src;
  let beginOf = _._strBeginOf( result, begin );
  if( beginOf !== undefined )
  result = result.substr( beginOf.length, result.length );
  return result;
}

//

/**
 * Removes occurrence of postfix ( end ) from the very end of string( src ).
 * Returns original string if no occurrence finded.
 * @param { String } src - Source string to parse.
 * @param { String } postfix - String that is to be dropped.
 * @returns { String } Returns string with result of postfix removement.
 *
 * @example
 * _.strRemoveEnd( 'example', 'le' );
 * // returns examp
 *
 * @example
 * _.strRemoveEnd( 'example', 'abc' );
 * // returns example
 *
 * @function removeEnd
 * @throws { Exception } Throws a exception if( src ) is not a String.
 * @throws { Exception } Throws a exception if( postfix ) is not a String.
 * @throws { Exception } Throws a exception if( arguments.length ) is not equal 2.
 * @namespace Tools
 *
 */

function removeEnd( src, end )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( _.strIs( end ) || _.regexpIs( end ), 'Expects string/regexp {-end-}' );

  let result = src;
  let endOf = _._strEndOf( result, end );
  if( endOf !== undefined )
  result = result.substr( 0, result.length - endOf.length );

  return result;
}

//

/**
 * Finds substring or regexp ( insStr ) first occurrence from the source string ( srcStr ) and removes it.
 * Returns original string if source( src ) does not have occurrence of ( insStr ).
 *
 * @param { String } srcStr - Source string to parse.
 * @param { String } insStr - String/RegExp that is to be dropped.
 * @returns { String } Returns string with result of substring removement.
 *
 * @example
 * _.strRemove( 'source string', 's' );
 * // returns ource tring
 *
 * @example
 * _.strRemove( 'example', 's' );
 * // returns example
 *
 * @function remove
 * @throws { Exception } Throws a exception if( srcStr ) is not a String.
 * @throws { Exception } Throws a exception if( insStr ) is not a String or a RegExp.
 * @throws { Exception } Throws a exception if( arguments.length ) is not equal 2.
 * @namespace Tools
 *
 */

function remove( srcStr, insStr )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( srcStr ), 'Expects string {-src-}' );
  _.assert( _.strIs( insStr ) || _.regexpIs( insStr ), 'Expects string/regexp {-begin-}' );

  let result = srcStr;

  result = result.replace( insStr, '' );

  return result;
}

// --
// str extension
// --

let StrExtension =
{

  // dichotomy

  is,
  like,

  defined,

  has,

  short_,
  _shortWidth,
  shortHeight,
  _shortHeight,

  concat,

  _beginOf,
  _endOf,

  begins,
  ends,

  beginOf,
  endOf,

  removeBegin,
  removeEnd,
  remove,

}

Object.assign( _.str, StrExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  // dichotomy

  strIs : is,
  strsAreAll,
  // regexpLike,
  // strsLikeAll,
  strDefined : defined,
  strsDefined,

  strHas : has,

  // converter

  strstrShort_ : short_, /* xxx : remove */
  strShort_ : short_,
  strShortWidth : shortWidth,
  _strShortWidth : _shortWidth,
  strShortHeight : shortHeight,
  _strShortHeight : _shortHeight,
  // strShort, /* original version without binary search cutting */
  // strShort_2, /* non-binary search implementation */
  strConcat : concat,

  //

  _strBeginOf : _beginOf,
  _strEndOf : _endOf,

  strBegins : begins,
  strEnds : ends,

  strBeginOf : beginOf,
  strEndOf : endOf,

  strRemoveBegin : removeBegin,
  strRemoveEnd : removeEnd,
  strRemove : remove,

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Str.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Str_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Str_s */ })();

/* */  /* begin of file Stringer_s */ ( function Stringer_s() { function Stringer_s_naked() { ( function _l1_Stringer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.stringer = _.stringer || Object.create( null );

// --
// implementation
// --

// --
// stringer extension
// --

let StringerExtension =
{
}

Object.assign( _.stringer, StringerExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Stringer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Stringer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Stringer_s */ })();

/* */  /* begin of file StrLines_s */ ( function StrLines_s() { function StrLines_s_naked() { ( function _l1_Str_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.str = _.str || Object.create( null );
_.str.lines = _.str.lines || Object.create( null );

// --
// lines
// --

function split( src, eol )
{
  if( _.arrayIs( src ) )
  return src;
  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( eol === undefined )
  eol = _.str.lines.Eol.default;
  return src.split( eol );
}

//

function join( src, eol )
{
  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( eol === undefined )
  eol = _.str.lines.Eol.default;
  let result = src;
  if( _.arrayIs( src ) )
  result = src.join( eol );
  return result;
}

//

/**
 * Remove espace characters and white spaces at the begin or at the end of each line.
 * Input arguments can be strings or arrays of strings. If input is a string, it splits it in lines and
 * removes the white/escape characters from the beggining and the end of each line. If input is an array,
 * it treats it as a single string split into lines, where each entry corresponds to a line. Therefore,
 * it removes the white/escape characters only from the beggining and the end of the strings in the array.
 *
 * @param { String/Array } [ src ] - Source string or array of strings.
 * @returns { String/Array } Returns string/array with empty lines and spaces removed.
 *
 * @example input string
 * _.str.lines.strip( '  Hello \r\n\t World \n\n ' );
 * // returns 'Hello\nWorld'
 *
 * @example input array
 * _.str.lines.strip( [ '  Hello \r\n\t world \n\n ', '\n! \n' ] );
 * // returns  [ 'Hello \r\n\t world', '!' ]
 *
 * @example input strings
 * _.str.lines.strip( '  Hello \r\n\t', ' World \n\n  ! \n\n', '\n\n' );
 * // returns [ 'Hello', 'World\n!', '' ]
 *
 * @example input arrays
 * _.str.lines.strip( [ '  Hello \r\n\t world \n\n ', '\n! \n' ], [ '\n\nHow\n\nAre  ', '  \r\nyou ? \n'], [ '\t\r\n  ' ] );
 * // returns [ [ 'Hello \r\n\t world', '!' ], [ 'How\n\nAre', 'you ?' ], [] ]
 *
 * @method strip
 * @throws { Exception } Throw an exception if( src ) is not a String or Array.
 * @namespace Tools/str/lines/strip
 */

/* qqq : measure time and optimize. ask */
function strip( src )
{

  if( arguments.length > 1 )
  {
    let result = _.unroll.make( null );
    for( let a = 0 ; a < arguments.length ; a++ )
    result[ a ] = _.str.lines.strip( arguments[ a ] );
    return result;
  }

  _.assert( _.strIs( src ) || _.arrayIs( src ) );
  _.assert( arguments.length === 1 );

  let lines = _.strLinesSplit( src );
  lines = lines.map( ( line ) => line.trim() ).filter( ( line ) => line );

  if( _.strIs( src ) )
  lines = _.str.lines.join( lines );
  return lines;
}

//

function atLeft( src, index, eol )
{
  let result;

  _.assert( _.number.is( index ) );

  if( index < 0 )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ 0, -1 ];
    return result;
  }

  let o2 = Object.create( null );
  o2.src = src;
  o2.eol = eol;
  o2.onEach = onEach;
  o2.interval = [ index, index ];
  o2.withLine = false;
  this.eachLeft( o2 );

  if( !result )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ src.length, src.length-1 ];
  }

  delete result.eol;
  delete result.onEach;
  delete result.interval;
  delete result.withLine;

  return result;

  function onEach( it )
  {
    result = it;
    result.line = src.slice( it.charInterval[ 0 ], it.charInterval[ 1 ]-it.nl.length+1 );
  }

}

//

function atRight( src, index, eol )
{
  let result;

  _.assert( _.number.is( index ) );

  if( index < 0 )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ src.length, src.length-1 ];
    return result;
  }

  let o2 = Object.create( null );
  o2.src = src;
  o2.eol = eol;
  o2.onEach = onEach;
  o2.interval = [ index, index ];
  o2.withLine = false;

  this.eachRight( o2 );

  if( !result )
  {
    result = Object.create( null );
    result.src = src;
    result.lineIndex = index;
    result.charInterval = [ 0, -1 ];
  }

  delete result.eol;
  delete result.onEach;
  delete result.interval;
  delete result.withLine;

  return result;

  function onEach( it )
  {
    result = it;
    result.line = src.slice( it.charInterval[ 0 ], it.charInterval[ 1 ]-it.nl.length+1 );
  }

}

//

function _eachLeft( o )
{

  if( o.eol === undefined )
  o.eol = _.str.lines.Eol.default;
  else if( !_.str.is( o.eol ) )
  o.eol = [ ... o.eol ];

  const lastIndex = o.interval ? o.interval[ 1 ] : Infinity;
  const src = o.src;
  let foundTokenIndex;
  let foundOffset;
  let handleEach;

  o.charInterval = [ -1, -1 ];
  o.lineIndex = -1;

  if( o.interval && o.interval[ 1 ] < 0 )
  {
    o.charInterval[ 0 ] = 0;
    return o;
  }

  o.nl = '';

  if( o.interval )
  {
    if( o.withLine )
    handleEach = handleWithIntervalWithLine;
    else
    handleEach = handleWithIntervalWithoutLine;
  }
  else
  {
    if( o.withLine )
    handleEach = handleWithoutIntervalWithLine;
    else
    handleEach = handleWithoutIntervalWithoutLine;
  }

  if( _.str.is( o.eol ) )
  single();
  else
  multiple();

  if( !o.interval || o.lineIndex < o.interval[ 1 ] )
  {
    o.lineIndex += 1;
    o.charInterval[ 0 ] = src.length;
    _.assert( o.charInterval[ 1 ] === src.length - 1 );
    if( o.withLine )
    o.line = '';
  }

  return o;

  /* */

  function single()
  {

    o.nl = o.eol;
    while( o.lineIndex !== lastIndex )
    {
      o.charInterval[ 0 ] = Math.max( o.charInterval[ 0 ], o.charInterval[ 1 ] ) + 1;
      o.charInterval[ 1 ] = src.indexOf( o.eol, o.charInterval[ 0 ] );
      o.lineIndex += 1;

      if( o.charInterval[ 1 ] === -1 )
      {
        o.charInterval[ 1 ] = src.length - 1;
        o.nl = '';
        handleEach();
        break;
      }
      else
      {
        o.charInterval[ 1 ] += o.nl.length - 1;
        handleEach();
      }

    }

  }

  /* */

  function multiple()
  {

    foundTokenIndex = -1;
    foundOffset = src.length;

    let first = indexInit();

    if( first.length === 1 )
    {
      o.eol = o.eol[ foundTokenIndex ];
      return single();
    }

    if( first.length === 0 )
    {

      o.lineIndex = 0;
      o.charInterval[ 0 ] = 0;
      o.charInterval[ 1 ] = src.length-1;
      handleEach();

      return;
    }

    while( o.lineIndex !== lastIndex )
    {
      o.charInterval[ 0 ] = Math.max( o.charInterval[ 0 ], o.charInterval[ 1 ] ) + 1;
      o.charInterval[ 1 ] = indexOf( first );
      o.lineIndex += 1;

      if( o.charInterval[ 1 ] === o.src.length )
      {
        o.charInterval[ 1 ] = src.length - 1;
        o.nl = '';
        handleEach();
        break;
      }
      else
      {
        o.nl = o.eol[ foundTokenIndex ];
        o.charInterval[ 1 ] += o.nl.length - 1;
        handleEach();
      }

    }

  }

  /* */

  function indexInit()
  {
    let first = [];
    for( let i = o.eol.length - 1 ; i >= 0 ; i-- )
    {
      let offset = src.indexOf( o.eol[ i ] );
      if( offset !== -1 )
      {
        first.unshift( offset );
        if( foundOffset >= offset )
        {
          foundOffset = offset;
          foundTokenIndex = i;
        }
      }
      else
      {
        o.eol.splice( i, 1 );
        foundTokenIndex -= 1;
      }
    }
    return first;
  }

  /* */

  function indexOf( first )
  {
    if( first[ foundTokenIndex ] >= o.charInterval[ 0 ] )
    return first[ foundTokenIndex ];
    foundOffset = src.length;
    for( let i = first.length - 1; i >= 0 ; i-- )
    {
      let offset = first[ i ];
      if( offset < o.charInterval[ 0 ] )
      {
        offset = src.indexOf( o.eol[ i ], first[ i ]+1 );
        if( offset === -1 )
        {
          tokenDelete( first, i );
          if( first.length === 0 )
          return src.length;
        }
        else
        {
          first[ i ] = offset;
          if( foundOffset >= offset )
          {
            foundOffset = offset;
            foundTokenIndex = i;
          }
        }
      }
      else
      {
        if( foundOffset >= offset )
        {
          foundOffset = offset;
          foundTokenIndex = i;
        }
      }
    }
    return first[ foundTokenIndex ];
  }

  /* */

  function tokenDelete( first, i )
  {
    o.eol.splice( i, 1 );
    first.splice( i, 1 );
    if( foundTokenIndex > i )
    foundTokenIndex -= 1;
  }

  /* */

  function handleWithoutIntervalWithoutLine()
  {
    o.onEach( o );
  }

  /* */

  function handleWithIntervalWithoutLine()
  {
    if( o.interval && o.interval[ 0 ] > o.lineIndex )
    return;
    o.onEach( o );
  }

  /* */

  function handleWithoutIntervalWithLine()
  {
    o.line = src.slice( o.charInterval[ 0 ], o.charInterval[ 1 ] - o.nl.length + 1 );
    o.onEach( o );
  }

  /* */

  function handleWithIntervalWithLine()
  {
    if( o.interval && o.interval[ 0 ] > o.lineIndex )
    return;
    o.line = src.slice( o.charInterval[ 0 ], o.charInterval[ 1 ] - o.nl.length + 1 );
    o.onEach( o );
  }

  /* */

}

_eachLeft.defaults =
{
  src : null,
  eol : null,
  interval : null,
  withLine : true,
}

//

function eachLeft( o )
{

  if( !_.map.is( o ) )
  {
    _.assert( arguments.length === 2 || arguments.length === 3 );
    if( arguments.length === 3 )
    o = { src : arguments[ 0 ], interval : arguments[ 1 ], onEach : arguments[ 2 ] };
    else
    o = { src : arguments[ 0 ], onEach : arguments[ 1 ] };
  }
  else
  {
    _.assert( arguments.length === 1 );
  }

  if( o.withLine === undefined )
  o.withLine = true;

  _.assert( _.routine.is( o.onEach ) );
  _.assert( _.str.is( o.src ) );

  return this._eachLeft( o );
}

//

function _eachRight( o )
{

  if( o.eol === undefined )
  o.eol = _.str.lines.Eol.default;
  else if( !_.str.is( o.eol ) )
  o.eol = [ ... o.eol ];

  const lastIndex = o.interval ? o.interval[ 1 ] : Infinity;
  const src = o.src;
  let foundTokenIndex;
  let foundOffset;
  let nnl = '';
  let handleEach;

  if( o.interval )
  {
    if( o.withLine )
    handleEach = handleWithIntervalWithLine;
    else
    handleEach = handleWithIntervalWithoutLine;
  }
  else
  {
    if( o.withLine )
    handleEach = handleWithoutIntervalWithLine;
    else
    handleEach = handleWithoutIntervalWithoutLine;
  }

  o.charInterval = [ o.src.length, o.src.length ];
  o.lineIndex = -1;

  if( o.interval && o.interval[ 1 ] < 0 )
  {
    o.charInterval[ 1 ] = o.src.length-1;
    return o;
  }

  o.nl = '';

  if( _.str.is( o.eol ) )
  single();
  else
  multiple();

  if( !o.interval || o.lineIndex < o.interval[ 1 ] )
  {
    o.lineIndex += 1;
    o.charInterval[ 1 ] = -1;
    _.assert( o.charInterval[ 0 ] === 0 );
    if( o.withLine )
    o.line = '';
  }

  return o;

  /* */

  function single()
  {

    while( o.lineIndex !== lastIndex )
    {

      o.lineIndex += 1;
      o.nl = nnl;

      o.charInterval[ 1 ] = o.charInterval[ 0 ] - 1;
      let right = o.charInterval[ 1 ] - o.nl.length;
      if( right >= 0 || o.lineIndex === 0 )
      o.charInterval[ 0 ] = src.lastIndexOf( o.eol, right );
      else
      o.charInterval[ 0 ] = -1;

      if( o.charInterval[ 0 ] === -1 )
      {
        o.charInterval[ 0 ] = 0;
        handleEach();
        break;
      }
      else
      {
        nnl = o.eol;
        o.charInterval[ 0 ] += nnl.length;
        handleEach();
      }

    }

  }

  /* */

  function multiple()
  {

    foundTokenIndex = -1;
    foundOffset = 0;

    let first = indexInit();

    if( first.length === 1 )
    {
      o.eol = o.eol[ foundTokenIndex ];
      return single();
    }

    if( first.length === 0 )
    {
      o.lineIndex = 0;
      o.charInterval[ 0 ] = 0;
      o.charInterval[ 1 ] = src.length-1;
      handleEach();
      return;
    }

    while( o.lineIndex !== lastIndex )
    {

      o.lineIndex += 1;
      o.nl = nnl;

      o.charInterval[ 1 ] = o.charInterval[ 0 ] - 1;
      o.charInterval[ 0 ] = indexOf( first );

      if( o.charInterval[ 0 ] === -1 )
      {
        o.charInterval[ 0 ] = 0;
        handleEach();
        break;
      }
      else
      {
        nnl = o.eol[ foundTokenIndex ];
        handleEach();
      }

    }

  }

  /* */

  function indexInit()
  {
    let first = [];
    for( let i = o.eol.length - 1 ; i >= 0 ; i-- )
    {
      let offset = src.lastIndexOf( o.eol[ i ] );
      if( offset !== -1 )
      {
        offset += o.eol[ i ].length;
        first.unshift( offset );
        if( foundOffset <= offset )
        {
          foundOffset = offset;
          foundTokenIndex = i;
        }
      }
      else
      {
        o.eol.splice( i, 1 );
        foundTokenIndex -= 1;
      }
    }
    return first;
  }

  /* */

  function indexOf( first )
  {
    let left = o.charInterval[ 0 ] - nnl.length - 1;
    if( first[ foundTokenIndex ] <= left )
    return first[ foundTokenIndex ];
    foundOffset = -1;
    for( let i = first.length - 1; i >= 0 ; i-- )
    {
      let offset = first[ i ];
      if( offset > left )
      {
        if( left >= 0 )
        offset = src.lastIndexOf( o.eol[ i ], left );
        else
        offset = -1;
        if( offset === -1 )
        {
          tokenDelete( first, i );
          if( first.length === 0 )
          return -1;
        }
        else
        {
          offset += o.eol[ i ].length;
          first[ i ] = offset;
          if( foundOffset <= offset )
          {
            foundOffset = offset;
            foundTokenIndex = i;
          }
        }
      }
      else
      {
        if( foundOffset <= offset )
        {
          foundOffset = offset;
          foundTokenIndex = i;
        }
      }
    }
    return first[ foundTokenIndex ];
  }

  /* */

  function tokenDelete( first, i )
  {
    o.eol.splice( i, 1 );
    first.splice( i, 1 );
    if( foundTokenIndex > i )
    foundTokenIndex -= 1;
  }

  /* */

  function handleWithoutIntervalWithoutLine()
  {
    o.onEach( o );
  }

  /* */

  function handleWithIntervalWithoutLine()
  {
    if( o.interval && o.interval[ 0 ] > o.lineIndex )
    return;
    o.onEach( o );
  }

  /* */

  function handleWithoutIntervalWithLine()
  {
    o.line = src.slice( o.charInterval[ 0 ], o.charInterval[ 1 ] - o.nl.length + 1 );
    o.onEach( o );
  }

  /* */

  function handleWithIntervalWithLine()
  {
    if( o.interval && o.interval[ 0 ] > o.lineIndex )
    return;
    o.line = src.slice( o.charInterval[ 0 ], o.charInterval[ 1 ] - o.nl.length + 1 );
    o.onEach( o );
  }

  /* */

}

_eachRight.defaults =
{
  ... _eachLeft.defaults,
}

//

function eachRight( o )
{

  if( !_.map.is( o ) )
  {
    _.assert( arguments.length === 2 || arguments.length === 3 );
    if( arguments.length === 3 )
    o = { src : arguments[ 0 ], interval : arguments[ 1 ], onEach : arguments[ 2 ] };
    else
    o = { src : arguments[ 0 ], onEach : arguments[ 1 ] };
  }
  else
  {
    _.assert( arguments.length === 1 );
  }

  if( o.withLine === undefined )
  o.withLine = true;

  _.assert( _.routine.is( o.onEach ) );
  _.assert( _.str.is( o.src ) );

  return this._eachRight( o );
}

// --
// str extension
// --

let Eol =
{
  any : [ '\r\n', '\n\r', '\n' ],
  posix : '\n',
  windows : '\r\n',
  mac : '\n\r',
  default : '\n',
}

let StrLinesExtension =
{

  Eol,

  split,
  join,
  strip,

  atLeft,
  atRight,
  at : atLeft,

  _eachLeft,
  eachLeft,
  _eachRight,
  eachRight,
  each : eachLeft,

}

Object.assign( _.str.lines, StrLinesExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  strLinesSplit : split,
  strLinesJoin : join,
  strLinesStrip : strip,

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/StrLines.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, StrLines_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file StrLines_s */ })();

/* */  /* begin of file Symbol_s */ ( function Symbol_s() { function Symbol_s_naked() { ( function _l1_Symbol_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.symbol = _.symbol || Object.create( null );

// --
// symbol
// --

function is( src )
{
  let result = Object.prototype.toString.call( src ) === '[object Symbol]';
  return result;
}

//

function exportStringCodeShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.symbol.is( src ) );

  let text = src.toString().slice( 7, -1 );
  let result = `Symbol.for(${text ? ' \'' + text + '\' )' : ')'}`;
  return result;
}

//

function exportStringDiagnosticShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.symbol.is( src ) );

  let text = src.toString().slice( 7, -1 );
  let result = `{- Symbol${text ? ' ' + text + ' ' : ' '}-}`;
  return result;
}

// --
// extension
// --

let ToolsExtension =
{
  symbolIs : is
}

//

let Extension =
{

  // dichotomy

  is,

  // exporter

  exportString : exportStringDiagnosticShallow,
  // exportStringDiagnosticShallow : exportStringDiagnosticShallow,
  exportStringCodeShallow,
  exportStringDiagnosticShallow,
  // exportStringDiagnostic : exportStringDiagnosticShallow,
  // exportStringCode : exportStringCodeShallow,

  // symbols

  def : Symbol.for( 'def' ),
  null : Symbol.for( 'null' ),
  undefined : Symbol.for( 'undefined' ),
  void : Symbol.for( 'void' ),
  nothing : Symbol.for( 'nothing' ),
  anything : Symbol.for( 'anything' ),
  maybe : Symbol.for( 'maybe' ),
  unknown : Symbol.for( 'unknown' ),
  dont : Symbol.for( 'dont' ),
  self : Symbol.for( 'self' ),
  optional : Symbol.for( 'optional' ),

  unroll : Symbol.for( 'unroll' ),
  prototype : Symbol.for( 'prototype' ),
  constructor : Symbol.for( 'constructor' ),

}

Object.assign( _, ToolsExtension );
Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Symbol.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Symbol_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Symbol_s */ })();

/* */  /* begin of file Time_s */ ( function Time_s() { function Time_s_naked() { ( function _l1_Time_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.time = _.time || Object.create( null );

// --
// time
// --

function timerIs( src )
{
  if( !src )
  return false;
  return _.strIs( src.type ) && !!src.time && !!src.cancel;
}

//

function competitorIs( src )
{
  if( !src )
  return false;
  if( !_.mapIs( src ) )
  return false;
  return src.competitorRoutine !== undefined;
}

//

/**
 * The routine timerInBegin() checks the state of timer {-timer-}. If {-timer-} is created and
 * timer methods is not executed, then routine returns true. Otherwise, false is returned.
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.timerInBegin( timer );
 * // returns : true
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.cancel( timer );
 * _.time.timerInBegin( timer );
 * // returns : false
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.out( 2000, () => _.time.timerInBegin( timer ) );
 * // returns : false
 *
 * @param { Timer } timer - The timer to check.
 * @returns { Boolean } - Returns true if timer methods is not executed. Otherwise, false is returned.
 * @function timerInBegin
 * @throws { Error } If arguments is not provided.
 * @throws { Error } If {-timer-} is not a Timer.
 * @namespace wTools.time
 * @extends Tools
 */

function timerInBegin( timer )
{
  _.assert( _.timerIs( timer ) );
  return timer.state === 0;
}

//

/**
 * The routine timerInCancelBegun() checks the state of timer {-timer-}. If {-timer-} starts executing of callback
 * {-onCancel-} and not finished it, then routine returns true. Otherwise, false is returned.
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.timerInCancelBegun( timer );
 * // returns : false
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', onCancel );
 * _.time.cancel( timer );
 * function onCancel()
 * {
 *   _.time.timerInCancelBegun( timer );
 *   // returns : true
 *   return 'canceled';
 * }
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.out( 2000, () => _.time.timerInCancelBegun( timer ) );
 * // returns : false
 *
 * @param { Timer } timer - The timer to check.
 * @returns { Boolean } - Returns true if timer starts canceling and not finished it.
 * Otherwise, false is returned.
 * @function timerInCancelBegun
 * @throws { Error } If arguments is not provided.
 * @throws { Error } If {-timer-} is not a Timer.
 * @namespace wTools.time
 * @extends Tools
 */

function timerInCancelBegun( timer )
{
  _.assert( _.timerIs( timer ) );
  return timer.state === -1;
}

//

/**
 * The routine timerInCancelEnded() checks the state of timer {-timer-}. If {-timer-} finished executing of
 * callback {-onCancel-}, then routine returns true. Otherwise, false is returned.
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.timerInCancelEnded( timer );
 * // returns : false
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', onCancel );
 * _.time.cancel( timer );
 * function onCancel()
 * {
 *   _.time.timerInCancelEnded( timer );
 *   // returns : false
 *   return 'canceled';
 * }
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.out( 2000, () => _.time.timerInCancelEnded( timer ) );
 * // returns : false
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.cancel( timer );
 * // returns : true
 *
 * @param { Timer } timer - The timer to check.
 * @returns { Boolean } - Returns true if timer starts canceling and finished it.
 * Otherwise, false is returned.
 * @function timerInCancelEnded
 * @throws { Error } If arguments is not provided.
 * @throws { Error } If {-timer-} is not a Timer.
 * @namespace wTools.time
 * @extends Tools
 */

function timerInCancelEnded( timer )
{
  _.assert( _.timerIs( timer ) );
  return timer.state === -2;
}

//

function timerIsCanceled( timer )
{
  _.assert( _.timerIs( timer ) );
  return timer.state === -1 || timer.state === -2;
}

//

/**
 * The routine timerInEndBegun() checks the state of timer {-timer-}. If {-timer-} starts executing of callback
 * {-onTime-} and not finished it, then routine returns true. Otherwise, false is returned.
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.timerInEndBegun( timer );
 * // returns : false
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', onCancel );
 * _.time.cancel( timer );
 * function onCancel()
 * {
 *   _.time.timerInEndBegun( timer );
 *   // returns : false
 *   return 'canceled';
 * }
 *
 * @example
 * let timer = _.time.begin( 500, onTime, () => 'canceled' );
 * function onTime()
 * {
 *  _.time.timerInEndBegun( timer );
 *  // returns : true
 *  return 'executed';
 * }
 *
 * @param { Timer } timer - The timer to check.
 * @returns { Boolean } - Returns true if timer starts executing of callback {-onTime-} and not finished it.
 * Otherwise, false is returned.
 * @function timerInEndBegun
 * @throws { Error } If arguments is not provided.
 * @throws { Error } If {-timer-} is not a Timer.
 * @namespace wTools.time
 * @extends Tools
 */

function timerInEndBegun( timer )
{
  _.assert( _.timerIs( timer ) );
  return timer.state === 1;
}

//

/**
 * The routine timerInEndEnded() checks the state of timer {-timer-}. If {-timer-} finished executing of callback
 * {-onTime-}, then routine returns true. Otherwise, false is returned.
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.timerInEndEnded( timer );
 * // returns : false
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', onCancel );
 * _.time.cancel( timer );
 * function onCancel()
 * {
 *   _.time.timerInEndEnded( timer );
 *   // returns : false
 *   return 'canceled';
 * }
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.out( 2000, () => _.time.timerInEndEnded( timer ) );
 * // returns : true
 *
 * @param { Timer } timer - The timer to check.
 * @returns { Boolean } - Returns true if timer finished executing of callback {-onTime-}.
 * Otherwise, false is returned.
 * @function timerInEndEnded
 * @throws { Error } If arguments is not provided.
 * @throws { Error } If {-timer-} is not a Timer.
 * @namespace wTools.time
 * @extends Tools
 */

function timerInEndEnded( timer )
{
  _.assert( _.timerIs( timer ) );
  return timer.state === 2;
}

// --
//
// --

let _TimeInfinity = Math.pow( 2, 31 )-1;

//

function _begin( delay, onTime, onCancel )
{
  let native;

  if( delay >= _TimeInfinity )
  delay = _TimeInfinity;

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );

  if( delay > 0 )
  native = setTimeout( time, delay );
  else
  native = soon( timeNonCancelable ) || null;

  let timer = Object.create( null );
  timer.onTime = onTime;
  timer.onCancel = onCancel;
  timer._time = _time;
  timer._cancel = _cancel;
  timer.time = native === null ? timeNonCancelable : time;
  timer.cancel = cancel;
  timer.state = 0;
  timer.type = 'delay';
  timer.native = native;
  return timer;

  /* */

  function _time()
  {
    if( timer.state === 1 || timer.state === -1 )
    return;

    _.assert( timer.state > -2, 'Cannot change state of timer.' );
    _.assert( timer.state < 2, 'Timer can be executed only one time.' );

    timer.state = 1;
    try
    {
      if( onTime )
      timer.result = onTime( timer );
    }
    finally
    {
      _.assert( timer.state === 1 );
      timer.state = 2;
    }
  }

  /* */

  function _cancel()
  {
    if( timer.state === 1 || timer.state === -1 )
    return;

    _.assert( timer.state < 2, 'Cannot change state of timer.' );
    _.assert( timer.state > -2, 'Timer can be canceled only one time.' );

    timer.state = -1;
    clearTimeout( timer.native );
    try
    {
      if( onCancel )
      timer.result = onCancel( timer );
    }
    finally
    {
      _.assert( timer.state === -1 );
      timer.state = -2;
    }
  }

  /* */

  function timeNonCancelable()
  {
    if( timer.state !== 0 )
    return;
    return time.call( this, arguments );
  }

  /* */

  function time()
  {
    timer._time();
    clearTimeout( timer.native );
    return timer;
  }

  /* */

  function cancel()
  {
    return timer._cancel();
  }

}

//

function _finally( delay, onTime )
{
  _.assert( arguments.length === 2 );
  let timer = _.time._begin( delay, onTime, onTime );
  return timer;
}

//

function _periodic( delay, onTime, onCancel )
{

  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects exactly two or three arguments' );

  let native = setInterval( time, delay );

  let timer = Object.create( null );
  timer.onTime = onTime;
  timer.onCancel = onCancel;
  timer._time = _time;
  timer._cancel = _cancel;
  timer.time = time;
  timer.cancel = cancel;
  timer.state = 0;
  timer.type = 'periodic';
  timer.native = native;
  return timer;

  /* */

  function _time()
  {
    _.assert( timer.state !== -1 && timer.state !== -2, 'Illegal call, timer is canceled. Please, use new timer.' );

    timer.state = 1;
    try
    {
      if( onTime )
      timer.result = onTime( timer );
    }
    finally
    {
      if( timer.result === undefined || timer.result === _.dont ) /* Dmytro : if it needs, change to any other stop value */
      timer.cancel();
      else
      timer.state = 2;
    }
  }

  /* */

  function _cancel()
  {

    _.assert( timer.state !== -1 && timer.state !== -2, 'Illegal call, timer is canceled.' );

    timer.state = -1;
    clearInterval( timer.native );
    try
    {
      if( onCancel )
      timer.result = onCancel( timer );
    }
    finally
    {
      timer.state = -2;
    }
  }

  /* */

  function time()
  {
    return timer._time();
  }

  /* */

  function cancel()
  {
    return timer._cancel();
  }

}

//

function _cancel( timer )
{
  _.assert( _.timerIs( timer ) );

  timer.cancel();

  return timer;
}

//

/**
 * The routine begin() make new timer for procedure {-procedure-}. The timer executes callback {-onTime-} only once.
 * Callback {-onTime-} executes when time delay {-delay-} is elapsed. If the timer is canceled, then the callback
 * {-onCancel-} is executed.
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.out( 1000, () =>
 * {
 *  console.log( timer.result );
 *  // log : 'executed'
 *  return null;
 * });
 * console.log( timer.result );
 * // log : undefined
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * _.time.cancel( timer );
 * console.log( timer.result );
 * // log : 'canceled'
 *
 * @param { Number } delay - The time delay.
 * @param { Procedure|Undefined } procedure - The procedure for timer.
 * @param { Function|Undefined|Null } onTime - The callback to execute when time is elapsed.
 * @param { Function|Undefined|Null } onCancel - The callback to execute when timer is canceled.
 * @returns { Timer } - Returns timer.
 * @function begin
 * @throws { Error } If arguments.length is less than 2 or great than 4.
 * @throws { Error } If {-delay-} is not a Number.
 * @throws { Error } If {-onTime-} neither is a Function, nor undefined, nor null.
 * @throws { Error } If {-onCancel-} neither is a Function, nor undefined, nor null.
 * @namespace wTools.time
 * @extends Tools
 */

function begin( /* delay, procedure, onTime, onCancel */ )
{
  let delay = arguments[ 0 ];
  let procedure = arguments[ 1 ];
  let onTime = arguments[ 2 ];
  let onCancel = arguments[ 3 ];

  if( !_.procedureIs( procedure ) )
  {
    onTime = arguments[ 1 ] === undefined ? null : arguments[ 1 ];
    onCancel = arguments[ 2 ] === undefined ? null : arguments[ 2 ];
  }

  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4 );
  _.assert( _.number.is( delay ) );
  _.assert( _.routine.is( onTime ) || onTime === undefined || onTime === null );
  _.assert( _.routine.is( onCancel ) || onCancel === undefined || onCancel === null );

  return this._begin( delay, onTime, onCancel );
}

//

/**
 * The routine finally() make new timer for procedure {-procedure-}. The timer executes callback {-onTime-} only once.
 * Callback {-onTime-} executes when time delay {-delay-} is elapsed or if the timer is canceled.
 *
 * @example
 * let timer = _.time.finally( 500, () => 'executed' );
 * _.time.out( 1000, () =>
 * {
 *  console.log( timer.result );
 *  // log : 'executed'
 *  return null;
 * });
 * console.log( timer.result );
 * // log : undefined
 *
 * @example
 * let timer = _.time.finally( 500, () => 'executed', () => 'canceled' );
 * _.time.cancel( timer );
 * console.log( timer.result );
 * // log : 'executed'
 *
 * @param { Number } delay - The time delay.
 * @param { Procedure|Undefined } procedure - The procedure for timer.
 * @param { Function|Undefined|Null } onTime - The callback to execute when time is elapsed.
 * @param { Function|Undefined|Null } onCancel - The callback to execute when timer is canceled.
 * @returns { Timer } - Returns timer.
 * @function finally
 * @throws { Error } If arguments.length is less than 2 or great than 3.
 * @throws { Error } If {-delay-} is not a Number.
 * @throws { Error } If {-onTime-} neither is a Function, nor undefined, nor null.
 * @namespace wTools.time
 * @extends Tools
 */

function finally_( delay, procedure, onTime )
{
  if( arguments.length === 2 )
  if( !_.procedureIs( procedure ) )
  onTime = arguments[ 1 ] === undefined ? null : arguments[ 1 ];

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.number.is( delay ) );
  _.assert( _.routine.is( onTime ) || onTime === undefined || onTime === null );

  return this._finally( delay, onTime );
}

//

/**
 * The routine periodic() make new periodic timer for procedure {-procedure-}. The timer executes callback {-onTime-}
 * periodically with time interval {-delay-}. If callback {-onTime-} returns undefined or Symbol _.dont, then the
 * callback {-onCancel-} executes and timer stops.
 * If the times is canceled, then the callback {-onCancel-} is executed.
 *
 * @example
 * let result = [];
 * function onTime()
 * {
 *   if( result.length < 3 )
 *   return result.push( 1 );
 *   else
 *   return undefined;
 * }
 * let timer = _.time.periodic( 500, onTime, () => 'canceled' );
 * _.time.out( 3000, () =>
 * {
 *   console.log( result );
 *   // log : [ 1, 1, 1 ]
 *   console.log( timer.result );
 *   // log : 'canceled'
 *   return null;
 * });
 * console.log( timer.result );
 * // log : undefined
 *
 * @example
 * let result = [];
 * function onTime()
 * {
 *   if( result.length < 3 )
 *   return result.push( 1 );
 *   else
 *   return undefined;
 * }
 * let timer = _.time.periodic( 500, onTime, () => 'canceled' );
 * _.time.cancel( timer );
 * console.log( result );
 * // log : []
 * console.log( timer.result );
 * // log : 'canceled'
 *
 * @param { Number } delay - The time delay.
 * @param { Procedure|Undefined } procedure - The procedure for timer.
 * @param { Function } onTime - The callback to execute when time is elapsed.
 * @param { Function|Undefined|Null } onCancel - The callback to execute when timer is canceled.
 * @returns { Timer } - Returns periodic timer.
 * @function begin
 * @throws { Error } If arguments.length is less than 2 or great than 4.
 * @throws { Error } If {-delay-} is not a Number.
 * @throws { Error } If {-onTime-} is not a Function.
 * @throws { Error } If {-onCancel-} neither is a Function, nor undefined, nor null.
 * @namespace wTools.time
 * @extends Tools
 */

function periodic( /* delay, procedure, onTime, onCancel */ )
{
  let delay = arguments[ 0 ];
  let procedure = arguments[ 1 ];
  let onTime = arguments[ 2 ];
  let onCancel = arguments[ 3 ];

  if( !_.procedureIs( procedure ) )
  {
    onTime = arguments[ 1 ] === undefined ? null : arguments[ 1 ];
    onCancel = arguments[ 2 ] === undefined ? null : arguments[ 2 ];
  }

  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4 );
  _.assert( _.number.is( delay ) );
  _.assert( _.routine.is( onTime ) );
  _.assert( _.routine.is( onCancel ) || onCancel === undefined || onCancel === null );

  return this._periodic( delay, onTime, onCancel );
}

//

/**
 * The routine cancel() cancels timer {-timer-}.
 *
 * @example
 * let timer = _.time.begin( 500, () => 'executed', () => 'canceled' );
 * let canceled = _.time.cancel( timer );
 * console.log( timer.result );
 * // log : 'canceled'
 * console.log( timer === canceled );
 * // log : true
 *
 * @example
 * let timer = _.time.periodic( 500, () => 'executed', () => 'canceled' );
 * let canceled = _.time.cancel( timer );
 * console.log( timer.result );
 * // log : 'canceled'
 * console.log( timer === canceled );
 * // log : true
 *
 * @param { Timer } timer - The timer to cancel.
 * @returns { Timer } - Returns canceled timer.
 * @function cancel
 * @throws { Error } If {-timer-} is not a Timer.
 * @namespace wTools.time
 * @extends Tools
 */

function cancel( timer )
{
  return _.time._cancel( ... arguments );
}

//

/**
 * The routine _now_functor() make the better function to get current time in ms.
 * The returned function depends on environment.
 *
 * @example
 * let now = _.time._now_functor();
 * console.log( _.routine.is( now ) );
 * // log : true
 * console.log( now() );
 * // log : 1603172830154
 *
 * @returns { Function } - Returns function to get current time in ms.
 * @function _now_functor
 * @namespace wTools.time
 * @extends Tools
 */

function _now_functor()
{
  let now;

  if( typeof performance !== 'undefined' && performance.now !== undefined )
  now = _.routine.join( performance, performance.now );
  else if( Date.now )
  now = _.routine.join( Date, Date.now );
  else
  now = function(){ return Date().getTime() };

  return now;
}

//

/**
 * The routine soon() execute routine {-h-} asynchronously as soon as possible. In NodeJS interpreter it
 * executes on nextTick, in another interpreters in async queue.
 *
 * @example
 * let result = [ _.time.now() ];
 * _.time.soon( () => result.push( _.time.now() ) );
 * // the delta ( result[ 1 ] - result[ 0 ] ) is small as possible
 *
 * @param { Function } h - The routine to execute.
 * @returns { Undefined } - Returns undefined, executes routine {-h-}.
 * @function soon
 * @throws { Error } If arguments is not provided.
 * @throws { Error } If {-h-} is not a Function.
 * @namespace wTools.time
 * @extends Tools
 */

const soon = typeof process === 'undefined' ? function( h ){ return setTimeout( h, 0 ) } : process.nextTick;

// --
// implementation
// --

/* qqq : make namespace _.timer */
let TimeExtension =
{

  /* qqq : for junior : bad */
  timerIs, /* qqq : cover */
  competitorIs, /* xxx : move */

  timerInBegin,
  timerInCancelBegun,
  timerInCancelEnded,
  timerIsCanceled,
  timerInEndBegun,
  timerInEndEnded,

  _begin,
  _finally,
  _periodic,
  _cancel,

  begin,
  finally : finally_,
  periodic,
  cancel,

  _now_functor,
  now : _now_functor(),
  soon,

}

//

Object.assign( _.time, TimeExtension );

//

let ToolsExtension =
{

  /* qqq : for junior : bad */
  timerIs,
  competitorIs, /* xxx : move */

}

//

Object.assign( _, ToolsExtension );

/* qqq : for junior : replace Routines+Fields -> {- name of namespace -}Extension in all files */

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Time.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Time_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Time_s */ })();

/* */  /* begin of file Type_s */ ( function Type_s() { function Type_s_naked() { ( function _l1_Type_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _global_.wTools;

// --
// type test
// --

function undefinedIs( src )
{
  if( src === undefined )
  return true;
  return false;
}

//

function nullIs( src )
{
  if( src === null )
  return true;
  return false;
}

//

function nothingIs( src )
{
  if( src === null )
  return true;
  if( src === undefined )
  return true;
  if( src === _.nothing )
  return true;
  return false;
}

//

function definedIs( src )
{
  return src !== undefined && src !== null && !Number.isNaN( src ) && src !== _.nothing;
}

//

// function primitiveIs( src )
// {
//   if( !src )
//   return true;
//   let t = Object.prototype.toString.call( src );
//   return t === '[object Symbol]' || t === '[object Number]' || t === '[object BigInt]' || t === '[object Boolean]' || t === '[object String]';
// }

//

function consequenceIs( src )
{
  if( !src )
  return false;

  let prototype = Object.getPrototypeOf( src );

  if( !prototype )
  return false;

  return prototype.shortName === 'Consequence';
}

//

function consequenceLike( src )
{
  if( _.consequenceIs( src ) )
  return true;

  if( _.promiseIs( src ) )
  return true;

  return false;
}

//

function promiseIs( src )
{
  if( !src )
  return false;
  return src instanceof Promise;
}

//

function promiseLike( src )
{
  if( !src )
  return false;
  // if( !_.object.isBasic( src ) )
  // return false;
  return _.routine.is( src.then ) && _.routine.is( src.catch ) && ( src.constructor ) && ( src.constructor.name !== 'wConsequence' );
}

//

function typeOf( src, constructor )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 2 )
  {
    return _.typeOf( src ) === constructor;
  }

  if( src === null || src === undefined )
  {
    return null;
  }
  else if( _.number.is( src ) || _.bool.is( src ) || _.strIs( src ) ) /* yyy */
  {
    return src.constructor;
  }
  else if( src.constructor )
  {
    _.assert( _.routine.is( src.constructor ) && src instanceof src.constructor );
    return src.constructor;
  }
  else
  {
    return null;
  }

}

// //
//
// function prototypeIsStandard( src )
// {
//
//   if( !_.workpiece.prototypeIs( src ) )
//   return false;
//
//   if( !Object.hasOwnProperty.call( src, 'Composes' ) )
//   return false;
//
//   return true;
// }

//

/**
 * Checks if argument( cls ) is a constructor.
 * @function constructorIs
 * @param {Object} cls - entity to check
 * @namespace Tools
 */

function constructorIs( cls )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  return _.routine.is( cls ) && !instanceIs( cls );
}

//

/**
 * Is instance of a class.
 * @function instanceIs
 * @param {object} src - entity to check
 * @namespace Tools
 */

function instanceIs( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.primitive.is( src ) )
  return false;

  if( Object.hasOwnProperty.call( src, 'constructor' ) )
  return false;
  if( !Reflect.has( src, 'constructor' ) )
  return false;

  let prototype = Object.getPrototypeOf( src );
  _.assert( prototype !== undefined );

  if( prototype === null )
  return false;
  // if( prototype === undefined )
  // return false;
  if( prototype === Object.prototype )
  return false;
  if( _.routine.is( prototype ) )
  return false;

  // return Object.hasOwnProperty.call( prototype, 'constructor' );

  return true;
}

//

function workerIs( src )
{
  _.assert( arguments.length === 0 || arguments.length === 1 );
  if( arguments.length === 1 )
  {
    if( typeof WorkerGlobalScope !== 'undefined' && src instanceof WorkerGlobalScope )
    return true;
    if( typeof Worker !== 'undefined' && src instanceof Worker )
    return true;
    return false;
  }
  else
  {
    return typeof WorkerGlobalScope !== 'undefined';
  }
}

//

function streamIs( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  return _.object.isBasic( src ) && _.routine.is( src.pipe )
}

//
// xxx : remove from here
//
// function consoleIs( src )
// {
//   _.assert( arguments.length === 1, 'Expects single argument' );
//
//   if( console.Console )
//   if( src && src instanceof console.Console )
//   return true;
//
//   if( src !== console )
//   return false;
//
//   let result = Object.prototype.toString.call( src );
//   if( result === '[object Console]' || result === '[object Object]' )
//   return true;
//
//   return false;
// }
//
// //
//
// function loggerIs( src )
// {
//   _.assert( arguments.length === 1, 'Expects single argument' );
//
//   if( !_.Logger )
//   return false;
//
//   if( src instanceof _.Logger )
//   return true;
//
//   return false;
// }

//

function processIs( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  // let type = _.entity.strType( src );
  let type = _.entity.strTypeSecondary( src );
  if( type === 'ChildProcess' || type === 'process' )
  return true;

  return false;
}

//

function procedureIs( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( !src )
  return false;
  if( !_.Procedure )
  return false;
  return src instanceof _.Procedure;
}

//

function definitionIs( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( !src )
  return false;

  if( !_.Definition )
  return false;

  return src instanceof _.Definition;
}

//

function traitIs( trait )
{
  if( !_.definitionIs( trait ) )
  return false;
  return trait.defGroup === 'trait';
}

//

function blueprintIsDefinitive( blueprint )
{
  if( !blueprint )
  return false;
  if( !_.blueprint.isDefinitive )
  return false;
  return _.blueprint.isDefinitive( blueprint );
}

//

function blueprintIsRuntime( blueprint )
{
  if( !blueprint )
  return false;
  if( !_.blueprint.isRuntime )
  return false;
  return _.blueprint.isRuntime( blueprint );
}

// --
// implementation
// --

let ToolsExtension =
{

  // primitive

  undefinedIs,
  nullIs,
  nothingIs,
  definedIs,

  //

  consequenceIs,
  consequenceLike,
  promiseIs,
  promiseLike,

  typeOf,
  constructorIs,
  instanceIs,

  workerIs,
  streamIs,
  // consoleIs,
  // loggerIs,
  processIs,
  procedureIs,

  definitionIs, /* xxx : move to namespace::property */
  traitIs, /* xxx : move to namespace::property */

  blueprintIsDefinitive,
  blueprintIsRuntime,

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Type.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Type_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Type_s */ })();

/* */  /* begin of file Units_s */ ( function Units_s() { function Units_s_naked() { ( function _l1_Units_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.units = _.units || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{

}

//

var ToolsExtension =
{

}

//

Object.assign( _.units, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Units.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Units_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Units_s */ })();

/* */  /* begin of file Unroll_s */ ( function Unroll_s() { function Unroll_s_naked() { ( function _l1_Unroll_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.unroll = _.unroll || Object.create( null );

// --
// unroll
// --

/**
 * The routine is() determines whether the passed value is an instance of type Unroll ( unroll-array ).
 *
 * If {-src-} is an Unroll, then returns true, otherwise returns false.
 *
 * @param { * } src - The object to be checked.
 *
 * @example
 * _.unroll.is( _.unroll.make( [ 1, 'str' ] ) );
 * // returns true
 *
 * @example
 * _.unroll.is( [] );
 * // returns false
 *
 * @example
 * _.unroll.is( 1 );
 * // returns false
 *
 * @returns { boolean } Returns true if {-src-} is an Unroll.
 * @function is
 * @namespace Tools/unroll
 */

function is( src )
{
  if( !_.arrayIs( src ) )
  return false;
  return !!src[ unrollSymbol ];
}

//

function isEmpty( src )
{
  if( !_.unroll.is( src ) )
  return false;
  return src.length === 0;
}

//

/**
 * The routine isPopulated() determines whether the unroll-array has elements (length).
 *
 * If {-src-} is an unroll-array and has one or more elements, then returns true, otherwise returns false.
 *
 * @param { * } src - The object to be checked.
 *
 * @example
 * let src = _.unroll.from( [ 1, 'str' ] );
 * _.isPopulated( src );
 * // returns true
 *
 * @example
 * let src = _.unroll.make( [] )
 * _.isPopulated( src );
 * // returns false
 *
 * @returns { boolean } Returns true if argument ( src ) is an Unroll and has one or more elements ( length ).
 * @function isPopulated
 * @namespace Tools/unroll
 */

function isPopulated( src )
{
  if( !_.unroll.is( src ) )
  return false;
  return src.length > 0;
}

//

function like( src )
{
  return _.unroll.is( src );
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return true;
}

// --
// maker
// --

// function _makeEmpty( src )
// {
//   return _.unroll._make();
// }
//
// //
//
// function makeEmpty( src )
// {
//   _.assert( arguments.length === 0 || arguments.length === 1 );
//   return _.unroll._makeEmpty( ... arguments );
// }

//

/**
 * The routine makeUndefined() returns a new Unroll with length equal to {-length-}.
 * If the argument {-length-} is not provided, routine returns new Unroll with the length defined from {-src-}.
 *
 * @param { Long|Number|Null } src - Any Long, Number or null. If {-length-} is not provided, then routine defines length from {-src-}.
 * @param { Number|Long|Null } length - Defines length of new Unroll. If null is provided, then length defines by {-src-}.
 *
 * @example
 * _.unroll.makeUndefined();
 * // returns []
 *
 * @example
 * _.unroll.makeUndefined( null );
 * // returns []
 *
 * @example
 * _.unroll.makeUndefined( null, null );
 * // returns []
 *
 * @example
 * _.unroll.makeUndefined( 3 );
 * // returns [ undefined, undefined, undefined]
 *
 * @example
 * _.unroll.makeUndefined( 3, null );
 * // returns [ undefined, undefined, undefined]
 *
 * @example
 * _.unroll.makeUndefined( [ 1, 2, 3 ] );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * _.unroll.makeUndefined( [ 1, 2, 3 ], null );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * _.unroll.makeUndefined( [ 1, 2, 3 ], 4 );
 * // returns [ undefined, undefined, undefined, undefined ]
 *
 * @example
 * _.unroll.makeUndefined( [ 1, 2, 3, 4 ], [ 1, 2 ] );
 * // returns [ undefined, undefined ]
 *
 * @example
 * let src = new F32x( [ 1, 2, 3, 4, 5 ] );
 * let got = _.unroll.makeUndefined( src, 3 );
 * console.log( got );
 * // log [ undefined, undefined, undefined ]
 *
 * @returns { Unroll } Returns a new Unroll with length equal to {-length-} or defined from {-src-}.
 * If null passed, routine returns the empty Unroll.
 * @function makeUndefined
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If argument {-src-} is not a Long, not null.
 * @throws { Error } If argument {-length-} is not a number, not a Long.
 * @namespace Tools/unroll
 */

// function _makeUndefined( src, length )
// {
//   if( arguments.length === 0 )
//   return _.unroll._make();
//
//   if( _.longIs( length ) )
//   {
//     length = length.length;
//   }
//   if( length === undefined || length === null )
//   {
//     if( src === null )
//     {
//       length = 0;
//     }
//     else if( _.longLike( src ) )
//     {
//       length = src.length;
//     }
//     else if( _.number.is( src ) )
//     {
//       length = src;
//       src = null;
//     }
//     else _.assert( 0 );
//   }
//
//   _.assert( _.number.isFinite( length ) );
//   _.assert( _.longIs( src ) || src === null );
//
//   return _.unroll._make( length );
// }
//
// //
//
// function makeUndefined( src, length )
// {
//   _.assert( arguments.length === 0 || arguments.length === 1 || arguments.length === 2 );
//   // _.assert( _.number.isFinite( length ) );
//   // _.assert( _.longIs( src ) || src === null );
//   return _.unroll._makeUndefined( ... arguments );
// }

//

// function _makeFilling( type, value, length )
// {
//   if( arguments.length === 2 )
//   {
//     value = arguments[ 0 ];
//     length = arguments[ 1 ];
//   }
//
//   if( _.longIs( length ) )
//   length = length.length;
//
//   let result = this._make( type, length );
//   for( let i = 0 ; i < length ; i++ )
//   result[ i ] = value;
//
//   return result;
// }

//

/**
 * The routine make() returns a new unroll-array maiden from {-src-}.
 *
 * Unroll constructed by attaching symbol _.unroll Symbol to ordinary array. Making an unroll normalizes its content.
 *
 * @param { Number|Long|Set|Null|Undefined } src - The number or other instance to make unroll-array. If null is provided,
 * then routine returns an empty Unroll.
 *
 * @example
 * let src = _.unroll.make();
 * // returns []
 * _.unrollIs( src );
 * // returns true
 *
 * @example
 * let src = _.unroll.make( null );
 * // returns []
 * _.unrollIs( src );
 * // returns true
 *
 * @example
 * let src = _.unroll.make( null, null );
 * // returns []
 * _.unrollIs( src );
 * // returns true
 *
 * @example
 * let src = _.unroll.make( 3 );
 * // returns [ undefined, undefined, undefined ]
 * _.unrollIs( src );
 * // returns true
 *
 * @example
 * let src = _.unroll.make( [ 1, 2, 'str' ] );
 * // returns [ 1, 2, 'str' ]
 * _.unrollIs( src );
 * // returns true
 *
 * @returns { Unroll } - Returns a new Unroll maiden from {-src-}.
 * Otherwise, it returns the empty Unroll.
 * @function make
 * @throws { Error } If arguments.length is more then one.
 * @throws { Error } If {-src-} is not a number, not a Long, not Set, not null, not undefined.
 * @namespace Tools/unroll
 */

function _make( src, length )
{
  let result = _.array._make( ... arguments );
  result[ unrollSymbol ] = true;
  if
  (
    ( src !== null && src !== undefined && !_.unroll.is( src ) )
    || ( src !== null && src !== undefined && !_.unroll.is( src ) )
  )
  result = _.unroll.normalize( result );
  return result;

  // let result;
  // result = _.array._make( ... arguments );
  // result[ unrollSymbol ] = true;
  // if( src !== null && src !== undefined && !_.unroll.is( src ) )
  // result = _.unroll.normalize( result );
  // return result;
}

//

// function make( src, length )
// {
//   _.assert( arguments.length === 0 || src === null || _.countable.is( src ) || _.numberIs( src ) );
//   _.assert( length === undefined || !_.number.is( src ) || !_.number.is( length ) );
//   _.assert( arguments.length < 2 || _.number.is( length ) || _.countable.is( length ) );
//   _.assert( arguments.length <= 2 );
//   return this._make( ... arguments );
//   // _.assert( arguments.length === 0 || arguments.length === 1 );
//   // _.assert( arguments.length === 0 || src === null || _.number.is( src ) || _.countable.is( src ) );
//   // return _.unroll._make( src );
// }

//

function _cloneShallow( src )
{
  let result = _.array._cloneShallow( ... arguments );
  result[ unrollSymbol ] = true;
  if( !_.unroll.is( src ) )
  result = _.unroll.normalize( result );
  return result;
}

//

// function cloneShallow( src )
// {
//   _.assert( arguments.length === 1 );
//   return _.unroll._cloneShallow( src );
// }

//

/**
 * The routine from() performs conversion of {-src-} to unroll-array.
 *
 * If {-src-} is not unroll-array, routine from() returns new unroll-array.
 * If {-src-} is unroll-array, then routine returns {-src-}.
 *
 * @param { Long|Set|Number|Null|Undefined } src - The number, array-like object or Unroll. If null is provided,
 * then routine returns an empty Unroll.
 *
 * @example
 * let got = _.unroll.from( null );
 * // returns []
 * _.unrollIs( got );
 * // returns true
 *
 * @example
 * let got = _.unroll.from( 3 );
 * // returns [ undefined, undefined, undefined ]
 * _.unrollIs( got );
 * // returns true
 *
 * @example
 * let got = _.unroll.from( [ 1, 2, 'str' ] );
 * // returns [ 1, 2, 'str' ]
 * console.log( _.unrollIs( got ) );
 * // log true
 *
 * @example
 * let got = _.unroll.from( new F32x( [ 1, 2, 0 ] ) );
 * // returns [ 1, 2, 0 ]
 * console.log( _.unrollIs( got ) );
 * // log true
 *
 * @example
 * let got = _.unroll.from( new Set( [ 1, 2, 'str' ] ) );
 * // returns [ 1, 2, 'str' ]
 * console.log( _.unrollIs( got ) );
 * // log true
 *
 * @example
 * let src = _.unroll.make( [ 1, 2, 'str' ] );
 * let got = _.unroll.from( src );
 * // returns [ 1, 2, 'str' ]
 * console.log ( src === got );
 * // log true
 *
 * @returns { Unroll } Returns Unroll converted from {-src-}. If {-src-} is Unroll, then routine returns {-src-}.
 * @function from
 * @throws { Error } If arguments.length is less or more then one.
 * @throws { Error } If argument {-src-} is not Long, not number, not Set, not null, not undefined.
 * @namespace Tools/unroll
 */

// function _from( src )
// {
//   if( _.unrollIs( src ) )
//   return src;
//   return _.unroll._make( ... arguments );
// }
//
// //
//
// function from( src )
// {
//   _.assert( arguments.length === 1 );
//   _.assert( src === null || _.number.is( src ) || _.countable.is( src ) );
//   return _.unroll._from( ... arguments );
// }

//

function _as( src )
{
  if( _.unrollIs( src ) )
  return src;
  if( _.countable.is( src ) )
  return _.unroll._make( ... arguments );
  if( src === undefined )
  return _.unroll._make( [] );
  return _.unroll._make( [ src ] );
}

//

function as( src )
{
  _.assert( arguments.length === 1 );
  return _.unroll._as( ... arguments );
}

//

/**
 * The routine normalize() performs normalization of {-dstArray-}.
 * Normalization is unrolling of Unrolls, which is elements of {-dstArray-}.
 *
 * If {-dstArray-} is unroll-array, routine normalize() returns unroll-array
 * with normalized elements.
 * If {-dstArray-} is array, routine normalize() returns array with unrolled elements.
 *
 * @param { Array|Unroll } dstArray - The Unroll to be unrolled (normalized).
 *
 * @example
 * let unroll = _.unroll.from( [ 1, 2, _.unroll.make( [ 3, 'str' ] ) ] );
 * let result = _.unroll.normalize( unroll )
 * console.log( result );
 * // log [ 1, 2, 3, 'str' ]
 * console.log( _.unrollIs( result ) );
 * // log true
 *
 * @example
 * let unroll = _.unroll.from( [ 1,'str' ] );
 * let result = _.unroll.normalize( [ 1, unroll, [ unroll ] ] );
 * console.log( result );
 * // log [ 1, 1, 'str', [ 1, 'str' ] ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @returns { Array } If {-dstArray-} is array, routine returns an array with normalized elements.
 * @returns { Unroll } If {-dstArray-} is Unroll, routine returns an Unroll with normalized elements.
 * @function normalize
 * @throws { Error } If ( arguments.length ) is not equal to one.
 * @throws { Error } If argument ( dstArray ) is not arrayLike.
 * @namespace Tools/unroll
 */

function normalize( dstArray )
{

  _.assert( arguments.length === 1 );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  for( let a = 0 ; a < dstArray.length ; a++ )
  {
    if( _.unrollIs( dstArray[ a ] ) )
    {
      let args = [ a, 1 ];
      args.push.apply( args, dstArray[ a ] );
      dstArray.splice.apply( dstArray, args );
      a += args.length - 3;
      /* no normalization of ready unrolls, them should be normal */
    }
    else if( _.arrayIs( dstArray[ a ] ) )
    {
      _.unroll.normalize( dstArray[ a ] );
    }
  }

  return dstArray;
}

// --
// editor
// --

/**
 * The routine prepend() returns an array with elements added to the begin of destination array {-dstArray-}.
 * During the operation unrolling of Unrolls happens.
 *
 * If {-dstArray-} is unroll-array, routine prepend() returns unroll-array
 * with normalized elements.
 * If {-dstArray-} is array, routine prepend() returns array with unrolled elements.
 *
 * @param { Array|Unroll } dstArray - The destination array.
 * @param { * } args - The elements to be added.
 *
 * @example
 * let result = _.prepend( null, [ 1, 2, 'str' ] );
 * console.log( result );
 * // log [ [ 1, 2, 'str' ] ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.prepend( null, _.unroll.make( [ 1, 2, 'str' ] ) );
 * console.log( result );
 * // log [ 1, 2, 'str' ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.prepend( _.unroll.from( [ 1, 'str' ] ), [ 1, 2 ] );
 * console.log( result );
 * // log [ [ 1, 2 ], 1, 'str' ]
 * console.log( _.unrollIs( result ) );
 * // log true
 *
 * @example
 * let result = _.prepend( [ 1, 'str' ],  _.unroll.from( [ 2, 3 ] ) );
 * console.log( result );
 * // log [ 2, 3, 1, 'str' ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.prepend( _.unroll.make( [ 1, 'str' ] ),  _.unroll.from( [ 2, 3 ] ) );
 * console.log( result );
 * // log [ 2, 3, 1, 'str' ]
 * console.log( _.unrollIs( result ) );
 * // log true
 *
 * @returns { Unroll } If {-dstArray-} is Unroll, routine returns updated Unroll
 * with normalized elements that are added to the begin of {-dstArray-}.
 * @returns { Array } If {-dstArray-} is array, routine returns updated array
 * with normalized elements that are added to the begin of {-dstArray-}.
 * If {-dstArray-} is null, routine returns empty array.
 * @function prepend
 * @throws { Error } An Error if {-dstArray-} is not an Array or not null.
 * @throws { Error } An Error if ( arguments.length ) is less then one.
 * @namespace Tools
 */

function prepend( dstArray )
{
  _.assert( arguments.length >= 1 );
  _.assert( _.longIs( dstArray ) || dstArray === null, 'Expects long or unroll' );

  dstArray = dstArray || [];

  _prepend( dstArray, Array.prototype.slice.call( arguments, 1 ) );

  return dstArray;

  function _prepend( dstArray, srcArray )
  {

    for( let a = srcArray.length - 1 ; a >= 0 ; a-- )
    {
      if( _.unrollIs( srcArray[ a ] ) )
      {
        _prepend( dstArray, srcArray[ a ] );
      }
      else
      {
        if( _.arrayIs( srcArray[ a ] ) )
        _.unroll.normalize( srcArray[ a ] )
        dstArray.unshift( srcArray[ a ] );
      }
    }

    return dstArray;
  }

}

//

/**
 * The routine append() returns an array with elements added to the end of destination array {-dstArray-}.
 * During the operation unrolling of Unrolls happens.
 *
 * If {-dstArray-} is unroll-array, routine append() returns unroll-array
 * with normalized elements.
 * If {-dstArray-} is array, routine append() returns array with unrolled elements.
 *
 * @param { Array|Unroll } dstArray - The destination array.
 * @param { * } args - The elements to be added.
 *
 * @example
 * let result = _.append( null, [ 1, 2, 'str' ] );
 * console.log( result );
 * // log [ [ 1, 2, 'str' ] ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.append( null, _.unroll.make( [ 1, 2, 'str' ] ) );
 * console.log( result );
 * // log [ 1, 2, str ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.append( _.unroll.from( [ 1, 'str' ] ), [ 1, 2 ] );
 * console.log( result );
 * // log [ 1, 'str', [ 1, 2 ] ]
 * console.log( _.unrollIs( result ) );
 * // log true
 *
 * @example
 * let result = _.append( [ 1, 'str' ],  _.unroll.from( [ 2, 3 ] ) );
 * console.log( result );
 * // log [ 1, 'str', 2, 3 ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.append( _.unroll.make( [ 1, 'str' ] ),  _.unroll.from( [ 2, 3 ] ) );
 * console.log( result );
 * // log [ 1, 'str', 2, 3 ]
 * console.log( _.unrollIs( result ) );
 * // log true
 *
 * @returns { Unroll } If {-dstArray-} is Unroll, routine returns updated Unroll
 * with normalized elements that are added to the end of {-dstArray-}.
 * @returns { Array } If {-dstArray-} is array, routine returns updated array
 * with normalized elements that are added to the end of {-dstArray-}.
 * If {-dstArray-} is null, routine returns empty array.
 * @function append
 * @throws { Error } An Error if {-dstArray-} is not an Array or not null.
 * @throws { Error } An Error if ( arguments.length ) is less then one.
 * @namespace Tools
 */

function append( dstArray )
{
  _.assert( arguments.length >= 1 );
  _.assert( _.longIs( dstArray ) || dstArray === null, 'Expects long or unroll' );

  dstArray = dstArray || [];

  _append( dstArray, Array.prototype.slice.call( arguments, 1 ) );

  return dstArray;

  function _append( dstArray, srcArray )
  {
    _.assert( arguments.length === 2 );

    for( let a = 0, len = srcArray.length ; a < len; a++ )
    {
      if( _.unrollIs( srcArray[ a ] ) )
      {
        _append( dstArray, srcArray[ a ] );
      }
      else
      {
        if( _.arrayIs( srcArray[ a ] ) )
        _.unroll.normalize( srcArray[ a ] )
        dstArray.push( srcArray[ a ] );
      }
    }

    return dstArray;
  }

}

//

/**
 * The routine remove() removes all matching elements in destination array {-dstArray-}
 * and returns a modified {-dstArray-}. During the operation unrolling of Unrolls happens.
 *
 * @param { Array|Unroll } dstArray - The destination array.
 * @param { * } args - The elements to be removed.
 *
 * @example
 * let result = _.remove( null, [ 1, 2, 'str' ] );
 * console.log( result );
 * // log []
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.remove( _.unroll.make( null ), [ 1, 2, 'str' ] );
 * console.log( result );
 * // log []
 * console.log( _.unrollIs( result ) );
 * // log true
 *
 * @example
 * let result = _.remove( [ 1, 2, 1, 3, 'str' ], [ 1, 'str', 0, 5 ] );
 * console.log( result );
 * // log [ 1, 2, 1, 3, 'str' ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.remove( [ 1, 2, 1, 3, 'str' ], _.unroll.from( [ 1, 'str', 0, 5 ] ) );
 * console.log( result );
 * // log [ 2, 3 ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let result = _.remove( _.unroll.from( [ 1, 2, 1, 3, 'str' ] ), [ 1, 'str', 0, 5 ] );
 * console.log( result );
 * // log [ 1, 2, 1, 3, 'str' ]
 * console.log( _.unrollIs( result ) );
 * // log true
 *
 * @example
 * let dstArray = _.unroll.from( [ 1, 2, 1, 3, 'str' ] );
 * let ins = _.unroll.from( [ 1, 'str', 0, 5 ] );
 * let result = _.remove( dstArray, ins );
 * console.log( result );
 * // log [ 2, 3 ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @example
 * let dstArray = _.unroll.from( [ 1, 2, 1, 3, 'str' ] );
 * let ins = _.unroll.from( [ 1, _.unroll.make( [ 'str', 0, 5 ] ) ] );
 * let result = _.remove( dstArray, ins );
 * console.log( result );
 * // log [ 2, 3 ]
 * console.log( _.unrollIs( result ) );
 * // log false
 *
 * @returns { Unroll } If {-dstArray-} is Unroll, routine removes all matching elements
 * and returns updated Unroll.
 * @returns { Array } If {-dstArray-} is array, routine removes all matching elements
 * and returns updated array. If {-dstArray-} is null, routine returns empty array.
 * @function append
 * @throws { Error } An Error if {-dstArray-} is not an Array or not null.
 * @throws { Error } An Error if ( arguments.length ) is less then one.
 * @namespace Tools
 */

function remove( dstArray )
{
  _.assert( arguments.length >= 2 );
  _.assert( _.longIs( dstArray ) || dstArray === null, 'Expects long or unroll' );

  dstArray = dstArray || [];

  _remove( dstArray, Array.prototype.slice.call( arguments, 1 ) );

  return dstArray;

  function _remove( dstArray, srcArray )
  {
    _.assert( arguments.length === 2 );

    for( let a = 0, len = srcArray.length ; a < len; a++ )
    {
      if( _.unrollIs( srcArray[ a ] ) )
      {
        _remove( dstArray, srcArray[ a ] );
      }
      else
      {
        if( _.arrayIs( srcArray[ a ] ) )
        _.unroll.normalize( srcArray[ a ] );
        while( dstArray.indexOf( srcArray[ a ] ) >= 0 )
        dstArray.splice( dstArray.indexOf( srcArray[ a ] ), 1 );
      }
    }

    return dstArray;
  }

}

// --
// declaration
// --

let unrollSymbol = Symbol.for( 'unroll' );

// --
// declaration
// --

let ToolsExtension =
{

  // dichotomy

  unrollIs : is.bind( _.unroll ),
  unrollIsEmpty : isEmpty.bind( _.unroll ),
  unrollIsPopulated : isPopulated.bind( _.unroll ),
  unrollLike : like.bind( _.unroll ),

  // maker

  unrollMakeEmpty : _.argumentsArray.makeEmpty.bind( _.unroll ),
  // unrollMakeEmpty : makeEmpty.bind( _.unroll ),
  unrollMakeUndefined : _.argumentsArray.makeUndefined.bind( _.unroll ),
  // unrollMakeUndefined : makeUndefined.bind( _.unroll ),
  unrollMake : _.argumentsArray.make.bind( _.unroll ),
  // unrollMake : make.bind( _.unroll ),
  unrollCloneShallow : _.argumentsArray.cloneShallow.bind( _.unroll ),
  // unrollCloneShallow : cloneShallow.bind( _.unroll ),
  unrollFrom : _.argumentsArray.from.bind( _.unroll ),
  // unrollFrom : from.bind( _.unroll ),

  // editor

  unrollPrepend : prepend.bind( _.unroll ),
  unrollAppend : append.bind( _.unroll ),
  unrollRemove : remove.bind( _.unroll ),

}

//

Object.assign( _, ToolsExtension );

//

/* qqq : for junior : make replacements */

let UnrollExtension =
{

  //

  NamespaceName : 'unroll',
  NamespaceNames : [ 'unroll' ],
  NamespaceQname : 'wTools/unroll',
  MoreGeneralNamespaceName : 'long',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'Unroll',
  TypeNames : [ 'Unroll' ],
  // SecondTypeName : 'Unroll',
  InstanceConstructor : null,
  tools : _,
  symbol : unrollSymbol,

  // dichotomy

  is,
  isEmpty,
  isPopulated,
  like,
  IsResizable,

  // maker

  _makeEmpty : _.argumentsArray._makeEmpty,
  makeEmpty : _.argumentsArray.makeEmpty, /* qqq : for junior : cover */
  _makeUndefined : _.argumentsArray._makeUndefined,
  makeUndefined : _.argumentsArray.makeUndefined, /* qqq : for junior : cover */
  _makeZeroed : _.argumentsArray._makeZeroed,
  makeZeroed : _.argumentsArray.makeZeroed, /* qqq : for junior : cover */
  _makeFilling : _.argumentsArray._makeFilling,
  makeFilling : _.argumentsArray.makeFilling,
  _make,
  make : _.argumentsArray.make, /* qqq : for junior : cover */
  // make, /* qqq : for junior : cover */
  _cloneShallow,
  cloneShallow : _.argumentsArray.cloneShallow, /* qqq : for junior : cover */
  // _from,
  from : _.argumentsArray.from,
  _as,
  as,
  normalize,

  // editor

  prepend,
  append,
  remove,

  // meta

  namespaceOf : _.blank.namespaceOf,
  namespaceWithDefaultOf : _.blank.namespaceWithDefaultOf,
  _functor_functor : _.blank._functor_functor,

}

//

Object.assign( _.unroll, UnrollExtension );
_.long._namespaceRegister( _.unroll );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Unroll.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Unroll_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Unroll_s */ })();

/* */  /* begin of file Vector_s */ ( function Vector_s() { function Vector_s_naked() { ( function _l1_Vector_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.vector = _.vector || Object.create( null );

_.assert( !!_.long.make, 'Expects routine _.long.make' );

// --
// implementation
// --

function is( src )
{

  if( _.arrayIs( src ) )
  return true;
  if( _.primitive.is( src ) )
  return false;

  if( _.class.methodIteratorOf( src ) )
  if( _.number.is( src.length ) ) /* yyy */
  if( !_.mapIs( src ) )
  return true;

  return false;
}

//

function like( src )
{
  return _.vector.is( src );
}

//

function IsResizable()
{
  _.assert( arguments.length === 0 );
  return this.default.IsResizable();
}

// --
// meta
// --

/* qqq : optimize */
function namespaceOf( src )
{
  if( !this.is( src ) )
  return null;

  let result = _.long.namespaceOf( src );
  if( result )
  return result;

  return this;
}

// --
// extension
// --

var ToolsExtension =
{

  vectorIs : is.bind( _.vector ),
  vectorLike : like.bind( _.vector ),

}

Object.assign( _, ToolsExtension );

//

var VectorExtension =
{

  //

  NamespaceName : 'vector',
  NamespaceNames : [ 'vector' ],
  NamespaceQname : 'wTools/vector',
  MoreGeneralNamespaceName : 'countable',
  MostGeneralNamespaceName : 'countable',
  TypeName : 'Vector',
  TypeNames : [ 'Vector' ],
  // SecondTypeName : 'Vector',
  InstanceConstructor : null,
  tools : _,

  // dichotomy

  is, /* qqq : cover here and in the module::MathVector */
  like, /* qqq : cover here and in the module::MathVector */
  IsResizable,

  // maker

  _makeEmpty : _.countable._makeEmpty,
  makeEmpty : _.countable.makeEmpty, /* qqq : for junior : cover */
  _makeUndefined : _.countable._makeUndefined,
  makeUndefined : _.countable.makeUndefined, /* qqq : for junior : cover */
  _makeZeroed : _.countable._makeZeroed,
  makeZeroed : _.countable.makeZeroed, /* qqq : for junior : cover */
  _make : _.countable._make,
  make : _.countable.make, /* qqq : for junior : cover */
  _cloneShallow : _.countable._cloneShallow,
  cloneShallow : _.countable.cloneShallow, /* qqq : for junior : cover */
  from : _.countable.from, /* qqq : for junior : cover */

  // meta

  namespaceOf,
  namespaceWithDefaultOf : _.props.namespaceWithDefaultOf,
  _functor_functor : _.props._functor_functor,

}

Object.assign( _.vector, VectorExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Vector.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Vector_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Vector_s */ })();

/* */  /* begin of file Wrap_s */ ( function Wrap_s() { function Wrap_s_naked() { ( function _l1_Wrap_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.wrap = _.wrap || Object.create( null );

// --
// implement
// --

// --
// declare
// --

var Extension =
{
}

//

Object.assign( _.wrap, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/Wrap.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Wrap_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Wrap_s */ })();

/* */  /* begin of file zErr_s */ ( function zErr_s() { function zErr_s_naked() { ( function _l1_1Err_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _global_.wTools;

_.error = _.error || Object.create( null );

// --
// dichotomy
// --

function is( src )
{
  return src instanceof Error || Object.prototype.toString.call( src ) === '[object Error]';
}

//

function isFormed( src )
{
  if( !_.error.is( src ) )
  return false;
  return src.originalMessage !== undefined;
}

//

function isAttended( src )
{
  if( !_.error.is( src ) )
  return false;
  return !!src.attended;
}

//

function isLogged( src )
{
  if( _.error.is( src ) === false )
  return false;
  return !!src.logged;
}

//

function isSuspended( src )
{
  if( _.error.is( src ) === false )
  return false;
  return !!src.suspended;
}

//

function isWary( src )
{
  if( _.error.is( src ) === false )
  return false;
  return !!src.wary;
}

//

function isBrief( src )
{
  if( !_.error.is( src ) )
  return false;
  return !!src.brief;
}


// --
// generator
// --

function _sectionsJoin( o )
{
  o.message = o.message || '';

  // _.map.assertHasAll( o, _sectionsJoin.defaults );

  if( Config.debug )
  for( let k in _sectionsJoin.defaults )
  {
    if( o[ k ] === undefined )
    throw Error( `Expects defined option::${k}` );
  }

  for( let s in o.sections )
  {
    let section = o.sections[ s ];
    let head = section.head || '';
    let body = strLinesIndentation( section.body, '    ' );
    if( !body.trim().length )
    continue;
    o.message += ` = ${head}\n${body}\n\n`;
  }

  return o.message;

  function strLinesIndentation( str, indentation )
  {
    if( _.strLinesIndentation )
    return indentation + _.strLinesIndentation( str, indentation );
    else
    return str;
  }

}

_sectionsJoin.defaults =
{
  sections : null,
  message : '',
}

//

function _messageForm( o )
{

  o.message = o.message || '';

  if( !_.strIs( o.originalMessage ) )
  throw 'Expects string {- o.originalMessage -}';

  // _.map.assertHasAll( o, _messageForm.defaults );

  if( Config.debug )
  for( let k in _messageForm.defaults )
  {
    if( o[ k ] === undefined )
    throw Error( `Expects defined option::${k}` );
  }

  if( o.brief )
  {
    o.message += o.originalMessage;
  }
  else
  {
    o.message = _.error._sectionsJoin( o );
  }

  if( o.error )
  nonenumerable( 'message', o.message );

  return o.message;

  /* */

  function nonenumerable( propName, value )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        writable : true,
        value,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
  }

}

_messageForm.defaults =
{
  error : null,
  sections : null,
  brief : false,
  message : '',
}

//

/* qqq : cover please */
function sectionRemove( error, name )
{

  _.assert( arguments.length === 2 );
  _.assert( !!error );
  _.assert( _.strDefined( name ) );

  if( !_.error.isFormed( error ) )
  error = _.err( error );

  delete eror.sections[ name ];

  let o2 = Object.create( null );
  o2.error = error;
  o2.sections = error.sections;
  o2.brief = error.brief;
  o2.message = '';
  o2.originalMessage = error.originalMessage;
  _.error._messageForm( o2 );

  return error;
}

//

function sectionAdd( o )
{

  if( arguments.length === 2 )
  {
    o = arguments[ 1 ];
    o.error = arguments[ 0 ];
  }

  _.routine.options( sectionAdd, o ); /* qqq : eliminate such routines here */
  if( o.head === null )
  o.head = o.name.substring( 0, 1 ).toUpperCase() + o.name.substring( 1 );

  _.assert( _.strDefined( o.name ) ); /* qqq : eliminate such routines here */
  _.assert( _.strDefined( o.head ) );
  _.assert( _.strDefined( o.body ) );
  _.assert( !!o.error );

  if( !_.error.isFormed( o.error ) )
  {
    o.error = _._err({ args : [ o.error ], sections : { [ o.name ] : { head : o.head, body : o.body } } });
    return o.error;
  }

  o.sections = o.error.sections;
  _.error._sectionAdd( o );

  o.brief = o.error.brief;
  o.message = '';
  o.originalMessage = o.error.originalMessage;
  _.error._messageForm( o );

  return o.error;
}

sectionAdd.defaults =
{
  error : null,
  name : null,
  head : null,
  body : null,
}

//

function _sectionAdd( o )
{

  if( Config.debug )
  for( let k in _sectionAdd.defaults )
  {
    if( o[ k ] === undefined )
    throw Error( `Expects defined option::${k}` );
  }

  let section = Object.create( null );
  section.name = o.name;
  section.head = o.head;
  section.body = o.body;
  o.sections[ o.name ] = section;
  return section;
}

_sectionAdd.defaults =
{
  sections : null,
  name : null,
  head : null,
  body : null,
}

//

function _sectionExposedAdd( o )
{
  const exportString = _.entity.exportString ? _.entity.exportString.bind( _.entity ) : String;

  if( Config.debug )
  for( let k in _sectionExposedAdd.defaults )
  {
    if( o[ k ] === undefined )
    throw Error( `Expects defined option::${k}` );
  }

  let i = 0;
  let body = '';
  for( let k in o.exposed )
  {
    if( i > 0 )
    body += `\n`;
    body += `${k} : ${exportString( o.exposed[ k ] )}`;
    i += 1;
  }

  _.error._sectionAdd
  ({
    sections : o.sections,
    name : 'exposed',
    head : 'Exposed',
    body,
  });
}

_sectionExposedAdd.defaults =
{
  sections : null,
  exposed : null,
}

//

function exposedSet( args, props )
{

  _.assert( arguments.length === 2 );
  _.assert( _.mapIs( props ) )

  if( !_.longIs( args ) )
  args = [ args ];

  let err = args[ 0 ];

  if( _.symbol.is( err ) )
  {
    _.assert( args.length === 1 );
    return err;
  }

  if( args.length !== 1 || !_.error.isFormed( err ) )
  err = _._err
  ({
    args,
    level : 2,
  });

  /* */

  try
  {

    for( let f in props )
    {
      err[ f ] = props[ f ];
    }

  }
  catch( err )
  {
    if( Config.debug )
    console.error( `Cant assign "${f}" property to error\n${err.toString()}` );
  }

  /* */

  return err;
}

//

function concealedSet( args, props )
{

  _.assert( arguments.length === 2 );
  _.assert( _.mapIs( props ) )

  if( !_.longIs( args ) )
  args = [ args ];

  let err = args[ 0 ];

  if( _.symbol.is( err ) )
  {
    _.assert( args.length === 1 );
    return err;
  }

  if( args.length !== 1 || !_.error.isFormed( err ) )
  err = _._err
  ({
    args,
    level : 2,
  });

  /* */

  try
  {

    for( let f in props )
    {
      let o =
      {
        enumerable : false,
        configurable : true,
        writable : true,
        value : props[ f ],
      };
      Object.defineProperty( err, f, o );
    }

  }
  catch( err )
  {
    if( Config.debug )
    console.error( `Cant assign "${f}" property to error\n${err.toString()}` );
  }

  /* */

  return err;
}

//

function _inStr( errStr )
{
  _.assert( _.strIs( errStr ) );

  if( !_.strHas( errStr, /\=\s+Message of/m ) )
  return false;

  if( !_.strHas( errStr, /(^|\n)\s*=\s+Beautified calls stack/m ) )
  return false;

  return true;
}

// --
// introductor
// --

function _make( o )
{
  const logger = _global_.logger || _global_.console;

  if( arguments.length !== 1 )
  throw Error( 'Expects single argument : options map' );

  if( !_.mapIs( o ) )
  throw Error( 'Expects single argument : options map' );

  for( let k in o )
  {
    if( _make.defaults[ k ] === undefined )
    throw Error( `Unknown option::${k}` );
  }

  for( let k in _.error._make.defaults )
  {
    if( o[ k ] === undefined )
    o[ k ] = _.error._make.defaults[ k ];
  }

  if( !_.error.is( o.error ) )
  throw Error( 'Expects option.error:Error' );

  if( !_.strIs( o.originalMessage ) )
  throw Error( 'Expects option.originalMessage:String' );

  if( !_.strIs( o.combinedStack ) )
  throw Error( 'Expects option.combinedStack:String' );

  if( !_.strIs( o.throwCallsStack ) )
  throw Error( 'Expects option.throwCallsStack:String' );

  if( !_.strIs( o.throwsStack ) )
  throw Error( 'Expects option.throwsStack:String' );

  if( !o.throwLocation )
  throw Error( 'Expects option.throwLocation:Location' );

  attributesForm();
  exposedForm();
  sectionsForm();
  _.error._messageForm( o );
  form();

  return o.error;

  /* */

  function attributesForm()
  {

    if( o.attended === null || o.attended === undefined )
    o.attended = o.error.attended;
    o.attended = !!o.attended;

    if( o.logged === null || o.logged === undefined )
    o.logged = o.error.logged;
    o.logged = !!o.logged;

    if( o.brief === null || o.brief === undefined )
    o.brief = o.error.brief;
    o.brief = !!o.brief;

    if( o.reason === null || o.reason === undefined )
    o.reason = o.error.reason;

    o.sections = o.sections || Object.create( null );
    if( o.error.section )
    _.props.supplement( o.sections, o.error.section );

    o.id = o.error.id;
    if( !o.id )
    {
      _.error._errorCounter += 1;
      o.id = _.error._errorCounter;
    }

  }

  /* */

  function exposedForm()
  {
    var has = false;
    for( let k in o.error )
    {
      has = true;
      break;
    }
    if( has )
    {
      if( o.exposed )
      {
        for( let k in o.error )
        if( !Reflect.has( o.exposed, k ) )
        o.exposed[ k ] = o.error[ k ];
      }
      else
      {
        o.exposed = Object.create( null );
        for( let k in o.error )
        o.exposed[ k ] = o.error[ k ];
      }
    }
  }

  /* */

  function sectionsForm()
  {
    let result = '';

    // sectionAdd( 'message', `Message of Error#${o.id}`, o.originalMessage );
    sectionAdd( 'message', `Message of ${o.error.name || 'error'}#${o.id}`, o.originalMessage );
    sectionAdd( 'combinedStack', o.stackCondensing ? 'Beautified calls stack' : 'Calls stack', o.combinedStack );
    sectionAdd( 'throwsStack', `Throws stack`, o.throwsStack );

    /* xxx : postpone */
    if( o.sourceCode )
    if( _.strIs( o.sourceCode ) )
    sectionAdd( 'sourceCode', `Source code`, o.sourceCode );
    else if( _.routine.is( o.sourceCode.read ) )
    sectionAdd( 'sourceCode', `Source code from ${o.sourceCode.path}`, o.sourceCode.read );
    else if( _.strIs( o.sourceCode.code ) )
    sectionAdd( 'sourceCode', `Source code from ${o.sourceCode.path}`, o.sourceCode.code );
    else
    console.error( 'Unknown format of {- o.sourceCode -}' );

    if( o.exposed && Object.keys( o.exposed ).length > 0 )
    _.error._sectionExposedAdd( o );

    for( let s in o.sections )
    {
      let section = o.sections[ s ];
      if( !_.strIs( section.head ) )
      {
        logger.error
        (
          `Each section of an error should have head, but head of section::${s} is ${_.entity.strType(section.head)}`
        );
        delete o.sections[ s ];
      }
      if( !_.strIs( section.body ) )
      {
        logger.error
        (
          `Each section of an error should have body, but body of section::${s} is ${_.entity.strType(section.body)}`
        );
        delete o.sections[ s ];
      }
    }

    return result;
  }

  /* */

  function sectionAdd( name, head, body )
  {
    _.error._sectionAdd({ name, head, body, sections : o.sections });
  }

  /* */

  function form()
  {

    nonenumerable( 'originalMessage', o.originalMessage );
    logging( 'stack' );
    nonenumerable( 'reason', o.reason );

    nonenumerable( 'combinedStack', o.combinedStack );
    nonenumerable( 'throwCallsStack', o.throwCallsStack );
    nonenumerable( 'asyncCallsStack', o.asyncCallsStack );
    nonenumerable( 'throwsStack', o.throwsStack );
    nonenumerable( 'catchCounter', o.error.catchCounter ? o.error.catchCounter+1 : 1 );

    nonenumerable( 'attended', o.attended );
    nonenumerable( 'logged', o.logged );
    nonenumerable( 'brief', o.brief );

    if( o.throwLocation.line !== undefined )
    nonenumerable( 'lineNumber', o.throwLocation.line );
    if( o.error.throwLocation === undefined )
    nonenumerable( 'location', o.throwLocation );
    nonenumerable( 'sourceCode', o.sourceCode || null );
    nonenumerable( 'id', o.id );

    nonenumerable( 'toString', function() { return this.stack } );
    nonenumerable( 'sections', o.sections );

    getter( 'name', function() { return this.constructor.name } );

    o.error[ Symbol.for( 'nodejs.util.inspect.custom' ) ] = o.error.toString;

    if( o.concealed )
    {
      for( let k in o.concealed )
      nonenumerable( k, o.concealed[ k ] );
    }

  }

  /* */

  function nonenumerable( propName, value )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        writable : true,
        value,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
  }

  /* */

  function getter( propName, get )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        get,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
  }

  /* */

  function logging( propName )
  {
    try
    {
      let o2 =
      {
        enumerable : false,
        configurable : true,
        get,
        set,
      };
      Object.defineProperty( o.error, propName, o2 );
    }
    catch( err2 )
    {
      console.error( err2 );
    }
    function get()
    {
      /*
      workaround to avoid Njs issue: Njs stingify inherited error
      */
      /* zzz : qqq : find better solution */
      if( ( new Error().stack ).split( '\n' ).length !== 3 )
      {
        _.error.logged( this );
        _.error.attend( this );
      }
      return this.message;
    }
    function set( src )
    {
      this.message = src;
      return src;
    }
  }

}

_make.defaults =
{

  error : null,
  id : null,
  throwLocation : null,
  sections : null, /* qqq : cover please */
  concealed : null, /* qqq : cover please */
  exposed : null,

  attended : null,
  logged : null,
  brief : null,
  stackCondensing : null,

  originalMessage : null,
  combinedStack : '',
  throwCallsStack : '',
  throwsStack : '',
  asyncCallsStack : '',
  sourceCode : null,
  reason : null,

}

//

/**
 * Creates Error object based on passed options.
 * Result error contains in message detailed stack trace and error description.
 * @param {Object} o Options for creating error.
 * @param {String[]|Error[]} o.args array with messages or errors objects, from which will be created Error obj.
 * @param {number} [o.level] using for specifying in error message on which level of stack trace was caught error.
 * @returns {Error} Result Error. If in `o.args` passed Error object, result will be reference to it.
 * @private
 * @throws {Error} Expects single argument if pass les or more than one argument
 * @throws {Error} o.args should be array like, if o.args is not array.
 * @function _err
 * @namespace Tools
 */

function _err( o )
{
  const exportString = _.entity.exportString ? _.entity.exportString.bind( _.entity ) : String;
  let error;

  if( arguments.length !== 1 )
  throw Error( '_err : Expects single argument : options map' );

  if( !_.mapIs( o ) )
  throw Error( '_err : Expects single argument : options map' );

  if( !_.longIs( o.args ) )
  throw Error( '_err : Expects Long option::args' );

  for( let e in o )
  {
    if( _err.defaults[ e ] === undefined )
    {
      debugger;
      throw Error( `Unknown option::${e}` );
    }
  }

  for( let e in _err.defaults )
  {
    if( o[ e ] === undefined )
    o[ e ] = _err.defaults[ e ];
  }

  if( _.error._errorMaking )
  {
    throw Error( 'Recursive dead lock because of error inside of routine _err()!' );
  }
  _.error._errorMaking = true;

  if( o.level === undefined || o.level === null )
  o.level = null;

  /* let */

  if( !o.message )
  o.message = '';
  let fallBackMessage = '';
  let errors = [];
  let combinedStack = '';

  /* algorithm */

  try
  {

    argumentsPreprocessArguments();
    argumentsPreprocessErrors();
    locationForm();
    stackAndErrorForm();
    attributesForm();
    catchesForm();
    sourceCodeForm();
    originalMessageForm();

    error = _.error._make
    ({
      error,
      throwLocation : o.throwLocation,
      sections : o.sections,
      concealed : o.concealed,
      exposed : o.exposed,

      attended : o.attended,
      logged : o.logged,
      brief : o.brief,
      stackCondensing : o.stackCondensing,

      originalMessage : o.message,
      combinedStack,
      throwCallsStack : o.throwCallsStack,
      throwsStack : o.throwsStack,
      asyncCallsStack : o.asyncCallsStack,
      sourceCode : o.sourceCode,
      reason : o.reason,
    });

  }
  catch( err2 )
  {
    _.error._errorMaking = false;
    console.log( err2.message );
    console.log( err2.stack );
  }
  _.error._errorMaking = false;

  return error;

  /* */

  function argumentsPreprocessArguments()
  {

    for( let a = 0 ; a < o.args.length ; a++ )
    {
      let arg = o.args[ a ];

      if( !_.error.is( arg ) && _.routine.is( arg ) )
      {
        if( arg.length === 0 )
        {
          try
          {
            arg = o.args[ a ] = arg();
          }
          catch( err )
          {
            let original = arg;
            arg = o.args[ a ] = 'Error throwen by callback for formatting of error string';
            console.error( String( err ) );
            if( _.strLinesSelect ) /* aaa : for Dmytro : make sure it works and cover */ /* Dmytro : works, covered. Test routine `_errWithArgsIncludedRoutine` */
            console.error( _.strLinesSelect
            ({
              src : original.toString(),
              line : 0,
              nearestLines : 5,
              numbering : 1,
            }));
            else
            console.error( original.toString() );
          }
        }
        if( _.unrollIs( arg ) )
        {
          debugger;
          o.args = [ ... Array.prototype.slice.call( o.args, 0, a ), ... arg, ... Array.prototype.slice.call( o.args, a+1, o.args.length ) ];
          // o.args = _.longBut_( null, o.args, [ a, a ], arg );
          // o.args = _.longBut( o.args, [ a, a+1 ], arg );
          a -= 1;
          continue;
        }
      }

    }

  }

  /* */

  function argumentsPreprocessErrors()
  {

    for( let a = 0 ; a < o.args.length ; a++ )
    {
      let arg = o.args[ a ];

      if( _.error.is( arg ) )
      {

        errProcess( arg );
        o.args[ a ] = _.error.originalMessage( arg )

      }
      else if( _.strIs( arg ) && _.error._inStr( arg ) )
      {

        let err = _.error.fromStr( arg );
        errProcess( err );
        o.args[ a ] = _.error.originalMessage( err );

      }

    }

  }

  /* */

  function errProcess( arg )
  {

    if( !error )
    {
      error = arg;
      if( !o.sourceCode )
      o.sourceCode = arg.sourceCode || null;
      if( o.attended === null )
      o.attended = arg.attended || false;
      if( o.logged === null )
      o.logged = arg.logged || false;
    }

    if( arg.throwCallsStack )
    if( !o.throwCallsStack )
    o.throwCallsStack = arg.throwCallsStack;

    // if( arg.asyncCallsStack )
    // if( !o.asyncCallsStack )
    // o.asyncCallsStack = arg.asyncCallsStack;

    if( arg.throwsStack )
    if( o.throwsStack )
    o.throwsStack += '\n' + arg.throwsStack;
    else
    o.throwsStack = arg.throwsStack;

    if( arg.constructor )
    fallBackMessage = fallBackMessage || arg.constructor.name;
    errors.push( arg );

  }

  /* */

  function locationForm()
  {

    if( !error )
    for( let a = 0 ; a < o.args.length ; a++ )
    {
      let arg = o.args[ a ];
      if( !_.primitive.is( arg ) && _.object.like( arg ) )
      try
      {
        o.throwLocation = _.introspector.location
        ({
          error : arg,
          location : o.throwLocation,
        });
      }
      catch( err2 )
      {
        console.error( err2 );
      }
    }

    o.throwLocation = o.throwLocation || Object.create( null );
    o.catchLocation = o.catchLocation || Object.create( null );

  }

  /* */

  function stackAndErrorForm()
  {

    if( error )
    {

      /* qqq : cover each if-branch. ask how to. *difficult problem* */

      if( !o.throwCallsStack )
      if( o.throwLocation )
      o.throwCallsStack = _.introspector.locationToStack( o.throwLocation );
      if( !o.throwCallsStack )
      o.throwCallsStack = _.error.originalStack( error );
      if( !o.throwCallsStack )
      o.throwCallsStack = _.introspector.stack([ ( o.level || 0 ) + 1, Infinity ]);

      if( !o.catchCallsStack && o.catchLocation )
      o.catchCallsStack = _.introspector.locationToStack( o.catchLocation );
      if( !o.catchCallsStack )
      o.catchCallsStack = _.introspector.stack( o.catchCallsStack, [ ( o.level || 0 ) + 1, Infinity ] );

      if( !o.throwCallsStack && o.catchCallsStack )
      o.throwCallsStack = o.catchCallsStack;
      if( !o.throwCallsStack )
      o.throwCallsStack = _.introspector.stack( error, [ ( o.level || 0 ) + 1, Infinity ] );

      o.level = 0;

    }
    else
    {

      error = new Error( o.message + '\n' );
      if( o.throwCallsStack )
      {
        error.stack = o.throwCallsStack;
        o.catchCallsStack = _.introspector.stack( o.catchCallsStack, [ o.level + 1, Infinity ] );
        o.level = 0;
      }
      else
      {
        if( o.catchCallsStack )
        {
          o.throwCallsStack = error.stack = o.catchCallsStack;
        }
        else
        {
          if( o.level === undefined || o.level === null )
          o.level = 1;
          o.level += 1;
          o.throwCallsStack = error.stack = _.introspector.stack( error.stack, [ o.level, Infinity ] );
        }
        o.level = 0;
        if( !o.catchCallsStack )
        o.catchCallsStack = o.throwCallsStack;
      }

    }

    _.assert( o.level === 0 );

    if( ( o.stackRemovingBeginIncluding || o.stackRemovingBeginExcluding ) && o.throwCallsStack )
    o.throwCallsStack = _.introspector.stackRemoveLeft
    (
      o.throwCallsStack, o.stackRemovingBeginIncluding || null, o.stackRemovingBeginExcluding || null
    );

    if( !o.throwCallsStack )
    o.throwCallsStack = error.stack = o.fallBackStack;

    combinedStack = o.throwCallsStack;

    _.assert
    (
      error.asyncCallsStack === undefined
      || error.asyncCallsStack === null
      || error.asyncCallsStack === ''
      || _.arrayIs( error.asyncCallsStack )
    );
    if( error.asyncCallsStack && error.asyncCallsStack.length )
    {
      o.asyncCallsStack = o.asyncCallsStack || [];
      o.asyncCallsStack.push( ... error.asyncCallsStack );
      // _.arrayAppendArray( o.asyncCallsStack, error.asyncCallsStack );
    }

    if( o.asyncCallsStack === null || o.asyncCallsStack === undefined )
    if( _.Procedure && _.Procedure.ActiveProcedure )
    o.asyncCallsStack = [ _.Procedure.ActiveProcedure.stack() ];

    _.assert( o.asyncCallsStack === null || _.arrayIs( o.asyncCallsStack ) );
    if( o.asyncCallsStack && o.asyncCallsStack.length )
    {
      combinedStack += '\n\n' + o.asyncCallsStack.join( '\n\n' );
    }

    _.assert( _.strIs( combinedStack ) );
    if( o.stackCondensing )
    combinedStack = _.introspector.stackCondense( combinedStack );

  }

  /* */

  function attributesForm()
  {

    try
    {
      o.catchLocation = _.introspector.location
      ({
        stack : o.catchCallsStack,
        location : o.catchLocation,
      });
    }
    catch( err2 )
    {
      console.error( err2 );
    }

    try
    {
      o.throwLocation = _.introspector.location
      ({
        error : error,
        stack : o.throwCallsStack,
        location : o.throwLocation,
      });
    }
    catch( err2 )
    {
      console.error( err2 );
    }

  }

  /* */

  function catchesForm()
  {

    if( o.throws )
    {
      _.assert( _.arrayIs( o.throws ) );
      o.throws.forEach( ( c ) =>
      {
        c = _.introspector.locationFromStackFrame( c ).routineFilePathLineCol;
        if( o.throwsStack )
        o.throwsStack += `\nthrown at ${c}`;
        else
        o.throwsStack = `thrown at ${c}`;
      });
    }

    _.assert( _.number.is( o.catchLocation.abstraction ) );
    if( !o.catchLocation.abstraction || o.catchLocation.abstraction === 1 )
    {
      if( o.throwsStack )
      o.throwsStack += `\nthrown at ${o.catchLocation.routineFilePathLineCol}`;
      else
      o.throwsStack = `thrown at ${o.catchLocation.routineFilePathLineCol}`;
    }

  }

  /* */

  function sourceCodeForm()
  {

    if( !o.usingSourceCode )
    return;

    if( o.sourceCode )
    return;

    if( error.sourceCode === undefined )
    {
      let c = _.introspector.code
      ({
        location : o.throwLocation,
        sourceCode : o.sourceCode,
        asMap : 1,
      });
      if( c && c.code && c.code.length < 400 )
      {
        o.sourceCode = c;
      }
    }

  }

  /* */

  function originalMessageForm()
  {
    let result = [];

    if( o.message )
    return;

    for( let a = 0 ; a < o.args.length ; a++ )
    {
      let arg = o.args[ a ];
      let str;

      if( arg && !_.primitive.is( arg ) )
      {

        if( _.routine.is( arg.toStr ) )
        {
          str = arg.toStr();
        }
        else if( _.error.is( arg ) && _.strIs( arg.originalMessage ) )
        {
          str = arg.originalMessage;
        }
        else if( _.error.is( arg ) )
        {
          if( _.strIs( arg.message ) )
          str = arg.message;
          else
          str = exportString( arg );
        }
        else
        {
          str = exportString( arg, { levels : 2 } );
        }
      }
      else if( arg === undefined )
      {
        str = '\n' + String( arg ) + '\n';
      }
      else
      {
        str = String( arg );
      }

      result[ a ] = str;

    }

    let o2 =
    {
      onToStr : eachMessageFormat,
      onPairWithDelimeter : strConcatenateCounting
    };
    o.message = _.strConcat( result, o2 );

    /*
      remove redundant spaces at the begin and the end of lines
    */

    o.message = o.message || fallBackMessage || 'UnknownError';
    o.message = o.message.replace( /^\s*/, '' );
    o.message = o.message.replace( /\x20*$/gm, '' );
    o.message = o.message.replace( /\s*$/, '' );

  }

  /* */

  function eachMessageFormat( str )
  {
    let strBeginsWithRegular = _.strBegins( str, /\S/ );
    let strEndsWithRegular = _.strEnds( str, /\S/ );

    if( !strBeginsWithRegular )
    {
      let notSpaceLikeSymbol = /\S/.exec( str );

      if( notSpaceLikeSymbol === null )
      {
        str = str.replace( /\x20+/g, '' );
        strEndsWithRegular = true;
      }
      else
      {
        let before = str.substring( 0, notSpaceLikeSymbol.index );
        let spaces = /(?<=\n)\x20+$/.exec( before );
        before = before.replace( /\x20+/g, '' );
        before += spaces ? spaces[ 0 ] : '';

        str = before + str.substring( notSpaceLikeSymbol.index );
      }
    }

    if( str && !strEndsWithRegular )
    {
      let notSpaceLikeSymbol = /\S\s*$/.exec( str );

      let after = str.substring( notSpaceLikeSymbol.index + 1 );
      let spaces = /^\x20+(?=\n)/.exec( after );
      after = after.replace( /\x20+/g, '' );
      after += spaces ? spaces[ 0 ] : '';

      str = str.substring( 0, notSpaceLikeSymbol.index + 1 ) + after;
    }

    return str;
  }

  /* */

  function strConcatenateCounting( src1, src2 )
  {
    let result;
    if( _.strEnds( src1, '\n' ) && _.strBegins( src2, '\n' ) )
    {
      let right = /\n+$/.exec( src1 );
      let left = /^\n+/.exec( src2 );

      result = src1.substring( 0, right.index );
      result += right[ 0 ].length > left[ 0 ].length ? right[ 0 ] : left[ 0 ];
      result += src2.substring( left[ 0 ].length );
    }
    else
    {
      result = src1 + src2;
    }
    return result;
  }
}

_err.defaults =
{

  /**/

  args : null,
  sections : null,
  concealed : null,
  exposed : null,
  level : 1, /* to make catch stack work properly level should be 1 by default */

  /* String */

  message : null, /* qqq : cover the option */
  reason : null,
  sourceCode : null,

  /* Boolean */

  stackRemovingBeginIncluding : 0,
  stackRemovingBeginExcluding : 0,
  usingSourceCode : 1,
  stackCondensing : 1,
  attended : null,
  logged : null,
  brief : null,

  /* Location */

  throwLocation : null,
  catchLocation : null,

  /* Stack */

  asyncCallsStack : null,
  throwCallsStack : null,
  catchCallsStack : null,
  fallBackStack : null,
  throwsStack : '',
  throws : null,

}

//

/**
 * Creates error object, with message created from passed `msg` parameters and contains error trace.
 * If passed several strings (or mixed error and strings) as arguments, the result error message is created by
 concatenating them.
 *
 * @example
 * function divide( x, y )
 * {
 *   if( y == 0 )
 *     throw _.err( 'divide by zero' )
 *   return x / y;
 * }
 * divide( 3, 0 );
 *
 * // log
 * // Error:
 * // caught     at divide (<anonymous>:2:29)
 * // divide by zero
 * // Error
 * //   at _err (file:///.../wTools/staging/Base.s:1418:13)
 * //   at wTools.err (file:///.../wTools/staging/Base.s:1449:10)
 * //   at divide (<anonymous>:2:29)
 * //   at <anonymous>:1:1
 *
 * @param {...String|Error} msg Accepts list of messeges/errors.
 * @returns {Error} Created Error. If passed existing error as one of parameters, routine modified it and return
 * reference.
 * @function err
 * @namespace Tools
 */

function err()
{
  return _._err
  ({
    args : arguments,
    level : 2,
  });
}

//

/* qqq : optimize */
function brief()
{
  return _._err
  ({
    args : arguments,
    level : 2,
    brief : 1,
  });
}

//

function unbrief()
{
  return _._err
  ({
    args : arguments,
    level : 2,
    brief : 0,
  });
}

//

function process( err )
{

  if( arguments.length !== 1 || !_.error.isFormed( err ) )
  err = _.err( ... arguments );

  if( _.process && _.process.entryPointInfo )
  _.error.sectionAdd( err, { name : 'process', body : _.process.entryPointInfo() });

  return err;
}

//

function unprocess()
{

  if( arguments.length !== 1 || !_.error.isFormed( err ) )
  err = _.err( ... arguments );

  _.error.sectionRemove( err, 'process' );

  return err;
}

//

function fromStr( errStr )
{

  try
  {

    errStr = _.str.lines.strip( errStr );

    let sectionBeginRegexp = /[=]\s+(.*?)\s*\n/mg;
    let splits = _.strSplitFast
    ({
      src : errStr,
      delimeter : sectionBeginRegexp,
    });

    let sectionName;
    let throwCallsStack = '';
    let throwsStack = '';
    let stackCondensing = true;
    let messages = [];
    for( let s = 0 ; s < splits.length ; s++ )
    {
      let split = splits[ s ];
      let sectionNameParsed = sectionBeginRegexp.exec( split + '\n' );
      if( sectionNameParsed )
      {
        sectionName = sectionNameParsed[ 1 ];
        continue;
      }

      if( !sectionName )
      messages.push( split );
      else if( !sectionName || _.strBegins( sectionName, 'Message of' ) )
      messages.push( split );
      else if( _.strBegins( sectionName, 'Beautified calls stack' ) )
      throwCallsStack = split;
      else if( _.strBegins( sectionName, 'Throws stack' ) )
      throwsStack = split;

    }

    let error = new Error();

    let throwLocation = _.introspector.locationFromStackFrame( throwCallsStack || error.stack );

    let originalMessage = messages.join( '\n' );

    let result = _.error._make
    ({
      error,
      throwLocation,
      stackCondensing,
      originalMessage,
      combinedStack : throwCallsStack,
      throwCallsStack,
      throwsStack,
    });

    return result;
  }
  catch( err2 )
  {
    console.error( err2 );
    return Error( errStr );
  }
}

// --
// stater
// --

function attend( err, value )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( value === undefined )
  value = Config.debug ? _.introspector.stack([ 0, Infinity ]) : true;
  let result = _.error.concealedSet( err, { attended : value } );
  return result;
}

//

function logged( err, value )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( value === undefined )
  value = Config.debug ? _.introspector.stack([ 0, Infinity ]) : true;
  // console.log( `logged ${value}` );
  return _.error.concealedSet( err, { logged : value } );
}

//

function suspend( err, owner, value )
{
  _.assert( arguments.length === 3 );
  _.assert( !!owner );

  /*
  cant suspend/resume suspended by another owner error
  */

  if( err.suspended && err.suspended !== owner )
  return _.error.concealedSet( err, {} );

  let value2 = err.suspended;
  if( value === undefined )
  value = true;
  let result = _.error.concealedSet( err, { suspended : value ? owner : false } );

  /*
  resuming of suspended wary error object should resume _handleUncaughtAsync
  */

  if( value2 && !value && err.wary )
  {
    _.error._handleUncaughtAsync( err );
  }

  return result
}

//

function wary( err, value )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  if( value === undefined )
  value = true;
  return _.error.concealedSet( err, { wary : value } );
}

//

/* zzz : standartize interface of similar routines */
function reason( err, value )
{

  if( arguments.length === 1 )
  {
    return err.reason;
  }
  else if( arguments.length === 2 )
  {
    // nonenumerable( 'reason', value );
    _.error.concealedSet( err, { reason : value } );
    return err.reason;
  }

  throw Error( 'Expects one or two argument' );

  // /* */
  //
  // function nonenumerable( propName, value )
  // {
  //   try
  //   {
  //     let o =
  //     {
  //       enumerable : false,
  //       configurable : true,
  //       writable : true,
  //       value,
  //     };
  //     Object.defineProperty( err, propName, o );
  //   }
  //   catch( err2 )
  //   {
  //     console.error( err2 );
  //   }
  // }

}

//

function restack( err, level )
{

  if( !( arguments.length === 1 || arguments.length === 2 ) )
  throw Error( 'Expects single argument or none' );

  if( level === undefined )
  level = 1;

  if( !_.number.defined( level ) )
  throw Error( 'Expects defined number' );

  let err2 = _._err
  ({
    args : [],
    level : level + 1,
  });

  return _.err( err2, err );
}

//

function once( err )
{

  err = _._err
  ({
    args : arguments,
    level : 2,
  });

  if( err.logged )
  return undefined;

  _.error.attend( err );

  return err;
}

//

function originalMessage( err )
{

  if( arguments.length !== 1 )
  throw Error( 'error.originalMessage : Expects single argument' );

  if( _.strIs( err ) )
  return err;

  if( !err )
  return;

  if( err.originalMessage )
  return err.originalMessage;

  let message = err.message;

  if( !message && message !== '' )
  message = err.msg;
  if( !message && message !== '' )
  message = err.name;

  return message;
}

//

function originalStack( err )
{

  if( arguments.length !== 1 )
  throw Error( 'error.originalStack : Expects single argument' );

  if( !_.error.is( err ) )
  throw Error( 'error.originalStack : Expects error' );

  if( err.throwCallsStack )
  return err.throwCallsStack;

  if( err.combinedStack )
  return err.combinedStack;

  if( err[ stackSymbol ] )
  return err[ stackSymbol ];

  if( err.stack )
  return _.introspector.stack( err.stack );

  /* should return null if nothing found */
  return null;
}

// --
// log
// --

function _log( err, logger )
{
  logger = logger || _global.logger || _global.console;

  /* */

  if( _.routine.is( err.toString ) )
  {
    let str = err.toString();
    if( _.color && _.color.strFormat )
    str = _.color.strFormat( str, 'negative' );
    logger.error( str )
  }
  else
  {
    logger.error( 'Error does not have toString' );
    logger.error( err );
  }

  /* */

  _.error.logged( err );
  _.error.attend( err );

  /* */

  return err;
}

//

/**
 * Creates error object, with message created from passed `msg` parameters and contains error trace.
 * If passed several strings (or mixed error and strings) as arguments, the result error message is created by
 concatenating them. Prints the created error.
 * If _global_.logger defined, routine will use it to print error, else uses console
 *
 * @see {@link wTools.err See err}
 *
 * @example
 * function divide( x, y )
 * {
 *   if( y == 0 )
 *    throw _.error.log( 'divide by zero' )
 *    return x / y;
 * }
 * divide( 3, 0 );
 *
 * // log
 * // Error:
 * // caught     at divide (<anonymous>:2:29)
 * // divide by zero
 * // Error
 * //   at _err (file:///.../wTools/staging/Base.s:1418:13)
 * //   at wTools.errLog (file:///.../wTools/staging/Base.s:1462:13)
 * //   at divide (<anonymous>:2:29)
 * //   at <anonymous>:1:1
 *
 * @param {...String|Error} msg Accepts list of messeges/errors.
 * @returns {Error} Created Error. If passed existing error as one of parameters, routine modified it and return
 * @function errLog
 * @namespace Tools
 */

function log()
{

  let err = _._err
  ({
    args : arguments,
    level : 2,
  });

  return _.error._log( err );
}

//

function logOnce( err )
{

  err = _._err
  ({
    args : arguments,
    level : 2,
  });

  if( err.logged )
  return err;

  return _.error._log( err );
}

//

function _Setup()
{

  Error.stackTraceLimit = Infinity;
/* Error.stackTraceLimit = 99; */

}

// --
// namespace
// --

let stackSymbol = Symbol.for( 'stack' );

let ToolsExtension =
{

  errIs : is,

  _errMake : _make,
  _err,
  err,
  errBrief : brief,
  errUnbrief : unbrief,
  errProcess : process,
  errUnprocess : unprocess,
  errAttend : attend,
  errLogged : logged,
  errSuspend : suspend,
  errWary : wary,
  errRestack : restack,
  errOnce : once,

  _errLog : _log,
  errLog : log,
  errLogOnce : logOnce,

}

Object.assign( _, ToolsExtension );

//

/**
 * @property {Object} error={}
 * @property {Boolean} breakpointOnAssertEnabled=!!Config.debug
 * @name ErrFields
 * @namespace Tools
 */

let ErrorExtension =
{

  // dichotomy

  is,
  isFormed,
  isAttended,
  isBrief,
  isLogged,
  isSuspended,
  isWary,

  // generator

  _sectionsJoin,
  _messageForm,
  sectionRemove,
  sectionAdd,
  _sectionAdd,
  _sectionExposedAdd,

  exposedSet,
  concealedSet,
  _inStr,

  // introductor

  _make,
  _err,
  err,
  brief,
  unbrief,
  process, /* qqq : cover please */
  unprocess, /* qqq : cover please */
  fromStr,

  // stater

  attend,
  logged,
  suspend, /* qqq : cover, please. should work okay with symbols */
  wary, /* qqq : cover */
  reason, /* qqq : cover */
  restack, /* qqq : cover */
  once, /* qqq : cover */
  originalMessage,
  originalStack,

  // log

  _log,
  log,
  logOnce,

  // meta

  _Setup,

  // fields

  breakpointOnDebugger : 0,
  breakpointOnAssertEnabled : !!Config.debug,
  _errorCounter : 0,
  _errorMaking : false,

}

Object.assign( _.error, ErrorExtension );
_.error._Setup();

/* zzz : improve formatting of stack with table */
/* xxx : postpone reading files as late as possible */
/* xxx : move unhandled error event to namespacer::error */
/* xxx : add module files stack */

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1/zErr.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, zErr_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file zErr_s */ })();

/* */  /* begin of file _1LogicNode_s */ ( function _1LogicNode_s() { function _1LogicNode_s_naked() { ( function _l3_1LogicNode_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implement
// --

function is( src )
{
  if( !src )
  return false;
  return src instanceof this.class;
}

//

function make( src )
{
  if( arguments.length !== 1 )
  throw new Error( 'Expects exactly one argument' );
  return new this.class( src );
}

//

function from( src )
{
  if( arguments.length !== 1 )
  throw new Error( 'Expects exactly one argument' );
  if( this.is( src ) )
  return src;
  return this.make( src );
}

//

function cloneShallow()
{
  _.assert( !( this instanceof cloneShallow ) );
  return this;
}

//

function cloneDeep()
{
  debugger;
  _.assert( !( this instanceof cloneDeep ) );
  return this;
}

//

function equalAre_functor( fo )
{
  let cls = fo.class;

  return function equalAre( it )
  {
    let self = this;

    _.assert( arguments.length === 1 );

    if( !it.src )
    return it.stop( false );
    if( !it.src2 )
    return it.stop( false );

    if( !( it.src instanceof cls ) )
    return it.stop( false );
    if( !( it.src2 instanceof cls ) )
    return it.stop( false );
    debugger;
    if( !it.src.type !== it.src2.type )
    return it.stop( false );

    if( it.src.elements.length !== it.src2.elements.length )
    return it.stop( false );

    for( let i = 0 ; i < it.src.elements.length ; i++ )
    {
      debugger; xxx
      it.equal( it.src, it.src2 );
    }

  }

}

//

function iterator()
{

  let iterator = Object.create( null );
  iterator.next = next;
  iterator.index = 0;
  iterator.instance = this;
  return iterator;

  function next()
  {
    let result = Object.create( null );
    let instance = this.instance;
    result.done = this.index === instance.elements.length;
    if( result.done )
    return result;
    result.value = instance.elements[ this.index ];
    this.index += 1;
    return result;
  }

}

//

function exportString()
{
  return `{- ${this.type} with ${String( this.elements.length )} elements -}`;
}

//

function exportStructure()
{

}

//

function lengthGet()
{
  return this.elements.length;
}

//

function exec( o )
{
  o = _.routine.options( exec, arguments );
  o.onEach = o.onEach || defaultOnEach;
  let r = this._exec( o );
  return r;

  function defaultOnEach( e, it )
  {
    return e;
  }

}

exec.defaults =
{
  onEach : null,
}

//

function _orExec( it )
{
  let result = false;
  this.elements.some( ( e ) =>
  {
    if( _.logic.isNode( e ) )
    e = e._exec( it );
    e = it.onEach( e, it );
    if( e )
    {
      result = e;
      return true;
    }
  });
  return result;
}

//

function _andExec( it )
{
  let result = true;
  this.elements.every( ( e ) =>
  {
    if( _.logic.isNode( e ) )
    e = e._exec( it );
    e = it.onEach( e, it );
    if( !e )
    {
      result = e;
      return false;
    }
    return true;
  });
  return result;
}

//

function _xorExec( it )
{
  let result = false;
  this.elements.forEach( ( e ) =>
  {
    if( _.logic.isNode( e ) )
    e = e._exec( it );
    e = it.onEach( e, it );
    if( e )
    result = !result;
  });
  return result;
}

//

function _xandExec( it )
{
  let result = true;
  this.elements.forEach( ( e ) =>
  {
    if( _.logic.isNode( e ) )
    e = e._exec( it );
    e = it.onEach( e, it );
    if( e )
    result = !result;
  });
  return result;
}

//

function _ifExec( it )
{

  for( let i = 0, l = this.elements.length - 1 ; i < l ; i++ )
  {
    let e = this.elements[ i ];
    if( _.logic.isNode( e ) )
    e = e._exec( it );
    e = it.onEach( e, it );
    if( !e )
    return true;
  }

  if( this.elements.length > 0 )
  {
    let e = this.elements[ this.elements.length-1 ];
    if( _.logic.isNode( e ) )
    e = e._exec( it );
    e = it.onEach( e, it );
    return e;
  }

  return true;
}

//

function _firstExec( it )
{
  let e = this.elements[ 0 ];
  if( _.logic.isNode( e ) )
  e = e._exec( it );
  e = it.onEach( e, it );
  return e;
}

//

function _secondExec( it )
{
  let e = this.elements[ 1 ];
  if( _.logic.isNode( e ) )
  e = e._exec( it );
  e = it.onEach( e, it );
  return e;
}

//

function _notExec( it )
{
  let e = this.elements[ 0 ];
  if( _.logic.isNode( e ) )
  e = e._exec( it );
  e = it.onEach( e, it );
  return !e;
}

// --
// meta
// --

function DeclareAbstract( fo )
{

  fo.class = function LogicAbstractNode( elements )
  {
    if( arguments.length !== 1 )
    throw new Error( 'Expects exactly 1 argument' );
    this.elements = elements;
    Object.freeze( this );
    return this;
  }

  _.class.declareBasic
  ({
    constructor : fo.class,
    iterator,
    equalAre : equalAre_functor( fo ),
    exportString,
    cloneShallow, /* xxx : implement */
    cloneDeep, /* xxx : implement */
  });

  const prototype = fo.class.prototype;
  prop( 'constructor', constructor );
  prop( 'type', 'abstract' );
  prop( 'exec', exec );
  prop( 'exportStructure', exportStructure );

  Object.defineProperty( fo.class, 'length',
  {
    get : lengthGet,
    enumerable : false,
    configurable : false,
  });

  return fo;

  function prop( k, v )
  {
    Object.defineProperty( prototype, k,
    {
      value : v,
      enumerable : false,
      configurable : false,
    });
  }

}

DeclareAbstract.defaults =
{
}

//

function Declare( fo )
{
  fo.parent = fo.parent || _.logic.node.Abstract;

  const type = fo.type;
  const parent = fo.parent;

  fo.class = { [ fo.name ] : function( val )
  {
    return parent.apply( this, arguments );
  }}[ fo.name ];

  const prototype = fo.class.prototype = Object.create( parent.prototype );
  prop( 'constructor', fo.class );
  prop( 'type', type );
  Object.setPrototypeOf( fo.class, parent );

  _.props.extend( prototype, Methods[ type ] );

  return fo;

  function prop( k, v )
  {
    Object.defineProperty( prototype, k,
    {
      value : v,
      enumerable : false,
      configurable : false,
    });
  }

}

Declare.defaults =
{
  name : null,
  parent : null,
}

// --
//
// --

let Methods =
{

  or :
  {
    _exec : _orExec,
  },
  and :
  {
    _exec : _andExec,
  },
  xor :
  {
    _exec : _xorExec,
  },
  xand :
  {
    _exec : _xandExec,
  },
  if :
  {
    _exec : _ifExec,
  },

  first :
  {
    _exec : _firstExec,
  },
  second :
  {
    _exec : _secondExec,
  },
  not :
  {
    _exec : _notExec,
  },

}

// --
//
// --

var Extension =
{

  DeclareAbstract,
  Declare,

}

Object.assign( _.logic.node, Extension );

_.logic.node.Abstract = _.logic.node.DeclareAbstract({}).class;
_.logic.node.Or = _.logic.node.Declare({ type : 'or', name : 'LogicOr' }).class;
_.logic.node.And = _.logic.node.Declare({ type : 'and', name : 'LogicAnd' }).class;
_.logic.node.Xor = _.logic.node.Declare({ type : 'xor', name : 'LogicXor' }).class;
_.logic.node.Xand = _.logic.node.Declare({ type : 'xand', name : 'LogicXand' }).class;
_.logic.node.First = _.logic.node.Declare({ type : 'first', name : 'LogicFirst' }).class;
_.logic.node.Second = _.logic.node.Declare({ type : 'second', name : 'LogicSecond' }).class;
_.logic.node.Not = _.logic.node.Declare({ type : 'not', name : 'LogicNot' }).class;
_.logic.node.If = _.logic.node.Declare({ type : 'if', name : 'LogicIf' }).class;

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/1LogicNode.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _1LogicNode_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _1LogicNode_s */ })();

/* */  /* begin of file _1Wrap_s */ ( function _1Wrap_s() { function _1Wrap_s_naked() { ( function _l3_1Wrap_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implement
// --

function is( src )
{
  if( !src )
  return false;
  return src instanceof this.class;
}

//

function make( src )
{
  if( arguments.length !== 1 )
  throw new Error( 'Expects exactly one argument' );
  return new this.class( src );
}

//

function from( src )
{
  if( arguments.length !== 1 )
  throw new Error( 'Expects exactly one argument' );
  if( this.is( src ) )
  return src;
  return this.make( src );
}

//

function cloneShallow()
{
  _.assert( !( this instanceof cloneShallow ) );
  return this;
}

//

function cloneDeep()
{
  debugger;
  _.assert( !( this instanceof cloneDeep ) );
  return this;
}

//

function equalAre_functor( fo )
{
  let cls = fo.class;

  return function equalAre( it )
  {
    let self = this;

    _.assert( arguments.length === 1 );

    if( !it.src )
    return it.stop( false );
    if( !it.src2 )
    return it.stop( false );

    if( !( it.src instanceof cls ) )
    return it.stop( false );
    if( !( it.src2 instanceof cls ) )
    return it.stop( false );

    if( it.src.val === it.src2.val )
    return it.stop( true );

    if( !( it.src.val instanceof cls ) )
    return it.stop( false );
    if( !( it.src2.val instanceof cls ) )
    return it.stop( false );
  }

}

//

function iterator()
{

  let iterator = Object.create( null );
  iterator.next = next;
  iterator.index = 0;
  iterator.instance = this;
  return iterator;

  function next()
  {
    let result = Object.create( null );
    result.done = this.index === 1;
    if( result.done )
    return result;
    result.value = this.instance.val;
    this.index += 1;
    return result;
  }

}

//

function exportString()
{
  if( _.symbol.is( this.val ) )
  return `{- ${this.constructor.name} {- Symbol ${Symbol.keyFor( this.val )} -} -}`;
  else
  return `{- ${this.constructor.name} ${String( this.val )} -}`;
}

//

function declare( fo )
{

  fo.class = { [ fo.name ] : function( val )
  {
    if( arguments.length !== 1 )
    throw new Error( 'Expects exactly 1 argument' );
    this.val = val;
    Object.freeze( this );
    return this;
  }}[ fo.name ];

  _.class.declareBasic
  ({
    constructor : fo.class,
    iterator,
    equalAre : equalAre_functor( fo ),
    exportString,
    cloneShallow, /* xxx : implement */
    cloneDeep, /* xxx : implement */
  });

  _.assert( fo.namespace === undefined );
  _.assert( fo.class.name === fo.name );

  fo.namespace =
  {
    is,
    make,
    from,
    class : fo.class,
  }

  return fo;
}

declare.defaults =
{
  name : null,
}

//

var Extension =
{

  declare,

}

//

Object.assign( _.wrap, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/1Wrap.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _1Wrap_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _1Wrap_s */ })();

/* */  /* begin of file _2Props_s */ ( function _2Props_s() { function _2Props_s_naked() { ( function _l3_2Property_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const prototypeSymbol = Symbol.for( 'prototype' );
const constructorSymbol = Symbol.for( 'constructor' );

// --
// equaler
// --

function _identicalShallow( src1, src2 )
{
  if( this.keys( src1 ).length !== this.keys( src2 ).length )
  return false;

  for( let s in src1 )
  {
    if( src1[ s ] !== src2[ s ] )
    return false;
  }

  return true;
}

//

function identicalShallow( src1, src2, o )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;

  return this._identicalShallow( src1, src2 );
}

//

function _equivalentShallow( src1, src2 )
{
  if( this.keys( src1 ).length !== this.keys( src2 ).length )
  return false;

  for( let s in src1 )
  {
    if( src1[ s ] !== src2[ s ] )
    return false;
  }

  return true;
}

//

function equivalentShallow( src1, src2, o )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;

  return this._equivalentShallow( src1, src2 );
}

// --
// exporter
// --

function _exportStringDiagnosticShallow( src, o )
{
  return `{- ${_.entity.strType( src )} with ${this._lengthOf( src )} elements -}`;
}

//

function exportStringDiagnosticShallow( src, o )
{
  _.assert( this.like( src ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( o === undefined || _.object.isBasic( o ) );
  return this._exportStringDiagnosticShallow( ... arguments );
}

// --
// properties
// --

function keyIsImplicit( key )
{
  if( !_.props.implicit.is( key ) )
  return false;
  if( key.val === prototypeSymbol )
  return true;
  if( key.val === constructorSymbol ) /* xxx : try */
  return true;
  return false;
}

//

function _onlyImplicitWithKey( src, key )
{
  if( !_.props.implicit.is( key ) )
  return;
  if( key.val === prototypeSymbol )
  {
    if( src === undefined || src === null )
    return undefined;
    return Object.getPrototypeOf( src );
  }
  if( key.val === constructorSymbol ) /* xxx : try */
  {
    if( src === undefined || src === null )
    return undefined;
    let prototype = Object.getPrototypeOf( src );
    if( !prototype )
    return prototype;
    return prototype.constructor;
  }
}

//

function onlyImplicitWithKey( src, key )
{
  _.assert( this === _.props );
  _.assert( arguments.length === 2 );
  return this._onlyImplicitWithKey( src, key );
}

//

function _onlyImplicitWithKeyTuple( container, key )
{
  let r = _.props._onlyImplicitWithKey( container, key );
  return [ r, key, r !== undefined ];
  // return [ r, key.val, r !== undefined ];
}

//

function onlyImplicit( src )
{
  let result = new HashMap();

  _.assert( this === _.props );
  _.assert( arguments.length === 1 );

  if( src === undefined || src === null )
  return result;
  var prototype = Object.getPrototypeOf( src );
  if( prototype )
  result.set( _.props.implicit.prototype, prototype );

  return result;
}

// --
// inspector
// --

function _lengthOf( src )
{
  return this.keys( src ).length;
}

//

function lengthOf( src )
{
  _.assert( arguments.length === 1 );
  _.assert( this.like( src ) );
  return this._lengthOf( src );
}

//

function _hasKey( src, key )
{
  if( _.primitive.is( src ) )
  return false;
  if( !Reflect.has( src, key ) )
  return false;
  return true;
}

//

function hasKey( src, key )
{
  _.assert( this.like( src ) );
  return this._hasKey( src, key );
}

//

function _hasCardinal( src, cardinal )
{
  if( cardinal < 0 )
  return false;
  let length = this._lengthOf( src );
  return cardinal < length;
}

//

function hasCardinal( src, cardinal )
{
  _.assert( this.like( src ) );
  return this._hasCardinal( src, cardinal );
}

//

function _keyWithCardinal( src, cardinal )
{
  if( cardinal < 0 )
  return [ undefined, false ];
  let keys = this.keys( src );
  if( cardinal < keys.length )
  return [ keys[ cardinal ], true ];
  return [ undefined, false ];
}

//

function keyWithCardinal( src, cardinal )
{
  _.assert( this.like( src ) );
  return this._keyWithCardinal( src, cardinal );
}

//

function _cardinalWithKey( src, key )
{
  if( !( key in src ) )
  return -1;
  let keys = this.keys( src );
  return keys.indexOf( key );
}

//

function cardinalWithKey( src, key )
{
  _.assert( this.like( src ) );
  return this._cardinalWithKey( src, key );
}

// --
// elementor
// --

function _elementWithKey( src, key )
{
  if( _.strIs( key ) )
  {
    if( _.props.has( src, key ) )
    return [ src[ key ], key, true ];
    else
    return [ undefined, key, false ];
  }
  else
  {
    return [ undefined, key, false ];
  }
}

//

function elementWithKey( src, key )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._elementWithKey( src, key );
}

//

function _elementWithImplicit( src, key )
{
  if( _.props.keyIsImplicit( key ) )
  return _.props._onlyImplicitWithKeyTuple( src, key );
  return this._elementWithKey( src, key );
}

//

function elementWithImplicit( src, key )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._elementWithImplicit( src, key );
}

//

function _elementWithCardinal( src, cardinal )
{
  if( !_.numberIs( cardinal ) || cardinal < 0 )
  return [ undefined, cardinal, false ];
  let keys = this.keys( src );
  let key2 = keys[ cardinal ];
  if( keys.length <= cardinal )
  return [ undefined, cardinal, false ];
  return [ src[ key2 ], key2, true ];
}

//

function elementWithCardinal( src, cardinal )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._elementWithCardinal( src, cardinal );
}

//

function _elementWithKeySet( dst, key, val )
{
  dst[ key ] = val;
  return [ key, true ];
}

//

function elementWithKeySet( dst, key, val )
{
  _.assert( arguments.length === 3 );
  _.assert( this.is( dst ) );
  return this._elementWithKeySet( dst, key, val );
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{
  let was = this._elementWithCardinal( dst, cardinal );
  if( was[ 2 ] === true )
  {
    dst[ was[ 1 ] ] = val;
    return [ was[ 1 ], true ];
  }
  else
  {
    return [ cardinal, false ];
  }
}

//

function elementWithCardinalSet( dst, cardinal, val )
{
  _.assert( arguments.length === 3 );
  _.assert( this.is( dst ) );
  return this._elementWithCardinalSet( dst, cardinal, val );
}

//

function _elementWithKeyDel( dst, key )
{
  if( !this._hasKey( dst, key ) )
  return false;
  delete dst[ key ];
  return true;
}

//

function elementWithKeyDel( dst, key )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( dst ) );
  return this._elementWithKeyDel( dst, key );
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  let has = this._keyWithCardinal( dst, cardinal );
  if( !has[ 1 ] )
  return false;
  delete dst[ has[ 0 ] ];
  return true;
}

//

function elementWithCardinalDel( dst, cardinal )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( dst ) );
  // return this._elementWithCardinalDel( dst, cardinal, val );
  return this._elementWithCardinalDel( dst, cardinal );
}

//

function _empty( dst )
{
  for( let k in dst )
  delete dst[ k ];
  return dst;
}

//

function empty( dst )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this.like( dst ) );
  return this._empty( dst );
}

// --
// iterator
// --

function _eachLeft( src, onEach )
{
  let c = 0;
  for( let k in src )
  {
    let val = src[ k ];
    onEach( val, k, c, src );
    c += 1;
  }
}

//

function eachLeft( src, onEach )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  this._eachLeft( src, onEach );
}

//

function _eachRight( src, onEach )
{
  let keys = this.keys( src );
  for( let c = keys.length-1 ; c >= 0 ; c-- )
  {
    let k = keys[ c ];
    let val = src[ k ];
    onEach( val, k, c, src );
  }
}

//

function eachRight( src, onEach )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  this._eachRight( src, onEach );
}

//

function _whileLeft( src, onEach )
{
  let c = 0;
  let lastk;
  for( let k in src )
  {
    let val = src[ k ];
    let r = onEach( val, k, c, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ val, k, c, false ];
    lastk = k;
    c += 1;
  }
  if( c === 0 )
  return [ undefined, undefined, -1, true ];
  return [ src[ lastk ], lastk, c-1, true ];
}

//

function whileLeft( src, onEach )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  this._whileLeft( src, onEach );
}

//

function _whileRight( src, onEach )
{
  let keys = this.keys( src );
  if( keys.length === 0 )
  return [ undefined, undefined, -1, true ];
  for( let c = keys.length-1 ; c >= 0 ; c-- )
  {
    let k = keys[ c ];
    let val = src[ k ];
    let r = onEach( val, k, c, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ val, k, c, false ];
  }

  var k = keys[ 0 ];
  return [ src[ k ], k, 0, true ];
}

//

function whileRight( src, onEach )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  this._whileRight( src, onEach );
}

//

function _aptLeft( src, onEach )
{
  let result, result2;

  if( onEach )
  result2 = this._whileLeft( src, function( val, k, c, src2 )
  {
    let r = onEach( ... arguments );
    if( r !== undefined )
    {
      result = [ r, k, c, true ];
      return false;
    }
    return true;
  });
  else
  result2 = this._whileLeft( src, function( val, k, c, src2 )
  {
    result = [ val, k, c, true ];
    return false;
  });

  if( result === undefined )
  {
    result2[ 3 ] = false;
    return result2;
  }

  return result;
}

//

function aptLeft( src, onEach )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._aptLeft( src, onEach );
}

//

function _aptRight( src, onEach )
{
  let result, result2;

  if( onEach )
  result2 = this._whileRight( src, function( val, k, c, src2 )
  {
    let r = onEach( ... arguments );
    if( r !== undefined )
    {
      result = [ r, k, c, true ];
      return false;
    }
    return true;
  });
  else
  result2 = this._whileRight( src, function( val, k, c, src2 )
  {
    result = [ val, k, c, true ];
    return false;
  });

  if( result === undefined )
  {
    result2[ 3 ] = false;
    return result2;
  }

  return result;
}

//

function aptRight( src, onEach )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._aptRight( src, onEach );
}

//

function _filterAct0()
{
  const self = this;
  const dst = arguments[ 0 ];
  const src = arguments[ 1 ];
  const onEach = arguments[ 2 ];
  const each = arguments[ 3 ];
  const escape = arguments[ 4 ];

  if( dst === src )
  each( src, function( val, k, c, src2 )
  {
    let val2 = onEach( val, k, c, src2, dst );
    let val3 = escape( val2 );
    if( val2 === undefined )
    self._elementDel( dst, k );
    else if( val3 === val )
    return
    else
    self._elementSet( dst, k, val3 );
  });
  else
  each( src, function( val, k, c, src2 )
  {
    let val2 = onEach( val, k, c, src2, dst );
    let val3 = escape( val2 );
    if( val2 === undefined )
    return;
    self._elementSet( dst, k, val3 );
  });

  return dst;
}

//

function _filterAct()
{
  let self = this;
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let onEach = arguments[ 2 ];
  let isLeft = arguments[ 3 ];
  let eachRoutineName = arguments[ 4 ];
  let escape = arguments[ 5 ];
  let general = this.tools[ this.MostGeneralNamespaceName ];

  if( dst === null )
  dst = this.makeUndefined( src );
  else if( dst === _.self )
  dst = src;

  if( Config.debug )
  {
    _.assert( arguments.length === 6, `Expects 3 arguments` );
    _.assert( this.is( dst ), () => `dst is not ${this.TypeName}` );
    _.assert( general.is( src ), () => `src is not ${general.TypeName}` );
    _.assert( _.routineIs( onEach ), () => 'onEach is not a routine' )
  }

  this._filterAct0( dst, src, onEach, general[ eachRoutineName ].bind( general ), escape );

  return dst;
}

//

function filterWithoutEscapeLeft( dst, src, onEach )
{
  return this._filterAct( ... arguments, true, 'eachLeft', ( val ) => val );
}

//

function filterWithoutEscapeRight( dst, src, onEach )
{
  return this._filterAct( ... arguments, false, 'eachRight', ( val ) => val );
}

//

function filterWithEscapeLeft( dst, src, onEach )
{
  return this._filterAct( ... arguments, true, 'eachLeft', ( val ) => _.escape.right( val ) );
}

//

function filterWithEscapeRight( dst, src, onEach )
{
  return this._filterAct( ... arguments, false, 'eachRight', ( val ) => _.escape.right( val ) );
}

//

function _mapAct0()
{
  const self = this;
  const dst = arguments[ 0 ];
  const src = arguments[ 1 ];
  const onEach = arguments[ 2 ];
  const each = arguments[ 3 ];
  const escape = arguments[ 4 ];

  if( dst === src )
  each( src, function( val, k, c, src2 )
  {
    let val2 = onEach( val, k, c, src2, dst );
    let val3 = escape( val2 );
    if( val3 === val || val2 === undefined )
    return;
    self._elementSet( dst, k, val3 );
  });
  else
  each( src, function( val, k, c, src2 )
  {
    let val2 = onEach( val, k, c, src2, dst );
    let val3 = escape( val2 );
    if( val2 === undefined )
    self._elementSet( dst, k, val );
    else
    self._elementSet( dst, k, val3 );
  });

  return dst;
}

//

function _mapAct()
{
  let self = this;
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let onEach = arguments[ 2 ];
  let isLeft = arguments[ 3 ];
  let eachRoutineName = arguments[ 4 ];
  let escape = arguments[ 5 ];
  let general = this.tools[ this.MostGeneralNamespaceName ];

  if( dst === null )
  {
    // dst = this.makeUndefined( src );
    let dstNamespace = self.namespaceOf( src ) || self.default || self;
    dst = dstNamespace.makeUndefined( src );
  }
  else if( dst === _.self )
  {
    dst = src;
  }

  if( Config.debug )
  {
    _.assert( arguments.length === 6, `Expects 3 arguments` );
    _.assert( this.is( dst ), () => `dst is not ${this.TypeName}` );
    _.assert( general.is( src ), () => `src is not ${general.TypeName}` );
    _.assert( _.routineIs( onEach ), () => `onEach is not a routine` );
  }

  this._mapAct0( dst, src, onEach, general[ eachRoutineName ].bind( general ), escape );

  return dst;
}

//

function mapWithoutEscapeLeft( dst, src, onEach )
{
  return this._mapAct( ... arguments, true, 'eachLeft', ( val ) => val );
}

//

function mapWithoutEscapeRight( dst, src, onEach )
{
  return this._mapAct( ... arguments, false, 'eachRight', ( val ) => val );
}

//

function mapWithEscapeLeft( dst, src, onEach )
{
  return this._mapAct( ... arguments, true, 'eachLeft', ( val ) => _.escape.right( val ) );
}

//

function mapWithEscapeRight( dst, src, onEach )
{
  return this._mapAct( ... arguments, false, 'eachRight', ( val ) => _.escape.right( val ) );
}

// --
// property implicit
// --

_.assert( _.props.implicit === undefined );
_.assert( _.props.Implicit === undefined );
_.props.implicit = _.wrap.declare({ name : 'Implicit' }).namespace;
_.props.Implicit = _.props.implicit.class;
_.assert( _.mapIs( _.props.implicit ) );
_.assert( _.routineIs( _.props.Implicit ) );

_.props.implicit.prototype = new _.props.Implicit( prototypeSymbol );
_.props.implicit.constructor = new _.props.Implicit( constructorSymbol );

// --
// extension
// --

let Extension =
{

  // equaler

  _identicalShallow,
  identicalShallow,
  identical : identicalShallow,
  _equivalentShallow,
  equivalentShallow,
  equivalent : equivalentShallow,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : exportStringDiagnosticShallow,
  exportString : exportStringDiagnosticShallow,

  // properties

  keyIsImplicit, /* qqq : cover */
  _onlyImplicitWithKey,
  onlyImplicitWithKey, /* qqq : cover */
  _onlyImplicitWithKeyTuple,
  onlyImplicit,

  // inspector

  _lengthOf,
  lengthOf, /* qqq : cover */
  _hasKey,
  hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal, /* qqq : cover */
  _cardinalWithKey,
  cardinalWithKey, /* qqq : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : elementWithKey, /* qqq : cover */
  _elementWithKey,
  elementWithKey, /* qqq : cover */
  _elementWithImplicit,
  elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : elementWithKeySet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : elementWithKeyDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty, /* qqq : for junior : cover */

  // iterator

  _each : _eachLeft,
  each : eachLeft, /* qqq : cover */
  _eachLeft,
  eachLeft, /* qqq : cover */
  _eachRight,
  eachRight, /* qqq : cover */

  _while : _whileLeft,
  while : whileLeft, /* qqq : cover */
  _whileLeft,
  whileLeft, /* qqq : cover */
  _whileRight,
  whileRight, /* qqq : cover */

  _aptLeft,
  aptLeft, /* qqq : cover */
  first : aptLeft,
  _aptRight, /* qqq : cover */
  aptRight,
  last : aptRight, /* qqq : cover */

  _filterAct0,
  _filterAct,
  filterWithoutEscapeLeft,
  filterWithoutEscapeRight,
  filterWithoutEscape : filterWithoutEscapeLeft,
  filterWithEscapeLeft,
  filterWithEscapeRight,
  filterWithEscape : filterWithEscapeLeft,
  filter : filterWithoutEscapeLeft,

  _mapAct0,
  _mapAct,
  mapWithoutEscapeLeft,
  mapWithoutEscapeRight,
  mapWithoutEscape : mapWithoutEscapeLeft,
  mapWithEscapeLeft,
  mapWithEscapeRight,
  mapWithEscape : mapWithEscapeLeft,
  map : mapWithoutEscapeLeft,

}

//

Object.assign( _.props, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/2Props.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _2Props_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _2Props_s */ })();

/* */  /* begin of file _3Blank_s */ ( function _3Blank_s() { function _3Blank_s_naked() { ( function _l1_3Blank_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.blank = _.blank || Object.create( null );

// --
// equaler
// --

function _identicalShallow( src1, src2 )
{
  return src1 === src2;
}

// --
// exporter
// --

function _exportStringDiagnosticShallow( src )
{
  return `{- ${_.entity.strType( src )} -}`;
}

// --
// container interface
// --

function _lengthOf( src )
{
  return 0;
}

//

function _hasKey( src, key )
{
  return false;
}

//

function _hasCardinal( src, cardinal )
{
  return false;
}

//

function _keyWithCardinal( src, cardinal )
{
  return [ undefined, false ];
}

//

function _cardinalWithKey( key )
{
  return -1;
}

//

function _elementWithKey( src, key )
{
  return [ undefined, key, false ];
}

//

function _elementWithCardinal( src, cardinal )
{
  return [ undefined, cardinal, false ];
}

//

function _elementWithKeySet( dst, key, val )
{
  return [ key, false ];
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{
  return [ cardinal, false ];
}

//

function _elementWithKeyDel( dst, key )
{
  _.assert( 0, `Cant delete element of ${this.NamespaceName}` );
  return false;
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  _.assert( 0, `Cant delete element of ${this.NamespaceName}` );
  return false;
}

//

function _empty( dst )
{
  _.assert( 0, `Cant empty ${this.NamespaceName}` );
  return dst;
}

//

function _eachLeft( src, onEach )
{
}

//

function _eachRight( src, onEach )
{
}

//

function _whileLeft( src, onEach )
{
  return [ undefined, undefined, -1, true ];
}

//

function _whileRight( src, onEach )
{
  return [ undefined, undefined, -1, true ];
}

// --
// extension
// --

let BlankExtension =
{

  // equaler

  _identicalShallow,
  identicalShallow : _.props.identicalShallow,
  identical : _.props.identical,
  _equivalentShallow : _identicalShallow,
  equivalentShallow : _.props.equivalentShallow,
  equivalent : _.props.equivalent,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // inspector

  _lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */
  _hasKey,
  hasKey : _.props.hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal : _.props.hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal : _.props.keyWithCardinal, /* qqq : cover */
  _cardinalWithKey,
  cardinalWithKey : _.props.cardinalWithKey, /* qqq : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : _.props.elementGet, /* qqq : cover */
  _elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.props._elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty : _.props.empty, /* qqq : for junior : cover */

  // iterator

  _each : _eachLeft,
  each : _.props.each, /* qqq : cover */
  _eachLeft,
  eachLeft : _.props.eachLeft, /* qqq : cover */
  _eachRight,
  eachRight : _.props.eachRight, /* qqq : cover */

  _while : _whileLeft,
  while : _.props.while, /* qqq : cover */
  _whileLeft,
  whileLeft : _.props.whileLeft, /* qqq : cover */
  _whileRight,
  whileRight : _.props.whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct0 : _.props._filterAct0,
  _filterAct : _.props._filterAct,
  filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  filterWithoutEscape : _.props.filterWithoutEscape,
  filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  filterWithEscapeRight : _.props.filterWithEscapeRight,
  filterWithEscape : _.props.filterWithEscape,
  filter : _.props.filter,

  _mapAct0 : _.props._mapAct0,
  _mapAct : _.props._mapAct,
  mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  mapWithoutEscape : _.props.mapWithoutEscape,
  mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  mapWithEscapeRight : _.props.mapWithEscapeRight,
  mapWithEscape : _.props.mapWithEscape,
  map : _.props.map,

}

Object.assign( _.blank, BlankExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/3Blank.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _3Blank_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _3Blank_s */ })();

/* */  /* begin of file _3Long_s */ ( function _3Long_s() { function _3Long_s_naked() { ( function _l3_Long_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const _functor_functor = _.container._functor_functor;

_.long = _.long || Object.create( null );

// --
//
// --

function appender( src )
{
  _.assert( _.longLike( src ) );

  if( 'append' in src && _.routine.is( src.append ) )
  return appendWithAppend;
  else if( 'push' in src && _.routine.is( src.push ) )
  return appendWithPush;
  else if( 'add' in src && _.routine.is( src.add ) )
  return appendWithAdd;

  function appendWithAppend( val )
  {
    src.append( val );
  }

  function appendWithPush( val )
  {
    src.push( val );
  }

  function appendWithAdd( val )
  {
    src.add( val );
  }

}

//

function prepender( src )
{
  _.assert( _.longLike( src ) );

  if( 'prepend' in src && _.routine.is( src.prepend ) )
  return prependWithAppend;
  else if( 'push' in src && _.routine.is( src.push ) )
  return prependWithPush;
  else if( 'add' in src && _.routine.is( src.add ) )
  return prependWithAdd;

  function prependWithAppend( val )
  {
    src.prepend( val );
  }

  function prependWithPush( val )
  {
    src.unshift( val );
  }

  function prependWithAdd( val )
  {
    src.add( val );
  }

}

//

function eacher( src )
{

  _.assert( _.longLike( src ) );

  if( _.class.methodIteratorOf( src ) )
  return eachOf;
  else
  return eachLength;

  /* */

  function eachOf( onEach )
  {
    let k = 0;
    for( let val of src )
    {
      onEach( val, k, src );
      k += 1;
    }
    return k;
  }

  /* */

  function eachLength( onEach )
  {
    let k = 0;
    while( k < src.length )
    {
      let val = src[ k ];
      args2[ 0 ] = val;
      onEach( val, k, src );
      k += 1;
    }
    return k;
  }

  /* */

}

// --
// equaler
// --

/**
 * The long.identicalShallow() routine checks the equality of two arrays.
 *
 * @param { longLike } src1 - The first array.
 * @param { longLike } src2 - The second array.
 *
 * @example
 * _.long.identicalShallow( [ 1, 2, 3 ], [ 1, 2, 3 ] );
 * // returns true
 *
 * @returns { Boolean } - Returns true if all values of the two arrays are equal. Otherwise, returns false.
 * @function long.identicalShallow
 * @throws { Error } Will throw an Error if (arguments.length) is less or more than two.
 * @namespace Tools
 */

//

function _identicalShallow( src1, src2 )
{
  let result = true;

  if( src1.length !== src2.length )
  return false;

  for( let s = 0 ; s < src1.length ; s++ )
  {
    result = src1[ s ] === src2[ s ];
    if( result === false )
    return false;
  }

  return result;
}

// --
// exporter
// --

function _exportStringDiagnosticShallow( src )
{
  if( _.unroll.is( src ) )
  return `{- ${_.entity.strType( src )}.unroll with ${this._lengthOf( src )} elements -}`;
  return `{- ${_.entity.strType( src )} with ${this._lengthOf( src )} elements -}`;
}

// --
// inspector
// --

function _lengthOf( src )
{
  return src.length;
}

//

function lengthOf( src )
{
  _.assert( arguments.length === 1 );
  _.assert( this.like( src ) );
  return this._lengthOf( src );
}

//

function _hasKey( src, key )
{
  if( key < 0 )
  return false;
  return key < src.length;
}

//

function hasKey( src, key )
{
  _.assert( this.like( src ) );
  return this._hasKey( src, key );
}

//

function _hasCardinal( src, cardinal )
{
  if( cardinal < 0 )
  return false;
  return cardinal < src.length;
}

//

function hasCardinal( src, cardinal )
{
  _.assert( this.like( src ) );
  return this._hasCardinal( src, cardinal );
}

//

function _keyWithCardinal( src, cardinal )
{
  if( cardinal < 0 || src.length <= cardinal )
  return [ undefined, false ];
  return [ cardinal, true ]
}

//

function keyWithCardinal( src, cardinal )
{
  _.assert( this.like( src ) );
  return this._keyWithCardinal( src, cardinal );
}

//

function _cardinalWithKey( src, key )
{
  if( key < 0 || src.length <= key )
  return -1;
  return key;
}

//

function cardinalWithKey( src, key )
{
  _.assert( this.like( src ) );
  return this._cardinalWithKey( src, key );
}

// --
// elementor
// --

function _elementWithKey( src, key )
{
  if( key < 0 || src.length <= key || !_.numberIs( key ) )
  return [ undefined, key, false ];
  else
  return [ src[ key ], key, true ];
}

//

function elementWithKey( src, key )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._elementWithKey( src, key );
}

//

function _elementWithImplicit( src, key )
{
  if( _.props.keyIsImplicit( key ) )
  return _.props._onlyImplicitWithKeyTuple( src, key );
  return this._elementWithKey( src, key );
}

//

function elementWithImplicit( src, key )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._elementWithImplicit( src, key );
}

//

function _elementWithCardinal( src, cardinal )
{
  if( cardinal < 0 || src.length <= cardinal || !_.numberIs( cardinal ) )
  return [ undefined, cardinal, false ];
  else
  return [ src[ cardinal ], cardinal, true ];
}

//

function elementWithCardinal( src, cardinal )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._elementWithCardinal( src, cardinal );
}

//

function _elementWithKeySet( dst, key, val )
{
  if( _.long.isResizable( dst ) )
  {
    if( key < 0 || !_.numberIs( key ) )
    return [ key, false ];
  }
  else
  {
    if( key < 0 || dst.length <= key || !_.numberIs( key ) )
    return [ key, false ];
  }
  dst[ key ] = val;
  return [ key, true ];
}

//

function elementWithKeySet( dst, key, val )
{
  _.assert( arguments.length === 3 );
  _.assert( this.is( dst ) );
  return this._elementWithKeySet( dst, key, val );
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{
  if( cardinal < 0 || dst.length <= cardinal || !_.numberIs( cardinal ) )
  return [ cardinal, false ];
  dst[ cardinal ] = val;
  return [ cardinal, true ];
}

//

function elementWithCardinalSet( dst, cardinal, val )
{
  _.assert( arguments.length === 3 );
  _.assert( this.is( dst ) );
  return this._elementWithCardinalSet( dst, cardinal, val );
}

// --
// container interface
// --

function _elementAppend( dst, val )
{
  dst.push( val );
  return dst.length-1;
}

//

function elementAppend( dst, val )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( dst ) );
  _.assert( this.isResizable( dst ) );
  return this._elementAppend( dst, val );
}

//

function _elementPrepend( dst, val )
{
  dst.unshift( val );
  return 0;
}

//

function elementPrepend( dst, val )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( dst ) );
  _.assert( this.isResizable( dst ) );
  return this._elementPrepend( dst, val );
}

//

function _elementWithKeyDel( dst, key )
{
  if( !this._hasKey( dst, key ) )
  return false;
  dst.splice( key, 1 );
  return true;
}

//

function elementWithKeyDel( dst, key )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( dst ) );
  _.assert( this.isResizable( dst ) );
  return this._elementWithKeyDel( dst, key );
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  if( !this._hasKey( dst, cardinal ) )
  return false;
  dst.splice( cardinal, 1 );
  return true;
}

//

function elementWithCardinalDel( dst, cardinal )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( dst ) );
  _.assert( this.isResizable( dst ) );
  return this._elementWithCardinalDel( dst, cardinal, val );
}

//

function _empty( dst )
{
  dst.splice( 0, dst.length );
  return dst;
}

//

function empty( dst )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this.like( dst ) );
  _.assert( this.isResizable( dst ) );
  return this._empty( dst );
}

// --
// iterator
// --

function _eachLeft( src, onEach )
{
  for( let k = 0 ; k < src.length ; k++ )
  {
    onEach( src[ k ], k, k, src );
  }
}

//

function eachLeft( src, onEach )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  this._eachLeft( src, onEach );
}

//

function _eachRight( src, onEach )
{
  for( let k = src.length-1 ; k >= 0 ; k-- )
  {
    onEach( src[ k ], k, k, src );
  }
}

//

function eachRight( src, onEach )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  this._eachRight( src, onEach );
}

//

function _whileLeft( src, onEach )
{
  for( let k = 0 ; k < src.length ; k++ )
  {
    let r = onEach( src[ k ], k, k, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ src[ k ], k, k, false ];
  }
  let k = src.length-1;
  if( src.length > 0 )
  return [ src[ k ], k, k, true ];
  else
  return [ undefined, k, k, true ];
}

//

function whileLeft( src, onEach )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  this._whileLeft( src, onEach );
}

//

function _whileRight( src, onEach )
{
  for( let k = src.length-1 ; k >= 0 ; k-- )
  {
    let r = onEach( src[ k ], k, k, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ src[ k ], k, k, false ];
  }
  if( src.length > 0 )
  return [ src[ 0 ], 0, 0, true ];
  else
  return [ undefined, -1, -1, true ];
}

//

function whileRight( src, onEach )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  this._whileRight( src, onEach );
}

//

function _filterAct( ... args )
{
  const self = this;
  let dst = arguments[ 0 ];
  const src = arguments[ 1 ];
  const onEach = arguments[ 2 ];
  const isLeft = arguments[ 3 ];
  const eachRoutineName = arguments[ 4 ];
  const escape = arguments[ 5 ];
  const srcNamesapce = this.tools[ this.MostGeneralNamespaceName ].namespaceOf( src );
  let dstNamespace;
  const each = srcNamesapce[ eachRoutineName ];
  let isSelf;
  let dstIsResizable;
  let srcSample = null;

  if( dst === null )
  {
    dstNamespace = self.namespaceOf( src ) || self.default || self;
    isSelf = false;
    if( dstNamespace.IsResizable() )
    {
      if( dstNamespace.is( src ) && !_.countable.isResizable( src ) )
      {
        srcSample = src;
        dstIsResizable = false;
      }
      else
      {
        dst = dstNamespace.makeEmpty( src );
        dstIsResizable = true;
      }
    }
    else
    {
      dstIsResizable = false;
    }
  }
  else if( dst === _.self )
  {
    isSelf = true;
    dst = src;
    dstNamespace = self.namespaceWithDefaultOf( dst );
    dstIsResizable = _.countable.isResizable( dst );
  }
  else
  {
    dstNamespace = self.namespaceWithDefaultOf( dst );
    dstIsResizable = _.countable.isResizable( dst );
    isSelf = dst === src;
    if( dstIsResizable )
    if( !isSelf )
    dstNamespace._empty( dst );
  }

  if( Config.debug )
  verify();

  if( dstIsResizable )
  {

    if( isSelf )
    {
      if( isLeft )
      resizableSelfLeft();
      else
      resizableSelfRight();
    }
    else
    {
      resizableNonEq();
    }

  }
  else
  {

    if( dst === null )
    nonResizableNull()
    else
    nonResizableNonNull();

  }

  return dst;

  function resizableSelfLeft()
  {
    let l = dstNamespace._lengthOf( src );
    for( let k = 0 ; k < l ; k++ )
    {
      let val = src[ k ];
      let val2 = onEach( val, k, k, src, dst );
      if( val2 === undefined )
      {
        dstNamespace._elementDel( dst, k );
        k -= 1;
        l -= 1;
        continue;
      }
      let val3 = escape( val2 );
      if( val3 === val )
      continue;
      dstNamespace._elementSet( dst, k, val3 );
    }
  }

  function resizableSelfRight()
  {
    each.call( srcNamesapce, src, function( val, k, c, src2 )
    {
      let val2 = onEach( val, k, c, src2, dst );
      let val3 = escape( val2 );
      if( val2 === undefined )
      dstNamespace._elementDel( dst, k );
      else if( val3 === val )
      return;
      else
      dstNamespace._elementSet( dst, k, val3 );
    });
  }

  function resizableNonEq()
  {
    const append = isLeft ? dstNamespace._elementAppend : dstNamespace._elementPrepend;
    each.call( srcNamesapce, src, function( val, k, c, src2 )
    {
      let val2 = onEach( val, k, c, src2, dst );
      let val3 = escape( val2 );
      if( val2 === undefined )
      return;
      append.call( dstNamespace, dst, val3 );
    });
  }

  function nonResizableNull()
  {
    let dst2 = [];
    if( isLeft )
    each.call( srcNamesapce, src, function( val, k, c, src2 )
    {
      let val2 = onEach( val, k, c, src2, dst2 );
      let val3 = escape( val2 );
      if( val2 === undefined )
      return;
      dst2.push( val3 );
    });
    else
    each.call( srcNamesapce, src, function( val, k, c, src2 )
    {
      let val2 = onEach( val, k, c, src2, dst2 );
      let val3 = escape( val2 );
      if( val2 === undefined )
      return;
      dst2.unshift( val3 );
    });
    dst = dstNamespace.make( srcSample, dst2 );
  }

  function nonResizableNonNull()
  {
    each.call( srcNamesapce, src, function( val, k, c, src2 )
    {
      let val2 = onEach( val, k, c, src2, dst );
      let val3 = escape( val2 );
      if( val2 === undefined )
      return;
      dstNamespace._elementSet( dst, k, val3 );
    });
  }

  function verify()
  {
    _.assert( args.length === 6, `Expects 3 arguments` );
    _.assert( dst === null || self.is( dst ), () => `dst is not ${self.TypeName}` );
    _.assert( srcNamesapce.is( src ), () => `src is not ${srcNamesapce.TypeName}` );
    _.assert( _.routineIs( onEach ), () => `onEach is not a routine` );
    _.assert
    (
      dst === null || _.countable.isResizable( dst ) || self._lengthOf( dst ) === srcNamesapce._lengthOf( src )
      , () => `dst is ${self.TypeName} and lengthOf( dst ) is ${self._lengthOf( dst )}, but lengthOf( src ) is ${self._lengthOf( src )}`
    );
  }

}

//

function _mapAct( ... args )
{
  const self = this;
  let dst = arguments[ 0 ];
  const src = arguments[ 1 ];
  const onEach = arguments[ 2 ];
  const isLeft = arguments[ 3 ];
  const eachRoutineName = arguments[ 4 ];
  const escape = arguments[ 5 ];
  const srcNamesapce = this.tools[ this.MostGeneralNamespaceName ].namespaceOf( src );
  const each = srcNamesapce[ eachRoutineName ];
  let isSelf;
  let dstIsResizable;
  let dstNamespace;

  if( dst === null )
  {
    isSelf = false;
    dstNamespace = self.namespaceOf( src ) || self.default || self;
    dst = dstNamespace.makeUndefined( src );
    dstIsResizable = self.IsResizable();
  }
  else if( dst === _.self )
  {
    isSelf = true;
    dst = src;
    dstNamespace = self.namespaceWithDefaultOf( dst );
    dstIsResizable = _.countable.isResizable( dst );
  }
  else
  {
    dstNamespace = self.namespaceWithDefaultOf( dst );
    dstIsResizable = _.countable.isResizable( dst );
    isSelf = dst === src;
    if( dstIsResizable )
    if( !isSelf )
    dst.length = srcNamesapce._lengthOf( src );
  }

  // const dstNamespace = self.namespaceWithDefaultOf( dst );

  if( Config.debug )
  verify();

  if( dst === src )
  each.call( srcNamesapce, src, function( val, k, c, src2 )
  {
    let val2 = onEach( val, k, c, src2, dst );
    let val3 = escape( val2 );
    if( val3 === val || val2 === undefined )
    return;
    self._elementSet( dst, k, val3 );
  });
  else
  each.call( srcNamesapce, src, function( val, k, c, src2 )
  {
    let val2 = onEach( val, k, c, src2, dst );
    let val3 = escape( val2 );
    if( val2 === undefined )
    self._elementSet( dst, k, val );
    else
    self._elementSet( dst, k, val3 );
  });

  return dst;

  function verify()
  {
    _.assert( args.length === 6, `Expects 3 arguments` );
    _.assert( dst === null || self.is( dst ), () => `dst is not ${self.TypeName}` );
    _.assert( srcNamesapce.is( src ), () => `src is not ${srcNamesapce.TypeName}` );
    _.assert( _.routineIs( onEach ), () => `onEach is not a routine` );
    _.assert
    (
      dst === null || _.countable.isResizable( dst ) || self._lengthOf( dst ) === srcNamesapce._lengthOf( src )
      , () => `dst is ${self.TypeName} and lengthOf( dst ) is ${self._lengthOf( dst )}, but lengthOf( src ) is ${self._lengthOf( src )}`
    );
  }

}

// --
// declare
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

//

let LongExtension =
{

  // er

  /* qqq : ask */
  /* xxx : evolve */
  appender,
  prepender,
  eacher,

  // equaler

  _identicalShallow,
  identicalShallow : _.props.identicalShallow,
  identical : _.props.identical,
  _equivalentShallow : _identicalShallow,
  equivalentShallow : _.props.equivalentShallow,
  equivalent : _.props.equivalent,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // inspector

  _lengthOf,
  lengthOf, /* qqq : cover */
  _hasKey,
  hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal, /* qqq : cover */
  _cardinalWithKey,
  cardinalWithKey, /* qqq : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : elementWithKey, /* qqq : cover */
  _elementWithKey,
  elementWithKey, /* qqq : cover */
  _elementWithImplicit,
  elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : elementWithKeySet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet,  /* qqq : cover */

  _elementAppend,
  elementAppend, /* qqq : cover */
  _elementPrepend,
  elementPrepend, /* qqq : cover */

  _elementWithKeyDel,
  elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel,  /* qqq : cover */
  _elementDel : _elementWithKeyDel,
  elementDel : _elementWithKeyDel, /* qqq : cover */
  _empty,
  empty,  /* qqq : cover */

  // iterator

  _each : _eachLeft,
  each : eachLeft, /* qqq : cover */
  _eachLeft,
  eachLeft, /* qqq : cover */
  _eachRight,
  eachRight, /* qqq : cover */

  _while : _whileLeft,
  while : whileLeft, /* qqq : cover */
  _whileLeft,
  whileLeft, /* qqq : cover */
  _whileRight,
  whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct,
  filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  filterWithoutEscape : _.props.filterWithoutEscape,
  filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  filterWithEscapeRight : _.props.filterWithEscapeRight,
  filterWithEscape : _.props.filterWithEscape,
  filter : _.props.filter,

  _mapAct,
  mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  mapWithoutEscape : _.props.mapWithoutEscape,
  mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  mapWithEscapeRight : _.props.mapWithEscapeRight,
  mapWithEscape : _.props.mapWithEscape,
  map : _.props.map,

}

//

Object.assign( _.long, LongExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/3Long.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _3Long_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _3Long_s */ })();

/* */  /* begin of file _3Path_s */ ( function _3Path_s() { function _3Path_s_naked() { ( function _l3_Path_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.path;

// --
// meta
// --

function Init()
{
  let self = this;

  _.assert( _.strIs( self.rootToken ) );
  _.assert( _.strIs( self.upToken ) );
  _.assert( _.strIs( self.hereToken ) );
  _.assert( _.strIs( self.downToken ) );

  if( !self.downUpToken )
  self.downUpToken = self.downToken + self.upToken; /* ../ */
  if( !self.hereUpToken )
  self.hereUpToken = self.hereToken + self.upToken; /* ./ */

  let root = _.regexpEscape( self.rootToken );
  let up = _.regexpEscape( self.upToken );
  let down = _.regexpEscape( self.downToken );
  let here = _.regexpEscape( self.hereToken );

  let beginOrChar = '(?:.|^)';
  let butUp = `(?:(?!${up}).)+`;
  let notDownUp = `(?!${down}(?:${up}|$))`;
  let upOrBegin = `(?:^|${up})`;
  let upOrEnd = `(?:${up}|$)`;
  let splitOrUp = `(?:(?:${up}${up})|((${upOrBegin})${notDownUp}${butUp}${up}))`; /* split or / */

  self._delDownRegexp = new RegExp( `(${beginOrChar})${splitOrUp}${down}(${upOrEnd})`, '' );
  self._delHereRegexp = new RegExp( up + here + '(' + up + '|$)' );
  self._delUpDupRegexp = /\/{2,}/g;

}

//

function CloneExtending( o )
{
  _.assert( arguments.length === 1 );
  let result = Object.create( this )
  _.props.extend( result, Parameters, o );
  result.Init();
  return result;
}

// --
// dichotomy
// --

function is( path )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  return _.strIs( path );
}

//

/**
 * Checks if string path is refined ( checks that the string doesnt contain left( \\ ) or double slashes ( // ) ), and it also
 * returns true when the path has slash ( / ) in the end .
 * @param {String} filePath Source path for check
 * @returns {boolean}
 * @function isRefined
 * @namespace Tools.path
 */

function isRefined( path )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( path ), 'Expects string {-path-}, but got', _.entity.strType( path ) );

  if( path[ 1 ] === ':' && path[ 2 ] === '\\' )
  return false;

  let leftSlash = /\\/g;
  let doubleSlash = /\/\//g;

  if( leftSlash.test( path ) )
  return false;

  return true;
}

//

/**
 * Checks if string path is normalized, and maybe trailed ( ends with a slash ( / ) ).
 * @param {String} filePath Source path for check
 * @returns {boolean}
 * @function isNormalized
 * @namespace Tools.path
 */

function isNormalized( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string' );
  let normalizedPath = this.normalize( filePath )
  let trailedPath = this.trail( normalizedPath );
  return normalizedPath === filePath || trailedPath === filePath;
}

//

function isAbsolute( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string {-filePath-}, but got', _.entity.strType( filePath ) );
  filePath = this.refine( filePath );
  return _.strBegins( filePath, this.upToken );
}

//

function isRelative( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string {-filePath-}, but got', _.entity.strType( filePath ) );
  return !this.isAbsolute( filePath );
}

//

function isGlobal( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string' );
  return _.strHas( filePath, '://' );
}

//

function isRoot( filePath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( filePath ), 'Expects string {-filePath-}, but got', _.entity.strType( filePath ) );
  if( filePath === this.rootToken )
  return true;
  if( this.isRelative( filePath ) )
  return false;
  if( this.normalize( filePath ) === this.rootToken )
  return true;
  return false;
}

//

function _isDotted( srcPath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( srcPath === this.hereToken )
  return true;
  if( srcPath === this.downToken )
  return true;
  if( _.strBegins( srcPath, this.hereToken + this.upToken ) )
  return true;
  if( _.strBegins( srcPath, this.downToken + this.upToken ) )
  return true;
  return false;
}

//

function isDotted( srcPath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( this._isDotted( srcPath ) )
  return true;
  if( _.strBegins( srcPath, this.hereToken + '\\' ) )
  return true;
  if( _.strBegins( srcPath, this.downToken + '\\' ) )
  return true;
  return false;
}

//

function isTrailed( srcPath )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( srcPath === this.rootToken )
  return false;
  return _.strEnds( srcPath, this.upToken );
}

//

function begins( srcPath, beginPath )
{
  _.assert( arguments.length === 2, 'Expects two arguments' );
  _.assert( _.strIs( srcPath ), 'Expects string {-srcPath-}, but got', _.entity.strType( srcPath ) );
  _.assert( _.strIs( beginPath ), 'Expects string {-beginPath-}, but got', _.entity.strType( beginPath ) );
  if( srcPath === beginPath )
  return true;
  return _.strBegins( srcPath, this.trail( beginPath ) );
}

//

function ends( srcPath, endPath )
{
  _.assert( arguments.length === 2, 'Expects two arguments' );
  endPath = this.undot( endPath );

  if( !_.strEnds( srcPath, endPath ) )
  return false;

  let begin = _.strRemoveEnd( srcPath, endPath );
  if( begin === '' || _.strEnds( begin, this.upToken ) || _.strEnds( begin, this.hereToken ) )
  return true;

  return false;
}

// --
// reformer
// --

/**
  * The routine refine() regularize a Windows paths to posix path format by replacing left slashes to slash ( \\ to / ).
  * If the path has a disk label, the routine puts slash '/' before and after the disk label.
  * If the path is an empty string, method returns ''. Otherwise, routine returns original path.
  *
  * @param {string} src - path for refinement.
  *
  * @example
  *  // returns '/foo//bar/../';
  *  let path = '\\foo\\\\bar\\..\\';
  *  path = wTools.refine( path );
  *
  * @example
  *  // returns '/C/temp//foo/bar/../';
  *  let path = 'C:\\temp\\\\foo\\bar\\..\\';
  *  path = wTools.refine( path );
  *
  * @example
  *  // returns '';
  *  let path = '';
  *  path = wTools.refine( path );
  *
  * @example
  *  // returns '/foo/bar/';
  *  let path = '/foo/bar/';
  *  path = wTools.refine( path );
  *
  * @returns {string} Returns refined path.
  * @throws {Error} If {-arguments.length-} is less or more then one.
  * @throws {Error} If passed argument is not a string.
  * @function refine
  * @namespace Tools.path
  */

function refine( src )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) );

  let result = src;

  if( result[ 1 ] === ':' )
  {
    if( result[ 2 ] === '\\' || result[ 2 ] === '/' )
    {
      if( result.length > 3 )
      result = '/' + result[ 0 ] + '/' + result.substring( 3 );
      else
      result = '/' + result[ 0 ]
    }
    else if( result.length === 2 )
    {
      result = '/' + result[ 0 ];
    }
  }

  result = result.replace( /\\/g, '/' );

  return result;
}

//

function _normalize( o )
{
  // let debug = 0;
  // if( 0 )
  // debug = 1;

  _.routine.assertOptions( _normalize, arguments );
  _.assert( _.strIs( o.src ), 'Expects string' );

  if( !o.src.length )
  return '';

  let result = o.src;

  result = this.refine( result );

  // if( debug )
  // console.log( 'normalize.refined : ' + result );

  /* detrailing */

  if( o.tolerant )
  {
    /* remove "/" duplicates */
    result = result.replace( this._delUpDupRegexp, this.upToken );
  }

  let endsWithUp = false;
  let beginsWithHere = false;

  /* remove right "/" */

  if( result !== this.upToken && !_.strEnds( result, this.upToken + this.upToken ) && _.strEnds( result, this.upToken ) )
  {
    endsWithUp = true;
    result = _.strRemoveEnd( result, this.upToken );
  }

  /* undoting */

  while( !_.strBegins( result, this.hereUpToken + this.upToken ) && _.strBegins( result, this.hereUpToken ) )
  {
    beginsWithHere = true;
    result = _.strRemoveBegin( result, this.hereUpToken );
  }

  /* remove second "." */

  if( result.indexOf( this.hereToken ) !== -1 )
  {

    while( this._delHereRegexp.test( result ) )
    result = result.replace( this._delHereRegexp, function( match, postSlash )
    {
      return postSlash || '';
    });
    if( result === '' )
    result = this.upToken;

  }

  /* remove .. */

  if( result.indexOf( this.downToken ) !== -1 )
  {

    while( this._delDownRegexp.test( result ) )
    result = result.replace( this._delDownRegexp, function( /* match, notBegin, split, preSlash, postSlash */ )
    {
      let match = arguments[ 0 ];
      let notBegin = arguments[ 1 ];
      let split = arguments[ 2 ];
      let preSlash = arguments[ 3 ];
      let postSlash = arguments[ 4 ];

      if( preSlash === '' )
      return notBegin;
      if( !notBegin )
      return notBegin + preSlash;
      else
      return notBegin + ( postSlash || '' );
    });

  }

  /* nothing left */

  if( !result.length )
  result = '.';

  /* dot and trail */

  if( o.detrailing )
  if( result !== this.upToken && !_.strEnds( result, this.upToken + this.upToken ) )
  result = _.strRemoveEnd( result, this.upToken );

  if( !o.detrailing && endsWithUp )
  if( result !== this.rootToken )
  result = result + this.upToken;

  if( !o.undoting && beginsWithHere )
  result = this._dot( result );

  // if( debug )
  // console.log( 'normalize.result : ' + result );

  return result;
}

_normalize.defaults =
{
  src : null,
  tolerant : false,
  detrailing : false,
  undoting : false,
}

//

/**
 * Regularize a path by collapsing redundant delimeters and resolving '..' and '.' segments,so A//B,A/./B and
    A/foo/../B all become A/B. This string manipulation may change the meaning of a path that contains symbolic links.
    On Windows,it converts forward slashes to backward slashes. If the path is an empty string,method returns '.'
    representing the current working directory.
 * @example
   let path = '/foo/bar//baz1/baz2//some/..'
   path = wTools.normalize( path ); // /foo/bar/baz1/baz2
 * @param {string} src path for normalization
 * @returns {string}
 * @function normalize
 * @namespace Tools.path
 */

function normalize( src )
{
  let result = this._normalize({ src, tolerant : false, detrailing : false, undoting : false });

  _.assert( _.strIs( src ), 'Expects string' );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
  _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );

  if( Config.debug )
  {
    let i = result.lastIndexOf( this.upToken + this.downToken + this.upToken );
    _.assert( i === -1 || !/\w/.test( result.substring( 0, i ) ) );
  }

  return result;
}

//

function normalizeTolerant( src )
{
  _.assert( _.strIs( src ), 'Expects string' );

  let result = this._normalize({ src, tolerant : true, detrailing : false, undoting : false });

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( result === this.upToken || _.strEnds( result, this.upToken ) || !_.strEnds( result, this.upToken + this.upToken ) );
  _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
  _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );

  if( Config.debug )
  {
    _.assert( !this._delUpDupRegexp.test( result ) );
  }

  return result;
}

//

function canonize( src )
{
  let result = this._normalize({ src, tolerant : false, detrailing : true, undoting : true });

  _.assert( _.strIs( src ), 'Expects string' );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( result === this.upToken || _.strEnds( result, this.upToken + this.upToken ) || !_.strEnds( result, this.upToken ) );
  _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
  _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );

  if( Config.debug )
  {
    let i = result.lastIndexOf( this.upToken + this.downToken + this.upToken );
    _.assert( i === -1 || !/\w/.test( result.substring( 0, i ) ) );
  }

  return result;
}

//

function canonizeTolerant( src )
{
  _.assert( _.strIs( src ), 'Expects string' );

  let result = this._normalize({ src, tolerant : true, detrailing : true, undoting : true });

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( result === this.upToken || _.strEnds( result, this.upToken ) || !_.strEnds( result, this.upToken + this.upToken ) );
  _.assert( result.lastIndexOf( this.upToken + this.hereToken + this.upToken ) === -1 );
  _.assert( !_.strEnds( result, this.upToken + this.hereToken ) );

  if( Config.debug )
  {
    _.assert( !this._delUpDupRegexp.test( result ) );
  }

  return result;
}

//

function _nativizeMinimalWindows( filePath )
{
  let self = this;

  let result = filePath;

  result = result.replace( /\//g, '\\' );

  if( result[ 0 ] === '\\' )
  if( result.length === 2 || result[ 2 ] === ':' || result[ 2 ] === '\\' )
  result = result[ 1 ] + ':' + result.substring( 2 );

  if( result.length === 2 && result[ 1 ] === ':' )
  result = result + '\\';

  return result;
}

//

function _nativizeWindows( filePath )
{
  let self = this;
  _.assert( _.strIs( filePath ), 'Expects string' ) ;

  let result = filePath;

  _.assert( _.routine.is( self.unescape ) );
  result = self.unescape( result ); /* xxx : remove from here */

  result = self._nativizeMinimalWindows( result );

  return result;
}

//

function _nativizeMinimalPosix( filePath )
{
  let self = this;
  let result = filePath;
  return result;
}

//

function _nativizePosix( filePath )
{
  let self = this;
  let result = filePath;
  _.assert( _.strIs( filePath ), 'Expects string' );
  _.assert( _.routine.is( self.unescape ) );
  result = self.unescape( result ); /* xxx : remove from here */
  return result;
}

//

function _nativizeEscapingWindows( filePath )
{
  let self = this;
  let unescapeResult = self._unescape( filePath )

  let result = self._nativizeMinimalWindows( unescapeResult.unescaped );

  if( unescapeResult.wasEscaped )
  result = filePath.replace( unescapeResult.unescaped, result );

  return result;
}

//

function _nativizeEscapingPosix( filePath )
{
  let self = this;
  let result = filePath;
  _.assert( _.strIs( filePath ), 'Expects string' );
  return result;
}

//

function nativize()
{
  if( _global.process && _global.process.platform === 'win32' )
  this.nativize = this._nativizeWindows;
  else
  this.nativize = this._nativizePosix;
  return this.nativize.apply( this, arguments );
}

//

function nativizeMinimal()
{
  if( _global.process && _global.process.platform === 'win32' )
  this.nativizeMinimal = this._nativizeMinimalWindows;
  else
  this.nativizeMinimal = this._nativizeMinimalPosix;
  return this.nativizeMinimal.apply( this, arguments );
}

//

function nativizeEscaping()
{
  if( _global.process && _global.process.platform === 'win32' )
  this.nativizeEscaping = this._nativizeEscapingWindows;
  else
  this.nativizeEscaping = this._nativizeEscapingPosix;
  return this.nativizeEscaping.apply( this, arguments );
}

// //
//
// function escape( filePath )
// {
//   let self = this;
//   let splits = self.split( filePath );
//
//   splits = splits.map( ( split ) =>
//   {
//
//     {
//       let i = 0;
//       while( split[ i ] === '"' )
//       i += 1;
//       if( i > 0 )
//       split = split.substring( 0, i ) + split;
//     }
//
//     {
//       let i = split.length-1;
//       while( split[ i ] === '"' )
//       i -= 1;
//       if( i < split.length-1 )
//       split = split + split.substring( i+1, split.length );
//     }
//
//     let left = _.strLeft_( split, self.escapeTokens )
//     if( left.entry )
//     return `"${split}"`;
//     return split;
//
//   });
//
//   return splits.join( self.upToken );
// }

//

function _unescape( filePath )
{
  let self = this;
  // let splits = self.split( filePath );
  /*
  cant use routine self.split because it normalizes path
  */
  let splits = filePath.split( self.upToken );

  let result = Object.create( null );
  result.wasEscaped = false;

  splits = splits.map( ( split ) =>
  {

    {
      let i = 0;
      while( split[ i ] === '"' )
      i += 1;
      if( i > 0 )
      {
        let c = i;
        if( c % 2 === 1 )
        result.wasEscaped = true;
        let c2 = Math.floor( ( c + 1 ) / 2 );
        split = split.substring( c2, split.length );
      }
    }

    {
      let i = split.length-1;
      while( split[ i ] === '"' )
      i -= 1;
      if( i < split.length-1 )
      {
        let c = split.length - i - 1;
        if( c % 2 === 1 )
        result.wasEscaped = true;
        let c2 = Math.floor( ( c + 1 ) / 2 );
        split = split.substring( 0, split.length - c2 );
      }
    }

    return split;
  });

  result.unescaped = splits.join( self.upToken );
  return result;
}

//

function unescape( filePath )
{
  let self = this;
  return self._unescape( filePath ).unescaped;
}

/* qqq2 : implement test routine _nativizeWindows */
/* qqq2 : implement test routine _nativizePosix */

/* qqq2 : implement routine _.path.unescape to transform:

`"'some path'"` -> `'some path'`
`"some path"` -> `some path`
`""some path""` -> `"some path"`
`'"some path"'` -> `'"some path"'`
`'some path'` -> `'some path'`

`some"-"path/t.txt` -> `some"-"path/t.txt`
`"some"-"path"/'t.txt'` -> `some"-"path/'t.txt'`

*/

/* qqq2 : implement routine _.path.escape

`"'some path'"` -> `""'some path'""`
`"some path"` -> `""some path""`
`""some path""` -> `"""some path"""`
`'"some path"'` -> `'"some path"'`
`'some path'` -> `'some path'`

`#some'` -> `"#some"`
`so#me'` -> `"so#me"`
`some#'` -> `"some#"`

`@some'` -> `"@some"`
`so@me'` -> `"so@me"`
`some@'` -> `"some@"`

`?some'` -> `"?some"`
`so?me'` -> `"so?me"`
`some?'` -> `"some?"`

=

`"#` -> `"""#"`
`"!` -> `""!`

`"#"` -> `"""#"""`
`"!"` -> `""!""`

`""#""` -> `"""""#"""""`
`""!""` -> `""""!""""`

*/

/* qqq2 : implement routines _.path.nativizeWindows_ _.path.nativizePosix_ using code from _.path.nativize and _.path.escape
*/

// --
// transformer
// --

function _split( path )
{
  return path.split( this.upToken );
}

//

function split( path )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( path ), 'Expects string' )
  let result = this._split( this.refine( path ) );
  return result;
}

//

function _dot( filePath )
{

  if( !this._isDotted( filePath ) )
  {
    _.assert( !_.strBegins( filePath, this.upToken ) );
    filePath = this.hereUpToken + filePath;
  }

  return filePath;
}

//

function dot( filePath )
{

  /*
    cant use isAbsolute
  */

  _.assert( !_.strBegins( filePath, this.upToken ) );
  _.assert( arguments.length === 1 );

  /*
    not .
    not begins with ./
    not ..
    not begins with ../
  */

  // if( filePath !== this.hereToken && !_.strBegins( filePath, this.hereUpToken ) && filePath !== this.downToken && !_.strBegins( filePath, this.downUpToken ) )
  if( !this.isDotted( filePath ) )
  {
    _.assert( !_.strBegins( filePath, this.upToken ) );
    filePath = this.hereUpToken + filePath;
  }

  return filePath;
}

//

function undot( filePath )
{
  if( filePath === this.hereUpToken )
  return filePath
  return _.strRemoveBegin( filePath, this.hereUpToken );
}

//

function absolute( filePath )
{
  return this.join( this.rootToken, filePath );
}

//

function unabsolute( filePath )
{
  return _.strRemoveBegin( filePath, this.rootToken );
}

//

function trail( srcPath )
{
  _.assert( this.is( srcPath ) );
  _.assert( arguments.length === 1 );

  if( !_.strEnds( srcPath, this.upToken ) )
  return srcPath + this.upToken;

  return srcPath;
}

//

function detrail( path )
{
  _.assert( this.is( path ) );
  _.assert( arguments.length === 1 );

  if( path !== this.rootToken )
  return _.strRemoveEnd( path, this.upToken );

  return path;
}

//

/**
 * Returns the directory name of `path`.
 * @example
 * let path = '/foo/bar/baz/text.txt'
 * wTools.dir( path ); // '/foo/bar/baz'
 * @param {string} path path string
 * @returns {string}
 * @throws {Error} If argument is not string
 * @function dir
 * @namespace Tools.path
 */

function dir_head( routine, args )
{
  let o = args[ 0 ];

  if( _.strIs( o ) )
  {
    if( args.length === 2 )
    o = { filePath : args[ 0 ], depth : args[ 1 ] };
    else
    o = { filePath : args[ 0 ] };
  }

  _.routine.options( routine, o );
  _.assert( args.length === 1 || args.length === 2 );
  _.assert( arguments.length === 2 );
  _.assert( _.intIs( o.depth ) );
  _.assert( _.strDefined( o.filePath ), 'Expects not empty string {- o.filePath -}' );

  return o;
}

function dir_body( o )
{
  let self = this;
  let isTrailed = this.isTrailed( o.filePath );

  _.routine.assertOptions( dir_body, arguments );

  if( o.first )
  o.filePath = this.normalize( o.filePath );
  else
  o.filePath = this.canonize( o.filePath );

  if( o.depth === 0 )
  {
    return o.filePath;
  }
  else if( o.depth > 1 )
  {
    for( let i = o.depth - 1; i >= 0; i-- )
    {
      if
      (
        o.filePath === this.rootToken || o.filePath === this.hereToken || o.filePath === this.downToken
        || o.filePath === this.hereToken + this.upToken || o.filePath === this.downToken + this.upToken
        || ( o.filePath.match( /\W{3}$/ ) && o.filePath.match( /\W{3}$/ )[ 0 ] === '/..' )
        || ( o.filePath.match( /\W{4}$/ ) && o.filePath.match( /\W{4}$/ )[ 0 ] === '/../' )
      )
      {
        if( o.filePath[ o.filePath.length - 1 ] === '/' )
        o.filePath = o.filePath + this.downToken + ( o.first ? this.upToken : '' );
        else
        o.filePath = o.filePath + this.upToken + this.downToken + ( o.first ? this.upToken : '' );
      }
      else
      {
        if( o.filePath[ o.filePath.length - 1 ] === '/' )
        {
          o.filePath = o.filePath.substring( 0, o.filePath.length - 1 );
          o.filePath = o.filePath.substring( 0, o.filePath.lastIndexOf( '/' ) + ( o.first ? 1 : 0 ) );
          if( o.filePath.length === 0 )
          o.filePath = '.';
        }
        else
        {
          let indexOfSubstr = o.filePath.lastIndexOf( '/' ) === 0 && !o.first ? 1 : o.filePath.lastIndexOf( '/' );
          o.filePath = o.filePath.substring( 0, indexOfSubstr + ( o.first ? 1 : 0 ) );
          if( o.filePath.length === 0 )
          o.filePath = '.';
        }
      }
    }

    if( !o.first )
    o.filePath = _.path.canonize( o.filePath );

    return o.filePath;
  }
  else
  {
    _.assert( o.depth > 0 );
  }

  if( o.first )
  if( isTrailed )
  return o.filePath;

  if( o.filePath === this.rootToken )
  {
    return o.filePath + this.downToken + ( o.first ? this.upToken : '' );
  }

  if( _.strEnds( o.filePath, this.upToken + this.downToken ) || o.filePath === this.downToken )
  {
    return o.filePath + this.upToken + this.downToken + ( o.first ? this.upToken : '' );
  }

  let i = o.filePath.lastIndexOf( this.upToken );

  if( i === 0 )
  {
    return this.rootToken;
  }

  if( i === -1 )
  {
    if( o.first )
    {
      if( o.filePath === this.hereToken )
      return this.downToken + this.upToken;
      else
      return this.hereToken + this.upToken;
    }
    else
    {
      if( o.filePath === this.hereToken )
      return this.downToken + ( isTrailed ? this.upToken : '' );
      else
      return this.hereToken + ( isTrailed ? this.upToken : '' );
    }
  }

  let result;

  if( o.first )
  result = o.filePath.substr( 0, i + self.upToken.length );
  else
  result = o.filePath.substr( 0, i );

  if( !o.first )
  if( isTrailed )
  result = _.strAppendOnce( result, self.upToken );

  _.assert( !!result.length )

  return result;
}

dir_body.defaults =
{
  filePath : null,
  first : 0,
  depth : 1,
}

let dir = _.routine.uniteCloning( dir_head, dir_body );
dir.defaults.first = 0;

let dirFirst = _.routine.uniteCloning( dir_head, dir_body );
dirFirst.defaults.first = 1;

_.assert( !dir.defaults.first );

//

/**
 * Returns path name (file name).
 * @example
 * wTools.name( '/foo/bar/baz.asdf' ); // 'baz'
 * @param {string|object} path|o Path string, or options
 * @param {boolean} o.full if this parameter set to true method return name with extension.
 * @returns {string}
 * @throws {Error} If passed argument is not string
 * @function name
 * @namespace Tools.path
 */

function name_head( routine, args )
{
  let o = args[ 0 ];
  if( _.strIs( o ) )
  o = { path : o };

  _.routine.options_( routine, o );
  _.assert( args.length === 1 );
  _.assert( arguments.length === 2 );
  _.assert( _.strIs( o.path ), 'Expects string {-o.path-}' );

  return o;
}

function name_body( o )
{

  if( _.strIs( o ) )
  o = { path : o };

  _.routine.assertOptions( name_body, arguments );

  o.path = this.canonize( o.path );

  let i = o.path.lastIndexOf( '/' );
  if( i !== -1 )
  o.path = o.path.substr( i+1 );

  if( !o.full )
  {
    let i = o.path.lastIndexOf( '.' );
    if( i !== -1 ) o.path = o.path.substr( 0, i );
  }

  return o.path;
}

name_body.defaults =
{
  path : null,
  full : 0,
}

let name = _.routine.uniteCloning( name_head, name_body );
name.defaults.full = 0;

let fullName = _.routine.uniteCloning( name_head, name_body );
fullName.defaults.full = 1;

// --
// extension
// --

let Parameters =
{

  rootToken : '/',
  upToken : '/',
  hereToken : '.',
  downToken : '..',
  hereUpToken : null, /* ./ */
  downUpToken : null, /* ../ */
  escapeTokens : [ '@', '#', '!', '?' ],

  _delHereRegexp : null,
  _delDownRegexp : null,
  _delUpDupRegexp : null,
  _pathIsGlobRegexp : null,

}

let Extension =
{

  // meta

  Init,
  CloneExtending,

  // dichotomy

  is,

  isRefined,
  isNormalized,
  isAbsolute,
  isRelative,
  isGlobal,
  isRoot,
  _isDotted,
  isDotted,
  isTrailed,

  begins,
  ends,

  // reformer

  refine,

  _normalize,
  normalize,
  normalizeTolerant,

  canonize,
  canonizeTolerant,

  _nativizeMinimalWindows,
  _nativizeWindows,
  _nativizeMinimalPosix,
  _nativizePosix,
  _nativizeEscapingWindows,
  _nativizeEscapingPosix,
  nativize,
  nativizeMinimal,
  nativizeEscaping,

  // escape,
  _unescape,
  unescape,

  // transformer

  _split,
  split,
  _dot,
  dot,
  undot,
  absolute, /* qqq : cover */
  unabsolute,
  trail,
  detrail,
  dir,
  dirFirst,
  name,
  fullName,

  // fields

  Parameters,

  fileProvider : null,
  path : Self,
  single : Self,
  s : null,

}

Object.assign( Self, Parameters );
Object.assign( Self, Extension );

Self.Init();

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/3Path.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _3Path_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _3Path_s */ })();

/* */  /* begin of file ArgumentsArray_s */ ( function ArgumentsArray_s() { function ArgumentsArray_s_naked() { ( function _l3_ArgumentsArray_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.long._aptLeft, 'Expects routine props._aptLeft' );
_.assert( !!_.long._elementWithKey, 'Expects routine long._elementWithKey' );

// --
// elementor
// --

function _elementAppend( dst, val )
{
  return -1;
}

//

function elementAppend( dst, val )
{
  _.assert( 0, `${this.TypeName} has fixed length` );
}

//

function _elementPrepend( dst, val )
{
  return -1;
}

//

function elementPrepend( dst, val )
{
  _.assert( 0, `${this.TypeName} has fixed length` );
}

//

function _elementWithKeyDel( src, key )
{
  _.assert( 0, `${this.TypeName} has fixed length` );
  return false;
}

//

function _elementWithCardinalDel( src, cardinal )
{
  _.assert( 0, `${this.TypeName} has fixed length` );
  return false;
}

//

function _empty( dst )
{
  _.assert( 0, `${this.TypeName} has fixed length` );
  return false;
}

// --
// extension
// --

var ArgumentsArrayExtension =
{

  // equaler

  _identicalShallow : _.long._identicalShallow,
  identicalShallow : _.long.identicalShallow,
  identical : _.long.identical,
  _equivalentShallow : _.long._equivalentShallow,
  equivalentShallow : _.long.equivalentShallow,
  equivalent : _.long.equivalent,

  // exporter

  _exportStringDiagnosticShallow : _.long._exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.long.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _.long._exportStringCodeShallow,
  exportStringCodeShallow : _.long.exportStringCodeShallow,
  exportString : _.long.exportString,

  // container interface

  _lengthOf : _.long._lengthOf,
  lengthOf : _.long.lengthOf, /* qqq : cover */

  _hasKey : _.long._hasKey,
  hasKey : _.long._hasKey, /* qqq : cover */
  _hasCardinal : _.long._hasKey,
  hasCardinal : _.long._hasKey, /* qqq : cover */
  _keyWithCardinal : _.long._hasKey,
  keyWithCardinal : _.long._hasKey, /* qqq : cover */
  _cardinalWithKey : _.long._cardinalWithKey,
  cardinalWithKey : _.long.cardinalWithKey, /* qqq : cover */

  _elementGet : _.long._elementWithKey,
  elementGet : _.long.elementWithKey, /* qqq : cover */
  _elementWithKey : _.long._elementWithKey,
  elementWithKey : _.long.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.long._elementWithImplicit,
  elementWithImplicit : _.long.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal : _.long._elementWithCardinal,
  elementWithCardinal : _.long.elementWithCardinal,  /* qqq : cover */

  _elementSet : _.long._elementSet,
  elementSet : _.long.elementSet, /* qqq : cover */
  _elementWithKeySet : _.long._elementWithKeySet,
  elementWithKeySet : _.long.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet : _.long._elementWithCardinalSet,
  elementWithCardinalSet : _.long.elementWithCardinalSet,  /* qqq : cover */

  _elementAppend,
  elementAppend, /* qqq : cover */
  _elementPrepend,
  elementPrepend, /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : _.long.elementDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel : _.long.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel : _.long.elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty : _.long.empty, /* qqq : for junior : cover */

  _each : _.long._each,
  each : _.long.each, /* qqq : cover */
  _eachLeft : _.long._eachLeft,
  eachLeft : _.long.eachLeft, /* qqq : cover */
  _eachRight : _.long._eachRight,
  eachRight : _.long.eachRight, /* qqq : cover */

  _while : _.long._while,
  while : _.long.while, /* qqq : cover */
  _whileLeft : _.long._whileLeft,
  whileLeft : _.long.whileLeft, /* qqq : cover */
  _whileRight : _.long._whileRight,
  whileRight : _.long.whileRight, /* qqq : cover */

  _aptLeft : _.long._aptLeft,
  aptLeft : _.long.aptLeft, /* qqq : cover */
  first : _.long.first,
  _aptRight : _.long._aptRight, /* qqq : cover */
  aptRight : _.long.aptRight,
  last : _.long.last, /* qqq : cover */

  _filterAct : _.long._filterAct,
  filterWithoutEscapeLeft : _.long.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.long.filterWithoutEscapeRight,
  filterWithoutEscape : _.long.filterWithoutEscape,
  filterWithEscapeLeft : _.long.filterWithEscapeLeft,
  filterWithEscapeRight : _.long.filterWithEscapeRight,
  filterWithEscape : _.long.filterWithEscape,
  filter : _.long.filter,

  _mapAct : _.long._mapAct,
  mapWithoutEscapeLeft : _.long.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.long.mapWithoutEscapeRight,
  mapWithoutEscape : _.long.mapWithoutEscape,
  mapWithEscapeLeft : _.long.mapWithEscapeLeft,
  mapWithEscapeRight : _.long.mapWithEscapeRight,
  mapWithEscape : _.long.mapWithEscape,
  map : _.long.map,

}

Object.assign( _.argumentsArray, ArgumentsArrayExtension );

//

var ToolsExtension =
{
}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/ArgumentsArray.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ArgumentsArray_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ArgumentsArray_s */ })();

/* */  /* begin of file Array_s */ ( function Array_s() { function Array_s_naked() { ( function _l3_Array_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.long._elementWithKey, 'Expects routine argumentsArray._elementWithKey' );
_.assert( !!_.long.exportString, 'Expects routine _.long.exportString' );

// --
// editor
// --

/**
 * The routine slice() returns a shallow copy of a portion of {-srcArray-} into a new array object.
 * The copy makes from first index {-f-} to last index {-l-}. The original {-srcArray-} will not be modified.
 *
 * @param { Array|Unroll } srcArray - The Array or Unroll from which makes a shallow copy.
 * @param { Number } f - Defines the start index of copying.
 * Negative value of argument {-f-} indicates an offset from the end of the sequence.
 * If {-f-} is undefined, slice begins from index 0.
 * If {-f-} is greater than the length of the sequence, an empty array is returned.
 * @param { Number } l - Defines last index of copying. An element with this index not included.
 * Negative value of {-l-} indicates an offset from the end of the sequence.
 * If {-l-} is omitted, slice extracts through the end of the sequence ( srcArray.length ).
 * If {-l-} is greater than the length of the sequence, slice extracts through to the end of the sequence (arr.length).
 *
 * @example
 * _.array.slice( [ 1, 2, 3, 4, '5' ] );
 * // returns [ 1, 2, 3, 4, '5' ]
 *
 * @example
 * _.array.slice( [ 1, 2, 3, 4, '5' ], 1, 4 );
 * // returns [ 2, 3, 4 ]
 *
 * @example
 * _.array.slice( [ 1, 2, 3, 4, '5' ], -2, 5 );
 * // returns [ 4, '5' ]
 *
 * @example
 * _.array.slice( [ 1, 2, 3, 4, '5' ], 2, -1 );
 * // returns [ 3, 4 ]
 *
 * @example
 * _.array.slice( [ 1, 2, 3, 4, '5' ], 6, 9 );
 * // returns []
 *
 * @returns { Array } Returns a new Array containing the extracted elements.
 * @function slice
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-srcArray-} is not an array or unroll.
 * @namespace Tools/array
 */

function slice( srcArray, f, l )
{
  _.assert( this.likeResizable( srcArray ) );
  _.assert( 1 <= arguments.length && arguments.length <= 3 );
  return srcArray.slice( f, l );
}

// --
// array prepend
// --

function arrayPrepend( dstArray, ins )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }
  arrayPrepended.apply( this, arguments );
  return dstArray;
}

//

/**
 * Method adds a value of argument( ins ) to the beginning of an array( dstArray )
 * if destination( dstArray ) doesn't have the value of ( ins ).
 * Additionaly takes callback( onEqualize ) that checks if element from( dstArray ) is equal to( ins ).
 *
 * @param { Array } dstArray - The destination array.
 * @param { * } ins - The value to add.
 * @param { wTools~compareCallback } onEqualize - A callback function. By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayPrependOnce( [ 1, 2, 3, 4 ], 5 );
 * // returns [ 5, 1, 2, 3, 4 ]
 *
 * @example
 * _.arrayPrependOnce( [ 1, 2, 3, 4, 5 ], 5 );
 * // returns [ 1, 2, 3, 4, 5 ]
 *
 * @example
 * _.arrayPrependOnce( [ 'Petre', 'Mikle', 'Oleg' ], 'Dmitry' );
 * // returns [ 'Dmitry', 'Petre', 'Mikle', 'Oleg' ]
 *
 * @example
 * _.arrayPrependOnce( [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ], 'Dmitry' );
 * // returns [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ]
 *
 * @example
 * function onEqualize( a, b )
 * {
 *  return a.value === b.value;
 * };
 * _.arrayPrependOnce( [ { value : 1 }, { value : 2 } ], { value : 1 }, onEqualize );
 * // returns [ { value : 1 }, { value : 2 } ]
 *
 * @returns { Array } If an array ( dstArray ) doesn't have a value ( ins ) it returns the updated array ( dstArray ) with the new length,
 * otherwise, it returns the original array ( dstArray ).
 * @function arrayPrependOnce
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( onEqualize ) is not an Function.
 * @throws { Error } An Error if ( arguments.length ) is not equal two or three.
 * @namespace Tools
 */

function arrayPrependOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayPrependedOnce.apply( this, arguments );
  return dstArray;
}

//

/**
 * Method adds a value of argument( ins ) to the beginning of an array( dstArray )
 * if destination( dstArray ) doesn't have the value of ( ins ).
 * Additionaly takes callback( onEqualize ) that checks if element from( dstArray ) is equal to( ins ).
 * Returns updated array( dstArray ) if( ins ) was added, otherwise throws an Error.
 *
 * @param { Array } dstArray - The destination array.
 * @param { * } ins - The value to add.
 * @param { wTools~compareCallback } onEqualize - A callback function. By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayPrependOnceStrictly( [ 1, 2, 3, 4 ], 5 );
 * // returns [ 5, 1, 2, 3, 4 ]
 *
 * @example
 * _.arrayPrependOnceStrictly( [ 1, 2, 3, 4, 5 ], 5 );
 * // throws error
 *
 * @example
 * _.arrayPrependOnceStrictly( [ 'Petre', 'Mikle', 'Oleg' ], 'Dmitry' );
 * // returns [ 'Dmitry', 'Petre', 'Mikle', 'Oleg' ]
 *
 * @example
 * _.arrayPrependOnceStrictly( [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ], 'Dmitry' );
 * // throws error
 *
 * @example
 * function onEqualize( a, b )
 * {
 *  return a.value === b.value;
 * };
 * _.arrayPrependOnceStrictly( [ { value : 1 }, { value : 2 } ], { value : 0 }, onEqualize );
 * // returns [ { value : 0 }, { value : 1 }, { value : 2 } ]
 *
 * @returns { Array } If an array ( dstArray ) doesn't have a value ( ins ) it returns the updated array ( dstArray ) with the new length,
 * otherwise, it throws an Error.
 * @function arrayPrependOnceStrictly
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( onEqualize ) is not an Function.
 * @throws { Error } An Error if ( arguments.length ) is not equal two or three.
 * @throws { Error } An Error if ( ins ) already exists on( dstArray ).
 * @namespace Tools
 */

function arrayPrependOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    result = arrayPrependedOnce.apply( this, arguments );
    _.assert( result >= 0, () => `Array should have only unique elements, but has several ${ _.entity.exportStringDiagnosticShallow( ins ) }` );
  }
  else
  {
    result = arrayPrepended.apply( this, [ dstArray, ins ] );
  }

  return dstArray;
}

//

function arrayPrepended( dstArray, ins )
{
  _.assert( arguments.length === 2 );
  _.assert( _.array.is( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  dstArray.unshift( ins );
  return 0;
}

//

/**
 * Method adds a value of argument( ins ) to the beginning of an array( dstArray )
 * if destination( dstArray ) doesn't have the value of ( ins ).
 * Additionally takes callback( onEqualize ) that checks if element from( dstArray ) is equal to( ins ).
 *
 * @param { Array } dstArray - The destination array.
 * @param { * } ins - The value to add.
 * @param { wTools~compareCallback } onEqualize - A callback function. By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayPrependedOnce( [ 1, 2, 3, 4 ], 5 );
 * // returns 0
 *
 * @example
 * _.arrayPrependedOnce( [ 1, 2, 3, 4, 5 ], 5 );
 * // returns -1
 *
 * @example
 * _.arrayPrependedOnce( [ 'Petre', 'Mikle', 'Oleg' ], 'Dmitry' );
 * // returns 0
 *
 * @example
 * _.arrayPrependedOnce( [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ], 'Dmitry' );
 * // returns -1
 *
 * @example
 * function onEqualize( a, b )
 * {
 *  return a.value === b.value;
 * };
 * _.arrayPrependedOnce( [ { value : 1 }, { value : 2 } ], { value : 1 }, onEqualize );
 * // returns -1
 *
 * @returns { Array } Returns zero if elements was succesfully added, otherwise returns -1.
 *
 * @function arrayPrependedOnce
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( onEqualize ) is not an Function.
 * @throws { Error } An Error if ( arguments.length ) is not equal two or three.
 * @namespace Tools
 */

function arrayPrependedOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( _.array.is( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  let i = _.longLeftIndex.apply( _, arguments );

  if( i === -1 )
  {
    dstArray.unshift( ins );
    return 0;
  }
  return -1;
}

//

function arrayPrependedOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    result = arrayPrependedOnce.apply( this, arguments );
    _.assert( result >= 0, () => `Array should have only unique elements, but has several ${ _.entity.exportStringDiagnosticShallow( ins ) }` );
  }
  else
  {
    result = arrayPrepended.apply( this, [ dstArray, ins ] );
  }

  return result;
}

//

/**
 * Routine adds a value of argument( ins ) to the beginning of an array( dstArray ).
 *
 * @param { Array } dstArray - The destination array.
 * @param { * } ins - The element to add.
 *
 * @example
 * _.arrayPrependElement( [ 1, 2, 3, 4 ], 5 );
 * // returns [ 5, 1, 2, 3, 4 ]
 *
 * @example
 * _.arrayPrependElement( [ 1, 2, 3, 4, 5 ], 5 );
 * // returns [ 5, 1, 2, 3, 4, 5 ]
 *
 * @returns { Array } Returns updated array, that contains new element( ins ).
 * @function arrayPrependElement
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( arguments.length ) is less or more than two.
 * @namespace Tools
 */

function arrayPrependElement( dstArray, ins )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayPrependedElement.apply( this, arguments );
  return dstArray;
}

//

function arrayPrependElementOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayPrependedElementOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayPrependElementOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    result = arrayPrependedElementOnce.apply( this, arguments );
    _.assert( result !== undefined, 'Array should have only unique elements, but has several', ins );
  }
  else
  {
    result = arrayPrependedElement.apply( this, [ dstArray, ins ] );
  }

  return dstArray;
}

/*
function arrayPrependOnceStrictly( dstArray, ins, evaluator1, evaluator2 )
{

  let result = arrayPrependedOnce.apply( this, arguments );
  _.assert( result >= 0, () => `Array should have only unique elements, but has several ${ _.entity.exportStringDiagnosticShallow( ins ) }` );

  return dstArray;
}
*/

//

/**
 * Method adds a value of argument( ins ) to the beginning of an array( dstArray )
 * and returns zero if value was succesfully added.
 *
 * @param { Array } dstArray - The destination array.
 * @param { * } ins - The element to add.
 *
 * @example
 * _.arrayPrependedElement( [ 1, 2, 3, 4 ], 5 );
 * // returns 0
 *
 * @returns { Array } Returns updated array, that contains new element( ins ).
 * @function arrayPrependedElement
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( arguments.length ) is not equal to two.
 * @namespace Tools
 */

function arrayPrependedElement( dstArray, ins )
{
  _.assert( arguments.length === 2 );
  _.assert( _.array.is( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  dstArray.unshift( ins );

  return ins;
}

//

function arrayPrependedElementOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( _.array.is( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  let i = _.longLeftIndex.apply( _, arguments );

  if( i === -1 )
  {
    dstArray.unshift( ins );
    return dstArray[ 0 ];
  }
  return undefined;
}

//

function arrayPrependedElementOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    debugger;
    result = arrayPrependedElementOnce.apply( this, arguments );
    _.assert( result !== undefined, 'Array should have only unique elements, but has several', ins );
  }
  else
  {
    result = arrayPrependedElement.apply( this, [ dstArray, ins ] );
  }

  return result;
}

//

/**
 * Method adds all elements from array( insArray ) to the beginning of an array( dstArray ).
 *
 * @param { Array } dstArray - The destination array.
 * @param { ArrayLike } insArray - The source array.
 *
 * @example
 * _.arrayPrependArray( [ 1, 2, 3, 4 ], [ 5 ] );
 * // returns [ 5, 1, 2, 3, 4 ]
 *
 * @example
 * _.arrayPrependArray( [ 1, 2, 3, 4, 5 ], [ 5 ] );
 * // returns [ 5, 1, 2, 3, 4, 5 ]
 *
 * @returns { Array } Returns updated array, that contains elements from( insArray ).
 * @function arrayPrependArray
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( insArray ) is not an ArrayLike entity.
 * @throws { Error } An Error if ( arguments.length ) is less or more than two.
 * @namespace Tools
 */

function arrayPrependArray( dstArray, insArray )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayPrependedArray.apply( this, arguments );
  return dstArray;
}

//

/**
 * Method adds all unique elements from array( insArray ) to the beginning of an array( dstArray )
 * Additionaly takes callback( onEqualize ) that checks if element from( dstArray ) is equal to( ins ).
 *
 * @param { Array } dstArray - The destination array.
 * @param { ArrayLike } insArray - The source array.
 * @param { wTools~compareCallback } onEqualize - A callback function. By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayPrependArrayOnce( [ 1, 2, 3, 4 ], [ 0, 1, 2, 3, 4 ] );
 * // returns [ 0, 1, 2, 3, 4 ]
 *
 * @example
 * _.arrayPrependArrayOnce( [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ], [ 'Dmitry' ] );
 * // returns [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ]
 *
 * @example
 * function onEqualize( a, b )
 * {
 *  return a.value === b.value;
 * };
 * _.arrayPrependArrayOnce( [ { value : 1 }, { value : 2 } ], [ { value : 1 } ], onEqualize );
 * // returns [ { value : 1 }, { value : 2 } ]
 *
 * @returns { Array } Returns updated array( dstArray ) or original if nothing added.
 * @function arrayPrependArrayOnce
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( insArray ) is not an ArrayLike entity.
 * @throws { Error } An Error if ( onEqualize ) is not an Function.
 * @throws { Error } An Error if ( arguments.length ) is not equal two or three.
 * @namespace Tools
 */

function arrayPrependArrayOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayPrependedArrayOnce.apply( this, arguments );
  return dstArray;
}

//

/**
 * Method adds all unique elements from array( insArray ) to the beginning of an array( dstArray )
 * Additionaly takes callback( onEqualize ) that checks if element from( dstArray ) is equal to( ins ).
 * Returns updated array( dstArray ) if all elements from( insArray ) was added, otherwise throws error.
 * Even error was thrown, elements that was prepended to( dstArray ) stays in the destination array.
 *
 * @param { Array } dstArray - The destination array.
 * @param { ArrayLike } insArray - The source array.
 * @param { wTools~compareCallback } onEqualize - A callback function. By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayPrependArrayOnceStrictly( [ 1, 2, 3, 4 ], [ 0, 1, 2, 3, 4 ] );
 * // returns [ 0, 1, 2, 3, 4 ]
 *
 * @example
 * function onEqualize( a, b )
 * {
 *  return a.value === b.value;
 * };
 * _.arrayPrependArrayOnceStrictly( [ { value : 1 }, { value : 2 } ], { value : 1 }, onEqualize );
 * // returns [ { value : 1 }, { value : 2 } ]
 *
 * * @example
 * let dst = [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ];
 * _.arrayPrependArrayOnceStrictly( dst, [ 'Antony', 'Dmitry' ] );
 * // throws error, but dstArray was updated by one element from insArray
 *
 * @returns { Array } Returns updated array( dstArray ) or throws an error if not all elements from source
 * array( insArray ) was added.
 * @function arrayPrependArrayOnceStrictly
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( insArray ) is not an ArrayLike entity.
 * @throws { Error } An Error if ( onEqualize ) is not an Function.
 * @throws { Error } An Error if ( arguments.length ) is not equal two or three.
 * @namespace Tools
 */

function arrayPrependArrayOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    let insArrayLength = insArray.length
    result = arrayPrependedArrayOnce.apply( this, arguments );
    _.assert( result === insArrayLength );
  }
  else
  {
    result = arrayPrependedArray.apply( this, [ dstArray, insArray ] );
  }

  return dstArray;
}

/*
function arrayPrependArrayOnceStrictly( dstArray, insArray, evaluator1, evaluator2 )
{
  let result = arrayPrependedArrayOnce.apply( this, arguments );
  _.assert( result === insArray.length );
  return dstArray;
}
*/

//

/**
 * Method adds all elements from array( insArray ) to the beginning of an array( dstArray ).
 * Returns count of added elements.
 *
 * @param { Array } dstArray - The destination array.
 * @param { ArrayLike } insArray - The source array.
 *
 * @example
 * let dst = [ 1, 2, 3, 4 ];
 * _.arrayPrependedArray( dst, [ 5, 6, 7 ] );
 * // returns 3
 * console.log( dst );
 * //log [ 5, 6, 7, 1, 2, 3, 4 ]
 *
 * @returns { Array } Returns count of added elements.
 * @function arrayPrependedArray
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( insArray ) is not an ArrayLike entity.
 * @throws { Error } An Error if ( arguments.length ) is less or more than two.
 * @namespace Tools
 */

function arrayPrependedArray( dstArray, insArray )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.array.is( dstArray ), 'arrayPrependedArray :', 'Expects array' );
  _.assert( _.longLike( insArray ), 'arrayPrependedArray :', 'Expects longLike' );

  let result = insArray.length;
  dstArray.unshift.apply( dstArray, insArray );
  return result;
}

//

/**
 * Method adds all unique elements from array( insArray ) to the beginning of an array( dstArray )
 * Additionaly takes callback( onEqualize ) that checks if element from( dstArray ) is equal to( ins ).
 * Returns count of added elements.
 *
 * @param { Array } dstArray - The destination array.
 * @param { ArrayLike } insArray - The source array.
 * @param { wTools~compareCallback } onEqualize - A callback function. By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayPrependedArrayOnce( [ 1, 2, 3 ], [ 4, 5, 6] );
 * // returns 3
 *
 * @example
 * _.arrayPrependedArrayOnce( [ 0, 2, 3, 4 ], [ 1, 1, 1 ] );
 * // returns 1
 *
 * @example
 * _.arrayPrependedArrayOnce( [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ], [ 'Dmitry' ] );
 * // returns 0
 *
 * @example
 * function onEqualize( a, b )
 * {
 *  return a.value === b.value;
 * };
 * _.arrayPrependedArrayOnce( [ { value : 1 }, { value : 2 } ], [ { value : 1 } ], onEqualize );
 * // returns 0
 *
 * @returns { Array } Returns count of added elements.
 * @function arrayPrependedArrayOnce
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if ( insArray ) is not an ArrayLike entity.
 * @throws { Error } An Error if ( onEqualize ) is not an Function.
 * @throws { Error } An Error if ( arguments.length ) is not equal two or three.
 * @namespace Tools
 */

function arrayPrependedArrayOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.array.is( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
  _.assert( _.longLike( insArray ) );

  let result = 0;

  if( dstArray === insArray )
  if( arguments.length === 2 )
  return result;

  for( let i = insArray.length - 1; i >= 0; i-- )
  {
    let index = i;
    if( dstArray === insArray )
    index = i + result;

    if( _.longLeftIndex( dstArray, insArray[ index ], evaluator1, evaluator2 ) === -1 )
    {
      dstArray.unshift( insArray[ index ] );
      result += 1;
    }
  }

  return result;
}

//

function arrayPrependedArrayOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    let insArrayLength = insArray.length;
    result = arrayPrependedArrayOnce.apply( this, arguments );
    _.assert( result === insArrayLength );
  }
  else
  {
    result = arrayPrependedArray.apply( this, [ dstArray, insArray ] );
  }

  return result;
}

//

/**
 * Method adds all elements from provided arrays to the beginning of an array( dstArray ) in same order
 * that they are in( arguments ).
 * If argument provided after( dstArray ) is not a ArrayLike entity it will be prepended to destination array as usual element.
 * If argument is an ArrayLike entity and contains inner arrays, routine looks for elements only on first two levels.
 * Example: _.arrayPrependArrays( [], [ [ 1 ], [ [ 2 ] ] ] ) -> [ 1, [ 2 ] ];
 * Throws an error if one of arguments is undefined. Even if error was thrown, elements that was prepended to( dstArray ) stays in the destination array.
 *
 * @param { Array } dstArray - The destination array.
 * @param{ longLike | * } arguments[...] - Source arguments.
 *
 * @example
 * _.arrayPrependArrays( [ 1, 2, 3, 4 ], [ 5 ], [ 6 ], 7 );
 * // returns [ 5, 6, 7, 1, 2, 3, 4 ]
 *
 * @example
 * let dst = [ 1, 2, 3, 4 ];
 * _.arrayPrependArrays( dst, [ 5 ], [ 6 ], undefined );
 * // throws error, but dst becomes equal [ 5, 6, 1, 2, 3, 4 ]
 *
 * @returns { Array } Returns updated array( dstArray ).
 * @function arrayPrependArrays
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if one of ( arguments ) is undefined.
 * @namespace Tools
 */

function arrayPrependArrays( dstArray, insArray )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayPrependedArrays.apply( this, arguments );
  return dstArray;
}

//

/**
 * Method adds all unique elements from provided arrays to the beginning of an array( dstArray ) in same order
 * that they are in( arguments ).
 * If argument provided after( dstArray ) is not a ArrayLike entity it will be prepended to destination array as usual element.
 * If argument is an ArrayLike entity and contains inner arrays, routine looks for elements only on first two levels.
 * Example: _.arrayPrependArrays( [], [ [ 1 ], [ [ 2 ] ] ] ) -> [ 1, [ 2 ] ];
 * Throws an error if one of arguments is undefined. Even if error was thrown, elements that was prepended to( dstArray ) stays in the destination array.

 * @param { Array } dstArray - The destination array.
 * @param{ longLike | * } arguments[...] - Source arguments.
 *
 * @example
 * _.arrayPrependArraysOnce( [ 1, 2, 3, 4 ], [ 5 ], 5, [ 6 ], 6, 7, [ 7 ] );
 * // returns [ 5, 6, 7, 1, 2, 3, 4 ]
 *
 * @example
 * let dst = [ 1, 2, 3, 4 ];
 * _.arrayPrependArraysOnce( dst, [ 5 ], 5, [ 6 ], 6, undefined );
 * // throws error, but dst becomes equal [ 5, 6, 1, 2, 3, 4 ]
 *
 * @returns { Array } Returns updated array( dstArray ).
 * @function arrayPrependArraysOnce
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if one of ( arguments ) is undefined.
 * @namespace Tools
 */

function arrayPrependArraysOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayPrependedArraysOnce.apply( this, arguments );
  return dstArray;
}

//

/**
 * Method adds all unique elements from provided arrays to the beginning of an array( dstArray ) in same order
 * that they are in( arguments ).
 * Throws an error if one of arguments is undefined.
 * If argument provided after( dstArray ) is not a ArrayLike entity it will be prepended to destination array as usual element.
 * If argument is an ArrayLike entity and contains inner arrays, routine looks for elements only on first two levels.
 * Example: _.arrayPrependArraysOnce( [], [ [ 1 ], [ [ 2 ] ] ] ) -> [ 1, [ 2 ] ];
 * After copying checks if all elements( from first two levels ) was copied, if true returns updated array( dstArray ), otherwise throws an error.
 * Even if error was thrown, elements that was prepended to( dstArray ) stays in the destination array.

 * @param { Array } dstArray - The destination array.
 * @param { longLike | * } arguments[...] - Source arguments.
 * @param { wTools~compareCallback } onEqualize - A callback function that can be provided through routine`s context. By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayPrependArraysOnceStrictly( [ 1, 2, 3, 4 ], 5, [ 6, [ 7 ] ], 8 );
 * // returns [ 5, 6, 7, 8, 1, 2, 3, 4 ]
 *
 * @example
 * _.arrayPrependArraysOnceStrictly( [ 1, 2, 3, 4 ], [ 5 ], 5, [ 6 ], 6, 7, [ 7 ] );
 * // throws error
 *
 * @example
 * function onEqualize( a, b )
 * {
 *  return a === b;
 * };
 * let dst = [];
 * let arguments = [ dst, [ 1, [ 2 ], [ [ 3 ] ] ], 4 ];
 * _.arrayPrependArraysOnceStrictly.apply( { onEqualize }, arguments );
 * // returns [ 1, 2, [ 3 ], 4 ]
 *
 * @returns { Array } Returns updated array( dstArray ).
 * @function arrayPrependArraysOnceStrictly
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @throws { Error } An Error if one of ( arguments ) is undefined.
 * @throws { Error } An Error if count of added elements is not equal to count of elements from( arguments )( only first two levels inside of array are counted ).
 * @namespace Tools
 */

function arrayPrependArraysOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    let expected = 0;
    let insIsDst = 0;
    for( let i = insArray.length - 1; i >= 0; i-- )
    {
      if( _.longLike( insArray[ i ] ) )
      {
        expected += insArray[ i ].length

        if( insArray[ i ] === dstArray )
        {
          insIsDst += 1;
          if( insIsDst > 1 )
          expected += insArray[ i ].length
        }
      }
      else
      expected += 1;
    }
    result = arrayPrependedArraysOnce.apply( this, arguments );
    _.assert( result === expected, '{-dstArray-} should have none element from {-insArray-}' );
  }
  else
  {
    result = arrayPrependedArrays.apply( this, [ dstArray, insArray ] );
  }

  return dstArray;
}

/*
function arrayPrependArraysOnceStrictly( dstArray, insArray, evaluator1, evaluator2 )
{
  let result = arrayPrependedArraysOnce.apply( this, arguments );
  let expected = 0;

  if( Config.debug )
  {

    for( let i = insArray.length - 1; i >= 0; i-- )
    {
      if( _.longLike( insArray[ i ] ) )
      expected += insArray[ i ].length;
      else
      expected += 1;
    }

    _.assert( result === expected, '{-dstArray-} should have none element from {-insArray-}' );

  }

  return dstArray;
}
*/

//

/**
 * Method adds all elements from provided arrays to the beginning of an array( dstArray ) in same order
 * that they are in( arguments ).
 * If argument provided after( dstArray ) is not a ArrayLike entity it will be prepended to destination array as usual element.
 * If argument is an ArrayLike entity and contains inner arrays, routine looks for elements only on first two levels.
 * Example: _.arrayPrependArrays( [], [ [ 1 ], [ [ 2 ] ] ] ) -> [ 1, [ 2 ] ];
 * Throws an error if one of arguments is undefined. Even if error was thrown, elements that was prepended to( dstArray ) stays in the destination array.
 *
 * @param { Array } dstArray - The destination array.
 * @param{ longLike | * } arguments[...] - Source arguments.
 *
 * @example
 * _.arrayPrependedArrays( [ 1, 2, 3, 4 ], [ 5 ], [ 6 ], 7 );
 * // returns 3
 *
 * @example
 * let dst = [ 1, 2, 3, 4 ];
 * _.arrayPrependedArrays( dst, [ 5 ], [ 6 ], undefined );
 * // throws error, but dst becomes equal [ 5, 6, 1, 2, 3, 4 ]
 *
 * @returns { Array } Returns count of added elements.
 * @function arrayPrependedArrays
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @namespace Tools
 */

function arrayPrependedArrays( dstArray, insArray )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.array.is( dstArray ), 'arrayPrependedArrays :', 'Expects array' );
  _.assert( _.longLike( insArray ), 'arrayPrependedArrays :', 'Expects longLike entity' );

  let result = 0;

  if( dstArray === insArray )
  {
    result = insArray.length;
    dstArray.unshift.apply( dstArray, insArray );
    return result;
  }

  for( let a = 0, len = insArray.length ; a < len ; a++ )
  {
    if( _.longLike( insArray[ a ] ) )
    {
      result += insArray[ a ].length;
      dstArray.unshift.apply( dstArray, insArray[ a ] );
    }
    else
    {
      dstArray.unshift( insArray[ a ] );
      result += 1;
    }
  }

  return result;
}

//

/**
 * Method adds all unique elements from provided arrays to the beginning of an array( dstArray ) in same order
 * that they are in( arguments ).
 * If argument provided after( dstArray ) is not a ArrayLike entity it will be prepended to destination array as usual element.
 * If argument is an ArrayLike entity and contains inner arrays, routine looks for elements only on first two levels.
 * Example: _.arrayPrependArrays( [], [ [ 1 ], [ [ 2 ] ] ] ) -> [ 1, [ 2 ] ];
 * Throws an error if one of arguments is undefined. Even if error was thrown, elements that was prepended to( dstArray ) stays in the destination array.
 *
 * @param { Array } dstArray - The destination array.
 * @param{ longLike | * } arguments[...] - Source arguments.
 *
 * @example
 * _.arrayPrependedArraysOnce( [ 1, 2, 3, 4, 5, 6, 7 ], [ 5 ], [ 6 ], 7 );
 * // returns 0
 *
 * @example
 * _.arrayPrependedArraysOnce( [ 1, 2, 3, 4 ], [ 5 ], 5, [ 6 ], 6, 7, [ 7 ] );
 * // returns 3
 *
 * @example
 * let dst = [ 1, 2, 3, 4 ];
 * _.arrayPrependedArraysOnce( dst, [ 5 ], [ 6 ], undefined );
 * // throws error, but dst becomes equal [ 5, 6, 1, 2, 3, 4 ]
 *
 * @returns { Array } Returns count of added elements.
 * @function arrayPrependedArraysOnce
 * @throws { Error } An Error if ( dstArray ) is not an Array.
 * @namespace Tools
 */

function arrayPrependedArraysOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.array.is( dstArray ), 'arrayPrependedArraysOnce :', 'Expects array' );
  _.assert( _.longLike( insArray ), 'arrayPrependedArraysOnce :', 'Expects longLike entity' );

  let result = 0;

  if( dstArray === insArray )
  if( arguments.length === 2 )
  return result;

  function _prependOnce( element )
  {
    let index = _.longLeftIndex( dstArray, element, evaluator1, evaluator2 );
    if( index === -1 )
    {
      dstArray.unshift( element );
      // dstArray.splice( result, 0, element );
      result += 1;
    }
  }

  // for( let ii = insArray.length - 1; ii >= 0; ii-- )
  for( let ii = 0, len = insArray.length; ii < len ; ii++ )
  {
    if( _.longLike( insArray[ ii ] ) )
    {
      let array = insArray[ ii ];
      if( array === dstArray )
      array = array.slice();
      // for( let a = array.length - 1; a >= 0; a-- )
      for( let a = array.length - 1; a >= 0 ; a-- )
      _prependOnce( array[ a ] );
    }
    else
    {
      if( dstArray === insArray )
      _prependOnce( insArray[ ii + result ] );
      else
      _prependOnce( insArray[ ii ] );
    }
  }

  return result;
}

//

function arrayPrependedArraysOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    let expected = 0;
    let insIsDst = 0;
    for( let i = insArray.length - 1; i >= 0; i-- )
    {
      if( _.longLike( insArray[ i ] ) )
      {
        expected += insArray[ i ].length

        if( insArray[ i ] === dstArray )
        {
          insIsDst += 1;
          if( insIsDst > 1 )
          expected += insArray[ i ].length
        }
      }
      else
      expected += 1;
    }

    result = arrayPrependedArraysOnce.apply( this, arguments );

    _.assert( result === expected, '{-dstArray-} should have none element from {-insArray-}' );
  }
  else
  {
    result = arrayPrependedArrays.apply( this, [ dstArray, insArray ] );
  }

  return result;
}

// --
// array append
// --

// function arrayAppend_( dstArray )
// {
//   _.assert( arguments.length >= 1 );
//   _.assert( _.array.is( dstArray ) || dstArray === null, 'Expects array' );
//
//   dstArray = dstArray || [];
//
//   for( let a = 1, len = arguments.length ; a < len; a++ )
//   {
//     if( _.longLike( arguments[ a ] ) )
//     {
//       dstArray.push.apply( dstArray, arguments[ a ] );
//     }
//     else
//     {
//       dstArray.push( arguments[ a ] );
//     }
//   }
//
//   return dstArray;
// }

//

function arrayAppend( dstArray, ins )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayAppended.apply( this, arguments );
  return dstArray;
}

//

/**
 * The arrayAppendOnce() routine adds at the end of an array (dst) a value {-srcMap-},
 * if the array (dst) doesn't have the value {-srcMap-}.
 *
 * @param { Array } dst - The source array.
 * @param { * } src - The value to add.
 *
 * @example
 * _.arrayAppendOnce( [ 1, 2, 3, 4 ], 5 );
 * // returns [ 1, 2, 3, 4, 5 ]
 *
 * @example
 * _.arrayAppendOnce( [ 1, 2, 3, 4, 5 ], 5 );
 * // returns [ 1, 2, 3, 4, 5 ]
 *
 * @example
 * _.arrayAppendOnce( [ 'Petre', 'Mikle', 'Oleg' ], 'Dmitry' );
 * // returns [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ]
 *
 * @example
 * _.arrayAppendOnce( [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ], 'Dmitry' );
 * // returns [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ]
 *
 * @returns { Array } If an array (dst) doesn't have a value {-srcMap-} it returns the updated array (dst) with the new length,
 * otherwise, it returns the original array (dst).
 * @function arrayAppendOnce
 * @throws { Error } Will throw an Error if (dst) is not an Array.
 * @throws { Error } Will throw an Error if (arguments.length) is less or more than two.
 * @namespace Tools
 */

function arrayAppendOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayAppendedOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayAppendOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    result = _.arrayAppendedOnce.apply( this, arguments );
    _.assert( result >= 0, () => `Array should have only unique elements, but has several ${ _.entity.exportStringDiagnosticShallow( ins ) }` );
  }
  else
  {
    result = _.arrayAppended.apply( this, [ dstArray, ins ] );
  }
  return dstArray;
}

//

function arrayAppended( dstArray, ins )
{
  _.assert( arguments.length === 2 );
  _.assert( _.array.is( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
  dstArray.push( ins );
  return dstArray.length - 1;
}

//

function arrayAppendedOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let i = _.longLeftIndex.apply( _, arguments );

  if( i === -1 )
  {
    dstArray.push( ins );
    return dstArray.length - 1;
  }

  return -1;
}

//

function arrayAppendedOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    result = _.arrayAppendedOnce.apply( this, arguments );
    _.assert( result >= 0, () => `Array should have only unique elements, but has several ${ _.entity.exportStringDiagnosticShallow( ins ) }` );
  }
  else
  {
    result = _.arrayAppended.apply( this, [ dstArray, ins ] );
  }
  return result;
}


//

function arrayAppendElement( dstArray, ins )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayAppendedElement.apply( this, arguments );
  return dstArray;
}

//

function arrayAppendElementOnce( dstArray, ins )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayAppendedElementOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayAppendElementOnceStrictly( dstArray, ins )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    result = arrayAppendedElementOnce.apply( this, arguments );
    _.assert( result !== false, 'Array should have only unique elements, but has several', ins );
  }
  else
  {
    result = arrayAppendedElement.apply( this, [ dstArray, ins ] );
  }
  return dstArray;
}

//

function arrayAppendedElement( dstArray, ins )
{
  _.assert( arguments.length === 2 );
  _.assert( _.array.is( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
  dstArray.push( ins );
  return dstArray.length - 1;
}

//

function arrayAppendedElementOnce( dstArray, ins )
{
  let i = _.longLeftIndex.apply( _, arguments );

  if( i === -1 )
  {
    dstArray.push( ins );
    return dstArray[ dstArray.length - 1 ];
  }

  return false;
  // return -1;
}

//

function arrayAppendedElementOnceStrictly( dstArray, ins )
{
  let result;
  if( Config.debug )
  {
    result = arrayAppendedElementOnce.apply( this, arguments );
    _.assert( result !== false, 'Array should have only unique elements, but has several', ins );
  }
  else
  {
    result = arrayAppendedElement.apply( this, [ dstArray, ins ] );
  }
  return result;
}

//

/**
* The arrayAppendArray() routine adds one or more elements to the end of the (dst) array
* and returns the new length of the array.
*
* It creates two variables the (result) - array and the (argument) - elements of array-like object (arguments[]),
* iterate over array-like object (arguments[]) and assigns to the (argument) each element,
* checks, if (argument) is equal to the 'undefined'.
* If true, it throws an Error.
* If (argument) is an array-like.
* If true, it merges the (argument) into the (result) array.
* Otherwise, it adds element to the result.
*
* @param { Array } dst - Initial array.
* @param {*} arguments[] - One or more argument(s) to add to the end of the (dst) array.
*
* @example
* _.arrayAppendArray( [ 1, 2 ], 'str', false, { a : 1 }, 42, [ 3, 7, 13 ] );
* // returns [ 1, 2, 'str', false, { a : 1 }, 42, 3, 7, 13 ];
*
* @returns { Array } - Returns an array (dst) with all of the following argument(s) that were added to the end of the (dst) array.
* @function arrayAppendArray
* @throws { Error } If the first argument is not an array.
* @throws { Error } If type of the argument is equal undefined.
* @namespace Tools
*/

function arrayAppendArray( dstArray, insArray )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayAppendedArray.apply( this, arguments );
  return dstArray;
}

//

/**
 * The arrayAppendArrayOnce() routine returns an array of elements from (dst)
 * and appending only unique following arguments to the end.
 *
 * It creates two variables the (result) - array and the (argument) - elements of array-like object (arguments[]),
 * iterate over array-like object (arguments[]) and assigns to the (argument) each element,
 * checks, if (argument) is equal to the 'undefined'.
 * If true, it throws an Error.
 * if (argument) is an array-like.
 * If true, it iterate over array (argument) and checks if (result) has the same values as the (argument).
 * If false, it adds elements of (argument) to the end of the (result) array.
 * Otherwise, it checks if (result) has not the same values as the (argument).
 * If true, it adds elements to the end of the (result) array.
 *
 * @param { Array } dst - Initial array.
 * @param {*} arguments[] - One or more argument(s).
 *
 * @example
 * _.arrayAppendArrayOnce( [ 1, 2 ], 'str', 2, {}, [ 'str', 5 ] );
 * // returns [ 1, 2, 'str', {}, 5 ]
 *
 * @returns { Array } - Returns an array (dst) with only unique following argument(s) that were added to the end of the (dst) array.
 * @function arrayAppendArrayOnce
 * @throws { Error } If the first argument is not array.
 * @throws { Error } If type of the argument is equal undefined.
 * @namespace Tools
 */

function arrayAppendArrayOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayAppendedArrayOnce.apply( this, arguments )
  return dstArray;
}

//

function arrayAppendArrayOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    let insArrayLength = insArray.length
    result = _.arrayAppendedArrayOnce.apply( this, arguments )
    _.assert( result === insArrayLength );
  }
  else
  {
    result = arrayAppendedArray.apply( this, [ dstArray, insArray ] )
  }
  return dstArray;
}

/*
function arrayAppendArrayOnceStrictly( dstArray, insArray, evaluator1, evaluator2 )
{
  let result = arrayAppendedArrayOnce.apply( this, arguments )
  _.assert( result === insArray.length );
  return dstArray;
}
*/

//

function arrayAppendedArray( dstArray, insArray )
{
  _.assert( arguments.length === 2 )
  _.assert( _.array.is( dstArray ), 'arrayPrependedArray :', 'Expects array' );
  _.assert( _.longLike( insArray ), 'arrayPrependedArray :', 'Expects longLike' );

  let result = insArray.length;
  dstArray.push.apply( dstArray, insArray );
  return result;
}

//

function arrayAppendedArrayOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( _.longLike( insArray ) );
  _.assert( 2 <= arguments.length && arguments.length <= 4 );

  let result = 0;

  if( dstArray === insArray )
  if( arguments.length === 2 )
  return result;

  for( let i = 0, len = insArray.length; i < len ; i++ )
  {
    if( _.longLeftIndex( dstArray, insArray[ i ], evaluator1, evaluator2 ) === -1 )
    {
      dstArray.push( insArray[ i ] );
      result += 1;
    }
  }

  return result;
}

//

function arrayAppendedArrayOnceStrictly( dstArray, ins )
{
  let result;
  if( Config.debug )
  {
    let insArrayLength = ins.length;
    result = _.arrayAppendedArrayOnce.apply( this, arguments );
    _.assert( result === insArrayLength, 'Array should have only unique elements, but has several', ins );
  }
  else
  {
    result = arrayAppendedElement.apply( this, [ dstArray, ins ] );
  }
  return result;
}

//

function arrayAppendArrays( dstArray, insArray )
{

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  if( dstArray === undefined )
  {
    _.assert( arguments.length === 2 );
    return insArray;
  }

  _.arrayAppendedArrays.apply( this, arguments );

  return dstArray;
}

//

function arrayAppendArraysOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }
  else if( dstArray === undefined )
  {
    if( _.array.is( insArray ) )
    {
      dstArray = [];
      arguments[ 0 ] = dstArray;
    }
    else
    {
      _.assert( 2 <= arguments.length && arguments.length <= 4 );
      return insArray;
    }
  }

  _.arrayAppendedArraysOnce.apply( this, arguments );

  return dstArray;
}

//

function arrayAppendArraysOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  let result;
  if( Config.debug )
  {
    let expected = 0;
    let insIsDst = 0;
    for( let i = insArray.length - 1; i >= 0; i-- )
    {
      if( _.longLike( insArray[ i ] ) )
      {
        expected += insArray[ i ].length

        if( insArray[ i ] === dstArray )
        {
          insIsDst += 1;
          if( insIsDst > 1 )
          expected += insArray[ i ].length
        }
      }
      else
      expected += 1;
    }

    result = _.arrayAppendedArraysOnce.apply( this, arguments );

    _.assert( result === expected, '{-dstArray-} should have none element from {-insArray-}' );
  }
  else
  {
    result = arrayAppendedArrays.apply( this, [ dstArray, insArray ] );
  }

  return dstArray;
}

//

function arrayAppendedArrays( dstArray, insArray )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !_.longLike( insArray ) && insArray !== undefined )
  insArray = [ insArray ];

  // if( !_.longLike( insArray ) )
  // {
  //   if( !_.array.is( dstArray ) )
  //   return [ dstArray, insArray ];
  //   else
  //   dstArray.push( insArray );
  //   return 1;
  // }

  // if( !_.array.is( insArray ) && insArray !== undefined )
  // insArray = [ insArray ];
  // if( !_.array.is( insArray ) && insArray !== undefined )
  // insArray = [ insArray ];

  _.assert( _.array.is( dstArray ), 'Expects array' );
  _.assert( _.longLike( insArray ), 'Expects longLike entity' );

  let result = 0;

  for( let a = 0, len = insArray.length; a < len; a++ )
  {
    if( _.longLike( insArray[ a ] ) )
    {
      dstArray.push.apply( dstArray, insArray[ a ] );
      result += insArray[ a ].length;
    }
    else
    {
      dstArray.push( insArray[ a ] );
      result += 1;
    }
  }

  return result;
}

//

function arrayAppendedArraysOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );

  if( dstArray === undefined )
  return insArray;

  if( !_.array.is( insArray ) && insArray !== undefined )
  insArray = [ insArray ];

  _.assert( _.array.is( dstArray ), 'Expects array' );
  _.assert( _.longLike( insArray ), 'Expects longLike entity' );

  let result = 0;

  if( dstArray === insArray )
  if( arguments.length === 2 )
  return result;

  for( let a = 0, len = insArray.length; a < len; a++ )
  {
    if( _.longLike( insArray[ a ] ) )
    {
      let array = insArray[ a ];
      for( let i = 0, alen = array.length; i < alen; i++ )
      _appendOnce( array[ i ] );
    }
    else
    {
      _appendOnce( insArray[ a ] );
    }
  }

  return result;

  function _appendOnce( argument )
  {
    let index = _.longLeftIndex( dstArray, argument, evaluator1, evaluator2 );
    if( index === -1 )
    {
      dstArray.push( argument );
      result += 1;
    }
  }

}

//

function arrayAppendedArraysOnceStrictly( dstArray, ins )
{
  let result;
  if( Config.debug )
  {
    let expected = 0;
    let insIsDst = 0;
    for( let i = ins.length - 1; i >= 0; i-- )
    {
      if( _.longLike( ins[ i ] ) )
      {
        expected += ins[ i ].length

        if( ins[ i ] === dstArray )
        {
          insIsDst += 1;
          if( insIsDst > 1 )
          expected += ins[ i ].length
        }
      }
      else
      expected += 1;
    }
    result = _.arrayAppendedArraysOnce.apply( this, arguments );
    _.assert( result === expected, '{-dstArray-} should have none element from {-insArray-}' );
  }
  else
  {
    result = arrayAppendedArrays.apply( this, [ dstArray, ins ] );
  }

  return result;
}

// --
// container interface
// --

function _elementAppend( dst, val )
{
  dst.push( val );
  return dst.length-1;
}

//

function elementAppend( dst, val )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( dst ) );
  return this._elementAppend( dst, val );
}

//

function _elementPrepend( dst, val )
{
  dst.unshift( val );
  return 0;
}

//

function elementPrepend( dst, val )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( dst ) );
  return this._elementAppend( dst, val );
}

//

function _elementWithKeyDel( src, key )
{
  if( !this._hasKey( src, key ) )
  return false;
  src.splice( key, 1 );
  return true;
}

//

function elementWithKeyDel( src, key )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._elementWithKeyDel( src, key );
}

//

function _elementWithCardinalDel( src, cardinal )
{
  if( !this._hasKey( src, cardinal ) )
  return false;
  src.splice( cardinal, 1 );
  return true;
}

//

function elementWithCardinalDel( src, cardinal )
{
  _.assert( arguments.length === 2 );
  _.assert( this.is( src ) );
  return this._elementWithCardinalDel( src, cardinal, val );
}

//

function _empty( dst )
{
  dst.splice( 0, dst.length );
  return dst;
}

//

function empty( dst )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( this.like( dst ) );
  return this._empty( dst );
}

// --
// declaration
// --

/* qqq2 : for junior : duplicate routines. ask */
let ToolsExtension =
{

  // array prepend

  arrayPrepend,
  arrayPrependOnce,
  arrayPrependOnceStrictly,
  arrayPrepended,
  arrayPrependedOnce,
  arrayPrependedOnceStrictly,

  arrayPrependElement,
  arrayPrependElementOnce,
  arrayPrependElementOnceStrictly,
  arrayPrependedElement,
  arrayPrependedElementOnce,
  arrayPrependedElementOnceStrictly,

  arrayPrependArray,
  arrayPrependArrayOnce,
  arrayPrependArrayOnceStrictly,
  arrayPrependedArray,
  arrayPrependedArrayOnce,
  arrayPrependedArrayOnceStrictly,

  arrayPrependArrays,
  arrayPrependArraysOnce,
  arrayPrependArraysOnceStrictly,
  arrayPrependedArrays,
  arrayPrependedArraysOnce,
  arrayPrependedArraysOnceStrictly,

  // array append

  arrayAppend,
  arrayAppendOnce,
  arrayAppendOnceStrictly,
  arrayAppended,
  arrayAppendedOnce,
  arrayAppendedOnceStrictly,

  arrayAppendElement,
  arrayAppendElementOnce,
  arrayAppendElementOnceStrictly,
  arrayAppendedElement,
  arrayAppendedElementOnce,
  arrayAppendedElementOnceStrictly,

  arrayAppendArray,
  arrayAppendArrayOnce,
  arrayAppendArrayOnceStrictly,
  arrayAppendedArray,
  arrayAppendedArrayOnce,
  arrayAppendedArrayOnceStrictly,

  arrayAppendArrays,
  arrayAppendArraysOnce,
  arrayAppendArraysOnceStrictly,
  arrayAppendedArrays,
  arrayAppendedArraysOnce,
  arrayAppendedArraysOnceStrictly,

  // fields

  accuracy : 1e-7,
  accuracySqrt : 1e-4,
  accuracySqr : 1e-14,

}

//

Object.assign( _, ToolsExtension );

//

let ArrayExtension =
{

  // editor

  slice,

  // equaler

  _identicalShallow : _.long._identicalShallow,
  identicalShallow : _.long.identicalShallow,
  identical : _.long.identical,
  _equivalentShallow : _.long._equivalentShallow,
  equivalentShallow : _.long.equivalentShallow,
  equivalent : _.long.equivalent,

  // exporter

  _exportStringDiagnosticShallow : _.long._exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.long.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _.long._exportStringCodeShallow,
  exportStringCodeShallow : _.long.exportStringCodeShallow,
  exportString : _.long.exportString,

  // container interface

  _lengthOf : _.long._lengthOf,
  lengthOf : _.long.lengthOf, /* qqq : cover */

  _hasKey : _.long._hasKey,
  hasKey : _.long._hasKey, /* qqq : cover */
  _hasCardinal : _.long._hasKey,
  hasCardinal : _.long._hasKey, /* qqq : cover */
  _keyWithCardinal : _.long._hasKey,
  keyWithCardinal : _.long._hasKey, /* qqq : cover */
  _cardinalWithKey : _.long._cardinalWithKey,
  cardinalWithKey : _.long.cardinalWithKey, /* qqq : cover */

  _elementGet : _.long._elementWithKey,
  elementGet : _.long.elementWithKey, /* qqq : cover */
  _elementWithKey : _.long._elementWithKey,
  elementWithKey : _.long.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.long._elementWithImplicit,
  elementWithImplicit : _.long.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal : _.long._elementWithCardinal,
  elementWithCardinal : _.long.elementWithCardinal,  /* qqq : cover */

  _elementSet : _.long._elementSet,
  elementSet : _.long.elementSet, /* qqq : cover */
  _elementWithKeySet : _.long._elementWithKeySet,
  elementWithKeySet : _.long.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet : _.long._elementWithCardinalSet,
  elementWithCardinalSet : _.long.elementWithCardinalSet,  /* qqq : cover */

  _elementAppend,
  elementAppend, /* qqq : cover */
  _elementPrepend,
  elementPrepend, /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : elementWithKeyDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty, /* qqq : for junior : cover */

  _each : _.long._each,
  each : _.long.each, /* qqq : cover */
  _eachLeft : _.long._eachLeft,
  eachLeft : _.long.eachLeft, /* qqq : cover */
  _eachRight : _.long._eachRight,
  eachRight : _.long.eachRight, /* qqq : cover */

  _while : _.long._while,
  while : _.long.while, /* qqq : cover */
  _whileLeft : _.long._whileLeft,
  whileLeft : _.long.whileLeft, /* qqq : cover */
  _whileRight : _.long._whileRight,
  whileRight : _.long.whileRight, /* qqq : cover */

  _aptLeft : _.long._aptLeft,
  aptLeft : _.long.aptLeft, /* qqq : cover */
  first : _.long.first,
  _aptRight : _.long._aptRight, /* qqq : cover */
  aptRight : _.long.aptRight,
  last : _.long.last, /* qqq : cover */

  _filterAct : _.long._filterAct,
  filterWithoutEscapeLeft : _.long.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.long.filterWithoutEscapeRight,
  filterWithoutEscape : _.long.filterWithoutEscape,
  filterWithEscapeLeft : _.long.filterWithEscapeLeft,
  filterWithEscapeRight : _.long.filterWithEscapeRight,
  filterWithEscape : _.long.filterWithEscape,
  filter : _.long.filter,

  _mapAct : _.long._mapAct,
  mapWithoutEscapeLeft : _.long.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.long.mapWithoutEscapeRight,
  mapWithoutEscape : _.long.mapWithoutEscape,
  mapWithEscapeLeft : _.long.mapWithEscapeLeft,
  mapWithEscapeRight : _.long.mapWithEscapeRight,
  mapWithEscape : _.long.mapWithEscape,
  map : _.long.map,

}

//

Object.assign( _.array, ArrayExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Array.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Array_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Array_s */ })();

/* */  /* begin of file ArraySet_s */ ( function ArraySet_s() { function ArraySet_s_naked() { ( function _l3_ArraySet_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.arraySet = _.arraySet || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

//

let Extension =
{

}

Object.assign( _.arraySet, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/ArraySet.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ArraySet_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ArraySet_s */ })();

/* */  /* begin of file Auxiliary_s */ ( function Auxiliary_s() { function Auxiliary_s_naked() { ( function _l3_Auxiliary_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.props.exportString, 'Expects routine _.props.exportString' );

// --
// equaler
// --

function _identicalShallow( src1, src2 )
{

  if( Object.keys( src1 ).length !== Object.keys( src2 ).length )
  return false;

  for( let s in src1 )
  {
    if( src1[ s ] !== src2[ s ] )
    return false;
  }

  return true;
}

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

var AuxiliaryExtension =
{

  // equaler

  _identicalShallow,
  identicalShallow : _.props.identicalShallow,
  identical : _.props.identical,
  _equivalentShallow : _identicalShallow,
  equivalentShallow : _.props.equivalentShallow,
  equivalent : _.props.equivalent,

  // exporter

  _exportStringDiagnosticShallow : _.props._exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _.props._exportStringCodeShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // container interface

  _lengthOf : _.props._lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */

  _hasKey : _.props._hasKey,
  hasKey : _.props._hasKey, /* qqq : cover */
  _hasCardinal : _.props._hasKey,
  hasCardinal : _.props._hasKey, /* qqq : cover */
  _keyWithCardinal : _.props._hasKey,
  keyWithCardinal : _.props._hasKey, /* qqq : cover */
  _cardinalWithKey : _.props._cardinalWithKey,
  cardinalWithKey : _.props.cardinalWithKey, /* qqq : cover */

  _elementGet : _.props._elementWithKey,
  elementGet : _.props.elementWithKey, /* qqq : cover */
  _elementWithKey : _.props._elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.props._elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal : _.props._elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _.props._elementSet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet : _.props._elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet : _.props._elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */
  _empty : _.props._empty,
  empty : _.props.empty, /* qqq : for junior : cover */

  _elementDel : _.props._elementDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel : _.props._elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel : _.props._elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */

  _each : _.props._each,
  each : _.props.each, /* qqq : cover */
  _eachLeft : _.props._eachLeft,
  eachLeft : _.props.eachLeft, /* qqq : cover */
  _eachRight : _.props._eachRight,
  eachRight : _.props.eachRight, /* qqq : cover */

  _while : _.props._while,
  while : _.props.while, /* qqq : cover */
  _whileLeft : _.props._whileLeft,
  whileLeft : _.props.whileLeft, /* qqq : cover */
  _whileRight : _.props._whileRight,
  whileRight : _.props.whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct0 : _.props._filterAct0,
  _filterAct : _.props._filterAct,
  filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  filterWithoutEscape : _.props.filterWithoutEscape,
  filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  filterWithEscapeRight : _.props.filterWithEscapeRight,
  filterWithEscape : _.props.filterWithEscape,
  filter : _.props.filter,

  _mapAct0 : _.props._mapAct0,
  _mapAct : _.props._mapAct,
  mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  mapWithoutEscape : _.props.mapWithoutEscape,
  mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  mapWithEscapeRight : _.props.mapWithEscapeRight,
  mapWithEscape : _.props.mapWithEscape,
  map : _.props.map,

}

Object.assign( _.aux, AuxiliaryExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Auxiliary.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Auxiliary_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Auxiliary_s */ })();

/* */  /* begin of file Bool_s */ ( function Bool_s() { function Bool_s_naked() { ( function _l3_Bool_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// bool
// --

/**
 * @summary Returns copy of array( src ) with only boolean elements.
 * @description
 * Returns false if ( src ) is not ArrayLike object.
 * @function boolsAre
 * @param {Array} src - array of entities
 * @throws {Error} If more or less than one argument is provided.
 * @namespace Tools
 */

function are( src )
{
  _.assert( arguments.length === 1 );
  if( !_.argumentsArray.like( src ) )
  return false;
  return src.filter( ( e ) => _.bool.is( e ) );
}

//

/**
 * @summary Checks if all elements of array( src ) are booleans.
 * @description
 * * If ( src ) is not an array, routine checks if ( src ) is a boolean.
 * @function boolsAllAre
 * @param {Array} src - array of entities
 * @throws {Error} If more or less than one argument is provided.
 * @namespace Tools
 */

function allAre( src )
{
  _.assert( arguments.length === 1 );
  if( !_.arrayIs( src ) )
  return _.bool.is( src );
  return _.all( src.filter( ( e ) => _.bool.is( e ) ) );
}

//

/**
 * @summary Checks if at least one element from array( src ) is a boolean.
 * @description
 * * If ( src ) is not an array, routine checks if ( src ) is a boolean.
 * @function boolsAnyAre
 * @param {Array} src - array of entities
 * @throws {Error} If more or less than one argument is provided.
 * @namespace Tools
 */

function anyAre( src )
{
  _.assert( arguments.length === 1 );
  if( !_.arrayIs( src ) )
  return _.bool.is( src );
  return !!_.any( src.filter( ( e ) => _.bool.is( e ) ) );
}

//

/**
 * @summary Checks if array( src ) doesn't have booleans.
 * @description
 * * If ( src ) is not an array, routine checks if ( src ) is not a boolean.
 * @function boolsAnyAre
 * @param {Array} src - array of entities
 * @throws {Error} If more or less than one argument is provided.
 * @namespace Tools
 */

function noneAre( src )
{
  _.assert( arguments.length === 1 );
  if( !_.arrayIs( src ) )
  return _.bool.is( src );
  return _.none( src.filter( ( e ) => _.bool.is( e ) ) );
}

// //
//
// function areEquivalentShallow( src1, src2 )
// {
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//   _.assert( _.bool.like( src1 ) );
//   _.assert( _.bool.like( src2 ) );
//
//   if
//   (
//     ( _.bool.likeTrue( src1 ) && _.bool.likeTrue( src2 ) )
//     || ( ( _.bool.likeFalse( src1 ) && _.bool.likeFalse( src2 ) ) )
//   )
//   return true;
//
//   return false;
// }

//

function _identicalShallow( src1, src2 )
{
  if( src1 === src2 )
  return true;
  return false;
}

//

function identicalShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;
  return this._identicalShallow( src1, src2 );
}

//

function _equivalentShallow( src1, src2 )
{
  if
  (
    ( _.bool.likeTrue( src1 ) && _.bool.likeTrue( src2 ) )
    || ( ( _.bool.likeFalse( src1 ) && _.bool.likeFalse( src2 ) ) )
  )
  return true;
  return false;
}

//

function equivalentShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;
  return this._equivalentShallow( src1, src2 );
}

// --
// bool extension
// --

let BoolExtension =
{

  // equaler

  _identicalShallow,
  identicalShallow,
  identical : identicalShallow,
  _equivalentShallow,
  equivalentShallow,
  equivalent : equivalentShallow,

}

Object.assign( _.bool, BoolExtension );

// --
// bools
// --

let BoolsExtension =
{

  are,
  allAre,
  anyAre,
  noneAre,

}

Object.assign( _.bools, BoolsExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  boolsAre : are,
  boolsAllAre : allAre,
  boolsAnyAre : anyAre,
  boolsNoneAre : noneAre,

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Bool.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Bool_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Bool_s */ })();

/* */  /* begin of file Buffer_s */ ( function Buffer_s() { function Buffer_s_naked() { ( function _l3_Buffer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// dichotomy
// --

function constructorIsBuffer( src )
{
  if( !src )
  return false;
  if( !_.number.is( src.BYTES_PER_ELEMENT ) )
  return false;
  if( !_.strIs( src.name ) )
  return false;
  return src.name.indexOf( 'Array' ) !== -1;
}

// --
// maker
// --

function bufferCoerceFrom( o )
{
  let result;

  _.assert( arguments.length === 1 );
  _.assert( _.routine.is( o.bufferConstructor ), 'Expects bufferConstructor' );
  // _.map.assertHasOnly( o, bufferCoerceFrom.defaults );

  if( Config.debug )
  {
    for( let k in bufferCoerceFrom.defaults )
    {
      if( o[ k ] === undefined )
      throw Error( `Expects defined option::${k}` );
    }
    for( let k in o )
    {
      if( bufferCoerceFrom.defaults[ k ] === undefined )
      throw Error( `Unknown option::${k}` );
    }
  }

  if( o.src === null || _.number.is( o.src ) )
  {
    if( o.bufferConstructor.name === 'Buffer' )
    return o.bufferConstructor.alloc( o.src ? o.src : 0 );
    else if( o.bufferConstructor.name === 'DataView' )
    return new o.bufferConstructor( new U8x( o.src ).buffer )
    return new o.bufferConstructor( o.src );
  }

  _.assert( _.bufferAnyIs( o.src ) || _.long.is( o.src ) || _.strIs( o.src ) );

  if( _.strIs( o.src ) )
  o.src = _.bufferBytesFrom( o.src );

  /* */

  if( o.src.constructor === o.bufferConstructor )
  return o.src;

  /* */

  if( _.bufferViewIs( o.src ) )
  o.src = o.src.buffer.slice( o.src.byteOffset, o.src.byteLength );

  if( _.constructorIsBuffer( o.bufferConstructor ) )
  return new o.bufferConstructor( o.src );

  if( o.bufferConstructor.name === 'Buffer' )
  return o.bufferConstructor.from( o.src );

  if( o.bufferConstructor.name === 'DataView' )
  return new o.bufferConstructor( new U8x( o.src ).buffer );

  if( o.bufferConstructor.name === 'ArrayBuffer' )
  return new U8x( o.src ).buffer;

  if( o.bufferConstructor.name === 'SharedArrayBuffer' )
  {
    let srcTyped = _.bufferRawIs( o.src ) ? new U8x( o.src ) : o.src;
    let result = new BufferRawShared( srcTyped.length );
    let resultTyped = new U8x( result );
    for( let i = 0; i < srcTyped.length; i++ )
    resultTyped[ i ] = srcTyped[ i ];
    return result;
  }
}

bufferCoerceFrom.defaults =
{
  src : null,
  bufferConstructor : null,
}

// --
// equaler
// --

// /* qqq : extend test */
// function identicalShallow( src1, src2, o )
// {
//   _.assert( arguments.length === 2 || arguments.length === 3 );
//
//   if( !this.like( src1 ) )
//   return false;
//   if( !this.like( src2 ) )
//   return false;
//
//   return this._identicalShallow( src1, src2 );
// }
//
// //
//
// function _identicalShallow( src1, src2 )
// {
//   let result = true;
//
//   if( src1.length !== src2.length )
//   return false;
//
//   for( let s = 0 ; s < src1.length ; s++ )
//   {
//     result = src1[ s ] === src2[ s ];
//     if( result === false )
//     return false;
//   }
//
//   return result;
// }

function buffersTypedAreEquivalent( src1, src2, accuracy )
{

  if( !_.long.is( src1 ) )
  return false;
  if( !_.long.is( src2 ) )
  return false;

  if( src1.length !== src2.length )
  return false;

  if( accuracy === null || accuracy === undefined )
  accuracy = _.accuracy;

  for( let i = 0 ; i < src1.length ; i++ )
  if( Math.abs( src1[ i ] - src2[ i ] ) > accuracy )
  return false;

  return true;
}

//

function buffersTypedAreIdentical( src1, src2 )
{

  if( !_.bufferTypedIs( src1 ) )
  return false;
  if( !_.bufferTypedIs( src2 ) )
  return false;

  let t1 = Object.prototype.toString.call( src1 );
  let t2 = Object.prototype.toString.call( src2 );
  if( t1 !== t2 )
  return false;

  if( src1.length !== src2.length )
  return false;

  for( let i = 0 ; i < src1.length ; i++ )
  if( !Object.is( src1[ i ], src2[ i ] ) )
  return false;

  return true;
}

//

function buffersRawAreIdentical( src1, src2 )
{

  if( !_.bufferRawIs( src1 ) )
  return false;
  if( !_.bufferRawIs( src2 ) )
  return false;

  if( src1.byteLength !== src2.byteLength )
  return false;

  src1 = new U8x( src1 );
  src2 = new U8x( src2 );

  for( let i = 0 ; i < src1.length ; i++ )
  if( src1[ i ] !== src2[ i ] )
  return false;

  return true;
}

//

function buffersViewAreIdentical( src1, src2 )
{

  if( !_.bufferViewIs( src1 ) )
  return false;
  if( !_.bufferViewIs( src2 ) )
  return false;

  if( src1.byteLength !== src2.byteLength )
  return false;

  for( let i = 0 ; i < src1.byteLength ; i++ )
  if( src1.getUint8( i ) !== src2.getUint8( i ) )
  return false;

  return true;
}

//

function buffersNodeAreIdentical( src1, src2 )
{

  if( !_.bufferNodeIs( src1 ) )
  return false;
  if( !_.bufferNodeIs( src2 ) )
  return false;

  return src1.equals( src2 );
}

//

function _equivalentShallow( src1, src2, accuracy )
{

  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );

  if( _.bufferTypedIs( src1 ) )
  return _.buffersTypedAreEquivalent( src1, src2, accuracy );
  else if( _.bufferRawIs( src1 ) )
  return _.buffersRawAreIdentical( src1, src2 );
  else if( _.bufferViewIs( src1 ) )
  return _.buffersViewAreIdentical( src1, src2 );
  else if( _.bufferNodeIs( src1 ) )
  return _.buffersNodeAreIdentical( src1, src2 );
  else return false;

}

//

function equivalentShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( !_.buffer.like( src1 ) )
  return false;
  if( !_.buffer.like( src2 ) )
  return false;

  return _.buffer._equivalentShallow( src1, src2 );
}

//

function _identicalShallow( src1, src2 )
{

  let t1 = Object.prototype.toString.call( src1 );
  let t2 = Object.prototype.toString.call( src2 );
  if( t1 !== t2 )
  return false;

  if( _.bufferTypedIs( src1 ) )
  return _.buffersTypedAreIdentical( src1, src2 );
  else if( _.bufferRawIs( src1 ) )
  return _.buffersRawAreIdentical( src1, src2 );
  else if( _.bufferViewIs( src1 ) )
  return _.buffersViewAreIdentical( src1, src2 );
  else if( _.bufferNodeIs( src1 ) )
  return _.buffersNodeAreIdentical( src1, src2 );
  else return false;

}

//

function identicalShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( !_.buffer.like( src1 ) )
  return false;
  if( !_.buffer.like( src2 ) )
  return false;

  return _.buffer._identicalShallow( src1, src2 );
}

// --
// exporter
// --

function _exportStringDiagnosticShallow( src )
{
  if( _.long.is( src ) )
  return _.long._exportStringDiagnosticShallow( src );
  return _.object._exportStringDiagnosticShallow( src );
}

//

function _exportStringCodeShallow( src )
{
  if( _.long.is( src ) )
  return _.long._exportStringCodeShallow( src );
  return _.object._exportStringCodeShallow( src );
}

// --
// inspector
// --

function _lengthOf( src )
{
  if( _.long.is( src ) || _.bufferNode.is( src ) )
  return src.length;
  return _.itself._lengthOf( ... arguments );
}

//

function _hasKey( src, key )
{
  if( _.long.is( src ) || _.bufferNode.is( src ) )
  return _.long._hasKey( ... arguments );
  return _.itself._hasKey( ... arguments );
}

//

function _hasCardinal( src, cardinal )
{
  if( _.long.is( src ) || _.bufferNode.is( src ) )
  return _.long._hasCardinal( ... arguments );
  return _.itself._hasCardinal( ... arguments );
}

//

function _keyWithCardinal( src, cardinal )
{
  if( _.long.is( src ) || _.bufferNode.is( src ) )
  return _.long._keyWithCardinal( ... arguments );
  return _.itself._keyWithCardinal( ... arguments );
}

// --
// editor
// --

function _empty( dst )
{
  throw _.err( `${this.TypeName} has fixed length` );
  return false;
}

// --
// elementor
// --

function _elementWithKey( src, key )
{
  if( _.long.is( src ) || _.bufferNode.is( src ) )
  return _.long._elementWithKey( ... arguments );
  return _.itself._elementWithKey( ... arguments );
}

//

function _elementWithImplicit( src, key )
{
  if( _.props.keyIsImplicit( key ) )
  return _.props._onlyImplicitWithKeyTuple( src, key );
  return this._elementWithKey( src, key );
}

//

function _elementWithCardinal( src, cardinal )
{
  if( _.long.is( src ) || _.bufferNode.is( src ) )
  return _.long._elementWithCardinal( ... arguments );
  return _.itself._elementWithCardinal( ... arguments );
}

//

function _elementWithKeySet( dst, key, val )
{
  if( _.long.is( dst ) || _.bufferNode.is( dst ) )
  return _.long._elementWithKeySet( ... arguments );
  return _.itself._elementWithKeySet( ... arguments );
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{
  if( _.long.is( dst ) || _.bufferNode.is( dst ) )
  return _.long._elementWithCardinalSet( ... arguments );
  return _.itself._elementWithCardinalSet( ... arguments );
}

//

function _elementWithKeyDel( dst, key )
{
  throw _.err( `${this.TypeName} has fixed length` );
  return false;
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  throw _.err( `${this.TypeName} has fixed length` );
  return false;
}

// --
// declaration
// --

let BufferExtension =
{

  /* qqq : implement routines _.long has. discuss first */

  // equaler

  _identicalShallow,
  identicalShallow,
  identical : identicalShallow,
  _equivalentShallow,
  equivalentShallow,
  equivalent : equivalentShallow,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // inspector

  _lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */
  _hasKey,
  hasKey : _.props.hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal : _.props.hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal : _.props.keyWithCardinal, /* qqq : cover */

  // editor

  _empty,
  empty : _.props.elementWithKeyDel, /* qqq : for junior : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : _.props.elementGet, /* qqq : cover */
  _elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */

}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{

  // dichotomy

  constructorIsBuffer,

  // maker

  bufferCoerceFrom, /* qqq : cover. seems broken */

  // equaler

  buffersTypedAreEquivalent, /* qqq : cover pelase */
  buffersTypedAreIdentical, /* qqq : cover pelase */
  buffersRawAreIdentical,
  buffersViewAreIdentical,
  buffersNodeAreIdentical,
  buffersAreIdentical : identicalShallow,
  buffersIdenticalShallow : identicalShallow,
  buffersAreEquivalent : equivalentShallow,
  buffersEquivalentShallow : equivalentShallow,

}

/* qqq : split namespace of buffers. ask */
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Buffer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Buffer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Buffer_s */ })();

/* */  /* begin of file BuffersTyped_s */ ( function BuffersTyped_s() { function BuffersTyped_s_naked() { ( function _l1_BuffersTyped_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

function _functor( namespace )
{

  // --
  // declare
  // --

  let ToolsExtension =
  {
  }

  Object.assign( _, ToolsExtension );

  //

  let BufferTypedExtension =
  {

    // equaler

    _identicalShallow : _.long._identicalShallow,
    identicalShallow : _.long.identicalShallow,
    identical : _.long.identical,
    _equivalentShallow : _.long._equivalentShallow,
    equivalentShallow : _.long.equivalentShallow,
    equivalent : _.long.equivalent,

    // exporter

    _exportStringDiagnosticShallow : _.long._exportStringDiagnosticShallow,
    exportStringDiagnosticShallow : _.long.exportStringDiagnosticShallow,
    _exportStringCodeShallow : _.long._exportStringCodeShallow,
    exportStringCodeShallow : _.long.exportStringCodeShallow,
    exportString : _.long.exportString,

    // container interface

    _lengthOf : _.long._lengthOf,
    lengthOf : _.long.lengthOf, /* qqq : cover */

    _hasKey : _.long._hasKey,
    hasKey : _.long._hasKey, /* qqq : cover */
    _hasCardinal : _.long._hasKey,
    hasCardinal : _.long._hasKey, /* qqq : cover */
    _keyWithCardinal : _.long._hasKey,
    keyWithCardinal : _.long._hasKey, /* qqq : cover */
    _cardinalWithKey : _.long._cardinalWithKey,
    cardinalWithKey : _.long.cardinalWithKey, /* qqq : cover */

    _elementGet : _.long._elementWithKey,
    elementGet : _.long.elementWithKey, /* qqq : cover */
    _elementWithKey : _.long._elementWithKey,
    elementWithKey : _.long.elementWithKey, /* qqq : cover */
    _elementWithImplicit : _.long._elementWithImplicit,
    elementWithImplicit : _.long.elementWithImplicit,  /* qqq : cover */
    _elementWithCardinal : _.long._elementWithCardinal,
    elementWithCardinal : _.long.elementWithCardinal,  /* qqq : cover */

    _elementSet : _.long._elementSet,
    elementSet : _.long.elementSet, /* qqq : cover */
    _elementWithKeySet : _.long._elementWithKeySet,
    elementWithKeySet : _.long.elementWithKeySet, /* qqq : cover */
    _elementWithCardinalSet : _.long._elementWithCardinalSet,
    elementWithCardinalSet : _.long.elementWithCardinalSet,  /* qqq : cover */

    _elementAppend : _.argumentsArray._elementAppend,
    elementAppend : _.argumentsArray.elementAppend, /* qqq : cover */
    _elementPrepend : _.argumentsArray._elementPrepend,
    elementPrepend : _.argumentsArray.elementPrepend, /* qqq : cover */

    _elementDel : _.argumentsArray._elementDel,
    elementDel : _.argumentsArray.elementDel, /* qqq : cover */
    _elementWithKeyDel : _.argumentsArray._elementWithKeyDel,
    elementWithKeyDel : _.argumentsArray.elementWithKeyDel, /* qqq : cover */
    _elementWithCardinalDel : _.argumentsArray._elementWithCardinalDel,
    elementWithCardinalDel : _.argumentsArray.elementWithCardinalDel,  /* qqq : cover */
    _empty : _.argumentsArray._empty,
    empty : _.argumentsArray.empty, /* qqq : for junior : cover */

    _each : _.long._each,
    each : _.long.each, /* qqq : cover */
    _eachLeft : _.long._eachLeft,
    eachLeft : _.long.eachLeft, /* qqq : cover */
    _eachRight : _.long._eachRight,
    eachRight : _.long.eachRight, /* qqq : cover */

    _while : _.long._while,
    while : _.long.while, /* qqq : cover */
    _whileLeft : _.long._whileLeft,
    whileLeft : _.long.whileLeft, /* qqq : cover */
    _whileRight : _.long._whileRight,
    whileRight : _.long.whileRight, /* qqq : cover */

    _aptLeft : _.long._aptLeft,
    aptLeft : _.long.aptLeft, /* qqq : cover */
    first : _.long.first,
    _aptRight : _.long._aptRight, /* qqq : cover */
    aptRight : _.long.aptRight,
    last : _.long.last, /* qqq : cover */

    _filterAct : _.long._filterAct,
    filterWithoutEscapeLeft : _.long.filterWithoutEscapeLeft,
    filterWithoutEscapeRight : _.long.filterWithoutEscapeRight,
    filterWithoutEscape : _.long.filterWithoutEscape,
    filterWithEscapeLeft : _.long.filterWithEscapeLeft,
    filterWithEscapeRight : _.long.filterWithEscapeRight,
    filterWithEscape : _.long.filterWithEscape,
    filter : _.long.filter,

    _mapAct : _.long._mapAct,
    mapWithoutEscapeLeft : _.long.mapWithoutEscapeLeft,
    mapWithoutEscapeRight : _.long.mapWithoutEscapeRight,
    mapWithoutEscape : _.long.mapWithoutEscape,
    mapWithEscapeLeft : _.long.mapWithEscapeLeft,
    mapWithEscapeRight : _.long.mapWithEscapeRight,
    mapWithEscape : _.long.mapWithEscape,
    map : _.long.map,

  }

  //

  Object.assign( namespace, BufferTypedExtension );

}

_.assert( !!_.fx );
_.assert( !_.fx.filter );
_.assert( !_.fx.map );

for( let name in _.long.namespaces )
{
  let namespace = _.long.namespaces[ name ];
  if( namespace.IsTyped )
  _functor( namespace );
}

_.assert( !!_.fx.filter );
_.assert( !!_.fx.map );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/BuffersTyped.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BuffersTyped_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BuffersTyped_s */ })();

/* */  /* begin of file BufferTyped_s */ ( function BufferTyped_s() { function BufferTyped_s_naked() { ( function _l3_BufferTyped_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.long._aptLeft, 'Expects routine props._aptLeft' );
_.assert( !!_.long._elementWithKey, 'Expects routine long._elementWithKey' );

// --
// extension
// --

var BufferTypedExtension =
{

  // equaler

  _identicalShallow : _.long._identicalShallow,
  identicalShallow : _.long.identicalShallow,
  identical : _.long.identical,
  _equivalentShallow : _.long._equivalentShallow,
  equivalentShallow : _.long.equivalentShallow,
  equivalent : _.long.equivalent,

  // exporter

  _exportStringDiagnosticShallow : _.long._exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.long.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _.long._exportStringCodeShallow,
  exportStringCodeShallow : _.long.exportStringCodeShallow,
  exportString : _.long.exportString,

  // container interface

  _lengthOf : _.long._lengthOf,
  lengthOf : _.long.lengthOf, /* qqq : cover */

  _hasKey : _.long._hasKey,
  hasKey : _.long._hasKey, /* qqq : cover */
  _hasCardinal : _.long._hasKey,
  hasCardinal : _.long._hasKey, /* qqq : cover */
  _keyWithCardinal : _.long._hasKey,
  keyWithCardinal : _.long._hasKey, /* qqq : cover */
  _cardinalWithKey : _.long._cardinalWithKey,
  cardinalWithKey : _.long.cardinalWithKey, /* qqq : cover */

  _elementGet : _.long._elementWithKey,
  elementGet : _.long.elementWithKey, /* qqq : cover */
  _elementWithKey : _.long._elementWithKey,
  elementWithKey : _.long.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.long._elementWithImplicit,
  elementWithImplicit : _.long.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal : _.long._elementWithCardinal,
  elementWithCardinal : _.long.elementWithCardinal,  /* qqq : cover */

  _elementSet : _.long._elementSet,
  elementSet : _.long.elementSet, /* qqq : cover */
  _elementWithKeySet : _.long._elementWithKeySet,
  elementWithKeySet : _.long.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet : _.long._elementWithCardinalSet,
  elementWithCardinalSet : _.long.elementWithCardinalSet,  /* qqq : cover */

  _elementAppend : _.argumentsArray._elementAppend,
  elementAppend : _.argumentsArray.elementAppend, /* qqq : cover */
  _elementPrepend : _.argumentsArray._elementPrepend,
  elementPrepend : _.argumentsArray.elementPrepend, /* qqq : cover */

  _elementDel : _.argumentsArray._elementDel,
  elementDel : _.argumentsArray.elementDel, /* qqq : cover */
  _elementWithKeyDel : _.argumentsArray._elementWithKeyDel,
  elementWithKeyDel : _.argumentsArray.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel : _.argumentsArray._elementWithCardinalDel,
  elementWithCardinalDel : _.argumentsArray.elementWithCardinalDel,  /* qqq : cover */
  _empty : _.argumentsArray._empty,
  empty : _.argumentsArray.empty, /* qqq : for junior : cover */

  _each : _.long._each,
  each : _.long.each, /* qqq : cover */
  _eachLeft : _.long._eachLeft,
  eachLeft : _.long.eachLeft, /* qqq : cover */
  _eachRight : _.long._eachRight,
  eachRight : _.long.eachRight, /* qqq : cover */

  _while : _.long._while,
  while : _.long.while, /* qqq : cover */
  _whileLeft : _.long._whileLeft,
  whileLeft : _.long.whileLeft, /* qqq : cover */
  _whileRight : _.long._whileRight,
  whileRight : _.long.whileRight, /* qqq : cover */

  _aptLeft : _.long._aptLeft,
  aptLeft : _.long.aptLeft, /* qqq : cover */
  first : _.long.first,
  _aptRight : _.long._aptRight, /* qqq : cover */
  aptRight : _.long.aptRight,
  last : _.long.last, /* qqq : cover */

  _filterAct : _.long._filterAct,
  filterWithoutEscapeLeft : _.long.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.long.filterWithoutEscapeRight,
  filterWithoutEscape : _.long.filterWithoutEscape,
  filterWithEscapeLeft : _.long.filterWithEscapeLeft,
  filterWithEscapeRight : _.long.filterWithEscapeRight,
  filterWithEscape : _.long.filterWithEscape,
  filter : _.long.filter,

  _mapAct : _.long._mapAct,
  mapWithoutEscapeLeft : _.long.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.long.mapWithoutEscapeRight,
  mapWithoutEscape : _.long.mapWithoutEscape,
  mapWithEscapeLeft : _.long.mapWithEscapeLeft,
  mapWithEscapeRight : _.long.mapWithEscapeRight,
  mapWithEscape : _.long.mapWithEscape,
  map : _.long.map,

}

Object.assign( _.bufferTyped, BufferTypedExtension );

//

var ToolsExtension =
{
}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/BufferTyped.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BufferTyped_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BufferTyped_s */ })();

/* */  /* begin of file Container_s */ ( function Container_s() { function Container_s_naked() { ( function _l3_Container_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const _functor_functor = _.container._functor_functor;

// --
// exporter
// --

function _exportStringDiagnosticShallow( src, o )
{
  let result;
  let namespace = this.namespaceForExporting( src );

  if( namespace )
  result = namespace.exportStringDiagnosticShallow( src );
  else
  result = _.strShort_( String( src ) ).result;

  return result;
}

//

function exportStringDiagnosticShallow( src, o )
{
  let result;
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects 1 or 2 arguments' );
  _.assert( this.like( src ) );
  return this._exportStringDiagnosticShallow( ... arguments );
}

// --
// properties
// --

function keys( src )
{
  _.assert( arguments.length === 1 );
  return keys.functor.call( this, src )();
}

keys.functor = _functor_functor( 'keys' );

//

function vals( src )
{
  _.assert( arguments.length === 1 );
  return vals.functor.call( this, src )();
}

vals.functor = _functor_functor( 'vals' );

//

function pairs( src )
{
  _.assert( arguments.length === 1 );
  return pairs.functor.call( this, src )();
}

pairs.functor = _functor_functor( 'pairs' );

// --
// inspector
// --

function lengthOf( src ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 );
  return lengthOf.functor.call( this, src )();
}

lengthOf.functor = _functor_functor( 'lengthOf' );

//

function hasKey( src, ... args ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 2 );
  return hasKey.functor.call( this, src )( ... args );
}

hasKey.functor = _functor_functor( 'hasKey' );

//

function hasCardinal( src, ... args ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 2 );
  return hasCardinal.functor.call( this, src )( ... args );
}

hasCardinal.functor = _functor_functor( 'hasCardinal' );

//

function keyWithCardinal( src, ... args ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 2 );
  return keyWithCardinal.functor.call( this, src )( ... args );
}

keyWithCardinal.functor = _functor_functor( 'keyWithCardinal' );

//

function cardinalWithKey( src, ... args ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 2 );
  return cardinalWithKey.functor.call( this, src )( ... args );
}

cardinalWithKey.functor = _functor_functor( 'cardinalWithKey' );

// --
// editor
// --

// function empty( src ) /* qqq for junior : cover please */
// {
//   _.assert( arguments.length === 1 );
//   return empty.functor.call( this, src )();
// }
//
// empty.functor = _functor_functor( 'empty' );

//

/**
 * The routine elementWithCardinal() searches for value under a certain index {-key-} in a src {-src-}
 * and returns array with value, key, booLike.
 *
 * @param { Long|Set|HashMap|Aux } src - input src.
 * @param { Number } key - index to be looked in a src.
 *
 * @example
 * var src = { a : 1, b : 2 };
 * var got = _.src.elementWithCardinal( src, 0 );
 * console.log( got );
 * // log : [ 1, 'a', true ]
 *
 * @example
 * var src = [ 1, 2, 3 ];
 * var got = _.src.elementWithCardinal( src, 2 );
 * console.log( got );
 * // log : [ 3, 2, true ]
 *
 * @example
 * var src = new HashMap([ [ 'a', 1 ], [ true, false ], [ objRef, { a : 2 } ] ]);
 * var got = _.src.elementWithCardinal( src, 1 );
 * console.log( got )
 * // log : [ false, true, true ] );
 *
 * @example
 * var src = [ 1, 2, 3 ];
 * var got = _.src.elementWithCardinal( src, 5 );
 * console.log( got );
 * // log : [ undefined, 5, false ]
 *
 * @returns { Long } - with 3 elements : value ( undefined if index {-key-} is more or less than src's length ), key, boolLike ( true if index {-key-} is within src's length, false otherwise ).
 * @function elementWithCardinal
 * @throws { Error } If arguments.length is not equal to 2.
 * @throws { Error } If {-key-} is not Number.
 * @namespace Tools
 */

function elementWithCardinal( src, key ) /* qqq for junior : cover please | aaa : Done. */
{
  _.assert( arguments.length === 2 );
  _.assert( _.numberIs( key ) );
  if( !_.numberIs( key ) || key < 0 )
  return [ undefined, key, false ];
  return elementWithCardinal.functor.call( this, src )( key );
}

elementWithCardinal.functor = _functor_functor( 'elementWithCardinal' );

//

/**
 * The routine elementWithKey() searches for value under a certain {-key-} in a src {-src-}
 * and returns array with value, key, booLike.
 *
 * @param { Long|Set|HashMap|Aux } src - input src.
 * @param { * } key - key to be looked in a src.
 *
 * @example
 * var src = { a : 1, b : 2 };
 * var got = _.src.elementWithKey( src, 'a' );
 * console.log( got );
 * // log : [ 1, 'a', true ]
 *
 * @example
 * var src = [ 1, 2, 3 ];
 * var got = _.src.elementWithKey( src, 2 );
 * console.log( got );
 * // log : [ 3, 2, true ]
 *
 * @example
 * var src = new HashMap([ [ 'a', 1 ], [ true, false ], [ objRef, { a : 2 } ] ]);
 * var got = _.src.elementWithKey( src, true );
 * console.log( got )
 * // log : [ false, true, true ] );
 *
 * @example
 * var src = [ 1, 2, 3 ];
 * var got = _.src.elementWithKey( src, 5 );
 * console.log( got );
 * // log : [ undefined, 5, false ]
 *
 * @returns { Long } - with 3 elements : value ( undefined if key is absent ), key, boolLike ( true if key exists, false otherwise ).
 * @function elementWithKey
 * @throws { Error } If arguments.length is not equal to 2.
 * @namespace Tools
 */

function elementWithKey( src, key )
{
  _.assert( arguments.length === 2 );
  return elementWithKey.functor.call( this, src )( key );
}

elementWithKey.functor = _functor_functor( 'elementWithKey' );

//

function elementWithImplicit( src, key )
{
  _.assert( arguments.length === 2 );
  return elementWithImplicit.functor.call( this, src )( key );
}

elementWithImplicit.functor = _functor_functor( 'elementWithImplicit' );

//

function elementWithCardinalSet( src, key, val )
{
  _.assert( arguments.length === 3 );
  _.assert( _.numberIs( key ) );
  return elementWithCardinalSet.functor.call( this, src )( key, val );
}

elementWithCardinalSet.functor = _functor_functor( 'elementWithCardinalSet' );

//

function elementSet( src, key, val )
{
  _.assert( arguments.length === 3 );
  return elementSet.functor.call( this, src )( key, val );
}

elementSet.functor = _functor_functor( 'elementSet' );

// --
//
// --

function elementDel( src, key )
{
  _.assert( arguments.length === 2 );
  return elementDel.functor.call( this, src )( key );
}

elementDel.functor = _functor_functor( 'elementDel' );

//

function elementWithKeyDel( src, key )
{
  _.assert( arguments.length === 2 );
  return elementWithKeyDel.functor.call( this, src )( key );
}

elementWithKeyDel.functor = _functor_functor( 'elementWithKeyDel' );

//

function elementWithCardinalDel( src, key )
{
  _.assert( arguments.length === 2 );
  return elementWithCardinalDel.functor.call( this, src )( key );
}

elementWithCardinalDel.functor = _functor_functor( 'elementWithCardinalDel' );

//

/**
 * The routine empty() clears provided container {-dstContainer-}.
 *
 * @param { Long|Set|HashMap|Aux } dstContainer - Container to be cleared. {-dstContainer-} should be resizable.
 *
 * @example
 * let dst = [];
 * let got = _.src.empty( dst );
 * console.log( got );
 * // log []
 * console.log( got === dst );
 * log true
 *
 * @example
 * let dst = [ 1, 'str', { a : 2 } ];
 * let got = _.src.empty( dst );
 * console.log( got );
 * // log []
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let dst = _.unroll.make( [ 1, 'str', { a : 2 } ] );
 * let got = _.src.empty( dst );
 * console.log( got );
 * // log []
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let dst = new Set( [ 1, 'str', { a : 2 } ] );
 * let got = _.src.empty( dst );
 * console.log( got );
 * // log Set {}
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let dst = new HashMap( [ [ 1, 'str' ], [ 'a', null ] ] );
 * let got = _.src.empty( dst );
 * console.log( got );
 * // log Map {}
 * console.log( got === dst );
 * // log true
 *
 * @returns { Long|Set|HashMap|Aux } - Returns a empty {-dstContainer-}.
 * @function empty
 * @throws { Error } If arguments.length is less than one.
 * @throws { Error } If {-dstContainer-} is not a Long, not a Set, not a HashMap, not a Aux.
 * @throws { Error } If {-dstContainer-} is not a resizable Long, or if it is a WeakSet or WeakMap.
 * @namespace Tools
 */

function empty( src )
{
  _.assert( arguments.length === 1 );
  return empty.functor.call( this, src )();
}

empty.functor = _functor_functor( 'empty' );

  // elementDel, /* qqq : cover */
  // elementWithKeyDel, /* qqq : cover */
  // elementWithCardinalDel,  /* qqq : cover */
  // empty, /* qqq : for junior : cover */

// --
// iterator
// --

function eachLeft( src, onEach )
{
  _.assert( arguments.length === 2 );
  return eachLeft.functor.call( this, src )( onEach );
}

eachLeft.functor = _functor_functor( 'eachLeft' );

//

function eachRight( src, onEach )
{
  _.assert( arguments.length === 2 );
  return eachRight.functor.call( this, src )( onEach );
}

eachRight.functor = _functor_functor( 'eachRight' );

//

function whileLeft( src, onEach )
{
  _.assert( arguments.length === 2 );
  return whileLeft.functor.call( this, src )( onEach );
}

whileLeft.functor = _functor_functor( 'whileLeft' );

//

function whileRight( src, onEach )
{
  _.assert( arguments.length === 2 );
  return whileRight.functor.call( this, src )( onEach );
}

whileRight.functor = _functor_functor( 'whileRight' );

//

function aptLeft( src, onEach )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return aptLeft.functor.call( this, src )( onEach );
}

aptLeft.functor = _functor_functor( 'aptLeft' );

//

function aptRight( src, onEach )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return aptRight.functor.call( this, src )( onEach );
}

aptRight.functor = _functor_functor( 'aptRight' );

//

function filterWithoutEscapeLeft( dst, src, ... args )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  return filterWithoutEscapeLeft.functor.call( this, src )( dst, ... args );
}

filterWithoutEscapeLeft.functor = _functor_functor( 'filterWithoutEscapeLeft', null, 1 );

//

function filterWithoutEscapeRight( dst, src, ... args )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  return filterWithoutEscapeRight.functor.call( this, src )( dst, ... args );
}

filterWithoutEscapeRight.functor = _functor_functor( 'filterWithoutEscapeRight', null, 1 );

//

function filterWithEscapeLeft( dst, src, ... args )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  return filterWithEscapeLeft.functor.call( this, src )( dst, ... args );
}

filterWithEscapeLeft.functor = _functor_functor( 'filterWithEscapeLeft', null, 1 );

//

function filterWithEscapeRight( dst, src, ... args )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  return filterWithEscapeRight.functor.call( this, src )( dst, ... args );
}

filterWithEscapeRight.functor = _functor_functor( 'filterWithEscapeRight', null, 1 );

//

function mapWithoutEscapeLeft( dst, src, ... args )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  return mapWithoutEscapeLeft.functor.call( this, src )( dst, ... args );
}

mapWithoutEscapeLeft.functor = _functor_functor( 'mapWithoutEscapeLeft', null, 1 );

//

function mapWithoutEscapeRight( dst, src, ... args )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  return mapWithoutEscapeRight.functor.call( this, src )( dst, ... args );
}

mapWithoutEscapeRight.functor = _functor_functor( 'mapWithoutEscapeRight', null, 1 );

//

function mapWithEscapeLeft( dst, src, ... args )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  return mapWithEscapeLeft.functor.call( this, src )( dst, ... args );
}

mapWithEscapeLeft.functor = _functor_functor( 'mapWithEscapeLeft', null, 1 );

//

function mapWithEscapeRight( dst, src, ... args )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  return mapWithEscapeRight.functor.call( this, src )( dst, ... args );
}

mapWithEscapeRight.functor = _functor_functor( 'mapWithEscapeRight', null, 1 );

// --
// extension
// --

let ContainerExtension =
{

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : exportStringDiagnosticShallow,
  exportString : exportStringDiagnosticShallow,

  // properties

  /* xxx : review */
  keys,
  vals,
  pairs,

  // inspector

  lengthOf, /* qqq : cover */
  hasKey, /* qqq : cover */
  hasCardinal, /* qqq : cover */
  keyWithCardinal, /* qqq : cover */
  cardinalWithKey, /* qqq : cover */

  // editor

  // empty, /* qqq : cover */

  // elementor

  elementWithCardinal, /* qqq : cover */
  elementWithKey, /* qqq : cover */
  elementWithImplicit, /* qqq : cover */
  elementWithCardinalSet, /* qqq : cover */
  elementSet, /* qqq : cover */

  elementDel, /* qqq : cover */
  elementWithKeyDel, /* qqq : cover */
  elementWithCardinalDel,  /* qqq : cover */
  empty, /* qqq : for junior : cover */

  // iterator

  each : eachLeft, /* qqq : cover */
  eachLeft, /* qqq : cover */
  eachRight, /* qqq : cover */

  while : whileLeft, /* qqq : cover */
  whileLeft, /* qqq : cover */
  whileRight, /* qqq : cover */

  aptLeft, /* qqq : cover */
  first : aptLeft, /* qqq : cover */
  aptRight, /* qqq : cover */
  last : aptRight, /* qqq : cover */

  filterWithoutEscapeLeft,
  filterWithoutEscapeRight,
  filterWithoutEscape : filterWithoutEscapeLeft,
  filterWithEscapeLeft,
  filterWithEscapeRight,
  filterWithEscape : filterWithEscapeLeft,
  filter : filterWithoutEscapeLeft,

  mapWithoutEscapeLeft,
  mapWithoutEscapeRight,
  mapWithoutEscape : mapWithoutEscapeLeft,
  mapWithEscapeLeft,
  mapWithEscapeRight,
  mapWithEscape : mapWithEscapeLeft,
  map : mapWithoutEscapeLeft,

  // map,
  // filter,

}

Object.assign( _.container, ContainerExtension );

//

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Container.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Container_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Container_s */ })();

/* */  /* begin of file ContainerAdapter_s */ ( function ContainerAdapter_s() { function ContainerAdapter_s_naked() { ( function _l3_ContainerAdapter_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// exporter
// --



// --
// container adapter extension
// --

let ContainerAdapterExtension =
{

}

Object.assign( _.containerAdapter, ContainerAdapterExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/ContainerAdapter.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ContainerAdapter_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ContainerAdapter_s */ })();

/* */  /* begin of file Countable_s */ ( function Countable_s() { function Countable_s_naked() { ( function _l3_Countable_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

function _identicalShallow( src1, src2 )
{

  if( Object.prototype.toString.call( src1 ) !== Object.prototype.toString.call( src2 ) )
  return false;
  if( !_.countable.is( src1 ) )
  return false;
  if( !_.countable.is( src2 ) )
  return false;

  if( _.longIs( src1 ) )
  {
    return _.long.identicalShallow( src1, src2 );
  }
  else
  {
    /*
      entity with method iterator,
      entity with method iterator and length
    */

    let array1 = [ ... src1 ];
    for( let val of src2 )
    if( array1.indexOf( val ) === -1 )
    return false

    return true;
  }

}

//

function _equivalentShallow( src1, src2 )
{
  let result = true;

  if( _.longIs( src1 ) && _.longIs( src2 ) )
  {
    return _.long.equivalentShallow( src1, src2 );
  }
  else
  {
    /*
      entity with method iterator,
      entity with method iterator and length
    */

    /* don't create new array if one of arguments is array */
    if( _.argumentsArray.like( src1 ) )
    {
      result = check( src2, src1 );
    }
    else if( _.argumentsArray.like( src2 ) )
    {
      result = check( src1, src2 );
    }
    else
    {
      let array1 = [ ... src1 ];
      result = check( src2, array1 );
    }

    return result;
  }

  /* - */

  function check( arrayLoop, arrayCheck )
  {
    for( let val of arrayLoop )
    if( Array.prototype.indexOf.call( arrayCheck, val ) === -1 )
    return false
    return true;
  }
}

// --
// exporter
// --

function _exportStringDiagnosticShallow( src, o )
{
  if( _.unroll.is( src ) )
  return `{- ${_.entity.strType( src )}.unroll with ${this._lengthOf( src )} elements -}`;
  return `{- ${_.entity.strType( src )} with ${this._lengthOf( src )} elements -}`;
}

// --
// container interface
// --

function _lengthOf( src )
{
  if( _.vector.is( src ) )
  return src.length;
  return [ ... src ].length;
}

//

function _hasKey( src, key )
{
  if( key < 0 )
  return false;
  return key < this._lengthOf( src );
}

//

function _hasCardinal( src, cardinal )
{
  if( cardinal < 0 )
  return false;
  return cardinal < this._lengthOf( src );
}

//

function _keyWithCardinal( src, cardinal )
{
  if( cardinal < 0 || this._lengthOf( src ) <= cardinal )
  return [ undefined, false ];
  return [ cardinal, true ];
}

//

function _cardinalWithKey( src, key )
{
  if( key < 0 || this._lengthOf( src ) <= key )
  return -1;
  return key;
}

//

function _elementWithKey( src, key )
{

  if( _.long.is( src ) )
  return _.long._elementWithKey( ... arguments );

  if( _.number.is( key ) )
  {
    if( key < 0 )
    return [ undefined, key, false ];
    debugger;
    const src2 = [ ... src ];
    if( src2.length <= key )
    return [ undefined, key, false ];
    else
    return [ src2[ key ], key, true ];
  }
  else
  {
    return [ undefined, key, false ];
  }
}

//

function _elementWithCardinal( src, cardinal )
{

  if( _.long.is( src ) )
  return _.long._elementWithCardinal( ... arguments );

  if( !_.number.is( cardinal ) || cardinal < 0 )
  return [ undefined, cardinal, false ];
  const src2 = [ ... src ];
  if( src2.length <= cardinal )
  return [ undefined, cardinal, false ];
  else
  return [ src2[ cardinal ], cardinal, true ];
}

//

function _elementWithKeySet( dst, key, val )
{

  if( _.long.is( dst ) )
  return _.long._elementWithKeySet( ... arguments );

  if( !_.number.is( key ) || key < 0 )
  return [ key, false ];
  // const dst2 = [ ... dst ];
  // if( dst2.length <= key )
  // return [ key, false ];
  const length = this._lengthOf( dst );
  if( length <= key )
  return [ key, false ];

  let elementWithKeySet = _.class.methodElementWithKeySetOf( dst );
  if( elementWithKeySet )
  return elementWithKeySet.call( dst, key, val );

  let elementSet = _.class.methodElementSetOf( dst );
  if( elementSet )
  return [ elementSet.call( dst, key, val ), key, true ];

  _.assert( 0, 'Countable does not have implemented neither method "elementWithKeySet" nor method "eSet"' );
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{

  if( _.long.is( dst ) )
  return _.long._elementWithCardinalSet( ... arguments );

  if( !_.number.is( cardinal ) || cardinal < 0 )
  return [ cardinal, false ];
  // const dst2 = [ ... dst ];
  // if( dst2.length <= cardinal )
  const length = this._lengthOf( dst );
  if( length <= cardinal )
  return [ cardinal, false ];

  let was = this._elementWithCardinal( dst, cardinal );
  if( was[ 2 ] )
  this._elementWithKeySet( dst, was[ 1 ], val );
  return [ cardinal, false ];
}

//

function _elementWithKeyDel( dst, key )
{
  if( _.array.is( dst ) )
  return _.array._elementWithKeyDel( dst, key );
  _.assert( 0, 'Countable does not have implemented method "_elementWithKeyDel"' );
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  if( _.array.is( dst ) )
  return _.array._elementWithCardinalDel( dst, cardinal );
  _.assert( 0, 'Countable does not have implemented method "_elementWithCardinalDel"' );
}

//

function _empty( dst )
{
  if( _.array.is( dst ) )
  return _.array._empty( dst );
  _.assert( 0, 'Countable does not have implemented method "_empty"' );
}

//

function _elementAppend( dst, val )
{
  if( _.array.is( dst ) )
  {
    dst.push( val );
    return dst.length-1;
  }
  _.assert( 0, 'Countable does not have implemented method "_elementAppend"' );
}

//

function _elementPrepend( dst, val )
{
  if( _.array.is( dst ) )
  {
    dst.unshift( val );
    return 0;
  }
  _.assert( 0, 'Countable does not have implemented method "_elementPrepend"' );
}

//

function _eachLeft( src, onEach )
{
  let k = 0;
  for( let val of src )
  {
    onEach( val, k, k, src );
    k += 1;
  }
}

//

function _eachRight( src, onEach )
{
  let src2 = [ ... src ];
  for( let k = src2.length-1 ; k >= 0 ; k-- )
  {
    let val = src2[ k ];
    onEach( val, k, k, src );
  }
}

//

function _whileLeft( src, onEach )
{
  let k = 0;
  let laste;
  for( let val of src )
  {
    let r = onEach( val, k, k, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ val, k, false ];
    laste = val;
    k += 1;
  }
  if( k > 0 )
  return [ laste, k-1, k-1, true ];
  else
  return [ undefined, k-1, k-1, true ];
}

//

function _whileRight( src, onEach )
{
  let src2 = [ ... src ];
  for( let k = src2.length-1 ; k >= 0 ; k-- )
  {
    let val = src2[ k ];
    let r = onEach( val, k, k, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ val, k, k, false ];
  }
  if( src2.length > 0 )
  return [ src2[ 0 ], 0, 0, true ];
  else
  return [ undefined, -1, -1, true ];
}

//

function _filterAct()
{
  let self = this;
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];

  if( _.longIs( src ) )
  return _.long._filterAct( ... arguments );
  return _.props._filterAct.call( self, ... arguments );
}

//

function _mapAct()
{
  let self = this;
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];

  if( _.longIs( src ) )
  return _.long._mapAct( ... arguments );
  return _.props._mapAct.call( self, ... arguments );
}

// --
// extension
// --

var ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

var CountableExtension =
{

  // equaler

  _identicalShallow,
  identicalShallow : _.props.identicalShallow,
  identical : _.props.identical,
  _equivalentShallow,
  equivalentShallow : _.props.equivalentShallow,
  equivalent : _.props.equivalent,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // inspector

  _lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */
  _hasKey,
  hasKey : _.props.hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal : _.props.hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal : _.props.keyWithCardinal, /* qqq : cover */
  _cardinalWithKey,
  cardinalWithKey : _.props.cardinalWithKey, /* qqq : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : _.props.elementGet, /* qqq : cover */
  _elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.props._elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty : _.props.empty, /* qqq : for junior : cover */

  _elementAppend,
  elementAppend : _.long.elementAppend, /* qqq : cover */
  _elementPrepend,
  elementPrepend : _.long.elementPrepend, /* qqq : cover */

  // iterator

  _each : _eachLeft,
  each : _.props.each, /* qqq : cover */
  _eachLeft,
  eachLeft : _.props.eachLeft, /* qqq : cover */
  _eachRight,
  eachRight : _.props.eachRight, /* qqq : cover */

  _while : _whileLeft,
  while : _.props.while, /* qqq : cover */
  _whileLeft,
  whileLeft : _.props.whileLeft, /* qqq : cover */
  _whileRight,
  whileRight : _.props.whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct : _.long._filterAct,
  filterWithoutEscapeLeft : _.long.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.long.filterWithoutEscapeRight,
  filterWithoutEscape : _.long.filterWithoutEscape,
  filterWithEscapeLeft : _.long.filterWithEscapeLeft,
  filterWithEscapeRight : _.long.filterWithEscapeRight,
  filterWithEscape : _.long.filterWithEscape,
  filter : _.long.filter,

  _mapAct : _.long._mapAct,
  mapWithoutEscapeLeft : _.long.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.long.mapWithoutEscapeRight,
  mapWithoutEscape : _.long.mapWithoutEscape,
  mapWithEscapeLeft : _.long.mapWithEscapeLeft,
  mapWithEscapeRight : _.long.mapWithEscapeRight,
  mapWithEscape : _.long.mapWithEscape,
  map : _.long.map,

  // _filterAct0 : _.props._filterAct0,
  // _filterAct,
  // filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  // filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  // filterWithoutEscape : _.props.filterWithoutEscape,
  // filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  // filterWithEscapeRight : _.props.filterWithEscapeRight,
  // filterWithEscape : _.props.filterWithEscape,
  // filter : _.props.filter,
  //
  // _mapAct0 : _.props._mapAct0,
  // _mapAct,
  // mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  // mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  // mapWithoutEscape : _.props.mapWithoutEscape,
  // mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  // mapWithEscapeRight : _.props.mapWithEscapeRight,
  // mapWithEscape : _.props.mapWithEscape,
  // map : _.props.map,

}

Object.assign( _.countable, CountableExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Countable.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Countable_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Countable_s */ })();

/* */  /* begin of file Diagnostic_s */ ( function Diagnostic_s() { function Diagnostic_s_naked() { ( function _l3_Diagnostic_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --
//

function objectMake( o )
{
  let result;

  _.assert( arguments.length === 1 );

  o = optionsAdjust( o )

  let originalOptions = o;
  let constructor = o.pure ? countableConstructorPure : countableConstructorPolluted;

  result = _make( o );

  return result;

  /* - */

  function _make( o )
  {
    let result;
    if( o.new )
    {
      if( o.pure )
      result = new countableConstructorPure( o );
      else
      result = new countableConstructorPolluted( o );
    }
    else
    {
      result = _objectMake( null, o );
    }
    return result;
  }

  /* - */

  function optionsAdjust( o )
  {
    _.aux.supplement( o, objectMake.defaults );

    if( o.countable === null )
    o.countable = true;
    if( o.vector === null )
    o.vector = _.number.is( o.length ) ? true : false;

    countableConstructorPure.prototype = Object.create( null );

    let constructor = o.pure ? countableConstructorPure : countableConstructorPolluted;

    if( o.withConstructor )
    {
      countableConstructorPure.prototype.constructor = countableConstructorPure;
      _.assert( countableConstructorPolluted.prototype.constructor === countableConstructorPolluted );
    }
    else
    {
      delete countableConstructorPolluted.prototype.constructor;
    }

    _.assert( countableConstructorPolluted.prototype !== Object.prototype );
    _.assert( countableConstructorPolluted.prototype !== Function.prototype );

    if( o.countable )
    if( o.elements === undefined || o.elements === null )
    o.elements = [];

    if( o.vector && o.length === undefined )
    {
      _.assert( _.long.is( o.elements ) );
      o.length = o.elements.length;
    }

    _.assert( !o.vector || !!o.countable );
    _.assert( !!o.vector === !!_.number.is( o.length ) );

    return o;
  }

  /* */

  function optionsMake( o )
  {
    o = o || Object.create( null );
    return _.props.extend( o, { countable : originalOptions.countable, vector : originalOptions.vector } );
  }

  /* */

  function TypeNameGet()
  {
    return 'Custom1';
  }

  /* */

  function* _iterateGenerator()
  {
    yield 1;
    yield 2;
    yield 3;
  }

  /* */

  function _iterate()
  {

    let iterator = Object.create( null );
    iterator.next = next;
    iterator.index = 0;
    iterator.instance = this;
    return iterator;

    function next()
    {
      let result = Object.create( null );
      result.done = this.index === this.instance.elements.length;
      if( result.done )
      return result;
      result.value = this.instance.elements[ this.index ];
      this.index += 1;
      return result;
    }

  }

  /* */

  function countableConstructorPure( o )
  {
    if( _.long.is( o ) )
    o = optionsAdjust( optionsMake({ elements : o }) );
    else if( !o )
    o = optionsAdjust( optionsMake() );
    return _objectMake( this, o );
  }

  /* */

  function countableConstructorPolluted( o )
  {
    if( _.long.is( o ) )
    o = optionsAdjust( optionsMake({ elements : o }) );
    else if( !o )
    o = optionsAdjust( optionsMake() );
    let result = _objectMake( this, o );
    if( !o.withConstructor )
    {
      _.assert( Object.getPrototypeOf( result ) !== Object.prototype );
      // delete Object.getPrototypeOf( result ).constructor;
      _.assert( Object.getPrototypeOf( result ).constructor === Object.prototype.constructor );
    }
    return result
  }

  /* */

  function _objectMake( dst, o )
  {
    if( dst === null )
    if( o.pure )
    dst = Object.create( null );
    else
    dst = {};
    _.props.extend( dst, o );

    if( o.countable )
    {
      if( o.iteratorIsGenerator )
      dst[ Symbol.iterator ] = _iterateGenerator;
      else
      dst[ Symbol.iterator ] = _iterate;
    }

    if( o.withOwnConstructor )
    dst.constructor = constructor;
    // dst.constructor = function ownConstructor(){}

    if( !o.basic )
    {
      Object.defineProperty( constructor.prototype, Symbol.toStringTag,
      {
        enumerable : false,
        configurable : false,
        get : TypeNameGet,
      });
    }

    Object.defineProperty( dst, 'makeUndefined',
    {
      enumerable : false,
      configurable : true,
      writable : true,
      value : makeUndefined,
    });

    Object.defineProperty( dst, 'eSet',
    {
      enumerable : false,
      configurable : true,
      writable : true,
      value : eSet,
    });

    return dst;
  }

  /* */

  function eSet( key, val )
  {
    _.assert( arguments.length === 2 );
    _.assert( _.number.is( key ) );
    this.elements[ key ] = val;
  }

  /* */

  function makeUndefined()
  {
    debugger;
    if( _.object.is( this ) )
    {
      let o2 = optionsMake();
      if( o2.elements === null || o2.elements === undefined )
      {
        if( _.number.is( this.length ) )
        o2.elements = new Array( this.elements.length );
        if( this.elements && _.number.is( this.elements.length ) )
        o2.elements = new Array( this.elements.length );
      }
      optionsAdjust( o2 );
      // return new this.constructor( o2 );
      return _make( o2 );
    }
    _.assert( 0 );
  }

  /* */

}

objectMake.defaults =
{
  new : 1,
  pure : 0,
  basic : 1,
  countable : null,
  iteratorIsGenerator : 0,
  vector : null,
  withOwnConstructor : 0,
  withConstructor : 1,
  elements : null,
}

// --
// declare
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

//

let DiagnosticExtension =
{

  objectMake,
  /* qqq : for junior : use _.diagnostic.objectMake() in all tests */

}

Object.assign( _.diagnostic, DiagnosticExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Diagnostic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Diagnostic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Diagnostic_s */ })();

/* */  /* begin of file Entity_s */ ( function Entity_s() { function Entity_s_naked() { ( function _l3_Entity_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const _functor_functor = _.container._functor_functor;

_.entity = _.entity || Object.create( null );

_.assert( !!_.container.cloneShallow, 'Expects routine _.container.cloneShallow' );

// --
//
// --

function identicalShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( Object.prototype.toString.call( src1 ) !== Object.prototype.toString.call( src2 ) )
  return false;

  if( src1 === src2 )
  return true;

  if( _.hashMap.like( src1 ) )
  {
    /*
      - hashMap
    */
    return _.hashMap.identicalShallow( src1, src2 )
  }
  else if( _.set.like( src1 ) )
  {
    /*
      - set
    */
    return _.set.identicalShallow( src1, src2 );
  }
  else if( _.bufferAnyIs( src1 ) )
  {
    /*
      - BufferNode
      - BufferRaw
      - BufferRawShared
      - BufferTyped
      - BufferView
      - BufferBytes
    */
    return _.buffersIdenticalShallow( src1, src2 );
  }
  else if( _.countable.is( src1 ) )
  {
    /*
      - countable
      - vector
      - long
      - array
    */
    return _.countable.identicalShallow( src1, src2 );
  }
  else if( _.object.like( src1 ) )
  {
    /*
      - objectLike
      - object

      - Map
      - Auxiliary
      - MapPure
      - MapPolluted
      - AuxiliaryPolluted
      - MapPrototyped
      - AuxiliaryPrototyped
    */
    if( _.date.is( src1 ) )
    {
      return _.date.identicalShallow( src1, src2 );
    }
    else if( _.regexp.is( src1 ) )
    {
      return _.regexp.identicalShallow( src1, src2 );
    }
    else if( _.aux.is( src1 ) )
    {
      return _.aux.identicalShallow( src1, src2 );
    }

    /* non-identical objects */
    return false;
  }
  else if( _.primitiveIs( src1 ) )
  {
    /*
      - Symbol
      - Number
      - BigInt
      - Boolean
      - String
    */

    return _.primitive.identicalShallow( src1, src2 );
  }
  else
  {
    return false;
  }
}

//

function equivalentShallow( src1, src2, options )
{
  /*
    - boolLikeTrue and boolLikeTrue - ( true, 1 )
    - boolLikeFalse and boolLikeFalse - ( false, 0 )
    - | number1 - number2 | <= accuracy
    - strings that differ only in whitespaces at the start and/or at the end
    - regexp with same source and different flags
    - countable with the same length and content
  */
  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects 2 or 3 arguments' );
  _.assert( options === undefined || _.objectLike( options ), 'Expects map of options as third argument' );

  let accuracy;

  if( options )
  accuracy = options.accuracy || undefined;

  if( _.primitiveIs( src1 ) && _.primitiveIs( src2 ) ) /* check before type comparison ( 10n & 10 and 1 & true are equivalent ) */
  {
    /*
      - Symbol
      - Number
      - BigInt
      - Boolean
      - String
    */
    return _.primitive.equivalentShallow( src1, src2, accuracy );
  }

  if( src1 === src2 )
  return true;

  if( _.bufferAnyIs( src1 ) && _.bufferAnyIs( src2 ) )
  {
    /*
      - BufferNode
      - BufferRaw
      - BufferRawShared
      - BufferTyped
      - BufferView
      - BufferBytes
    */
    return _.buffersEquivalentShallow( src1, src2 );
  }
  else if( _.hashMap.like( src1 ) && _.hashMap.like( src1 ) )
  {
    /*
      - hashMap
    */
    return _.hashMap.equivalentShallow( src1, src2 )
  }
  else if( _.set.like( src1 ) && _.set.like( src2 ) )
  {
    /*
      - set
    */
    return _.set.equivalentShallow( src1, src2 );
  }
  else if( _.countable.is( src1 ) && _.countable.is( src2 ) )
  {
    /*
      - countable
      - vector
      - long
      - array
    */
    return _.countable.equivalentShallow( src1, src2 );
  }

  if( Object.prototype.toString.call( src1 ) !== Object.prototype.toString.call( src2 ) )
  return false;

  if( _.object.like( src1 ) )
  {
    /*
      - objectLike
      - object

      - Map
      - Auxiliary
      - MapPure
      - MapPolluted
      - AuxiliaryPolluted
      - MapPrototyped
      - AuxiliaryPrototyped
    */
    if( _.date.is( src1 ) )
    {
      return _.date.equivalentShallow( src1, src2 );
    }
    else if( _.regexp.is( src1 ) )
    {
      return _.regexp.equivalentShallow( src1, src2 );
    }
    else if( _.aux.is( src1 ) )
    {
      return _.aux.equivalentShallow( src1, src2 );
    }

    /* non-identical objects */
    return false;
  }
  else
  {
    return false;
  }
}

//

/**
 * The routine equal() checks equality of two entities {-src1-} and {-src2-}.
 * Routine accepts callbacks {-onEvaluate1-} and {-onEvaluate2-}, which apply to
 * entities {-src1-} and {-src2-}. The values returned by callbacks are compared with each other.
 * If callbacks is not passed, then routine compares {-src1-} and {-src2-} directly.
 *
 * @param { * } src1 - First entity to compare.
 * @param { * } src2 - Second entity to compare.
 * @param { Function } onEvaluate - It's a callback. If the routine has two parameters,
 * it is used as an equalizer, and if it has only one, then routine is used as the evaluator.
 * @param { Function } onEvaluate2 - The second part of evaluator. Accepts the {-src2-} to search.
 *
 * @example
 * _.entity.equal( 1, 1 );
 * // returns true
 *
 * @example
 * _.entity.equal( 1, 'str' );
 * // returns false
 *
 * @example
 * _.entity.equal( [ 1, 2, 3 ], [ 1, 2, 3 ] );
 * // returns false
 *
 * @example
 * _.entity.equal( [ 1, 2, 3 ], [ 1, 2, 3 ], ( e ) => e[ 0 ] );
 * // returns true
 *
 * @example
 * _.entity.equal( [ 1, 2, 3 ], [ 1, 2, 3 ], ( e1, e2 ) => e1[ 0 ] > e2[ 2 ] );
 * // returns false
 *
 * @example
 * _.entity.equal( [ 1, 2, 3 ], [ 1, 2, 3 ], ( e1 ) => e1[ 2 ], ( e2 ) => e2[ 2 ] );
 * // returns true
 *
 * @returns { Boolean } - Returns boolean value of equality of two entities.
 * @function equal
 * @throws { Error } If arguments.length is less then two or more then four.
 * @throws { Error } If {-onEvaluate1-} is not a routine.
 * @throws { Error } If {-onEvaluate1-} is undefines and onEvaluate2 provided.
 * @throws { Error } If {-onEvaluate1-} is evaluator and accepts less or more then one parameter.
 * @throws { Error } If {-onEvaluate1-} is equalizer and onEvaluate2 provided.
 * @throws { Error } If {-onEvaluate2-} is not a routine.
 * @throws { Error } If {-onEvaluate2-} accepts less or more then one parameter.
 * @namespace Tools.entity
 */

function equal( /* src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let src1 = arguments[ 0 ];
  let src2 = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );

  if( !onEvaluate1 )
  {
    _.assert( !onEvaluate2 );
    return Object.is( src1, src2 );
  }
  else if( onEvaluate1.length === 2 ) /* equalizer */
  {
    _.assert( !onEvaluate2 );
    return onEvaluate1( src1, src2 );
  }
  else /* evaluator */
  {
    if( !onEvaluate2 )
    onEvaluate2 = onEvaluate1;
    _.assert( onEvaluate1.length === 1 );
    _.assert( onEvaluate2.length === 1 );
    return onEvaluate1( src1 ) === onEvaluate2( src2 );
  }

}

// --
// maker
// --

// function cloneShallow( container ) /* qqq for junior : cover please */
// {
//   _.assert( arguments.length === 1 );
//   return cloneShallow.functor.call( this, container )();
// }
//
// cloneShallow.functor = _functor_functor( 'cloneShallow' );
//
// //
//
// function make( container, ... args ) /* qqq for junior : cover please */
// {
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   return make.functor.call( this, container )( ... args );
// }
//
// make.functor = _functor_functor( 'make' );
//
// //
//
// function makeEmpty( container ) /* qqq for junior : cover please */
// {
//   _.assert( arguments.length === 1 );
//   return makeEmpty.functor.call( this, container )();
// }
//
// makeEmpty.functor = _functor_functor( 'makeEmpty' );
//
// //
//
// function makeUndefined( container, ... args ) /* qqq for junior : cover please */
// {
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   return makeUndefined.functor.call( this, container )( ... args );
// }
//
// makeUndefined.functor = _functor_functor( 'makeUndefined' );
//
// // --
// // editor
// // --
//
// /**
//  * The routine empty() clears provided container {-dstContainer-}.
//  *
//  * @param { Long|Set|HashMap|Aux } dstContainer - Container to be cleared. {-dstContainer-} should be resizable.
//  *
//  * @example
//  * let dst = [];
//  * let got = _.container.empty( dst );
//  * console.log( got );
//  * // log []
//  * console.log( got === dst );
//  * log true
//  *
//  * @example
//  * let dst = [ 1, 'str', { a : 2 } ];
//  * let got = _.container.empty( dst );
//  * console.log( got );
//  * // log []
//  * console.log( got === dst );
//  * // log true
//  *
//  * @example
//  * let dst = _.unroll.make( [ 1, 'str', { a : 2 } ] );
//  * let got = _.container.empty( dst );
//  * console.log( got );
//  * // log []
//  * console.log( got === dst );
//  * // log true
//  *
//  * @example
//  * let dst = new Set( [ 1, 'str', { a : 2 } ] );
//  * let got = _.container.empty( dst );
//  * console.log( got );
//  * // log Set {}
//  * console.log( got === dst );
//  * // log true
//  *
//  * @example
//  * let dst = new HashMap( [ [ 1, 'str' ], [ 'a', null ] ] );
//  * let got = _.container.empty( dst );
//  * console.log( got );
//  * // log Map {}
//  * console.log( got === dst );
//  * // log true
//  *
//  * @returns { Long|Set|HashMap|Aux } - Returns a empty {-dstContainer-}.
//  * @function empty
//  * @throws { Error } If arguments.length is less than one.
//  * @throws { Error } If {-dstContainer-} is not a Long, not a Set, not a HashMap, not a Aux.
//  * @throws { Error } If {-dstContainer-} is not a resizable Long, or if it is a WeakSet or WeakMap.
//  * @namespace Tools
//  */
//
// function empty( container ) /* qqq for junior : cover please */
// {
//   _.assert( arguments.length === 1 );
//   return empty.functor.call( this, container )();
// }
//
// empty.functor = _functor_functor( 'empty' );

// --
// inspector
// --

/**
 * Returns "length" of entity( src ). Representation of "length" depends on type of( src ):
 *  - For object returns number of it own enumerable properties;
 *  - For array or array-like object returns value of length property;
 *  - For undefined returns 0;
 *  - In other cases returns 1.
 *
 * @param { * } src - Source entity.
 *
 * @example
 * _.entity.lengthOf( [ 1, 2, 3 ] );
 * // returns 3
 *
 * @example
 * _.entity.lengthOf( 'string' );
 * // returns 1
 *
 * @example
 * _.entity.lengthOf( { a : 1, b : 2 } );
 * // returns 2
 *
 * @example
 * let src = undefined;
 * _.entity.lengthOf( src );
 * // returns 0
 *
 * @returns {number} Returns "length" of entity.
 * @function lengthOf
 * @namespace Tools/entity
*/

function lengthOf( src ) /* qqq for junior : cover please */
{
  _.assert( arguments.length === 1 );
  return lengthOf.functor.call( this, src )();
}

lengthOf.functor = _functor_functor( 'lengthOf' );

// --
// entity extension
// --

let EntityExtension =
{

  identicalShallow,
  equivalentShallow,

  equal, /* xxx : deprecate? */

  // exporter

  _exportStringDiagnosticShallow : _.container._exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.container.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _.container._exportStringCodeShallow,
  exportStringCodeShallow : _.container.exportStringCodeShallow,
  exportString : _.container.exportString,

  // editor

  empty : _.container.empty, /* qqq : cover */

  // inspector

  lengthOf, /* qqq : cover */

  // elementor

  elementWithCardinal : _.container.elementWithCardinal, /* qqq : cover */
  elementWithKey : _.container.elementWithKey, /* qqq : cover */
  elementWithImplicit : _.container.elementWithImplicit, /* qqq : cover */
  elementWithCardinalSet : _.container.elementWithCardinalSet, /* qqq : cover */
  elementSet : _.container.elementSet, /* qqq : cover */

  elementDel : _.container.elementDel, /* qqq : cover */
  elementWithKeyDel : _.container.elementWithKeyDel, /* qqq : cover */
  elementWithCardinalDel : _.container.elementWithCardinalDel,  /* qqq : cover */
  empty : _.container.empty, /* qqq : for junior : cover */

  // iterator

  each : _.container.each, /* qqq : cover */
  eachLeft : _.container.eachLeft, /* qqq : cover */
  eachRight : _.container.eachRight, /* qqq : cover */

  while : _.container.while, /* qqq : cover */
  whileLeft : _.container.whileLeft, /* qqq : cover */
  whileRight : _.container.whileRight, /* qqq : cover */

  aptLeft : _.container.aptLeft, /* qqq : cover */
  first : _.container.first, /* qqq : cover */
  aptRight : _.container.aptRight, /* qqq : cover */
  last : _.container.last, /* qqq : cover */

}

//

Object.assign( _.entity, EntityExtension );

// --
// tools extension
// --

let ToolsExtension =
{

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Entity.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Entity_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Entity_s */ })();

/* */  /* begin of file Escape_s */ ( function Escape_s() { function Escape_s_naked() { ( function _l3_Escape_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.escape.escaped = _.escape.escaped || Object.create( null );

// _.assert( _.symbolIs( _.symbol.prototype ) );
// _.assert( _.symbolIs( _.symbol.constructor ) );

// --
// implementation
// --

function isEscapable( src )
{
  if( _.escape._EscapeMap.has( src ) )
  return true;
  if( _.escape.is( src ) )
  return true;
  return false;
}

//

function left( src )
{
  _.assert( arguments.length === 1 );
  if( _.escape._EscapeMap.has( src ) )
  return _.escape._EscapeMap.get( src );
  if( _.escape.is( src ) )
  return new _.Escape( src );
  return src;
}

//

function rightWithNothing( src )
{
  _.assert( arguments.length === 1 );
  if( _.escape.is( src ) )
  return src.val;

  if( src === _.undefined )
  return undefined;
  if( src === _.null )
  return null;

  if( src === _.nothing )
  return undefined;

  return src;
}

//

function rightWithoutNothing( src )
{
  _.assert( arguments.length === 1 );
  if( _.escape.is( src ) )
  return src.val;

  if( src === _.undefined )
  return undefined;
  if( src === _.null )
  return null;

  return src;
}

//

function wrap( src )
{
  _.assert( arguments.length === 1 );
  _.assert( !_.escape.is( src ) );
  return new _.Escape( src );
}

//

function unwrap( src )
{
  _.assert( arguments.length === 1 );
  if( _.escape.is( src ) )
  return src.val;
  return src;
}

// --
// class
// --

let fo = _.wrap.declare({ name : 'Escape' });
_.assert( _.Escape === undefined );
_.assert( _.routineIs( fo.class ) );
_.assert( fo.class.name === 'Escape' );
_.Escape = fo.class;
_.assert( _.mapIs( fo.namespace ) );
Object.assign( _.escape, fo.namespace );

// --
// extension
// --

var Extension =
{
  isEscapable,
  left,
  rightWithNothing,
  rightWithoutNothing,
  right : rightWithNothing,
  wrap,
  unwrap,
}

//

Object.assign( _.escape, Extension );
_.escape.escaped.nothing = _.escape.wrap( _.nothing );
_.escape.escaped.null = _.escape.wrap( _.null );
_.escape.escaped.undefined = _.escape.wrap( _.undefined );

_.escape._EscapeMap = new HashMap();
_.escape._EscapeMap.set( _.nothing, _.escape.escaped.nothing );
_.escape._EscapeMap.set( _.null, _.escape.escaped.null );
_.escape._EscapeMap.set( _.undefined, _.escape.escaped.undefined );
_.escape._EscapeMap.set( undefined, _.undefined );
_.escape._EscapeMap.set( null, _.null );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Escape.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Escape_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Escape_s */ })();

/* */  /* begin of file Event_s */ ( function Event_s() { function Event_s_naked() { ( function _l3_Event_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function _chainGenerate( args )
{
  let chain = [];

  _.assert( arguments.length === 1 );
  _.assert( _.longIs( args ) );

  for( let a = 0 ; a < args.length-2 ; a++ )
  chainMake( a );

  chain.push([ _.event.nameValueFrom( args[ args.length-2 ] ), args[ args.length-1 ] ]);

  _.assert( _.routine.is( args[ args.length-1 ] ) );

  return chain;

  /* */

  function chainMake( a )
  {
    let e1 = _.event.nameValueFrom( args[ a ] );
    chain.push([ e1, on ]);
    function on()
    {
      let self = this;
      let next = chain[ a + 1 ];

      if( _.routine.is( self.on ) )
      {
        /*
            Dmytro : it is strange code because the owners of edispatcher can be classes like Process.
            And this solution allows direct call of callbacks when the routine eventGive is not used :
            https://github.com/Wandalen/wProcess/blob/master/proto/wtools/abase/l4_process/Basic.s#L210
            https://github.com/Wandalen/wProcedure/blob/master/proto/wtools/abase/l8_procedure/Namespace.s#L59
        */
        self.on( next[ 0 ], next[ 1 ] );
        if( self.eventHasHandler( e1, on ) )
        self.off( e1, on );
      }
      else
      {
        let o = _.event.onHead( _.event.on, next );
        o.once = on.once;
        _.event._on( self, o );

        if( !on.once )
        if( _.event.eventHasHandler( self, { eventName : e1, eventHandler : on } ) )
        _.event.off( self, { callbackMap : { [ e1 ] : on } } );
      }

    }
  }
}

//

function _chainToCallback( args )
{
  let chain = _.event._chainGenerate( args );
  let firstPair = chain[ 0 ];
  return firstPair[ 1 ];
}

//

function _chainValidate( chain )
{

  for( let i = 0 ; i < chain.length - 1 ; i++ )
  {
    _.assert( _.event.nameIs( chain[ i ] ) );
  }
  _.assert( _.routine.is( chain[ chain.length - 1 ] ) );

  return true;
}

//

function _callbackMapValidate( callbackMap )
{

  _.assert( _.mapIs( callbackMap ) );
  for( let k in callbackMap )
  {
    let callback = callbackMap[ k ];
    _.assert( _.routine.is( callback ) || _.longIs( callback ) );
    if( _.routine.is( callback ) )
    continue;
    _.event._chainValidate( callback );
  }

}

//

function nameValueFrom( name )
{
  if( _.strIs( name ) )
  return name;
  _.assert( _.event.nameIs( name ) );
  return name.value;
}

//

function nameIs( name )
{
  return name instanceof _.event.Name;
}

//

/**
 * The routine chainIs() checks of whether the passed value {-src-} is an instance of wTools.event.Chain.
 *
 * @example
 * var chain = { chain : [ 'event1', 'event2' ] };
 * console.log( _.event.chainIs( chain ) );
 * // log : false
 *
 * @example
 * var chain = _.event.chain( 'event1', 'event2' );
 * console.log( _.event.chainIs( chain ) );
 * // log : true
 *
 * @param { * } src - The value to check.
 * @returns { Boolean } - Returns true if {-src-} is an instance of class wTools.event.Chain.
 * Otherwise, routine returns false.
 * @function chainIs
 * @namespace wTools.event
 * @extends Tools
 */

function chainIs( src )
{
  return src instanceof _.event.Chain;
}

//

/*
_.process.on( 'available', _.event.Name( 'exit' ), _.event.Name( 'exit' ), _.procedure._eventProcessExitHandle )
->
_.process.on( _.event.Chain( 'available', 'exit', 'exit' ), _.procedure._eventProcessExitHandle )
*/

/* qqq for Dmytro : remove the class */
function Name( name )
{
  if( !( this instanceof Name ) )
  {
    if( _.event.nameIs( name ) )
    return name;
    return new Name( ... arguments );
  }
  _.assert( arguments.length === 1 );
  _.assert( _.strIs( name ) );
  this.value = name;
  return this;
}

Name.prototype = Object.create( null );

//

/**
 * The routine Chain() implements class Chain. The instance of the class holds chain of event names.
 *
 * @example
 * var chain = _.event.chain( 'event1', 'event2' );
 * console.log( _.event.chainIs( chain ) );
 * // log : true
 * console.log( chain.chain );
 * // log : [ 'event1', 'event2' ]
 *
 * @example
 * var name1 = _.event.Name( 'event1' );
 * var name2 = _.event.Name( 'event2' );
 * var chain = _.event.chain( name1, name2 );
 * console.log( _.event.chainIs( chain ) );
 * // log : true
 * console.log( chain.chain.length );
 * // log : 2
 * console.log( chain.chain[ 0 ] === name1 );
 * // log : true
 * console.log( chain.chain[ 1 ] === name2 );
 * // log : true
 *
 * @param { String|wTools.event.Name|wTools.event.Chain } ... arguments - The set of event names of single instance of Chain.
 * @returns { wTools.event.Chain } - Returns instance of class.
 * @function Chain
 * @class wTools.event.Chain
 * @throws { Error } If arguments.length is less than 1.
 * @throws { Error } If arguments have incompatible type.
 * @throws { Error } If arguments contain instance of Chain and another elements.
 * @namespace wTools.event
 * @extends Tools
 */

function Chain()
{
  if( !( _.event.chainIs( this ) ) )
  {
    if( _.event.chainIs( arguments[ 0 ] ) )
    {
      _.assert( arguments.length === 1, 'Expects single Chain or set of event names' );
      return arguments[ 0 ];
    }
    return new Chain( ... arguments );
  }

  let result = _.array.make( arguments.length );
  _.assert( arguments.length >= 1, 'Expects events names' );
  for( let i = 0 ; i < arguments.length ; i++ )
  result[ i ] = _.event.Name( arguments[ i ] );

  this.chain = result;
  return this;
}

Chain.prototype = Object.create( null );

//

function onHead( routine, args )
{
  let o;

  _.assert( _.longIs( args ) );
  _.assert( arguments.length === 2 );

  if( args.length === 2 )
  {
    _.assert( _.routine.is( args[ 1 ] ) );

    o = Object.create( null );
    o.callbackMap = Object.create( null );

    if( _.event.chainIs( args[ 0 ] ) )
    {
      let chain = args[ 0 ].chain;
      o.callbackMap[ chain[ 0 ].value ] = _.longOnly_( null, chain, [ 1, chain.length - 1 ] );
      o.callbackMap[ chain[ 0 ].value ].push( args[ 1 ] );
    }
    else if( _.strIs( args[ 0 ] ) )
    {
      o.callbackMap[ args[ 0 ] ] = args[ 1 ];
    }
    else if( _.event.nameIs( args[ 0 ] ) )
    {
      o.callbackMap[ args[ 0 ].value ] = args[ 1 ];
    }
    else
    {
      _.assert( 0, 'Expects Chain with names or single name of event.' );
    }
  }
  else if( args.length === 1 )
  {
    o = args[ 0 ];
  }
  else
  {
    _.assert( 0, 'Expects single options map {-o-} or events Chain and callback as arguments.' );
  }

  if( Config.debug )
  {
    _.assert( _.mapIs( o ) );
    _.event._callbackMapValidate( o.callbackMap );
  }

  // _.event._callbackMapNormalize( o.callbackMap );

  return o;
}

//

function _on( edispatcher, o )
{

  _.routine.options( _on, o );
  _.assert( _.mapIs( o.callbackMap ) );
  _.assert( _.object.isBasic( edispatcher ) );
  _.assert( _.object.isBasic( edispatcher.events ) );
  _.map.assertHasOnly( o.callbackMap, edispatcher.events, 'Unknown kind of event' );
  _.assert( arguments.length === 2 );

  const once = !!o.once;
  let descriptors = Object.create( null );
  let append;
  if( o.first )
  append = _.arrayPrepend;
  else
  append = _.arrayAppend;

  for( let c in o.callbackMap )
  {
    let callback = o.callbackMap[ c ];
    descriptors[ c ] = descriptorMake();

    if( _.longIs( callback ) )
    callback = _.event._chainToCallback([ c, ... callback ]);

    _.assert( _.routine.is( callback ) );

    callback = callbackOn_functor.call( descriptors[ c ], callback, c );
    descriptors[ c ].off = off_functor.call( descriptors[ c ], edispatcher, { callbackMap : { [ c ] : callback } } );

    append( edispatcher.events[ c ], callback );

    // if( o.first )
    // _.arrayPrepend( edispatcher.events[ c ], callback );
    // else
    // _.arrayAppend( edispatcher.events[ c ], callback );

    /* */

  }

  return descriptors;

  /* */

  // function callbackOn_functor( callback ) /* Dmytro : can't extract name from descriptor. Maybe, it can contains field `name` */
  function callbackOn_functor( callback, name )
  {
    let self = this;

    function callbackOn()
    {
      let result;
      if( self.enabled )
      {
        result = callback.apply( this, arguments );
        if( once === true )
        _.event.off( edispatcher, { callbackMap : { [ name ] : callbackOn } } );
        // _.event.off( edispatcher, { callbackMap : { [ name ] : callbackOnce } } ); /* Dmytro : callbackOnce does not exist */
      }
      return result;
    }
    callbackOn.native = callback;
    callbackOn.native.once = once;

    return callbackOn;
  }

  /* */

  function descriptorMake()
  {
    let descriptor = Object.create( null );
    descriptor.off = null;
    descriptor.enabled = true;
    descriptor.first = o.first; /* Dmytro : please, explain, does it need to save original value? */
    descriptor.callbackMap = o.callbackMap; /* Dmytro : please, explain, does it need to save link to original callback map? */
    return descriptor;
  }

  /* */

  function off_functor( edispatcher, o )
  {
    let self = this;

    return function()
    {
      _.assert( arguments.length === 0, 'Expects no arguments.' );
      return _.event.off( edispatcher, o );
    }
  }

  /* */

}

_on.defaults =
{
  callbackMap : null,
  first : false,
  once : false,
}

// const on = _.routine.uniteCloning( on_head, on_body );
// on.defaults.once = false;

//

function on( edispatcher, o )
{
  o.once = false;
  return _.event._on( edispatcher, o );
}

// //
//
// function on( edispatcher, o )
// {
//
//   // if( _.longIs( o.callbackMap ) )
//   // o.callbackMap = callbackMapFromChain( o.callbackMap );
//
//   _.routine.options( on, o );
//   _.assert( _.mapIs( o.callbackMap ) );
//   _.assert( _.object.isBasic( edispatcher ) );
//   _.assert( _.object.isBasic( edispatcher.events ) );
//   _.map.assertHasOnly( o.callbackMap, edispatcher.events, 'Unknown kind of event' );
//   _.assert( arguments.length === 2 );
//
//   let descriptors = Object.create( null );
//
//   for( let c in o.callbackMap )
//   {
//     let callback = o.callbackMap[ c ];
//     descriptors[ c ] = descriptorMake();
//
//     if( _.longIs( callback ) )
//     callback = _.event._chainToCallback([ c, ... callback ]);
//
//     _.assert( _.routine.is( callback ) );
//
//     callback = callbackOn_functor.call( descriptors[ c ], callback );
//     descriptors[ c ].off = off_functor.call( descriptors[ c ], edispatcher, { callbackMap : { [ c ] : callback } } );
//
//     if( o.first )
//     _.arrayPrepend( edispatcher.events[ c ], callback );
//     else
//     _.arrayAppend( edispatcher.events[ c ], callback );
//
//     /* */
//
//   }
//
//   return descriptors;
//
//   /* */
//
//   function callbackOn_functor( callback )
//   {
//     let self = this;
//
//     function callbackOn()
//     {
//       let result;
//       if( self.enabled )
//       result = callback.apply( this, arguments );
//       return result;
//     }
//     callbackOn.native = callback;
//
//     return callbackOn;
//   }
//
//   /* */
//
//   function descriptorMake()
//   {
//     let descriptor = Object.create( null );
//     descriptor.off = null;
//     descriptor.enabled = true;
//     descriptor.first = o.first; /* Dmytro : please, explain, does it need to save original value? */
//     descriptor.callbackMap = o.callbackMap; /* Dmytro : please, explain, does it need to save link to original callback map? */
//     return descriptor;
//   }
//
//   /* */
//
//   function off_functor( edispatcher, o )
//   {
//     let self = this;
//
//     return function()
//     {
//       _.assert( arguments.length === 0, 'Expects no arguments.' );
//       return _.event.off( edispatcher, o );
//     }
//   }
//
//   /* */
//
// }
//
// on.head = on_head;
// on.defaults =
// {
//   callbackMap : null,
//   first : 0,
// };

// //
//
// function on( edispatcher, o )
// {
//
//   // if( _.longIs( o.callbackMap ) )
//   // o.callbackMap = callbackMapFromChain( o.callbackMap );
//
//   _.routine.options( on, o );
//   _.assert( _.mapIs( o.callbackMap ) );
//   _.assert( _.object.isBasic( edispatcher ) );
//   _.assert( _.object.isBasic( edispatcher.events ) );
//   _.map.assertHasOnly( o.callbackMap, edispatcher.events, 'Unknown kind of event' );
//   _.assert( arguments.length === 2 );
//
//   let descriptors = Object.create( null );
//
//   for( let c in o.callbackMap )
//   {
//     let callback = o.callbackMap[ c ];
//     descriptors[ c ] = descriptorMake();
//
//     if( _.longIs( callback ) )
//     callback = _.event._chainToCallback([ c, ... callback ]);
//
//     _.assert( _.routine.is( callback ) );
//
//     callback = callbackOn_functor.call( descriptors[ c ], callback );
//     descriptors[ c ].off = off_functor.call( descriptors[ c ], edispatcher, { callbackMap : { [ c ] : callback } } );
//
//     if( o.first )
//     _.arrayPrepend( edispatcher.events[ c ], callback );
//     else
//     _.arrayAppend( edispatcher.events[ c ], callback );
//
//     /* */
//
//   }
//
//   return descriptors;
//
//   /* */
//
//   function callbackOn_functor( callback )
//   {
//     let self = this;
//
//     function callbackOn()
//     {
//       let result;
//       if( self.enabled )
//       result = callback.apply( this, arguments );
//       return result;
//     }
//     callbackOn.native = callback;
//
//     return callbackOn;
//   }
//
//   /* */
//
//   function descriptorMake()
//   {
//     let descriptor = Object.create( null );
//     descriptor.off = null;
//     descriptor.enabled = true;
//     descriptor.first = o.first; /* Dmytro : please, explain, does it need to save original value? */
//     descriptor.callbackMap = o.callbackMap; /* Dmytro : please, explain, does it need to save link to original callback map? */
//     return descriptor;
//   }
//
//   /* */
//
//   function off_functor( edispatcher, o )
//   {
//     let self = this;
//
//     return function()
//     {
//       _.assert( arguments.length === 0, 'Expects no arguments.' );
//       return _.event.off( edispatcher, o );
//     }
//   }
//
//   /* */
//
// }
//
// on.head = on_head;
// on.defaults =
// {
//   callbackMap : null,
//   first : 0,
// };

//

/**
 * The routine once() registers callback of some kind in event handler {-edispatcher-}.
 * Registered callback executes once and deleted from queue.
 *
 * @example
 * let edispatcher = { events : { begin : [] } };
 * let result = [];
 * let onBegin = () => result.push( result.length );
 * console.log( edispatcher.events.begin.length );
 * // log : 0
 * _.event.once( edispatcher, { callbackMap : { begin : onBegin } } );
 * console.log( edispatcher.events.begin.length );
 * // log : 1
 * console.log( result );
 * // log : []
 *
 * @example
 * let edispatcher = { events : { begin : [] } };
 * let result = [];
 * let onBegin = () => result.push( result.length );
 * _.event.once( edispatcher, { callbackMap : { begin : onBegin } } );
 * _.event.eventGive( edispatcher, 'begin' );
 * console.log( edispatcher.events.begin.length );
 * // log : 0
 * console.log( result );
 * // log : [ 0 ]
 *
 * @example
 * let edispatcher = { events : { begin : [], end : [] } };
 * let result = [];
 * let onBegin = () => result.push( result.length );
 * let onBegin2 = () => result.push( result.length + 1 );
 * let onEnd = result.splice();
 * _.event.once( edispatcher, { callbackMap : { begin : onBegin } } );
 * _.event.once( edispatcher, { callbackMap : { begin : onBegin2 } } );
 * _.event.once( edispatcher, { callbackMap : { end : onEnd } } );
 * _.event.eventGive( edispatcher, 'begin' );
 * console.log( edispatcher.events.begin.length );
 * // log : 0
 * console.log( result );
 * // log : [ 0, 2 ]
 * _.event.eventGive( edispatcher, 'end' );
 * console.log( result );
 * // log : []
 *
 * @param { Object } edispatcher - The events handler with map of available events.
 * @param { Map|Aux } o - Options map.
 * @param { Map } o.callbackMap - Map with pairs: [ eventName ] : [ callback ]. The value
 * [ callback ] can be a Function or Array with callbacks.
 * @param { Boolean|BoolLike } o.first - If it has value `true`, then callback prepends to callback queue.
 * Otherwise, callback appends to callback queue.
 * @returns { Map|Aux } - Returns options map {-o-}.
 * @function once
 * @throws { Error } If arguments.length is not equal to 2.
 * @throws { Error } If {-edispatcher-} is not an Object.
 * @throws { Error } If {-edispatcher.events-} is not an Object.
 * @throws { Error } If {-o-} has incompatible type.
 * @throws { Error } If {-o-} has extra options.
 * @throws { Error } If {-o.callbackMap-} is not a Map.
 * @throws { Error } If {-o.callbackMap-} has events than does not exist in map {-edispatcher.events-}.
 * @namespace wTools.event
 * @extends Tools
 */

// const once = _.routine.uniteCloning( on_head, on_body );
// once.defaults.once = true;
// _.assert( on.defaults.once === false );

function once( edispatcher, o )
{
  o.once = true;
  return _.event._on( edispatcher, o );
}

/* qqq : for Dmytro : bad! */
// function once( edispatcher, o )
// {
//
//   _.routine.options( once, o );
//   _.assert( _.mapIs( o.callbackMap ) );
//   _.assert( _.object.isBasic( edispatcher ) );
//   _.assert( _.object.isBasic( edispatcher.events ) );
//   _.map.assertHasOnly( o.callbackMap, edispatcher.events, 'Unknown kind of event' );
//   _.assert( arguments.length === 2 );
//
//   let descriptors = Object.create( null );
//
//   for( let c in o.callbackMap )
//   {
//     let callback = o.callbackMap[ c ];
//     descriptors[ c ] = descriptorMake();
//
//     if( _.longIs( callback ) )
//     {
//       let length = callback.length;
//       _.assert( _.routine.is( callback[ length - 1 ] ), 'Expects routine to execute.' );
//
//       let name = callback[ length - 2 ] || c;
//       name = name.value !== undefined ? name.value : name;
//       callback[ length - 1 ] = callbackOnce_functor.call( descriptors[ c ], name, callback[ length - 1 ] );
//       callback = _.event._chainToCallback([ c, ... callback ]);
//     }
//     else
//     {
//       callback = callbackOnce_functor.call( descriptors[ c ], c, callback );
//     }
//     descriptors[ c ].off = off_functor.call( descriptors[ c ], edispatcher, { callbackMap : { [ c ] : callback } } );
//
//     _.assert( _.routine.is( callback ) );
//
//     callbackAdd( edispatcher, c, callback );
//   }
//
//   return descriptors;
//
//   /* */
//
//   function callbackOnce_functor( name, callback )
//   {
//     let self = this;
//
//     function callbackOnce()
//     {
//       let result;
//       if( self.enabled )
//       {
//         callback.apply( this, arguments );
//         _.event.off( edispatcher, { callbackMap : { [ name ] : callbackOnce } } );
//       }
//       return result;
//     }
//     callbackOnce.native = callback; /* Dmytro : this solution does not affects original callback and interfaces of calls. And simultaneously it slow down searching in routine `off` */
//
//     return callbackOnce;
//   }
//
//   /* */
//
//   function callbackAdd( handler, name, callback )
//   {
//     if( o.first )
//     _.arrayPrepend( handler.events[ name ], callback );
//     else
//     _.arrayAppend( handler.events[ name ], callback );
//   }
//
//   /* */
//
//   function descriptorMake()
//   {
//     let descriptor = Object.create( null );
//     descriptor.off = null;
//     descriptor.enabled = true;
//     descriptor.first = o.first; /* Dmytro : please, explain, does it need to save original value? */
//     descriptor.callbackMap = o.callbackMap; /* Dmytro : please, explain, does it need to save link to original callback map? */
//
//     return descriptor;
//   }
// }
//
// once.head = on_head;
// once.defaults =
// {
//   callbackMap : null,
//   first : 0,
// };

//

/**
 * The routine off() removes callback of some kind in event handler {-edispatcher-}.
 *
 * @example
 * let onBegin = () => result.push( result.length );
 * let onBegin2 = () => result.push( result.length );
 * let edispatcher = { events : { begin : [ onBegin, onBegin2 ] } };
 * _.event.off( edispatcher, { callbackMap : { begin : onBegin } } );
 * console.log( edispatcher.events.begin.length );
 * // log : 1
 * console.log( edispatcher.events.begin[ 0 ] === onBegin2 );
 * // log : true
 *
 * @example
 * let onBegin = () => result.push( result.length );
 * let onBegin2 = () => result.push( result.length );
 * let edispatcher = { events : { begin : [ onBegin, onBegin2 ] } };
 * _.event.off( edispatcher, { callbackMap : { begin : null } } );
 * console.log( edispatcher.events.begin.length );
 * // log : 0
 *
 * @param { Object } edispatcher - The events handler with map of available events.
 * @param { Map|Aux } o - Options map.
 * @param { Map } o.callbackMap - Map with pairs: [ eventName ] : [ callback ]. The value
 * [ callback ] can be a Function or Null. If null is provided, routine removes all callbacks.
 * @returns { Map|Aux } - Returns options map {-o-}.
 * @function off
 * @throws { Error } If arguments.length is not equal to 2.
 * @throws { Error } If {-edispatcher-} is not an Object.
 * @throws { Error } If {-edispatcher.events-} is not an Object.
 * @throws { Error } If {-o-} has incompatible type.
 * @throws { Error } If {-o-} has extra options.
 * @throws { Error } If {-o.callbackMap-} is not a Map.
 * @throws { Error } If {-o.callbackMap-} has events than does not exist in map {-edispatcher.events-}.
 * @throws { Error } If {-edispatcher.events-} callback queue has a few callbacks
 * which should be removed separately.
 * @namespace wTools.event
 * @extends Tools
 */

function offHead( routine, args )
{

  _.assert( _.longIs( args ) );
  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 );

  let o = args[ 0 ];
  if( args.length === 2 )
  o = { callbackMap : { [ args[ 0 ] ] : args[ 1 ] } }
  else if( _.strIs( args[ 0 ] ) )
  o = { callbackMap : { [ args[ 0 ] ] : null } }

  _.assert( _.mapIs( o ) );

  return o;
}

//

function off( edispatcher, o )
{

  _.routine.options( off, o );
  _.assert( _.mapIs( o.callbackMap ) );
  _.assert( _.object.isBasic( edispatcher ) );
  _.assert( _.object.isBasic( edispatcher.events ) );
  _.map.assertHasOnly( o.callbackMap, edispatcher.events, 'Unknown kind of event' );
  _.assert( arguments.length === 2 );

  for( let c in o.callbackMap )
  {
    if( o.callbackMap[ c ] === null )
    _.array.empty( edispatcher.events[ c ] );
    else
    _.arrayRemoveOnceStrictly( edispatcher.events[ c ], o.callbackMap[ c ], callbackEqualize );
  }

  return o;

  /* */

  function callbackEqualize( callback, handler )
  {
    return handler === callback || handler === callback.native;
  }
}

// off.head = off_head;
off.defaults =
{
  callbackMap : null,
}

//

function eventHasHandlerHead( routine, args )
{
  let o;

  _.assert( _.longIs( args ) );
  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 );

  if( args.length > 1 )
  {
    o = Object.create( null );
    o.eventName = args[ 0 ];
    o.eventHandler = args[ 1 ];
  }
  else
  {
    o = args[ 0 ]
  }

  _.assert( _.mapIs( o ) );

  return o;
}

//

/* xxx */
function eventHasHandler( edispatcher, o )
{

  _.routine.options( eventHasHandler, o );
  _.assert( _.strIs( o.eventName ) );
  _.assert( _.routine.is( o.eventHandler ) );
  _.assert( _.mapIs( edispatcher ) );
  _.assert( _.mapIs( edispatcher.events ) );
  _.assert( arguments.length === 2 );

  return _.longHas( edispatcher.events[ o.eventName ], o.eventHandler, handlerEqualize );

  /* */

  function handlerEqualize( callback, handler )
  {
    return handler === callback || handler === callback.native;
  }
}

// eventHasHandler.head = eventHasHandler_head;
eventHasHandler.defaults =
{
  eventName : null,
  eventHandler : null,
}

//

function eventGiveHead( edispatcher, routine, args )
{
  let o = args[ 0 ];

  _.assert( arguments.length === 3, 'Expects exactly three arguments.' );
  _.assert( args.length > 0 );
  _.assert( _.aux.is( edispatcher.events ), 'Expects events dispatcher.' );

  if( _.strIs( o ) )
  o = { event : o };
  _.assert( _.aux.is( o ), 'Expects string or options map in {-o.args[ 1 ]-}.' ); /* Dmytro : restrict using options map in first argument */

  if( o.onError === null || o.onError === undefined )
  o.onError = onError;

  _.map.assertHasOnly( o, routine.defaults );

  if( o.args )
  _.assert( args.length === 1 ); /* Dmytro : restrict using options map in first argument */
  else /* Dmytro : do not overwrite arguments if the field exists */
  o.args = args;

  // if( o.args === null )
  // {
  //   o.args = [ Object.create( null ) ];
  //   o.args[ 0 ].event = o.event;
  // }

  return o;

  /* */

  function onError( err, o )
  {
    throw _.err( `Error on handing event ${o.event}\n`, err );
  }
}

//

function eventGive( edispatcher, o )
{

  // if( _.strIs( o ) )
  // o = { event : o }
  // _.routine.options( eventGive, o );
  //
  // if( o.onError === null )
  // o.onError = onError;
  // if( o.args === null )
  // {
  //   o.args = [ Object.create( null ) ];
  //   o.args[ 0 ].event = o.event;
  // }

  _.assert( arguments.length === 2 );
  _.assert( !!edispatcher.events[ o.event ], `Unknown event ${o.event}` );
  _.assert( _.long.is( o.args ), 'Expects arguments {-o.args-}' );

  let was;
  let visited = [];
  do
  {
    was = visited.length;
    let events = edispatcher.events[ o.event ].slice();
    _.each( events, ( callback ) =>
    {
      if( _.longHas( visited, callback ) )
      return;
      visited.push( callback );
      try
      {
        callback.apply( edispatcher, o.args );
      }
      catch( err )
      {
        o.onError( err, o );
      }
    });
  }
  while( was !== visited.length );

  /* */

  // function onError( err, o )
  // {
  //   throw _.err( `Error on handing event ${o.event}\n`, err );
  // }

}

eventGive.defaults =
{
  event : null,
  args : null,
  onError : null,
}

// --
// extension
// --

let Extension =
{

  _chainGenerate,
  _chainToCallback,
  _chainValidate,
  _callbackMapValidate,

  nameValueFrom,
  nameIs,
  chainIs,
  Name,
  Chain,

  onHead,
  _on,
  on,
  once,
  offHead,
  off,
  // off_functor,

  eventHasHandlerHead,
  eventHasHandler,
  eventGiveHead,
  eventGive,

}

Object.assign( _.event, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Event.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Event_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Event_s */ })();

/* */  /* begin of file HashMap_s */ ( function HashMap_s() { function HashMap_s_naked() { ( function _l3_HashMap_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// equaler
// --

function _identicalShallow( src1, src2 )
{

  if( src1.size !== src2.size )
  return false;

  for( let [ key, val ] of src1 )
  {
    if( src2.has( key ) === false )
    return false;

    let val2 = src2.get( key );

    // /*
    //   in cases of an undefined value, make sure the key
    //   exists on the object so there are no false positives
    // */
    // // if( testVal !== val || ( testVal === undefined && !src2.has( key ) ) )
    // // return false;

    if( !Object.is( val2, val ) )
    return false;

  }

  return true;
}

// --
// exporter
// --

function _exportStringDiagnosticShallow( src )
{
  return `{- ${_.entity.strType( src )} with ${_.entity.lengthOf( src )} elements -}`;
}

// --
// container interface
// --

function _lengthOf( src )
{
  return src.size;
}

//

function _hasKey( src, key )
{
  return src.has( key );
}

//

function _hasCardinal( src, cardinal )
{
  if( cardinal < 0 )
  return false;
  return cardinal < src.size;
}

//

function _keyWithCardinal( src, cardinal )
{
  if( cardinal < 0 || src.size <= cardinal )
  return [ undefined, false ];
  return [ this.keys[ cardinal ], true ];
}

//

function _cardinalWithKey( src, key )
{
  if( !src.has( key ) )
  return -1;
  let keys = this.keys( src );
  return keys.indexOf( key );
}

//

function _elementWithKey( src, key )
{
  if( src.has( key ) )
  return [ src.get( key ), key, true ];
  else
  return [ undefined, key, false ];
}

//

function _elementWithImplicit( src, key )
{
  if( _.props.keyIsImplicit( key ) )
  return _.props._onlyImplicitWithKeyTuple( src, key );
  return this._elementWithKey( src, key );
}

//

function _elementWithCardinal( src, cardinal )
{
  if( cardinal < 0 || src.size <= cardinal || !_.numberIs( cardinal ) )
  return [ undefined, cardinal, false ];
  let entry = [ ... src ][ cardinal ];
  return [ entry[ 1 ], entry[ 0 ], true ];
}

//

function _elementWithKeySet( dst, key, val )
{
  dst.set( key, val );
  return [ key, true ];
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{
  let was = this._elementWithCardinal( dst, cardinal );
  if( was[ 2 ] === true )
  {
    dst.set( was[ 1 ], val );
    return [ was[ 1 ], true ];
  }
  else
  {
    return [ cardinal, false ];
  }
}

//

function _elementWithKeyDel( dst, key )
{
  if( !this._hasKey( dst, key ) )
  return false;
  dst.delete( key );
  return true;
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  let has = this._keyWithCardinal( dst, cardinal );
  if( !has[ 1 ] )
  return false;
  dst.delete( has[ 0 ] );
  return true;
}

//

function _empty( dst )
{
  dst.clear();
  return dst;
}

//

function _eachLeft( src, onEach )
{
  let c = 0;
  for( let [ k, val ] of src )
  {
    onEach( val, k, c, src );
    c += 1;
  }
}

//

function _eachRight( src, onEach )
{
  let keys = [ ... src.keys() ];
  for( let c = keys.length-1 ; c >= 0 ; c-- )
  {
    let k = keys[ c ];
    let val = src.get( k );
    onEach( val, k, c, src );
  }
}

//

function _whileLeft( src, onEach )
{
  if( src.size === 0 )
  return [ undefined, undefined, -1, true ];
  let c = 0;
  let lastk;
  for( let [ k, val ] of src )
  {
    let r = onEach( val, k, c, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ val, k, c, false ];
    lastk = k;
    c += 1;
  }
  return [ src.get( lastk ), lastk, c-1, true ];
}

//

function _whileRight( src, onEach )
{
  if( src.size === 0 )
  return [ undefined, undefined, -1, true ];

  let keys = [ ... src.keys() ];
  for( let c = keys.length-1 ; c >= 0 ; c-- )
  {
    let k = keys[ c ];
    let val = src.get( k );
    let r = onEach( val, k, c, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ val, k, c, false ];
  }

  var k = keys[ 0 ];
  return [ src.get( k ), k, 0, true ];
}

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let Extension =
{

  // equaler

  _identicalShallow,
  identicalShallow : _.props.identicalShallow,
  identical : _.props.identical,
  _equivalentShallow : _identicalShallow,
  equivalentShallow : _.props.equivalentShallow,
  equivalent : _.props.equivalent,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // inspector

  _lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */
  _hasKey,
  hasKey : _.props.hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal : _.props.hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal : _.props.keyWithCardinal, /* qqq : cover */
  _cardinalWithKey,
  cardinalWithKey : _.props.cardinalWithKey, /* qqq : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : _.props.elementGet, /* qqq : cover */
  _elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.props._elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty : _.props.empty, /* qqq : for junior : cover */

  // iterator

  _each : _eachLeft,
  each : _.props.each, /* qqq : cover */
  _eachLeft,
  eachLeft : _.props.eachLeft, /* qqq : cover */
  _eachRight,
  eachRight : _.props.eachRight, /* qqq : cover */

  _while : _whileLeft,
  while : _.props.while, /* qqq : cover */
  _whileLeft,
  whileLeft : _.props.whileLeft, /* qqq : cover */
  _whileRight,
  whileRight : _.props.whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct0 : _.props._filterAct0,
  _filterAct : _.props._filterAct,
  filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  filterWithoutEscape : _.props.filterWithoutEscape,
  filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  filterWithEscapeRight : _.props.filterWithEscapeRight,
  filterWithEscape : _.props.filterWithEscape,
  filter : _.props.filter,

  _mapAct0 : _.props._mapAct0,
  _mapAct : _.props._mapAct,
  mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  mapWithoutEscape : _.props.mapWithoutEscape,
  mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  mapWithEscapeRight : _.props.mapWithEscapeRight,
  mapWithEscape : _.props.mapWithEscape,
  map : _.props.map,

}

Object.assign( _.hashMap, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/HashMap.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, HashMap_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file HashMap_s */ })();

/* */  /* begin of file Itself_s */ ( function Itself_s() { function Itself_s_naked() { ( function _l3_Itself_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.blank.identical, 'Expects routine blank.identical' );
_.assert( !!_.blank.exportString, 'Expects routine _.blank.exportString' );

// --
// container interface
// --

function _lengthOf( src )
{
  return 1;
}

//

function _hasKey( src, key )
{
  if( cardinal === 0 )
  return true;
  return false;
}

//

function _hasCardinal( src, cardinal )
{
  if( cardinal === 0 )
  return true;
  return false;
}

//

function _keyWithCardinal( src, cardinal )
{
  if( cardinal === 0 )
  return [ 0, true ];
  return [ undefined, false ];
}

//

function _cardinalWithKey( key )
{
  if( key === 0 )
  return 0;
  return -1;
}

//

function _elementWithKey( src, key )
{
  if( key === 0 )
  return [ src, key, true ];
  return [ undefined, key, false ];
}

//

function _elementWithCardinal( src, cardinal )
{
  if( cardinal === 0 )
  return [ src, cardinal, true ];
  return [ undefined, cardinal, false ];
}

//

function _elementWithKeySet( dst, key, val )
{
  return [ key, false ];
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{
  if( cardinal === 0 )
  return [ cardinal, true ];
  else
  return [ cardinal, false ];
}

//

function _elementWithKeyDel( dst, key )
{
  return false;
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  return false;
}

//

function _empty( dst )
{
  return dst;
}

//

function _eachLeft( src, onEach )
{
  onEach( src, null, 0, src );
}

//

function _eachRight( src, onEach )
{
  onEach( src, null, 0, src );
}

//

function _whileLeft( src, onEach )
{
  let r = onEach( src, null, 0, src );
  _.assert( r === true || r === false );
  if( r === false )
  return [ src, null, 0, false ];
  return [ src, null, 0, true ];
}

//

function _whileRight( src, onEach )
{
  let r = onEach( src, null, 0, src );
  _.assert( r === true || r === false );
  if( r === false )
  return [ src, null, 0, false ];
  return [ src, null, 0, true ];
}

// --
// extension
// --

let ItselfExtension =
{

  // equaler

  _identicalShallow : _.blank._identicalShallow,
  identicalShallow : _.blank.identicalShallow,
  identical : _.blank.identical,
  _equivalentShallow : _.blank._equivalentShallow,
  equivalentShallow : _.blank.equivalentShallow,
  equivalent : _.blank.equivalent,

  // exporter

  _exportStringDiagnosticShallow : _.blank._exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.blank.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _.blank._exportStringCodeShallow,
  exportStringCodeShallow : _.blank.exportStringCodeShallow,
  exportString : _.blank.exportString,

  // inspector

  _lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */
  _hasKey,
  hasKey : _.props.hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal : _.props.hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal : _.props.keyWithCardinal, /* qqq : cover */
  _cardinalWithKey,
  cardinalWithKey : _.props.cardinalWithKey, /* qqq : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : _.props.elementGet, /* qqq : cover */
  _elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.props._elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty : _.props.empty, /* qqq : for junior : cover */

  // iterator

  _each : _eachLeft,
  each : _.props.each, /* qqq : cover */
  _eachLeft,
  eachLeft : _.props.eachLeft, /* qqq : cover */
  _eachRight,
  eachRight : _.props.eachRight, /* qqq : cover */

  _while : _whileLeft,
  while : _.props.while, /* qqq : cover */
  _whileLeft,
  whileLeft : _.props.whileLeft, /* qqq : cover */
  _whileRight,
  whileRight : _.props.whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct0 : _.props._filterAct0,
  _filterAct : _.props._filterAct,
  filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  filterWithoutEscape : _.props.filterWithoutEscape,
  filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  filterWithEscapeRight : _.props.filterWithEscapeRight,
  filterWithEscape : _.props.filterWithEscape,
  filter : _.props.filter,

  _mapAct0 : _.props._mapAct0,
  _mapAct : _.props._mapAct,
  mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  mapWithoutEscape : _.props.mapWithoutEscape,
  mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  mapWithEscapeRight : _.props.mapWithEscapeRight,
  mapWithEscape : _.props.mapWithEscape,
  map : _.props.map,

}

Object.assign( _.itself, ItselfExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Itself.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Itself_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Itself_s */ })();

/* */  /* begin of file Logic_s */ ( function Logic_s() { function Logic_s_naked() { ( function _l3_Logic_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// logic
// --

function _identicalShallow( src1, src2 )
{
  if( src1 === src2 )
  return true;
  return false;
}

//

function identicalShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;
  return this._identicalShallow( src1, src2 );
}

//

function _equivalentShallow( src1, src2 )
{
  if
  (
    src1 === src2
  )
  return true;
  return false;
}

//

function equivalentShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;
  return this._equivalentShallow( src1, src2 );
}

//

function or( elements )
{
  return new _.logic.node.Or( ... arguments );
}

//

function and( elements )
{
  return new _.logic.node.And( ... arguments );
}

//

function xor( elements )
{
  return new _.logic.node.Xor( ... arguments );
}

//

function xand( elements )
{
  return new _.logic.node.Xand( ... arguments );
}

//

function _if( elements )
{
  return _.logic.node.If( ... arguments );
}

//

function first( elements )
{
  return new _.logic.node.First( ... arguments );
}

//

function second( elements )
{
  return new _.logic.node.Second( ... arguments );
}

//

function not( elements )
{
  return new _.logic.node.Not( ... arguments );
}

//

function exec( logic, ... args )
{
  return logic.exec( ... args );
}

// --
// logic extension
// --

let LogicExtension =
{

  // equaler

  _identicalShallow,
  identicalShallow,
  identical : identicalShallow,
  _equivalentShallow,
  equivalentShallow,
  equivalent : equivalentShallow,

  //

  and,
  or,
  xor,
  xand,
  first,
  second,
  not,
  if : _if,

  //

  exec,

}

Object.assign( _.logic, LogicExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Logic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Logic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Logic_s */ })();

/* */  /* begin of file Map_s */ ( function Map_s() { function Map_s_naked() { ( function _l3_Map_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.props._elementWithKey, 'Expects routine _.props._elementWithKey' );
_.assert( !!_.props.exportString, 'Expects routine _.props.exportString' );

// --
// equaler
// --

function _identicalShallow( src1, src2 )
{

  if( Object.keys( src1 ).length !== Object.keys( src2 ).length )
  return false;

  for( let s in src1 )
  {
    if( src1[ s ] !== src2[ s ] )
    return false;
  }

  return true;
}

//

/**
 * The containShallow() returns true, if the first object {-srcMap-}
 * has the same values as the second object(ins).
 *
 * It takes two objects (scr, ins),
 * checks if the first object {-srcMap-} has the same [key, value] as
 * the second object (ins).
 * If true, it returns true,
 * otherwise it returns false.
 *
 * @param { objectLike } src - Target object.
 * @param { objectLike } ins - Second object.
 * Objects to compare values.
 *
 * @example
 * _.map.containShallow( { a : 7, b : 13, c : 15 }, { a : 7, b : 13 } );
 * // returns true
 *
 * @example
 * _.map.containShallow( { a : 7, b : 13 }, { a : 7, b : 13, c : 15 } );
 * // returns false
 *
 * @returns { boolean } Returns true, if the first object {-srcMap-}
 * has the same values as the second object(ins).
 * @function containShallow
 * @throws Will throw an error if ( arguments.length !== 2 ).
 * @namespace Tools/map
 */

function containShallow( src, ins )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !this.like( src ) )
  return false;
  if( !this.like( ins ) )
  return false;

  for( let s in ins )
  {
    if( !( s in src ) )
    continue;
    if( src[ s ] !== ins[ s ] )
    return false;
  }

  return true;
}

// /**
//  * The mapsAreIdentical() returns true, if the second object (src2)
//  * has the same values as the first object(src1).
//  *
//  * It takes two objects (scr1, src2), checks
//  * if both object have the same length and [key, value] return true
//  * otherwise it returns false.
//  *
//  * @param { objectLike } src1 - First object.
//  * @param { objectLike } src2 - Target object.
//  * Objects to compare values.
//  *
//  * @example
//  * _.map.identical( { a : 7, b : 13 }, { a : 7, b : 13 } );
//  * // returns true
//  *
//  * @example
//  * _.map.identical( { a : 7, b : 13 }, { a : 33, b : 13 } );
//  * // returns false
//  *
//  * @example
//  * _.map.identical( { a : 7, b : 13, c : 33 }, { a : 7, b : 13 } );
//  * // returns false
//  *
//  * @returns { boolean } Returns true, if the second object (src2)
//  * has the same values as the first object(src1).
//  * @function mapsAreIdentical
//  * @throws Will throw an error if ( arguments.length !== 2 ).
//  * @namespace Tools
//  */
//
// function mapsAreIdentical( src1, src2 )
// {
//
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//   _.assert( !_.primitive.is( src1 ) );
//   _.assert( !_.primitive.is( src2 ) );
//
//   if( Object.keys( src1 ).length !== Object.keys( src2 ).length )
//   return false;
//
//   for( let s in src1 )
//   {
//     if( src1[ s ] !== src2[ s ] )
//     return false;
//   }
//
//   return true;
// }

// --
// extension
// --

/* qqq : for junior : duplicate routines */

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

//

let ExtensionMap =
{

  // equaler

  _identicalShallow,
  identicalShallow : _.props.identicalShallow,
  identical : _.props.identical,
  _equivalentShallow : _identicalShallow,
  equivalentShallow : _.props.equivalentShallow,
  equivalent : _.props.equivalent,

  containShallow,
  contain : containShallow,

  // exporter

  _exportStringDiagnosticShallow : _.props._exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _.props._exportStringCodeShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // container interface

  _lengthOf : _.props._lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */
  _hasKey : _.props._hasKey,
  hasKey : _.props._hasKey, /* qqq : cover */
  _hasCardinal : _.props._hasKey,
  hasCardinal : _.props._hasKey, /* qqq : cover */
  _keyWithCardinal : _.props._hasKey,
  keyWithCardinal : _.props._hasKey, /* qqq : cover */
  _cardinalWithKey : _.props._cardinalWithKey,
  cardinalWithKey : _.props.cardinalWithKey, /* qqq : cover */

  _elementGet : _.props._elementWithKey,
  elementGet : _.props.elementWithKey, /* qqq : cover */
  _elementWithKey : _.props._elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.props._elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal : _.props._elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _.props._elementSet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet : _.props._elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet : _.props._elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _.props._elementDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel : _.props._elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel : _.props._elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */
  _empty : _.props._empty,
  empty : _.props.empty, /* qqq : for junior : cover */

  _each : _.props._each,
  each : _.props.each, /* qqq : cover */
  _eachLeft : _.props._eachLeft,
  eachLeft : _.props.eachLeft, /* qqq : cover */
  _eachRight : _.props._eachRight,
  eachRight : _.props.eachRight, /* qqq : cover */

  _while : _.props._while,
  while : _.props.while, /* qqq : cover */
  _whileLeft : _.props._whileLeft,
  whileLeft : _.props.whileLeft, /* qqq : cover */
  _whileRight : _.props._whileRight,
  whileRight : _.props.whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct0 : _.props._filterAct0,
  _filterAct : _.props._filterAct,
  filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  filterWithoutEscape : _.props.filterWithoutEscape,
  filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  filterWithEscapeRight : _.props.filterWithEscapeRight,
  filterWithEscape : _.props.filterWithEscape,
  filter : _.props.filter,

  _mapAct0 : _.props._mapAct0,
  _mapAct : _.props._mapAct,
  mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  mapWithoutEscape : _.props.mapWithoutEscape,
  mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  mapWithEscapeRight : _.props.mapWithEscapeRight,
  mapWithEscape : _.props.mapWithEscape,
  map : _.props.map,

}

Object.assign( _.map, ExtensionMap );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Map.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Map_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Map_s */ })();

/* */  /* begin of file Module_s */ ( function Module_s() { function Module_s_naked() { ( function _l3_Module_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

const _toolsPath = _.path.canonize( __dirname + '/../../../../node_modules/Tools' );
function toolsPathGet()
{
  return _toolsPath;
}

//

const _toolsDir = _.path.canonize( __dirname + '/../../../../wtools' );
function toolsDirGet()
{
  return _toolsDir;
}

// --
// module extension
// --

var ModuleExtension =
{

  toolsPathGet,
  toolsDirGet,

}

Object.assign( _.module, ModuleExtension );

// --
// tools extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Module.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Module_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Module_s */ })();

/* */  /* begin of file Number_s */ ( function Number_s() { function Number_s_naked() { ( function _l1_Numbers_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// number
// --

function _identicalShallow( a, b )
{

  if( _.number.s.areAll( [ a, b ] ) )
  return Object.is( a, b ) || a === b;

  return false;
}

//

function identicalShallow( src1, src2, o )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( !this.is( src1 ) )
  return false;
  if( !this.is( src2 ) )
  return false;

  return this._identicalShallow( ... arguments );
}

//

function _identicalShallowStrictly( a, b )
{
  /*
  it takes into account -0 === +0 case
  */

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.number.s.areAll( [ a, b ] ) )
  return Object.is( a, b );

  return false;
}

//

function identicalShallowStrictly( src1, src2, o )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( !this.is( src1 ) )
  return false;
  if( !this.is( src2 ) )
  return false;

  return this._identicalShallowStrictly( ... arguments );
}

//

// function _equivalentShallow( a, b, accuracy )
// {
//
//   if( accuracy !== undefined )
//   _.assert( _.number.is( accuracy ) && accuracy >= 0, 'Accuracy has to be a number >= 0' );
//
//   /* qqq for junior : bad! */
//
//   if( _.number.is( a ) && _.number.is( b ) )
//   {
//     if( Object.is( a, b ) )
//     return true;
//   }
//
//   if( !_.number.is( a ) && !_.bigInt.is( a ) )
//   return false;
//
//   if( !_.number.is( b ) && !_.bigInt.is( b ) )
//   return false;
//
//   /* qqq for junior : cache results of *Is calls at the beginning of the routine */
//
//   // else
//   // {
//   //   return false;
//   // }
//
//   if( accuracy === undefined )
//   accuracy = _.accuracy;
//
//   if( _.bigInt.is( a ) )
//   {
//     if( _.intIs( b ) )
//     {
//       b = BigInt( b );
//     }
//     // else
//     // {
//     //   a = Number( a );
//     //   if( a === +Infinity || a === -Infinity )
//     //   return false;
//     // }
//   }
//
//   if( _.bigInt.is( b ) )
//   {
//     if( _.intIs( a ) )
//     {
//       a = BigInt( a );
//     }
//     // else
//     // {
//     //   b = Number( b );
//     //   if( b === +Infinity || b === -Infinity )
//     //   return false;
//     // }
//   }
//
//   if( Object.is( a, b ) )
//   return true;
//
//   if( _.bigInt.is( a ) && _.bigInt.is( b ) )
//   {
//     if( _.intIs( accuracy ) )
//     {
//       return BigIntMath.abs( a - b ) <= BigInt( accuracy );
//     }
//     else
//     {
//       let diff = BigIntMath.abs( a - b );
//       if( diff <= BigInt( Math.floor( accuracy ) ) )
//       return true;
//       if( diff > BigInt( Math.ceil( accuracy ) ) )
//       return false;
//       diff = Number( diff );
//       if( diff === Infinity || diff === -Infinity )
//       return false;
//       return Math.abs( diff ) <= accuracy;
//     }
//   }
//
//   // if( !_.number.is( a ) )
//   // return false;
//   //
//   // if( !_.number.is( b ) )
//   // return false;
//
//   return Math.abs( a - b ) <= accuracy;
//   // return +( Math.abs( a - b ) ).toFixed( 10 ) <= +( accuracy ).toFixed( 10 );
// }

//

/* xxx : qqq : refactor */
function _equivalentShallow( a, b, accuracy )
{
  let result;

  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );

  if( accuracy !== undefined )
  _.assert
  (
    ( _.number.is( accuracy ) || _.bigInt.is( accuracy ) ) && accuracy >= 0 && accuracy !== Infinity,
    'Accuracy has to be a finite Number >= 0'
  );

  let bigIntIsA = _.bigInt.is( a );
  let bigIntIsB = _.bigInt.is( b );
  let numberIsA = _.number.is( a );
  let numberIsB = _.number.is( b );

  if( !numberIsA && !bigIntIsA )
  return false;

  if( !numberIsB && !bigIntIsB )
  return false;

  if( numberIsA && numberIsB )
  {
    if( Object.is( a, b ) )
    return true;
  }

  /*
  Cases :
  a : BIF/BOF/FIB/FOB;
  b : BIF/BOF/FIB/FOB;
  accuracy : BIF/BOF/FIB/FOB;

  a       b            accuracy           implemented                covered

  BIF     BIF       BIF/BOF/FIB/FOB            +                       ++++
  BIF     BOF       BIF/BOF/FIB/FOB            +                       ++++
  BIF     FIB       BIF/BOF/FIB/FOB            +                       ++++
  BIF     FOB       BIF/BOF/FIB/FOB            +                       ++++

  BOF     BOF       BIF/BOF/FIB/FOB            +                       ++++
  BOF     FIB       BIF/BOF/FIB/FOB            +                       ++++
  BOF     FOB       BIF/BOF/FIB/FOB            +                       ++++

  FIB     FIB       BIF/BOF/FIB/FOB            +                       ++++
  FIB     FOB       BIF/BOF/FIB/FOB            +                       ++++

  FOB     FOB       BIF/BOF/FIB/FOB            +                       ++++

  Definitions :
  BIF = bigint inside range of float ( 0n, 3n, BigInt( Math.pow( 2, 52 ) ) )
  BOF = bigint outside range of float ( BigInt( Math.pow( 2, 54 ) ) )
  FIB = float inside range of bigint ( 5, 30 )
  FOB = float outside range of bigint ( 5.5, 30.1 )

  */

  if( accuracy === undefined )
  accuracy = _.accuracy;

  if( bigIntIsA && bigIntIsB ) /* a : BIF/BOF, b : BIF/BOF , accuracy : BIF/BOF/FIB/FOB  3 */
  {
    return abs( a - b ) <= accuracy;
  }

  if( bigIntIsA ) /* a : BIF/BOF, b : FIB/FOB , accuracy : BIF/BOF/FIB/FOB 4 */
  [ a, b, result ] = bigintCompare( a, b );
  if( result !== undefined )
  return result;

  // {
  //   if( _.intIs( b ) )
  //   {
  //     b = BigInt( b );
  //   }
  //   else
  //   {
  //     if( a >= Number.MIN_SAFE_INTEGER && a <= Number.MAX_SAFE_INTEGER ) /* a : BIF, b : FOB, accuracy : BIF/BOF/FIB/FOB */
  //     {
  //       a = Number( a );
  //     }
  //     else /* a : BOF, b : FOB, accuracy : BIF/BOF/FIB/FOB */
  //     {
  //       if( accuracy >= Number.MIN_SAFE_INTEGER && accuracy <= Number.MAX_SAFE_INTEGER ) /* a : BOF, b : FOB, accuracy : FIB/FOB */
  //       {
  //         let decimal = b % 1;
  //         b = BigInt( Math.floor( b ) )
  //         return abs( a - b ) <= accuracy + decimal;
  //       }
  //       else /* a : BOF, b : FOB, accuracy : BIF/BOF */
  //       {
  //         b = BigInt( Math.round( b ) );
  //       }
  //     }
  //   }
  // }

  if( bigIntIsB ) /* a : FIB/FOB, b : BIF/BOF , accuracy : BIF/BOF/FIB/FOB */
  [ b, a, result ] = bigintCompare( b, a );
  if( result !== undefined )
  return result;

  // {
  //   if( _.intIs( a ) ) /* a : FIB, b : BIF/BOF, accuracy : BIF/BOF/FIB/FOB */
  //   {
  //     a = BigInt( a );
  //   }
  //   else
  //   {
  //     if( b >= Number.MIN_SAFE_INTEGER && b <= Number.MAX_SAFE_INTEGER ) /* a : FOB, b : BIF, accuracy : BIF/BOF/FIB/FOB */
  //     {
  //       b = Number( b );
  //     }
  //     else /* a : FOB, b : BOF , accuracy : BIF/BOF/FIB/FOB */
  //     {
  //       if( accuracy >= Number.MIN_SAFE_INTEGER && accuracy <= Number.MAX_SAFE_INTEGER ) /* a : FOB, b : BOF, accuracy : FIB/FOB */
  //       {
  //         let decimal = a % 1;
  //         a = BigInt( Math.floor( a ) )
  //         return abs( a - b ) <= accuracy + decimal;
  //       }
  //       else /* a : FOB, b : BOF, accuracy : BIF/BOF */
  //       {
  //         a = BigInt( Math.round( a ) );
  //       }
  //     }
  //   }
  // }

  if( numberIsA && numberIsB ) /* a : FIB/FOB, b : FIB/FOB, accuracy : BIF/BOF/FIB/FOB 3 */
  return Math.abs( a - b ) <= accuracy;
  else
  return abs( a - b ) <= accuracy;

  /* - */

  function bigintCompare( a, b )
  {
    if( _.intIs( b ) )
    {
      b = BigInt( b );
    }
    else
    {
      if( a >= Number.MIN_SAFE_INTEGER && a <= Number.MAX_SAFE_INTEGER ) /* a : BIF, b : FOB, accuracy : BIF/BOF/FIB/FOB */
      {
        a = Number( a );
      }
      else /* a : BOF, b : FOB, accuracy : BIF/BOF/FIB/FOB */
      {
        if( accuracy >= Number.MIN_SAFE_INTEGER && accuracy <= Number.MAX_SAFE_INTEGER ) /* a : BOF, b : FOB, accuracy : FIB/FOB */
        {
          let decimal = b % 1;
          b = BigInt( Math.floor( b ) )
          return [ a, b, abs( a - b ) <= accuracy + decimal ];
        }
        else /* a : BOF, b : FOB, accuracy : BIF/BOF */
        {
          b = BigInt( Math.round( b ) );
        }
      }
    }
    return [ a, b, undefined ];
  }

  /* - */

  function sign( value )
  {
    if( value > BigInt( 0 ) )
    return BigInt( 1 );
    if( value < BigInt( 0 ) )
    return BigInt( -1 );

    return BigInt( 0 );
  }

  /* - */

  function abs( value )
  {
    if( sign( value ) === BigInt( -1 ) )
    return -value;
    return value;
  }

  /* - */

}

//

function equivalentShallow( src1, src2, accuracy )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;
  return this._equivalentShallow( ... arguments );
}

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let NumberExtension =
{

  // equaler

  _identicalShallow,
  identicalShallow,
  identical : identicalShallow,

  _identicalShallowStrictly,
  identicalShallowStrictly,
  identicalStrictly : identicalShallowStrictly,

  _equivalentShallow,
  equivalentShallow,
  equivalent : equivalentShallow,

  // areEquivalentShallow : areEquivalent,
  // areIdentical,
  // areIdenticalNotStrictly,
  // areEquivalent,

}

Object.assign( _.number, NumberExtension );

//

let NumbersExtension =
{
}

Object.assign( _.number.s, NumbersExtension );

})();


/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Number.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Number_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Number_s */ })();

/* */  /* begin of file Object_s */ ( function Object_s() { function Object_s_naked() { ( function _l3_Object_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.props._elementWithKey, 'Expects routine _.props._elementWithKey' );
_.assert( !!_.props.keys, 'Expects routine _.props.keys' );

// --
// equaler
// --

function _identicalShallow( src1, src2 )
{

  if( _.aux.is( src1 ) && _.aux.is( src2 ) )
  return _.aux._identicalShallow( src1, src2 );

  if( _.countable.is( src1 ) && _.countable.is( src2 ) )
  return _.countable._identicalShallow( src1, src2 );

  let equal = _.class.methodEqualOf( src1 ) || _.class.methodEqualOf( src2 );
  if( equal )
  return equal( src1, src2, {} );

  return src1 === src2;
}

//

function _equivalentShallow( src1, src2 )
{

  if( _.aux.is( src1 ) && _.aux.is( src2 ) )
  return _.aux._equivalentShallow( src1, src2 );

  if( _.countable.is( src1 ) && _.countable.is( src2 ) )
  return _.countable._equivalentShallow( src1, src2 );

  let equal = _.class.methodEqualOf( src1 ) || _.class.methodEqualOf( src2 );

  if( equal )
  return equal( src1, src2, {} );

  return src1 === src2;
}

// --
// exporter
// --

function _exportStringDiagnosticShallow( src )
{
  let result = '';
  let method = _.class.methodExportStringOf( src );

  if( method )
  {
    result = method.call( src, { verbosity : 1 } );
    result = _.strShort_( result ).result;
  }
  else
  {
    if( _.countable.is( src ) )
    result = _.countable.exportStringDiagnosticShallow( src );
    else
    result = `{- ${_.entity.strType( src )} -}`;
  }

  return result;
}

// --
// inspector
// --

function _lengthOf( src )
{
  if( _.countable.is( src ) )
  return _.countable._lengthOf( src );
  return _.props._lengthOf( src );
}

//

function _hasKey( src, key )
{
  // if( _.number.is( key ) )
  if( _.countable.is( src ) && _.number.is( key ) )
  return _.countable._hasKey( src, key );
  return _.props._hasKey( src, key );
}

//

function _hasCardinal( src, cardinal )
{
  if( _.countable.is( src ) )
  return _.countable._hasCardinal( src, cardinal );
  return _.props._hasCardinal( src, cardinal );
}

//

function _keyWithCardinal( src, cardinal )
{
  if( _.countable.is( src ) )
  return _.countable._keyWithCardinal( src, cardinal );
  return _.props._keyWithCardinal( src, cardinal );
}

//

function _cardinalWithKey( src, key )
{
  if( _.countable.is( src ) )
  return _.countable._cardinalWithKey( src, key );
  return _.props._cardinalWithKey( src, key );
}

// --
// elementor
// --

function _elementWithKey( src, key )
{
  // if( _.number.is( key ) )
  if( _.countable.is( src ) && _.number.is( key ) )
  return _.countable._elementWithKey( src, key );
  return _.props._elementWithKey( src, key );
}

//

function _elementWithCardinal( src, cardinal )
{
  if( _.countable.is( src ) )
  return _.countable._elementWithCardinal( src, cardinal );
  return _.props._elementWithCardinal( src, cardinal );
}

//

function _elementWithKeySet( dst, key, val )
{
  // if( _.number.is( key ) )
  if( _.countable.is( src ) && _.number.is( key ) )
  return _.countable._elementWithKeySet( dst, key, val );
  return _.props._elementWithKeySet( dst, key, val );
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{
  if( _.countable.is( dst ) )
  return _.countable._elementWithCardinalSet( dst, cardinal, val );
  return _.props._elementWithCardinalSet( dst, cardinal, val );
}

//

function _elementWithKeyDel( dst, key )
{
  // if( _.number.is( key ) )
  if( _.countable.is( src ) && _.number.is( key ) )
  return _.countable._elementWithKeyDel( dst, key );
  return _.props._elementWithKeyDel( dst, key );
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  if( _.countable.is( dst ) )
  return _.countable._elementWithCardinalDel( dst, cardinal );
  return _.props._elementWithCardinalDel( dst, cardinal );
}

//

function _empty( dst )
{
  if( _.countable.is( dst ) )
  return _.countable._empty( dst );
  return _.props._empty( dst );
}

// --
// iterator
// --

function _eachLeft( src, onEach )
{
  if( _.countable.is( src ) )
  return _.countable._eachLeft( src, onEach );
  return _.props._eachLeft( src, onEach );
}

//

function _eachRight( src, onEach )
{
  if( _.countable.is( src ) )
  return _.countable._eachRight( src, onEach );
  return _.props._eachRight( src, onEach );
}

//

function _whileLeft( src, onEach )
{
  if( _.countable.is( src ) )
  return _.countable._whileLeft( src, onEach );
  return _.props._whileLeft( src, onEach );
}

//

function _whileRight( src, onEach )
{
  if( _.countable.is( src ) )
  return _.countable._whileRight( src, onEach );
  return _.props._whileRight( src, onEach );
}

//

function _filterAct0( dst, src, ... args )
{
  if( _.countable.is( src ) )
  return _.countable._filterAct0( dst, src, ... args );
  return _.props._filterAct0( dst, src, ... args );
}

//

function _mapAct0( dst, src, ... args )
{
  if( _.countable.is( src ) )
  return _.countable._mapAct0( dst, src, ... args );
  return _.props._mapAct0( dst, src, ... args );
}

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let ObjectExtension =
{

  // equaler

  _identicalShallow,
  identicalShallow : _.props.identicalShallow,
  identical : _.props.identical,
  _equivalentShallow : _identicalShallow,
  equivalentShallow : _.props.equivalentShallow,
  equivalent : _.props.equivalent,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // inspector

  _lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */
  _hasKey,
  hasKey : _.props.hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal : _.props.hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal : _.props.keyWithCardinal, /* qqq : cover */
  _cardinalWithKey,
  cardinalWithKey : _.props.cardinalWithKey, /* qqq : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : _.props.elementGet, /* qqq : cover */
  _elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.props._elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty : _.props.empty, /* qqq : for junior : cover */

  // iterator

  _each : _eachLeft,
  each : _.props.each, /* qqq : cover */
  _eachLeft,
  eachLeft : _.props.eachLeft, /* qqq : cover */
  _eachRight,
  eachRight : _.props.eachRight, /* qqq : cover */

  _while : _whileLeft,
  while : _.props.while, /* qqq : cover */
  _whileLeft,
  whileLeft : _.props.whileLeft, /* qqq : cover */
  _whileRight,
  whileRight : _.props.whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct0,
  _filterAct : _.props._filterAct,
  filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  filterWithoutEscape : _.props.filterWithoutEscape,
  filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  filterWithEscapeRight : _.props.filterWithEscapeRight,
  filterWithEscape : _.props.filterWithEscape,
  filter : _.props.filter,

  _mapAct0,
  _mapAct : _.props._mapAct,
  mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  mapWithoutEscape : _.props.mapWithoutEscape,
  mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  mapWithEscapeRight : _.props.mapWithEscapeRight,
  mapWithEscape : _.props.mapWithEscape,
  map : _.props.map,

}

//

Object.assign( _.object, ObjectExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Object.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Object_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Object_s */ })();

/* */  /* begin of file Primitive_s */ ( function Primitive_s() { function Primitive_s_naked() { ( function _l3_Primitive_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// primitive
// --

function _identicalShallow( src1, src2 )
{

  if( !_.primitive.is( src1 ) )
  return false;
  if( !_.primitive.is( src2 ) )
  return false;

  return Object.is( src1, src2 );
}

//

function identicalShallow( src1, src2, o )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;

  return this._identicalShallow( ... arguments );
}

//

function _equivalentShallow( src1, src2, accuracy )
{

  if( _.strsAreAll([ src1, src2 ]) )
  return _.str.equivalentShallow( src1, src2 );

  if( _.bool.like( src1 ) && _.bool.like( src2 ) )
  return _.bool.equivalentShallow( src1, src2 );

  if
  (
    ( _.number.is( src1 ) || _.bigInt.is( src1 ) )
    && ( _.number.is( src2 ) || _.bigInt.is( src2 ) )
  )
  return _.number.equivalentShallow( src1, src2, accuracy );

  return Object.is( src1, src2 );
}

//

function equivalentShallow( src1, src2, accuracy )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.like( src1 ) )
  return false;
  if( !this.like( src2 ) )
  return false;
  return this._equivalentShallow( ... arguments );
}

// --
//
// --

function exportStringCodeShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.primitive.is( src ) );

  if( _.symbol.is( src ) )
  return _.symbol.exportStringCodeShallow( src );

  if( _.bigInt.is( src ) )
  return _.bigInt.exportStringCodeShallow( src );

  if( _.strIs( src ) )
  return `'${src}'`;

  return String( src );
}

//

function exportStringDiagnosticShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.primitive.is( src ) );

  if( _.symbol.is( src ) )
  return _.symbol.exportStringDiagnosticShallow( src );

  if( _.bigInt.is( src ) )
  return _.bigInt.exportStringDiagnosticShallow( src );

  return String( src );
}

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let PrimitiveExtension =
{

  // equaler

  _identicalShallow,
  identicalShallow,
  identical : identicalShallow,
  _equivalentShallow,
  equivalentShallow,
  equivalent : equivalentShallow,

  // exporter

  exportStringCodeShallow,
  exportStringDiagnosticShallow,
  exportString : exportStringDiagnosticShallow,

}

Object.assign( _.primitive, PrimitiveExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Primitive.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Primitive_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Primitive_s */ })();

/* */  /* begin of file Process_s */ ( function Process_s() { function Process_s_naked() { ( function _l3_Process_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

function on( o )
{
  o = _.event.onHead( _.event.on, arguments );
  return _.event.on( this._edispatcher, o );
}

on.defaults =
{
  callbackMap : null,
};

//

function once( o )
{
  o = _.event.onHead( _.event.once, arguments );
  return _.event.once( this._edispatcher, o );
}

once.defaults =
{
  callbackMap : null,
};

//

function off( o )
{
  o = _.event.offHead( _.event.off, arguments );
  return _.event.off( this._edispatcher, o );
}

off.defaults =
{
  callbackMap : null,
};

//

function eventHasHandler( o )
{
  o = _.event.eventHasHandlerHead( _.event.eventHasHandler, arguments );
  return _.event.eventHasHandler( this._edispatcher, o );
}

eventHasHandler.defaults =
{
  eventName : null,
  eventHandler : null,
}

//

function eventGive()
{
  let o = _.event.eventGiveHead( this._edispatcher, eventGive, arguments );
  return _.event.eventGive( this._edispatcher, o );
  // return _.event.eventGive( this._edispatcher, ... arguments );
}

eventGive.defaults =
{
  ... _.event.eventGive.defaults,
  origination : null,
  err : null,
}

// --
//
// --

let Inspector = null;
function isDebugged()
{
  _.assert( arguments.length === 0, 'Expects no arguments' );

  // return false; // xxx

  if( typeof process === 'undefined' )
  return false;

  if( Inspector === null )
  try
  {
    Inspector = require( 'inspector' );
  }
  catch( err )
  {
    Inspector = false;
  }

  if( Inspector )
  return _.strIs( Inspector.url() );

  if( !process.execArgv.length )
  return false;

  let execArgvString = process.execArgv.join();
  return _.strHasAny( execArgvString, [ '--inspect', '--inspect-brk', '--debug-brk' ] );
}

//

function insideTestContainer()
{
  if( !_global_.process )
  return false;
  return 'CI' in _global_.process.env;
}

//

function entryPointStructure()
{
  let result = Object.create( null );
  if( _global.process !== undefined )
  {
    if( _global.process.argv )
    result.execPath = _global.process.argv.join( ' ' );
    if( _.routine.is( _global.process.cwd ) )
    result.currentPath = _global.process.cwd();
  }
  return result;
}

//

function entryPointInfo()
{
  let data = _.process.entryPointStructure();
  let result = '';

  if( data.currentPath )
  result = join( 'Current path', data.currentPath );
  if( data.execPath )
  result = join( 'Exec path', data.execPath );

  return result;

  /* */

  function join( left, right )
  {
    if( result )
    result += '\n';
    result += left + ' : ' + right;
    return result;
  }
}

// --
// implementation
// --

let Events =
{
  'available' : [],
  'uncaughtError' : [],
}

let _edispatcher =
{
  events : Events,
}

let Extension =
{

  // event

  _edispatcher,
  on,
  once,
  off,
  eventHasHandler,
  eventGive,

  // dichotomy

  isDebugged,
  insideTestContainer,

  // entry point

  entryPointStructure,
  entryPointInfo,

}

//

Object.assign( _.process, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Process.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Process_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Process_s */ })();

/* */  /* begin of file Regexp_s */ ( function Regexp_s() { function Regexp_s_naked() { ( function _l3_Regexp_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// regexp
// --

function _identicalShallow( src1, src2 )
{
  return src1.source === src2.source && src1.flags === src2.flags;
}

//

function identicalShallow( src1, src2, o )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !_.regexp.is( src1 ) || !_.regexp.is( src2 ) )
  return false;
  return _.regexp._identicalShallow( src1, src2 );
}

//

function _equivalentShallow( src1, src2 )
{
  let strIs1 = _.strIs( src1 );
  let strIs2 = _.strIs( src2 );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( !strIs1 && strIs2 )
  return _.regexp._equivalentShallow( src2, src1 );

  _.assert( _.regexpLike( src1 ), 'Expects string-like ( string or regexp )' );
  _.assert( _.regexpLike( src1 ), 'Expects string-like ( string or regexp )' );

  if( strIs1 && strIs2 )
  {
    return src1 === src2;
    // if( src1 === src2 )
    // return true;
    // return _.str.lines.strip( src1 ) === _.str.lines.strip( src2 );
  }
  else if( strIs1 )
  {
    _.assert( !!src2.exec );
    let matched = src2.exec( src1 );
    if( !matched )
    return false;
    if( matched[ 0 ].length !== src1.length )
    return false;
    return true;
  }
  else
  {
    return _.regexp.identical( src1, src2 );
  }

  return false;
}

//

function equivalentShallow( src1, src2 )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !_.regexp.like( src1 ) || !_.regexp.like( src2 ) )
  return false;
  return _.regexp._equivalentShallow( src1, src2 );
}

//

function exportStringDiagnosticShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.regexp.is( src ) );

  return `/${src.source}/${src.flags}`;
}

// --
// extension
// --

let ToolsExtension =
{

  regexpIdentical : identicalShallow,
  regexpEquivalent : equivalentShallow,

}

Object.assign( _, ToolsExtension )

//

let RegexpExtension =
{

  // regexp

  _identicalShallow,
  identicalShallow,
  identical : identicalShallow,
  _equivalentShallow,
  equivalentShallow,
  equivalent : equivalentShallow,

  // exporter

  exportString : exportStringDiagnosticShallow,
  exportStringDiagnosticShallow,
  exportStringCodeShallow : exportStringDiagnosticShallow,

}

Object.assign( _.regexp, RegexpExtension )

//

let RegexpsExtension =
{


}

Object.assign( _.regexp.s, RegexpsExtension )

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Regexp.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Regexp_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Regexp_s */ })();

/* */  /* begin of file Routine_s */ ( function Routine_s() { function Routine_s_naked() { ( function _l3_Routine_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

/* qqq : for Dmytro : update jsdoc, please */
/**
 * The routine er() extend mechanism of routines constructing of routine routine.unite().
 * The routine er() adds to routine {-routine-} field {-er-} that is a functor for generating
 * of new routine similar to original routine but with changed map {-defaults-}.
 *
 * @example
 * function test_head( routine, args )
 * {
 *   let o = args[ 0 ];
 *   if( !_.mapIs( o ) )
 *   {
 *     if( o !== undefined )
 *     o = { arg : 0 };
 *     else
 *     o = Object.create( null );
 *   }
 *
 *   _.routine.options( routine, o );
 *   return o;
 * }
 *
 * function test_body( o )
 * {
 *   return o;
 * }
 * test_body.defaults = { arg : null, arg2 : 'arg2' };
 *
 * let routine = _.routine.unite( test_head, test_body );
 * console.log( routine.er === undefined );
 * // log : true
 *
 * let erhead = ( routine, args ) =>
 * {
 *   if( _.mapIs( args[ 0 ] ) )
 *   return args[ 0 ];
 *   return { 'arg' : args[ 0 ] };
 * };
 * _.routine.er( routine, erhead );
 * console.log( _.routine.is( routine.er ) );
 * // log : true
 *
 * let newRoutine = routine.er( 'arg1' );
 * console.log( newRoutine.defaults );
 * // log : { arg : 'arg1', arg2 : 'arg2' }
 *
 * var resultOld = routine();
 * console.log( resultOld );
 * // log : { arg : null, arg2 : 'arg2' }
 * var resultNew = newRoutine();
 * console.log( resultNew );
 * // log : { arg : 'arg1', arg2 : 'arg2' }
 *
 * @param { Function } routine - The routine from which generates new routine.
 * Routine should be generated by routine.unite.
 * @param { Function } erhead - The routine to make map {-defaults-} for new routine.
 * @returns { Function } - Returns original routine with functor in field {-er-}.
 * @function er
 * @throws { Error } If arguments.length neither is 1, nor 2.
 * @throws { Error } If {-routine-} is not a Function.
 * @throws { Error } If {-erhead-} is not a Function.
 * @throws { Error } If {-routine-} has not fields {-head-} and {-body-}.
 * The fields should have type Function.
 * @namespace Tools
 */

function er( routine, erhead )
{
  if( routine.er )
  return routine.er; /* Dmytro : maybe before return should be assert like : _.assert( _.routine.is( routine.er ) ) */
  routine.er = _.routine.erMake( ... arguments );
  return routine;
}

//

/* qqq : for Dmytro : update jsdoc, please */
/**
 * The routine erMake() extend mechanism of routines constructing of routine routine.unite().
 * The routine erMake() returns functor for generating of new routine similar to original
 * routine {-routine-} but with changed map {-defaults-}.
 *
 * @example
 * function test_head( routine, args )
 * {
 *   let o = args[ 0 ];
 *   if( !_.mapIs( o ) )
 *   {
 *     if( o !== undefined )
 *     o = { arg : 0 };
 *     else
 *     o = Object.create( null );
 *   }
 *
 *   _.routine.options( routine, o );
 *   return o;
 * }
 *
 * function test_body( o )
 * {
 *   return o;
 * }
 * test_body.defaults = { arg : null, arg2 : 'arg2' };
 *
 * let routine = _.routine.unite( test_head, test_body );
 * let erhead = ( routine, args ) =>
 * {
 *   if( _.mapIs( args[ 0 ] ) )
 *   return args[ 0 ];
 *   return { 'arg' : args[ 0 ] };
 * };
 * let functor = _.routine.erMake( routine, erhead );
 * console.log( _.routine.is( functor ) );
 * // log : true
 *
 * let newRoutine = functor( 'arg1' );
 * console.log( newRoutine.defaults );
 * // log : { arg : 'arg1', arg2 : 'arg2' }
 *
 * var resultOld = routine();
 * console.log( resultOld );
 * // log : { arg : null, arg2 : 'arg2' }
 * var resultNew = newRoutine();
 * console.log( resultNew );
 * // log : { arg : 'arg1', arg2 : 'arg2' }
 *
 * @param { Function } routine - The routine from which generates new routine.
 * Routine should be generated by routine.unite.
 * @param { Function } erhead - The routine to make map {-defaults-} for new routine.
 * @returns { Function } - Returns functor to generate new routine with changed map {-defaults-}.
 * @function erMake
 * @throws { Error } If arguments.length neither is 1, nor 2.
 * @throws { Error } If {-routine-} is not a Function.
 * @throws { Error } If {-erhead-} is not a Function.
 * @throws { Error } If {-routine-} has not fields {-head-} and {-body-}.
 * The fields should have type Function.
 * @namespace Tools
 */

function erMake( routine, erhead )
{

  erhead = erhead || routine.erhead || routine.head;
  let head = routine.head;
  let body = routine.body;
  let defaults = routine.defaults;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.routine.is( routine ) );
  _.assert( _.routine.is( erhead ) );
  _.assert( _.routine.is( head ) );
  _.assert( _.routine.is( body ) );
  _.assert( _.object.isBasic( defaults ) );

  return erMake;

  function erMake()
  {
    let self = this;
    let op = erhead.call( self, routine, arguments );

    _.assert( _.mapIs( op ) );
    _.map.assertHasOnly( op, defaults );

    er.defaults = _.props.supplement( op, defaults );

    return er;

    function er()
    {
      let result;
      let op2 = head.call( self, er, arguments );
      if( _.unrollIs( op2 ) )
      result = body.apply( self, op2 );
      else if( _.mapIs( op2 ) )
      result = body.call( self, op2 );
      return result;
    }

  }

}

// --
//
// --

function exportStringDiagnosticShallow( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.routine.is( src ) );

  if( src.name )
  return `{- routine ${src.name} -}`;
  else
  return `{- routine.anonymous -}`;
}

// --
// extension
// --

let RoutineExtension =
{

  // er

  er,
  erMake,

  // exporter

  exportString : exportStringDiagnosticShallow,
  // exportStringDiagnosticShallow : exportStringDiagnosticShallow,
  exportStringDiagnosticShallow,
  exportStringCodeShallow : exportStringDiagnosticShallow,
  // exportStringDiagnostic : exportStringDiagnosticShallow,
  // exportStringCode : exportStringDiagnosticShallow,

}

//

Object.assign( _.routine, RoutineExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Routine.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Routine_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Routine_s */ })();

/* */  /* begin of file Seeker_s */ ( function Seeker_s() { function Seeker_s_naked() { ( function _l3_Seeker_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Seeker.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Seeker_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Seeker_s */ })();

/* */  /* begin of file Set_s */ ( function Set_s() { function Set_s_naked() { ( function _l3_Set_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

function toArray( src )
{
  _.assert( arguments.length === 1 );
  _.assert( _.set.like( src ) );
  return [ ... src ];
}

//

function setsToArrays( srcs )
{
  _.assert( arguments.length === 1 );
  _.assert( _.longIs( srcs ) );
  let result = [];
  for( let s = 0, l = srcs.length ; s < l ; s++ )
  result[ s ] = _.set.toArray( srcs[ s ] );
  return result;
}

// --
// exporter
// --

function _exportStringDiagnosticShallow( src, o )
{
  return `{- ${_.entity.strType( src )} with ${_.entity.lengthOf( src )} elements -}`;
}

// --
// equaler
// --

function _identicalShallow( src1, src2 )
{
  if( src1.size !== src2.size)
  return false;

  for( let el of src1 )
  if( !src2.has( el ) )
  return false;

  return true;
}

// --
// container interface
// --

function _lengthOf( src )
{
  return src.size;
}

//

function _hasKey( src, key )
{
  return src.has( key );
}

//

function _hasCardinal( src, cardinal )
{
  if( cardinal < 0 )
  return false;
  return cardinal < src.size;
}

//

function _keyWithCardinal( src, cardinal )
{
  if( cardinal < 0 || src.size <= cardinal )
  return [ undefined, false ];
  return [ [ ... src ][ cardinal ], true ];
}

//

function _cardinalWithKey( src, key )
{
  return [ ... src ].indexOf( key );
}

//

function _elementWithKey( src, key )
{
  if( src.has( key ) )
  return [ key, key, true ];
  return [ undefined, key, false ];
}

//

function _elementWithCardinal( src, key )
{
  if( key < 0 || src.size <= key || !_.numberIs( key ) )
  if( src.size <= key || !_.number.is( key ) )
  return [ undefined, key, false ];
  return [ [ ... src ][ key ], key, true ];
}

//

function _elementWithKeySet( dst, key, val )
{
  // debugger;
  dst.add( val );
  return [ val, true ];
}

//

function _elementWithCardinalSet( dst, cardinal, val )
{
  let was = this._elementWithCardinal( dst, cardinal );
  if( was[ 2 ] === true )
  {
    dst.delete( was[ 0 ] );
    dst.add( val );
    return [ val, true ];
  }
  else
  {
    return [ cardinal, false ];
  }
}

//

function _elementWithKeyDel( dst, key )
{
  if( !this._hasKey( dst, key ) )
  return false;
  dst.delete( key );
  return true;
}

//

function _elementWithCardinalDel( dst, cardinal )
{
  let has = this._keyWithCardinal( dst, cardinal );
  if( !has[ 1 ] )
  return false;
  dst.delete( has[ 0 ] );
  return true;
}

//

function _empty( dst )
{
  dst.clear();
  return dst;
}

//

function _eachLeft( src, onEach )
{
  let c = 0;
  for( let e of src )
  {
    onEach( e, e, c, src );
    c += 1;
  }
}

//

function _eachRight( src, onEach )
{
  let src2 = [ ... src ];
  for( let k = src2.length-1 ; k >= 0 ; k-- )
  {
    let e = src[ k ];
    onEach( e, e, k, src );
  }
}

//

function _whileLeft( src, onEach )
{
  if( src.size === 0 )
  return [ undefined, undefined, -1, true ];
  let c = 0;
  let laste;
  for( let e of src )
  {
    let r = onEach( e, e, c, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ e, e, c, false ];
    laste = e;
    c += 1;
  }
  return [ laste, laste, src.size-1, true ];
}

//

function _whileRight( src, onEach )
{
  if( src.size === 0 )
  return [ undefined, undefined, -1, true ];
  var src2 = [ ... src ];
  for( let k = src2.length-1 ; k >= 0 ; k-- )
  {
    var e = src2[ k ];
    let r = onEach( e, e, k, src );
    _.assert( r === true || r === false );
    if( r === false )
    return [ e, e, k, false ];
  }
  var e = src2[ 0 ];
  return [ e, e, 0, true ];
}

// --
// set extension
// --

let SetExtension =
{

  // from,
  toArray,

  // equaler

  _identicalShallow,
  identicalShallow : _.props.identicalShallow,
  identical : _.props.identical,
  _equivalentShallow : _identicalShallow,
  equivalentShallow : _.props.equivalentShallow,
  equivalent : _.props.equivalent,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.props.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : _.props.exportStringCodeShallow,
  exportString : _.props.exportString,

  // inspector

  _lengthOf,
  lengthOf : _.props.lengthOf, /* qqq : cover */
  _hasKey,
  hasKey : _.props.hasKey, /* qqq : cover */
  _hasCardinal,
  hasCardinal : _.props.hasCardinal, /* qqq : cover */
  _keyWithCardinal,
  keyWithCardinal : _.props.keyWithCardinal, /* qqq : cover */
  _cardinalWithKey,
  cardinalWithKey : _.props.cardinalWithKey, /* qqq : cover */

  // elementor

  _elementGet : _elementWithKey,
  elementGet : _.props.elementGet, /* qqq : cover */
  _elementWithKey,
  elementWithKey : _.props.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.props._elementWithImplicit,
  elementWithImplicit : _.props.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal,
  elementWithCardinal : _.props.elementWithCardinal,  /* qqq : cover */

  _elementSet : _elementWithKeySet,
  elementSet : _.props.elementSet, /* qqq : cover */
  _elementWithKeySet,
  elementWithKeySet : _.props.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet,
  elementWithCardinalSet : _.props.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _elementWithKeyDel,
  elementDel : _.props.elementDel, /* qqq : cover */
  _elementWithKeyDel,
  elementWithKeyDel : _.props.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel,
  elementWithCardinalDel : _.props.elementWithCardinalDel,  /* qqq : cover */
  _empty,
  empty : _.props.empty, /* qqq : for junior : cover */

  // iterator

  _each : _eachLeft,
  each : _.props.each, /* qqq : cover */
  _eachLeft,
  eachLeft : _.props.eachLeft, /* qqq : cover */
  _eachRight,
  eachRight : _.props.eachRight, /* qqq : cover */

  _while : _whileLeft,
  while : _.props.while, /* qqq : cover */
  _whileLeft,
  whileLeft : _.props.whileLeft, /* qqq : cover */
  _whileRight,
  whileRight : _.props.whileRight, /* qqq : cover */

  _aptLeft : _.props._aptLeft,
  aptLeft : _.props.aptLeft, /* qqq : cover */
  first : _.props.first,
  _aptRight : _.props._aptRight, /* qqq : cover */
  aptRight : _.props.aptRight,
  last : _.props.last, /* qqq : cover */

  _filterAct0 : _.props._filterAct0,
  _filterAct : _.props._filterAct,
  filterWithoutEscapeLeft : _.props.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.props.filterWithoutEscapeRight,
  filterWithoutEscape : _.props.filterWithoutEscape,
  filterWithEscapeLeft : _.props.filterWithEscapeLeft,
  filterWithEscapeRight : _.props.filterWithEscapeRight,
  filterWithEscape : _.props.filterWithEscape,
  filter : _.props.filter,

  _mapAct0 : _.props._mapAct0,
  _mapAct : _.props._mapAct,
  mapWithoutEscapeLeft : _.props.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.props.mapWithoutEscapeRight,
  mapWithoutEscape : _.props.mapWithoutEscape,
  mapWithEscapeLeft : _.props.mapWithEscapeLeft,
  mapWithEscapeRight : _.props.mapWithEscapeRight,
  mapWithEscape : _.props.mapWithEscape,
  map : _.props.map,

}

Object.assign( _.set, SetExtension );

// --
// sets extension
// --

let SetsExtension =
{

  // set

  // from : setsFrom,
  toArrays : setsToArrays,

}

Object.assign( _.sets, SetsExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  setToArray : toArray,
  setsToArrays,

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Set.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Set_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Set_s */ })();

/* */  /* begin of file Str_s */ ( function Str_s() { function Str_s_naked() { ( function _l3_Str_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// exporter
// --

function _exportStringDiagnosticShallow( src, o )
{
  return src;
}

//

function exportStringDiagnosticShallow( src, o )
{
  let result;
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects 1 or 2 arguments' );
  _.assert( this.like( src ) );
  return this._exportStringDiagnosticShallow( ... arguments );
}

//

function _exportStringCodeShallow( src, o )
{
  return `'${src}'`;
}

//

function exportStringCodeShallow( src, o )
{
  let result;
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects 1 or 2 arguments' );
  _.assert( this.like( src ) );
  return this._exportStringCodeShallow( ... arguments );
}

// --
// equaler
// --

function _identicalShallow( src1, src2 )
{
  return src1 === src2;
}

//

function identicalShallow( src1, src2, accuracy )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !this.is( src1 ) )
  return false;
  if( !this.is( src2 ) )
  return false;
  return this._identicalShallow( ... arguments );
}

//

// function _equivalentShallow( src1, src2 )
// {
//   let strIs1 = _.strIs( src1 );
//   let strIs2 = _.strIs( src2 );
//
//   // _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//   //
//   // if( !strIs1 && strIs2 )
//   // return this._equivalentShallow( src2, src1 );
//
//   // _.assert( _.regexpLike( src1 ), 'Expects string-like ( string or regexp )' );
//   // _.assert( _.regexpLike( src1 ), 'Expects string-like ( string or regexp )' );
//
//   if( strIs1 && strIs2 )
//   {
//     /* qqq : for junior : bad | aaa : Fixed. */
//     if( src1 === src2 )
//     return true;
//     return _.str.lines.strip( src1 ) === _.str.lines.strip( src2 );
//   }
//   else
//   {
//     return false;
//     // return _.regexpIdentical( src1, src2 );
//   }
//
//   return false;
// }

//
//
// function _equivalentShallow( src1, src2 )
// {
//   let strIs1 = _.strIs( src1 );
//   let strIs2 = _.strIs( src2 );
//
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//
//   if( !strIs1 && strIs2 )
//   return this._equivalentShallow( src2, src1 );
//
//   _.assert( _.regexpLike( src1 ), 'Expects string-like ( string or regexp )' );
//   _.assert( _.regexpLike( src1 ), 'Expects string-like ( string or regexp )' );
//
//   if( strIs1 && strIs2 )
//   {
//     /* qqq : for junior : bad | aaa : Fixed. */
//     if( src1 === src2 )
//     return true;
//
//     return _.str.lines.strip( src1 ) === _.str.lines.strip( src2 );
//
//   }
//   else if( strIs1 )
//   {
//     _.assert( !!src2.exec );
//     let matched = src2.exec( src1 );
//     if( !matched )
//     return false;
//     if( matched[ 0 ].length !== src1.length )
//     return false;
//     return true;
//   }
//   else
//   {
//     return _.regexpIdentical( src1, src2 );
//   }
//
//   return false;
// }

//

function _equivalentShallow( src1, src2 )
{
  let strIs1 = _.strIs( src1 );
  let strIs2 = _.strIs( src2 );

  if( !strIs1 && strIs2 )
  return this._equivalentShallow( src2, src1 );

  if( strIs1 && strIs2 )
  {
    if( src1 === src2 )
    return true;
    return _.str.lines.strip( src1 ) === _.str.lines.strip( src2 );
  }
  else if( strIs1 )
  {
    _.assert( !!src2.exec );
    let matched = src2.exec( src1 );
    if( !matched )
    return false;
    if( matched[ 0 ].length !== src1.length )
    return false;
    return true;
  }
  else
  {
    return _.regexpIdentical( src1, src2 );
  }

  return false;
}

//

function equivalentShallow( src1, src2, accuracy )
{
  _.assert( arguments.length === 2 || arguments.length === 3 );
  if( !_.regexp.like( src1 ) )
  return false;
  if( !_.regexp.like( src2 ) )
  return false;
  return _.str._equivalentShallow( ... arguments );
}

//
// //
//
// function strsEquivalent( src1, src2 )
// {
//
//   _.assert( _.strIs( src1 ) || _.regexpIs( src1 ) || _.longIs( src1 ), 'Expects string/regexp or array of strings/regexps {-src1-}' );
//   _.assert( _.strIs( src2 ) || _.regexpIs( src2 ) || _.longIs( src2 ), 'Expects string/regexp or array of strings/regexps {-src2-}' );
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//
//   let isLong1 = _.longIs( src1 );
//   let isLong2 = _.longIs( src2 );
//
//   if( isLong1 && isLong2 )
//   {
//     let result = [];
//     _.assert( src1.length === src2.length );
//     for( let i = 0, len = src1.length ; i < len; i++ )
//     {
//       result[ i ] = _.str.equivalent( src1[ i ], src2[ i ] );
//     }
//     return result;
//   }
//   else if( !isLong1 && isLong2 )
//   {
//     let result = [];
//     for( let i = 0, len = src2.length ; i < len; i++ )
//     {
//       result[ i ] = _.str.equivalent( src1, src2[ i ] );
//     }
//     return result;
//   }
//   else if( isLong1 && !isLong2 )
//   {
//     let result = [];
//     for( let i = 0, len = src1.length ; i < len; i++ )
//     {
//       result[ i ] = _.str.equivalent( src1[ i ], src2 );
//     }
//     return result;
//   }
//   else
//   {
//     return _.str.equivalent( src1, src2 );
//   }
//
// }

// --
//
// --

/**
  * Prepends string( begin ) to the source( src ) if prefix( begin ) is not match with first chars of string( src ),
  * otherwise returns original string.
  * @param { String } src - Source string to parse.
  * @param { String } begin - String to prepend.
  *
  * @example
  * _.strPrependOnce( 'test', 'test' );
  * // returns 'test'
  *
  * @example
  * _.strPrependOnce( 'abc', 'x' );
  * // returns 'xabc'
  *
  * @returns { String } Returns result of prepending string( begin ) to source( src ) or original string.
  * @function prependOnce
  * @namespace Tools
  */

function prependOnce( src, begin )
{
  _.assert( _.strIs( src ) && _.strIs( begin ), 'Expects {-src-} and {-begin-} as strings' );
  if( src.lastIndexOf( begin, 0 ) === 0 )
  return src;
  else
  return begin + src;
}

//

/**
  * Appends string( end ) to the source( src ) if postfix( end ) is not match with last chars of string( src ),
  * otherwise returns original string.
  * @param {string} src - Source string to parse.
  * @param {string} end - String to append.
  *
  * @example
  * _.strAppendOnce( 'test', 'test' );
  * // returns 'test'
  *
  * @example
  * _.strAppendOnce( 'abc', 'x' );
  * // returns 'abcx'
  *
  * @returns {string} Returns result of appending string( end ) to source( src ) or original string.
  * @function appendOnce
  * @namespace Tools
  */

function appendOnce( src, end )
{
  _.assert( _.strIs( src ) && _.strIs( end ), 'Expects {-src-} and {-end-} as strings' );
  if( src.indexOf( end, src.length - end.length ) === -1 )
  return src + end;
  else
  return src;
}

// --
// str extension
// --

let StrExtension =
{

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow,
  _exportStringCodeShallow,
  exportStringCodeShallow,
  exportString : exportStringDiagnosticShallow,

  // equaler

  _identicalShallow,
  identicalShallow,
  identical : identicalShallow,
  _equivalentShallow,
  equivalentShallow,
  equivalent : equivalentShallow,

  prependOnce,
  appendOnce,

}

Object.assign( _.str, StrExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  /* qqq : for Rahul : ask */

  strPrependOnce : prependOnce,
  strAppendOnce : appendOnce,

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Str.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Str_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Str_s */ })();

/* */  /* begin of file Stringer_s */ ( function Stringer_s() { function Stringer_s_naked() { ( function _l3_Stringer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.stringer = _.stringer || Object.create( null );

// --
// implementation
// --

// --
// stringer extension
// --

let StringerExtension =
{
}

Object.assign( _.stringer, StringerExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Stringer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Stringer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Stringer_s */ })();

/* */  /* begin of file Time_s */ ( function Time_s() { function Time_s_naked() { ( function _l3_Time_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function _sleep( delay )
{
  _.assert( _.intIs( delay ) && delay >= 0, 'Specify valid value {-delay-}.' );
  let now = _.time.now();
  while( ( _.time.now() - now ) < delay )
  {
    if( Math.random() === 0 );
  }
}

//

/**
 * The routine sleep() suspends program execution on time delay {-delay-}.
 *
 * @example
 * let result = [];
 * let periodic = _.time.periodic( 100, () => result.length < 10 ? result.push( 1 ) : undefined );
 * let before = _.time.now();
 *  _.time.sleep( 500 );
 * console.log( result.length <= 1 );
 * // log : true
 * let after = _.time.now();
 * let delta = after - before;
 * console.log( delta <= 550 );
 * // log : true
 *
 * @param { Number } delay - The delay to suspend program.
 * @returns { Undefined } - Returns not a value, suspends program.
 * @function sleep
 * @throws { Error } If arguments.length is less then 1 or great then 2.
 * @throws { Error } If {-delay-} is not a Number.
 * @throws { Error } If {-delay-} is less then zero.
 * @throws { Error } If {-delay-} has not finite value.
 * @namespace wTools.time
 * @extends Tools
 */

function sleep( delay )
{
  _.assert( arguments.length === 1 );
  _.time._sleep.apply( this, arguments );
}

//

/**
 * The routine from() returns the time since 01.01.1970 in ms.
 *
 * @example
 * let date = new Date();
 * console.log( _.time.from( date ) );
 * // log : 1603174830154
 *
 * @param { Number|Date|String } time - The time to convert.
 * @returns { Number } - Returns time since 01.01.1970.
 * @function from
 * @throws { Error } If arguments.length is not equal to 1.
 * @throws { Error } If {-time-} neither is a Number, nor a Date, nor a valid time String.
 * @namespace wTools.time
 * @extends Tools
 */

function from( time )
{

  _.assert( arguments.length === 1 );

  if( _.number.is( time ) )
  {
    return time;
  }
  if( _.date.is( time ) )
  {
    return time.getTime();
  }
  if( _.strIs( time ) )
  {
    time = Date.parse( time );
    if( !isNaN( time ) )
    return time;
    else
    _.assert( 0, 'Wrong time format' );
  }
  _.assert( 0, 'Not clear how to coerce to time', _.entity.strType( time ) );
}

// --
// extension
// --

let TimeExtension =
{

  _sleep,
  sleep,

  from,

}

//

Object.assign( _.time, TimeExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Time.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Time_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Time_s */ })();

/* */  /* begin of file Unroll_s */ ( function Unroll_s() { function Unroll_s_naked() { ( function _l3_Unroll_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.long._elementWithKey, 'Expects routine array._elementWithKey' );

// --
// exporter
// --

function _exportStringDiagnosticShallow( src )
{
  return `{- ${_.entity.strType( src )}.unroll with ${this._lengthOf( src )} elements -}`;
}

// --
// declaration
// --

let unrollSymbol = Symbol.for( 'unroll' );

// --
// declaration
// --

let ToolsExtension =
{
}

//

Object.assign( _, ToolsExtension );

//

/* qqq : for junior : make replacements */

let UnrollExtension =
{

  // equaler

  _identicalShallow : _.long._identicalShallow,
  identicalShallow : _.long.identicalShallow,
  identical : _.long.identical,
  _equivalentShallow : _.long._equivalentShallow,
  equivalentShallow : _.long.equivalentShallow,
  equivalent : _.long.equivalent,

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.long.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _exportStringDiagnosticShallow,
  exportStringCodeShallow : _.long.exportStringCodeShallow,
  exportString : _.long.exportString,

  // container interface

  _lengthOf : _.long._lengthOf,
  lengthOf : _.long.lengthOf, /* qqq : cover */

  _hasKey : _.long._hasKey,
  hasKey : _.long._hasKey, /* qqq : cover */
  _hasCardinal : _.long._hasKey,
  hasCardinal : _.long._hasKey, /* qqq : cover */
  _keyWithCardinal : _.long._hasKey,
  keyWithCardinal : _.long._hasKey, /* qqq : cover */
  _cardinalWithKey : _.long._cardinalWithKey,
  cardinalWithKey : _.long.cardinalWithKey, /* qqq : cover */

  _elementGet : _.long._elementWithKey,
  elementGet : _.long.elementWithKey, /* qqq : cover */
  _elementWithKey : _.long._elementWithKey,
  elementWithKey : _.long.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.long._elementWithImplicit,
  elementWithImplicit : _.long.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal : _.long._elementWithCardinal,
  elementWithCardinal : _.long.elementWithCardinal,  /* qqq : cover */

  _elementSet : _.long._elementSet,
  elementSet : _.long.elementSet, /* qqq : cover */
  _elementWithKeySet : _.long._elementWithKeySet,
  elementWithKeySet : _.long.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet : _.long._elementWithCardinalSet,
  elementWithCardinalSet : _.long.elementWithCardinalSet,  /* qqq : cover */

  _elementAppend : _.array._elementAppend,
  elementAppend : _.array.elementAppend, /* qqq : cover */
  _elementPrepend : _.array._elementPrepend,
  elementPrepend : _.array.elementPrepend, /* qqq : cover */

  _elementDel : _.array._elementDel,
  elementDel : _.array.elementDel, /* qqq : cover */
  _elementWithKeyDel : _.array._elementWithKeyDel,
  elementWithKeyDel : _.array.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel : _.array._elementWithCardinalDel,
  elementWithCardinalDel : _.array.elementWithCardinalDel,  /* qqq : cover */
  _empty : _.array._empty,
  empty : _.array.empty, /* qqq : for junior : cover */

  _each : _.long._each,
  each : _.long.each, /* qqq : cover */
  _eachLeft : _.long._eachLeft,
  eachLeft : _.long.eachLeft, /* qqq : cover */
  _eachRight : _.long._eachRight,
  eachRight : _.long.eachRight, /* qqq : cover */

  _while : _.long._while,
  while : _.long.while, /* qqq : cover */
  _whileLeft : _.long._whileLeft,
  whileLeft : _.long.whileLeft, /* qqq : cover */
  _whileRight : _.long._whileRight,
  whileRight : _.long.whileRight, /* qqq : cover */

  _aptLeft : _.long._aptLeft,
  aptLeft : _.long.aptLeft, /* qqq : cover */
  first : _.long.first,
  _aptRight : _.long._aptRight, /* qqq : cover */
  aptRight : _.long.aptRight,
  last : _.long.last, /* qqq : cover */

  _filterAct : _.long._filterAct,
  filterWithoutEscapeLeft : _.long.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.long.filterWithoutEscapeRight,
  filterWithoutEscape : _.long.filterWithoutEscape,
  filterWithEscapeLeft : _.long.filterWithEscapeLeft,
  filterWithEscapeRight : _.long.filterWithEscapeRight,
  filterWithEscape : _.long.filterWithEscape,
  filter : _.long.filter,

  _mapAct : _.long._mapAct,
  mapWithoutEscapeLeft : _.long.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.long.mapWithoutEscapeRight,
  mapWithoutEscape : _.long.mapWithoutEscape,
  mapWithEscapeLeft : _.long.mapWithEscapeLeft,
  mapWithEscapeRight : _.long.mapWithEscapeRight,
  mapWithEscape : _.long.mapWithEscape,
  map : _.long.map,

}

//

Object.assign( _.unroll, UnrollExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Unroll.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Unroll_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Unroll_s */ })();

/* */  /* begin of file Vector_s */ ( function Vector_s() { function Vector_s_naked() { ( function _l3_Vector_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

_.assert( !!_.countable._elementWithKey, 'Expects routine countable._elementWithKey' );

// --
// dichotomy
// --

function adapterIs( src )
{
  return Object.prototype.toString.call( src ) === '[object VectorAdapter]';
}

//

function constructorIsVectorAdapter( src )
{
  if( !src )
  return false;
  return '_vectorBuffer' in src.prototype;
}

// --
// extension
// --

var ToolsExtension =
{
  vectorAdapterIs : adapterIs,
  vadIs : adapterIs,
  constructorIsVectorAdapter,
  constructorIsVad : constructorIsVectorAdapter,
}

Object.assign( _, ToolsExtension );

//

var VectorExtension =
{

  // dichotomy

  adapterIs,
  constructorIsVectorAdapter,

  // equaler

  /* qqq : implement more optimal own version of this routines */
  _identicalShallow : _.countable.identicalShallow,
  identicalShallow : _.countable.identicalShallow,
  identical : _.countable.identical,
  _equivalentShallow : _.countable.identicalShallow,
  equivalentShallow : _.countable.equivalentShallow,
  equivalent : _.countable.equivalent,

  // exporter

  /* qqq : implement more optimal own version of this routines */
  _exportStringDiagnosticShallow : _.countable._exportStringDiagnosticShallow,
  exportStringDiagnosticShallow : _.countable.exportStringDiagnosticShallow,
  _exportStringCodeShallow : _.countable._exportStringCodeShallow,
  exportStringCodeShallow : _.countable.exportStringCodeShallow,
  exportString : _.countable.exportString,

    // container interface

  _lengthOf : _.countable._lengthOf,
  lengthOf : _.countable.lengthOf, /* qqq : cover */

  _hasKey : _.countable._hasKey,
  hasKey : _.countable._hasKey, /* qqq : cover */
  _hasCardinal : _.countable._hasKey,
  hasCardinal : _.countable._hasKey, /* qqq : cover */
  _keyWithCardinal : _.countable._hasKey,
  keyWithCardinal : _.countable._hasKey, /* qqq : cover */
  _cardinalWithKey : _.countable._cardinalWithKey,
  cardinalWithKey : _.countable.cardinalWithKey, /* qqq : cover */

  _elementGet : _.countable._elementWithKey,
  elementGet : _.countable.elementWithKey, /* qqq : cover */
  _elementWithKey : _.countable._elementWithKey,
  elementWithKey : _.countable.elementWithKey, /* qqq : cover */
  _elementWithImplicit : _.countable._elementWithImplicit,
  elementWithImplicit : _.countable.elementWithImplicit,  /* qqq : cover */
  _elementWithCardinal : _.countable._elementWithCardinal,
  elementWithCardinal : _.countable.elementWithCardinal,  /* qqq : cover */

  _elementSet : _.countable._elementSet,
  elementSet : _.countable.elementSet, /* qqq : cover */
  _elementWithKeySet : _.countable._elementWithKeySet,
  elementWithKeySet : _.countable.elementWithKeySet, /* qqq : cover */
  _elementWithCardinalSet : _.countable._elementWithCardinalSet,
  elementWithCardinalSet : _.countable.elementWithCardinalSet,  /* qqq : cover */

  _elementDel : _.countable._elementDel,
  elementDel : _.countable.elementDel, /* qqq : cover */
  _elementWithKeyDel : _.countable._elementWithKeyDel,
  elementWithKeyDel : _.countable.elementWithKeyDel, /* qqq : cover */
  _elementWithCardinalDel : _.countable._elementWithCardinalDel,
  elementWithCardinalDel : _.countable.elementWithCardinalDel,  /* qqq : cover */
  _empty : _.countable._empty,
  empty : _.countable.empty,  /* qqq : cover */

  _elementAppend : _.countable._elementAppend,
  elementAppend : _.countable.elementAppend, /* qqq : cover */
  _elementPrepend : _.countable._elementPrepend,
  elementPrepend : _.countable.elementPrepend, /* qqq : cover */

  _each : _.countable._each,
  each : _.countable.each, /* qqq : cover */
  _eachLeft : _.countable._eachLeft,
  eachLeft : _.countable.eachLeft, /* qqq : cover */
  _eachRight : _.countable._eachRight,
  eachRight : _.countable.eachRight, /* qqq : cover */

  _while : _.countable._while,
  while : _.countable.while, /* qqq : cover */
  _whileLeft : _.countable._whileLeft,
  whileLeft : _.countable.whileLeft, /* qqq : cover */
  _whileRight : _.countable._whileRight,
  whileRight : _.countable.whileRight, /* qqq : cover */

  _aptLeft : _.countable._aptLeft,
  aptLeft : _.countable.aptLeft, /* qqq : cover */
  first : _.countable.first,
  _aptRight : _.countable._aptRight, /* qqq : cover */
  aptRight : _.countable.aptRight,
  last : _.countable.last, /* qqq : cover */

  _filterAct : _.countable._filterAct,
  filterWithoutEscapeLeft : _.countable.filterWithoutEscapeLeft,
  filterWithoutEscapeRight : _.countable.filterWithoutEscapeRight,
  filterWithoutEscape : _.countable.filterWithoutEscape,
  filterWithEscapeLeft : _.countable.filterWithEscapeLeft,
  filterWithEscapeRight : _.countable.filterWithEscapeRight,
  filterWithEscape : _.countable.filterWithEscape,
  filter : _.countable.filter,

  _mapAct : _.countable._mapAct,
  mapWithoutEscapeLeft : _.countable.mapWithoutEscapeLeft,
  mapWithoutEscapeRight : _.countable.mapWithoutEscapeRight,
  mapWithoutEscape : _.countable.mapWithoutEscape,
  mapWithEscapeLeft : _.countable.mapWithEscapeLeft,
  mapWithEscapeRight : _.countable.mapWithEscapeRight,
  mapWithEscape : _.countable.mapWithEscape,
  map : _.countable.map,

  // _filterAct0 : _.countable._filterAct0,
  // _filterAct : _.countable._filterAct,
  // filterWithoutEscapeLeft : _.countable.filterWithoutEscapeLeft,
  // filterWithoutEscapeRight : _.countable.filterWithoutEscapeRight,
  // filterWithoutEscape : _.countable.filterWithoutEscape,
  // filterWithEscapeLeft : _.countable.filterWithEscapeLeft,
  // filterWithEscapeRight : _.countable.filterWithEscapeRight,
  // filterWithEscape : _.countable.filterWithEscape,
  // filter : _.countable.filter,
  //
  // _mapAct0 : _.countable._mapAct0,
  // _mapAct : _.countable._mapAct,
  // mapWithoutEscapeLeft : _.countable.mapWithoutEscapeLeft,
  // mapWithoutEscapeRight : _.countable.mapWithoutEscapeRight,
  // mapWithoutEscape : _.countable.mapWithoutEscape,
  // mapWithEscapeLeft : _.countable.mapWithEscapeLeft,
  // mapWithEscapeRight : _.countable.mapWithEscapeRight,
  // mapWithEscape : _.countable.mapWithEscape,
  // map : _.countable.map,

}

Object.assign( _.vector, VectorExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/Vector.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Vector_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Vector_s */ })();

/* */  /* begin of file zErr_s */ ( function zErr_s() { function zErr_s_naked() { ( function _l3_Err_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function _handleUncaught2( o )
{
  const __ = _global_.globals && _globals_.testing.wTools;
  const process0 = processNamespaceGet();

  optionsRefine();

  /* xxx qqq : resolve issue in browser
    if file has syntax error then unachught error should not ( probably ) be throwen
    because browser thows uncontrolled information about syntax error after that
    avoid duplication of errors in log
  */

  o.err = errRefine( o.err );

  processUncaughtErrorEvent();

  if( _.error.isAttended( o.err ) )
  return;

  consoleUnbar();

  console.error( o.prefix );

  errLogFields();
  errLog();

  console.error( o.postfix );

  processExit();

  /* */

  function optionsRefine()
  {

    if( !o.origination )
    o.origination = 'uncaught error';

    // for( let k in o )
    // if( _handleUncaught2.defaults[ k ] !== undefined )
    // {
    //   console.error( `Routine::_handleUncaught2() does not expect option::${k}` );
    // }

    o.prefix = `--------------- ${o.origination} --------------->\n`;
    o.postfix = `--------------- ${o.origination} ---------------<\n`;
    o.logger = _global.logger || _global.console;

  }

  /* */

  function consoleUnbar()
  {
    let Logger = loggerClassGet();
    try
    {
      if( Logger && Logger.ConsoleBar && Logger.ConsoleIsBarred( console ) )
      Logger.ConsoleBar({ on : 0 });
    }
    catch( err2 )
    {
      debugger;
      console.error( err2 );
    }
  }

  /* */

  function errLog()
  {
    try
    {
      if( _.error && _.error._log )
      _.error._log( o.err, o.logger );
      else
      console.error( o.err );
    }
    catch( err2 )
    {
      debugger;
      console.error( err2 );
      console.error( o.err );
    }
  }

  /* */

  function errLogFields()
  {
    if( !o.err.originalMessage && _.object.like && _.object.like( o.err ) )
    try
    {
      let props = Object.create( null );
      for( let k in o.err )
      props[ k ] = o.err[ k ];
      // let serr = _.entity.exportString && _.props ? _.entity.exportString.fields( o.err, { errorAsMap : 1 } ) : o.err;
      o.logger.error( _.entity.exportString( props ) );
      debugger;
    }
    catch( err2 )
    {
      debugger;
      console.error( err2 );
    }
  }

  /* */

  function errRefine( err )
  {
    try
    {
      return _.error.process( err );
    }
    catch( err2 )
    {
      console.error( err2 );
      return err;
    }
  }

  /* */

  function processNamespaceGet()
  {
    let result;
    if( !result && _.process && _.process.exitReason )
    result = _.process;
    if( !result && _realGlobal_ && _realGlobal_.wTools && _realGlobal_.wTools.process && _realGlobal_.wTools.process.exitReason )
    result = _realGlobal_.wTools.process;
    if
    (
      !result
      && _realGlobal_._globals_.testing
      && __
      && __.process
      && __.process.exitReason
    )
    result = __.process;
    if( !result )
    result = _.process;
    return result;
  }

  /* */

  function loggerClassGet()
  {
    let result;
    if( !result && _.Logger && _.Logger.ConsoleBar )
    result = _.Logger;
    if( !result && _realGlobal_ && _realGlobal_.wTools && _realGlobal_.wTools.Logger && _realGlobal_.wTools.Logger.ConsoleBar )
    result = _realGlobal_.wTools.Logger;
    if
    (
      !result
      && __
      && __.Logger
      && __.Logger.ConsoleBar
    )
    result = __.Logger;
    return result;
  }

  /* */

  function processUncaughtErrorEvent()
  {
    try
    {
      // if( process0.eventGive ) /* xxx : cover in starter not catching uncaught error */
      if( process0 && process0.eventGive )
      // process0.eventGive({ event : 'uncaughtError', args : [ o ] });
      /* xxx : move to namespace app? */
      process0.eventGive({ event : 'uncaughtError', origination : o.origination, err : o.err });
      for( let g in _realGlobal_._globals_ )
      {
        const _global = _realGlobal_._globals_[ g ];
        if( _global.wTools && _global.wTools.process && _global.wTools.process.eventGive )
        if( _global.wTools.process !== process0 )
        _global.wTools.process.eventGive({ event : 'uncaughtError', origination : o.origination, err : o.err });
        // _global.wTools.process.eventGive({ event : 'uncaughtError', args : [ o ] });
      }
    }
    catch( err2 )
    {
      debugger;
      console.log( err2 );
      exitError( err2, false );
    }
  }

  /* */

  function exitError( err, rewriting )
  {
    let set = false;
    debugger;
    if( process0 && process0.exit )
    try
    {
      process0.exitCode( -1 );
      if( !process0.exitReason() )
      process0.exitReason( err );
      set = true;
    }
    catch( err2 )
    {
      debugger;
      console.log( err2 );
    }
    if( !set )
    try
    {
      if( _global.process )
      {
        if( !process.exitCode )
        process.exitCode = -1;
        set = true;
      }
    }
    catch( err2 )
    {
    }
  }

  /* */

  function processExit()
  {
    exitError( o.err, true );
    if( process0 && process0.exit )
    try
    {
      process0.exit();
    }
    catch( err2 )
    {
      debugger;
      console.log( err2 );
      exitError( o.err, false );
    }
    try
    {
      if( _global.process )
      process.exit();
    }
    catch( err2 )
    {
    }
  }

}

_handleUncaught2.defaults =
{
  err : null,
  origination : null,
}

//

function _handleUncaughtAsync( err )
{

  if( _.error.isAttended( err ) )
  return err;

  if( !err )
  debugger;
  _.error.wary( err, 1 );

  if( _.error.isSuspended( err ) )
  return err;

  let timer = _.time._finally( _.error.uncaughtDelayTime, function uncaught()
  {

    if( _.error.isAttended( err ) )
    return;

    if( _.error.isSuspended( err ) )
    return;

    if( !err )
    debugger;

    _.error._handleUncaught2({ err, origination : 'uncaught asynchronous error' });

  });

  return err;
}

//

function _setupUncaughtErrorHandler9()
{

  if( !_realGlobal_._setupUncaughtErrorHandlerDone )
  {
    debugger;
    throw Error( 'setup0 should be called first' );
  }

  if( _realGlobal_._setupUncaughtErrorHandlerDone > 1 )
  return;

  _realGlobal_._setupUncaughtErrorHandlerDone = 2;

  /* */

  if( _global.process && _.routine.is( _global.process.on ) )
  {
    _.error._handleUncaughtHead = _errHeadNode;
  }
  else if( Object.hasOwnProperty.call( _global, 'onerror' ) )
  {
    _.error._handleUncaughtHead = _errHeadBrowser;
  }

  /* */

  function _errHeadBrowser( args )
  {
    let [ message, sourcePath, lineno, colno, error ] = args;
    let err = error || message;

    if( _._err )
    err = _._err
    ({
      args : [ error || message ],
      level : 1,
      fallBackStack : 'at handleError @ ' + sourcePath + ':' + lineno,
      throwLocation :
      {
        filePath : sourcePath,
        line : lineno,
        col : colno,
      },
    });

    return [ { err, args } ];
  }

  /* */

  function _errHeadNode( args )
  {
    return [ { err : args[ 0 ], args } ];
  }

  /* */

}

//

/* qqq : for junior : for Rahul : implement performance test */
/* xxx : optimize */
function error_functor( name, onErrorMake )
{

  _.assert( _._err.defaults[ name ] === undefined );

  if( _.strIs( onErrorMake ) || _.arrayIs( onErrorMake ) )
  {
    let prepend = onErrorMake;
    onErrorMake = function onErrorMake()
    {
      debugger;
      let args = _.arrayAppendArrays( [], [ prepend, arguments ] );
      return args;
    }
  }
  else if( !onErrorMake )
  {
    onErrorMake = function onErrorMake()
    {
      return arguments;
    }
  }

  let Error =
  {
    [ name ] : function()
    {
      if( ( this instanceof ErrorConstructor ) )
      {

        let err1 = this;
        let args1 = onErrorMake.apply( err1, arguments );
        _.assert( _.argumentsArray.like( args1 ) );
        let args2 = args1;

        if( !Array.prototype.includes.call( args2, err1 ) )
        args2 = [ err1, ... args1 ];
        let err2 = _._err({ args : args2, level : 2, concealed : { [ name ] : true } });
        _.assert( err1 === err2 );
        _.assert( err2 instanceof _global.Error );
        _.assert( err2 instanceof ErrorConstructor );
        return err2;

      }
      else
      {

        if( arguments.length === 1 && arguments[ 0 ] && arguments[ 0 ] instanceof ErrorConstructor )
        return arguments[ 0 ];

        let err1;
        for( let i = 0 ; i < arguments.length ; i++ )
        if( arguments[ i ] && arguments[ i ] instanceof ErrorConstructor )
        {
          err1 = arguments[ i ];
          break;
        }

        if( err1 )
        return ErrorConstructor.apply( err1, arguments );
        return new ErrorConstructor( ... arguments );
      }
    }
  }

  let ErrorConstructor = Error[ name ];

  _.assert
  (
    ErrorConstructor.name === name,
    'Looks like your interpreter does not support dynamice naming of functions. Please use ES2015 or later interpreter.'
  );

  ErrorConstructor.prototype = Object.create( _global.Error.prototype );
  ErrorConstructor.prototype.constructor = ErrorConstructor;
  // ErrorConstructor.constructor = ErrorConstructor;
  // ErrorConstructor.constructor = Object.create( _global.Error.constructor );
  Object.setPrototypeOf( ErrorConstructor, _global.Error );

  return ErrorConstructor;
}

// --
// extension
// --

let Extension =
{

  _handleUncaught2,
  _handleUncaughtAsync,
  _setupUncaughtErrorHandler9,

  error_functor,

  uncaughtDelayTime : 100,

}

//

/* _.props.extend */Object.assign( _.error, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3/zErr.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l3' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, zErr_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file zErr_s */ })();

/* */  /* begin of file _1Seeker_s */ ( function _1Seeker_s() { function _1Seeker_s_naked() { ( function _l5_1Seeker_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function head( routine, args )
{
  _.assert( arguments.length === 2 );
  _.assert( !!routine.defaults.Seeker );
  let o = routine.defaults.Seeker.optionsFromArguments( args );
  o.Seeker = o.Seeker || routine.defaults;
  _.map.assertHasOnly( o, routine.defaults );
  _.assert
  (
    _.props.keys( routine.defaults ).length === _.props.keys( o.Seeker ).length,
    () => `${_.props.keys( routine.defaults ).length} <> ${_.props.keys( o.Seeker ).length}`
  );
  let it = o.Seeker.optionsToIteration( null, o );
  return it;
}

//

function optionsFromArguments( args )
{
  let o;

  if( args.length === 1 )
  {
    o = args[ 0 ];
  }
  else if( args.length === 2 )
  {
    o = { src : args[ 0 ], onUp : args[ 1 ] };
  }
  else if( args.length === 3 )
  {
    o = { src : args[ 0 ], onUp : args[ 1 ], onDown : args[ 2 ] };
  }
  else _.assert( 0, 'look expects single options-map, 2 or 3 arguments' );

  _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
  _.assert( arguments.length === 1 );
  _.assert( _.aux.is( o ) );

  return o;
}

//

function optionsToIteration( iterator, o )
{
  _.assert( o.it === undefined );
  _.assert( _.mapIs( o ) );
  _.assert( !_.props.ownEnumerable( o, 'constructor' ) );
  _.assert( arguments.length === 2 );
  if( iterator === null )
  iterator = o.Seeker.iteratorRetype( o );
  else
  Object.assign( iterator, o );
  o.Seeker.iteratorInit( iterator );
  let it = iterator.iteratorIterationMake();
  _.assert( it.Seeker.iterationProper( it ) );
  return it;
}

//

function iteratorProper( it )
{
  if( !it )
  return false;
  if( !it.Seeker )
  return false;
  if( it.iterator !== it )
  return false;
  if( it.constructor !== this.constructor )
  return false;
  return true;
}

//

function iteratorRetype( iterator )
{
  Object.setPrototypeOf( iterator, iterator.Seeker );
  iterator.iterator = iterator;
  return iterator;
}

//

function iteratorInit( iterator )
{
  let seeker = this;
  seeker.iteratorInitBegin( iterator );
  seeker.iteratorInitEnd( iterator );
}

//

function iteratorInitBegin( iterator )
{
  iterator.iterator = iterator;
  return iterator;
}

//

const _iteratorInitExcluding = new Set([ 'Seeker', 'iterationPrototype', 'firstIterationPrototype', 'iterator' ]);
function iteratorInitEnd( iterator )
{

  iterator.iterationPrototype = Object.create( iterator );
  iterator.firstIterationPrototype = Object.create( iterator.iterationPrototype );
  Object.assign( iterator.iterationPrototype, iterator.Seeker.Iteration );

  for( const [ key, val ] of Object.entries( iterator ) )
  {
    if( _iteratorInitExcluding.has( key ) )
    continue;

    if( !_.props.own( iterator.iterationPrototype, key ) )
    continue;

    if( _.props.has( iterator.Iteration, key ) )
    {
      if( iterator.firstIterationPrototype[ key ] !== val )
      {
        iterator.firstIterationPrototype[ key ] = val;
      }
    }
    else
    {
      if( iterator.iterationPrototype[ key ] !== val )
      {
        iterator.iterationPrototype[ key ] = val;
      }
    }

  }

  Object.preventExtensions( iterator.iterationPrototype );
  return iterator;
}

//

function iteratorIterationMake()
{
  let it = this;
  let newIt = Object.create( it.firstIterationPrototype );
  return newIt;
}

//

function iterationMake()
{
  let it = this;
  let newIt = Object.create( it.iterationPrototype );

  for( let k in it.Seeker.IterationPreserve )
  newIt[ k ] = it[ k ];

  newIt.down = it; /* xxx */

  return newIt;
}

//

function iterationProper( it )
{
  if( !it )
  return false;
  if( !it.Seeker )
  return false;
  if( !it.iterator )
  return false;
  if( it.iterator === it )
  return false;
  if( it.constructor !== this.constructor )
  return false;
  return true;
}

// --
//
// --

/**
 * @function is
 * @class Tools.Seeker
 */

function is( src )
{
  if( !src )
  return false;
  if( !src.Seeker )
  return false;
  return _.prototype.isPrototypeFor( src, src.Seeker );
}

//

/**
 * @function iteratorIs
 * @class Tools.Seeker
 */

function iteratorIs( it )
{
  if( !it )
  return false;
  if( !it.Seeker )
  return false;
  if( it.iterator !== it )
  return false;
  return true;
}

//

/**
 * @function iterationIs
 * @class Tools.Seeker
 */

function iterationIs( it )
{
  if( !it )
  return false;
  if( !it.Seeker )
  return false;
  if( !it.iterator )
  return false;
  if( it.iterator === it )
  return false;
  return true;
}

//

function classDefine( o )
{

  _.routine.options( classDefine, o );

  if( o.parent === null )
  o.parent = this.Seeker;
  if( o.name === null )
  o.name = 'CustomSeeker'

  _.assert( _.object.isBasic( o.parent ), `Parent should be object` );

  let seeker = _.props.extend( null, o.parent );

  if( !o.seeker || !o.seeker.constructor || o.seeker.constructor === Object )
  {
    let CustomSeeker = (function()
    {
      return ({
        [ o.name ] : function(){},
      })[ o.name ];
    })();
    seeker.constructor = CustomSeeker;
    _.assert( seeker.constructor.name === o.name );
  }

  if( o.prime )
  _.props.extend( seeker, o.prime );
  if( o.seeker )
  _.props.extend( seeker, o.seeker );
  if( o.iterator )
  _.props.extend( seeker, o.iterator );
  if( o.iterationPreserve )
  o.iteration = _.props.supplement( o.iteration || Object.create( null ), o.iterationPreserve );

  seeker.Seeker = seeker;
  seeker.OriginalSeeker = seeker;
  seeker.Prime = Object.create( seeker.Prime || null );
  if( o.prime )
  _.props.extend( seeker.Prime, o.prime );
  Object.preventExtensions( seeker.Prime );

  if( o.exec || seeker.exec )
  seeker.exec = exec_functor( o.exec || seeker.exec );
  if( o.execIt || seeker.execIt )
  seeker.execIt = exec_functor( o.execIt || seeker.execIt );

  let iterator = seeker.Iterator = Object.assign( Object.create( null ), seeker.Iterator );
  if( o.iterator )
  _.props.extend( iterator, o.iterator );

  seeker.Iteration = Object.assign( Object.create( null ), seeker.Iteration );
  let iterationPreserve = seeker.IterationPreserve = Object.assign( Object.create( null ), seeker.IterationPreserve );
  if( o.iterationPreserve )
  {
    _.props.extend( iterationPreserve, o.iterationPreserve );
  }
  if( o.iteration )
  _.props.extend( seeker.Iteration, o.iteration );

  Object.freeze( seeker.Iterator );
  Object.freeze( seeker.Iteration );
  Object.freeze( seeker.IterationPreserve );

  validate();

  return seeker;

  /* - */

  function exec_functor( original )
  {
    _.assert( _.routineIs( original.head ) );
    _.assert( _.routineIs( original.body ) );
    if( !original.body.defaults )
    original.body.defaults = seeker;
    let exec = _.routine._amend
    ({
      dst : null,
      srcs : [ original, { defaults : seeker } ],
      strategy : 'replacing',
      amending : 'extending',
    });
    _.assert( exec.defaults === seeker );
    _.assert( exec.body.defaults === seeker );
    return exec;
  }

  /* - */

  function validate()
  {
    if( !Config.debug )
    return;

    /* qqq : add explanation for each assert */
    _.assert( seeker.Prime.Seeker === undefined );
    _.assert( !_.props.has( seeker.Iteration, 'src' ) || seeker.Iteration.src === undefined );
    _.assert( !_.props.has( seeker.IterationPreserve, 'src' ) || seeker.IterationPreserve.src === undefined );
    _.assert( !_.props.has( seeker, 'src' ) || seeker.src === undefined );
    _.assert( !_.props.has( seeker.Iteration, 'root' ) || seeker.Iteration.root === undefined );
    _.assert( !_.props.has( seeker, 'root' ) || seeker.root === undefined );
    if( _.props.has( seeker, 'dst' ) )
    {
      _.assert( _.props.has( seeker.Iteration, 'dst' ) && seeker.Iteration.dst === undefined );
      _.assert( _.props.has( seeker, 'dst' ) && seeker.dst === undefined );
    }

    for( let k in seeker.Iteration )
    if( _.props.has( seeker, k ) )
    {
      _.assert
      (
        seeker[ k ] === seeker.Iteration[ k ],
        () => `Conflicting default value of field::${k} of Seeker::${o.name}`
        + `\n${seeker[ k ]} <> ${seeker.Iteration[ k ]}`
      );
    }

  }

  /* - */

}

classDefine.defaults =
{
  name : null,
  parent : null,
  prime : null,
  seeker : null,
  iterator : null,
  iteration : null,
  iterationPreserve : null,
  exec : null,
  execIt : null,
}

// --
//
// --

const Seeker = Object.create( null );
Seeker.OriginalSeeker = Seeker;
Seeker.Seeker = Seeker;
Seeker.constructor = function Seeker() /* xxx : implement */
{
  _.assert( 0, 'not implemented' );
  let prototype = _.prototype.of( this );
  _.assert( _.object.isBasic( prototype ) );
  _.assert( prototype.exec.defaults === prototype );
  let result = this.head( prototype.exec, arguments );
  _.assert( result === this );
  return this;
}

_.prototype.set( Seeker.constructor, null );
Seeker.constructor.prototype = Seeker;

Seeker.head = head;
Seeker.optionsToIteration = optionsToIteration;
Seeker.optionsFromArguments = optionsFromArguments;
Seeker.iteratorProper = iteratorProper;
Seeker.iteratorRetype = iteratorRetype;
Seeker.iteratorInit = iteratorInit;
Seeker.iteratorInitBegin = iteratorInitBegin;
Seeker.iteratorInitEnd = iteratorInitEnd;
Seeker.iteratorIterationMake = iteratorIterationMake;
Seeker.iterationMake = iterationMake;
Seeker.iterationProper = iterationProper;
Seeker.onUp = null;
Seeker.onDown = null;
Seeker.iterationPrototype = null;
Seeker.firstIterationPrototype = null;

/* xxx : remove Iterator? */
const Iterator = Seeker.Iterator = Object.create( null );

const Iteration = Seeker.Iteration = Object.create( null );
Iteration.down = null;

const IterationPreserve = Seeker.IterationPreserve = Object.create( null );

// --
// seeker extension
// --

let SeekerExtension =
{

  Seeker,

  is,
  iteratorIs,
  iterationIs,
  classDefine,

}

Object.assign( _.seeker, SeekerExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/1Seeker.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, _1Seeker_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file _1Seeker_s */ })();

/* */  /* begin of file ArgumentsArray_s */ ( function ArgumentsArray_s() { function ArgumentsArray_s_naked() { ( function _l5_ArgumentsArray_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let ArgumentsArrayExtension =
{
}

Object.assign( _.argumentsArray, ArgumentsArrayExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/ArgumentsArray.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ArgumentsArray_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ArgumentsArray_s */ })();

/* */  /* begin of file Array_s */ ( function Array_s() { function Array_s_naked() { ( function _l5_Array_s_()
{

'use strict';

const _ArrayIndexOf = Array.prototype.indexOf;
const _ArrayIncludes = Array.prototype.includes;
if( !_ArrayIncludes )
_ArrayIncludes = function( e ){ _ArrayIndexOf.call( this, e ) }

const _global = _global_;
const _ = _global_.wTools;

/*
               |  can grow   |  can shrink  |   range
grow                +                -         positive
select              -                +         positive
relength            +                +         positive
but                 -                +         negative
*/

/* array / long / buffer */
/* - / inplace */

/*

alteration Routines :

- array { Op } { Tense } { Second } { How }

alteration Op : [ Append , Prepend , Remove, Flatten ]        // operation
alteration Tense : [ - , ed ]                                 // what to return
alteration Second : [ -, element, array, array ]              // how to treat src arguments
alteration How : [ - , Once , OnceStrictly ]                  // how to treat repeats

~ 60 routines

*/

// --
// array checker
// --

function constructorLikeArray( src )
{
  if( !src )
  return false;

  if( src === Function )
  return false;
  if( src === Object )
  return false;
  if( src === String )
  return false;

  if( _.primitive.is( src ) )
  return false;

  if( !( 'length' in src.prototype ) )
  return false;
  if( Object.propertyIsEnumerable.call( src.prototype, 'length' ) )
  return false;

  return true;
}

// --
// array producer
// --

/**
 * The routine arrayFromCoercing() returns Array from provided argument {-src-}. The feature of routine is possibility of
 * converting an object-like {-src-} into Array. Also, routine longFromCoercing() converts string with number literals
 * to an Array.
 *
 * @param { Array|Long|ObjectLike|String } src - An instance to convert into Array.
 * If {-src-} is instance of Array, then routine converts not {-src-}.
 *
 * @example
 * let src = [ 3, 7, 13, 'abc', false, undefined, null, {} ];
 * let got = _.arrayFromCoercing( src );
 * // returns [ 3, 7, 13, 'abc', false, undefined, null, {} ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * let src = _.argumentsArray.make( [ 3, 7, 13, 'abc', false, undefined, null, {} ] );
 * let got = _.arrayFromCoercing( src );
 * // returns [ 3, 7, 13, 'abc', false, undefined, null, {} ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * let src = { a : 3, b : 7, c : 13 };
 * let got = _.arrayFromCoercing( src );
 * // returns [ [ 'a', 3 ], [ 'b', 7 ], [ 'c', 13 ] ]
 *
 * @example
 * let src = "3, 7, 13, 3.5abc, 5def, 7.5ghi, 13jkl";
 * let got = _.arrayFromCoercing( src );
 * // returns [ 3, 7, 13, 3.5, 5, 7.5, 13 ]
 *
 * @returns { Array } - Returns an Array. If {-src-} is Array instance, then routine returns original {-src-}.
 * @function arrayFromCoercing
 * @throws { Error } If {-src-} is not an Array, not a Long, not object-like, not a String.
 * @namespace Tools
 */

function arrayFromCoercing( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.arrayIs( src ) && !_.unrollIs( src ) )
  return src;

  if( _.longIs( src ) )
  return Array.prototype.slice.call( src );

  if( _.strIs( src ) )
  return this.arrayFromStr( src );

  if( _.object.isBasic( src ) )
  return _.props.pairs( src );

  _.assert( 0, 'Unknown data type : ' + _.entity.strType( src ) );
}

//

function arrayFromStr( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) );
  return src.split(/[, ]+/).map( ( s ) => s.length ? parseFloat( s ) : undefined );
}

// --
// array transformer
// --

function arrayExtendAppending( dst, src )
{

  _.assert( arguments.length === 2 );

  if( _.longIs( src ) )
  {

    if( dst === null || dst === undefined )
    dst = _.longSlice( src );
    else if( _.arrayIs( dst ) )
    dst = _.arrayAppendArray( dst, src );
    else if( _.longLike( dst ) )
    dst = _.arrayAppendArrays( null, [ dst, src ] );
    else
    dst = _.arrayAppendArray( [ dst ], src );

  }
  else
  {

    if( dst === null || dst === undefined )
    dst = [ src ];
    else if( _.arrayIs( dst ) )
    dst = _.arrayAppend( dst, src );
    else if( _.longLike( dst ) )
    dst = _.arrayAppendArrays( null, [ dst, src ] );
    else
    dst = _.arrayAppend( [ dst ], src );

  }

  return dst;
}

//

function arrayExtendPrepending( dst, src )
{

  _.assert( arguments.length === 2 );

  if( _.longIs( src ) )
  {

    if( dst === null || dst === undefined )
    dst = _.longSlice( src );
    else if( _.arrayIs( dst ) )
    dst = _.arrayPrependArray( dst, src );
    else if( _.longLike( dst ) )
    dst = _.arrayPrependArrays( null, [ dst, src ] );
    else
    dst = _.arrayPrependArray( [ dst ], src );

  }
  else
  {

    if( dst === null || dst === undefined )
    dst = [ src ];
    else if( _.arrayIs( dst ) )
    dst = _.arrayPrepend( dst, src );
    else if( _.longLike( dst ) )
    dst = _.arrayPrependArrays( null, [ dst, src ] );
    else
    dst = _.arrayPrepend( [ dst ], src );

  }

  return dst;
}

//

/**
 * The routine arrayBut() returns a shallow copy of provided array {-src-}. Routine removes existing
 * elements in bounds defined by {-range-} and insert new elements from {-ins-}. The original
 * source array {-src-} will not be modified.
 *
 * @param { Array|Unroll } src - The Array or Unroll from which makes a shallow copy.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for removing elements.
 * If {-range-} is number, then it defines the start index, and the end index is start index incremented by one.
 * If {-range-} is undefined, routine returns copy of {-src-}.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] > src.length, end index sets to src.length.
 * If range[ 1 ] <= range[ 0 ], then routine removes not elements, the insertion of elements begins at start index.
 * @param { Long } ins - The Long with elements for insertion. Inserting begins at start index.
 * If quantity of removed elements is not equal to ins.length, then returned array will have length different to src.length.
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayBut( src );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayBut( src, 2, [ 'str' ] );
 * console.log( got );
 * // log [ 1, 2, 'str', 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayBut( src, [ 1, 4 ], [ 'str' ] );
 * console.log( got );
 * // log [ 1, 'str', 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayBut( src, [ -5, 10 ], [ 'str' ] );
 * console.log( got );
 * // log [ 'str' ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayBut( src, [ 4, 1 ], [ 'str' ] );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 'str', 5 ]
 * console.log( got === src );
 * // log false
 *
 * @returns { Array|Unroll } Returns a copy of Array / Unroll with removed or replaced existing elements and / or added new elements.
 * @function arrayBut
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-src-} is not an array or unroll.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range elements is not number / undefined.
 * @throws { Error } If argument {-ins-} is not Long / undefined.
 * @namespace Tools
 */

function arrayBut( src, range, ins )
{

  _.assert( 1 <= arguments.length && arguments.length <= 3 );

  if( range === undefined )
  return _.array.make( src );

  if( _.number.is( range ) )
  range = [ range, range + 1 ];

  _.assert( _.arrayIs( src ) );
  _.assert( _.intervalIs( range ) );
  _.assert( ins === undefined || _.longLike( ins ) );

  _.ointerval.clamp/*rangeClamp*/( range, [ 0, src.length ] );
  if( range[ 1 ] < range[ 0 ] )
  range[ 1 ] = range[ 0 ];

  let args = [ range[ 0 ], range[ 1 ] - range[ 0 ] ];

  if( ins )
  _.arrayAppendArray( args, ins );

  let result = src.slice();

  result.splice.apply( result, args );

  return result;
}

//

/**
 * The routine arrayButInplace() returns a provided array {-src-} with removed existing elements in bounds
 * defined by {-range-} and inserted new elements from {-ins-}.
 *
 * @param { Array|Unroll } src - The Array or Unroll to remove, replace or add elements.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for removing elements.
 * If {-range-} is number, then it defines the start index, and the end index defines as start index incremented by one.
 * If {-range-} is undefined, routine returns {-src-}.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] > src.length, end index sets to src.length.
 * If range[ 1 ] <= range[ 0 ], then routine removes no elements, the insertion of elements begins at start index.
 * @param { Long } ins - The Long with elements for insertion. Inserting begins at start index.
 * If quantity of removed elements is not equal to ins.length, then returned array will have length different to original src.length.
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayButInplace( src );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayButInplace( src, 2, [ 'str' ] );
 * console.log( got );
 * // log [ 1, 2, 'str', 4, 5 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayButInplace( src, [ 1, 4 ], [ 'str' ] );
 * console.log( got );
 * // log [ 1, 'str', 5 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayButInplace( src, [ -5, 10 ], [ 'str' ] );
 * console.log( got );
 * // log [ 'str' ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayButInplace( src, [ 4, 1 ], [ 'str' ] );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 'str', 5 ]
 * console.log( got === src );
 * // log true
 *
 * @returns { Array|Unroll } Returns original Array / Unroll with removed or replaced existing elements and / or added new elements.
 * @function arrayButInplace
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-src-} is not an array or unroll.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range elements is not number / undefined.
 * @throws { Error } If argument {-ins-} is not Long / undefined.
 * @namespace Tools
 */

function arrayButInplace( src, range, ins )
{

  _.assert( 1 <= arguments.length && arguments.length <= 3 );

  if( range === undefined )
  return src;

  if( _.number.is( range ) )
  range = [ range, range + 1 ];

  _.assert( _.arrayLikeResizable( src ) );
  _.assert( _.intervalIs( range ) );
  _.assert( ins === undefined || _.longLike( ins ) );

  _.ointerval.clamp( range, [ 0, src.length ] );
  if( range[ 1 ] < range[ 0 ] )
  range[ 1 ] = range[ 0 ];

  let args = [ range[ 0 ], range[ 1 ] - range[ 0 ] ];

  if( ins )
  {
    if( !Object.isExtensible( src ) && ins.length > range[ 1 ] - range[ 0 ] )
    _.assert( 0, 'Array is not resizable, cannot change length of array' );
    else
    _.arrayAppendArray( args, ins );
  }


  let result = src;

  result.splice.apply( result, args );

  return result;
}

//

function arrayBut_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  if( cinterval === undefined )
  {
    cinterval = [ 0, -1 ];
    ins = undefined;
  }
  else if( _.number.is( cinterval ) )
  {
    cinterval = [ cinterval, cinterval ];
  }

  _.assert( _.arrayIs( dst ) || dst === null, 'Expects {-dst-} of Array type or null' );
  _.assert( _.longIs( src ), 'Expects {-src-} of Array type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );
  _.assert( _.longLike( ins ) || ins === undefined || ins === null, 'Expects long {-ins-} for insertion' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] !== undefined ? cinterval[ 0 ] : 0;
  let last = cinterval[ 1 ] = cinterval[ 1 ] !== undefined ? cinterval[ 1 ] : src.length - 1;

  if( first < 0 )
  first = 0;
  if( first > src.length )
  first = src.length;
  if( last > src.length - 1 )
  last = src.length - 1;

  if( last + 1 < first )
  last = first - 1;

  let delta = last - first + 1;
  let insLength = ins ? ins.length : 0;
  let delta2 = delta - insLength;
  let resultLength = src.length - delta2;

  let result = dst;
  if( dst === null )
  {
    result = _.array.makeUndefined( resultLength );
  }
  else if( dst === src )
  {
    if( !( ( dst.length === resultLength ) && delta === 0 ) )
    ins ? dst.splice( first, delta, ... ins ) : dst.splice( first, delta );
    return dst;
  }
  else if( dst.length !== resultLength )
  {
    if( dst.length < resultLength )
    _.assert( Object.isExtensible( result ), 'Expects extensible array {-dst-}' );
    dst.length = resultLength;
  }

  for( let i = 0 ; i < first ; i++ )
  result[ i ] = src[ i ];

  for( let i = last + 1 ; i < src.length ; i++ )
  result[ i - delta2 ] = src[ i ];

  if( ins )
  {
    for( let i = 0 ; i < ins.length ; i++ )
    result[ first + i ] = ins[ i ];
  }

  return result;
}

//

/**
 * The routine arrayShrink() returns a copy of a portion of provided array {-src-} into a new array object
 * selected by {-range-}. The original {-src-} will not be modified.
 *
 * @param { Array|Unroll } src - The Array or Unroll from which makes a shallow copy.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
 * If {-range-} is number, then it defines the start index, and the end index sets to src.length.
 * If {-range-} is undefined, routine returns copy of {-src-}.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] > src.length, end index sets to src.length.
 * If range[ 1 ] <= range[ 0 ], then routine returns empty array object.
 * @param { * } ins - The object of any type for insertion.
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrink( src );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrink( src, 2, 'str' );
 * console.log( got );
 * // log [ 3, 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrink( src, [ 1, 4 ], 'str' );
 * console.log( got );
 * // log [ 2, 3, 4 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrink( src, [ -5, 10 ], 'str' );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrink( src, [ 4, 1 ], 'str' );
 * console.log( got );
 * // log []
 * console.log( got === src );
 * // log false
 *
 * @returns { Array|Unroll } Returns a copy of Array / Unroll containing the extracted elements.
 * @function arrayShrink
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-src-} is not an array or unroll.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range elements is not number / undefined.
 * @namespace Tools
 */

function arrayShrink( src, range, ins )
{
  let result;

  _.assert( 1 <= arguments.length && arguments.length <= 3 );

  if( range === undefined )
  return src.slice();

  if( _.number.is( range ) )
  range = [ range, src.length ];

  _.assert( _.arrayIs( src ) );
  _.assert( _.intervalIs( range ) );

  _.ointerval.clamp/*rangeClamp*/( range, [ 0, src.length ] );
  if( range[ 1 ] < range[ 0 ] )
  range[ 1 ] = range[ 0 ];

  if( range[ 0 ] === 0 && range[ 1 ] === src.length )
  return src.slice( src );

  result = _.array.makeUndefined( src, range[ 1 ]-range[ 0 ] );

  let f2 = Math.max( range[ 0 ], 0 );
  let l2 = Math.min( src.length, range[ 1 ] );
  for( let r = f2 ; r < l2 ; r++ )
  result[ r-range[ 0 ] ] = src[ r ];

  return result;
}

//

/**
 * The routine arrayShrinkInplace() returns a portion of provided array {-src-} selected by {-range-}.
 *
 * @param { Array|Unroll } src - The Array or Unroll from which selects elements.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
 * If {-range-} is number, then it defines the start index, and the end index sets to src.length.
 * If {-range-} is undefined, routine returns {-src-}.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] > src.length, end index sets to src.length.
 * If range[ 1 ] <= range[ 0 ], then routine returns empty array object.
 * @param { * } ins - The object of any type for insertion.
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrinkInplace( src );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrinkInplace( src, 2, 'str' );
 * console.log( got );
 * // log [ 3, 4, 5 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrinkInplace( src, [ 1, 4 ], 'str' );
 * console.log( got );
 * // log [ 2, 3, 4 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrinkInplace( src, [ -5, 10 ], 'str' );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayShrinkInplace( src, [ 4, 1 ], 'str' );
 * console.log( got );
 * // log []
 * console.log( got === src );
 * // log true
 *
 * @returns { Array|Unroll } Returns a Array / Unroll containing the selected elements.
 * @function arrayShrinkInplace
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-src-} is not an array or unroll.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range elements is not number / undefined.
 * @namespace Tools
 */

function arrayShrinkInplace( src, range, ins )
{

  _.assert( 1 <= arguments.length && arguments.length <= 3 );

  if( range === undefined )
  return src;

  if( _.number.is( range ) )
  range = [ range, src.length ];

  _.assert( _.arrayIs( src ) );
  _.assert( _.intervalIs( range ) );

  _.ointerval.clamp/*rangeClamp*/( range, [ 0, src.length ] );
  if( range[ 1 ] < range[ 0 ] )
  range[ 1 ] = range[ 0 ];

  if( range[ 0 ] === 0 && range[ 1 ] === src.length )
  return src;

  let f2 = Math.max( range[ 0 ], 0 );
  let l2 = Math.min( src.length, range[ 1 ] );

  let result = src;

  result.splice.apply( result, [ 0, f2 ] );
  result.length = range[ 1 ] - range[ 0 ];

  return result;
}

//

function arrayShrink_( dst, src, cinterval )
{
  _.assert( 1 <= arguments.length && arguments.length <= 3, 'Expects not {-ins-} argument' );

  if( arguments.length < 3 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
  }

  if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval ];

  _.assert( _.arrayIs( dst ) || dst === null, 'Expects {-dst-} of Array type or null' );
  _.assert( _.arrayIs( src ), 'Expects {-src-} of Array type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] !== undefined ? cinterval[ 0 ] : 0;
  let last = cinterval[ 1 ] = cinterval[ 1 ] !== undefined ? cinterval[ 1 ] : src.length - 1;

  if( first < 0 )
  first = 0;
  if( last > src.length - 1 )
  last = src.length - 1;

  if( last + 1 < first )
  last = first - 1;

  let first2 = Math.max( first, 0 );
  let last2 = Math.min( src.length - 1, last );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.array.makeUndefined( resultLength );
  }
  else if( dst === src )
  {
    result.splice.apply( result, [ 0, first2 ] );
    result.length = resultLength;
    return result;
  }
  else if( dst.length < resultLength )
  {
    _.assert( Object.isExtensible( dst ), 'Array is not extensible, cannot change array' );
    result.length = resultLength;
  }

  for( let i = first2 ; i < last2 + 1 ; i++ )
  result[ i - first2 ] = src[ i ];

  return result;
}

//

/**
 * Routine arrayGrow() changes length of provided array {-src-} by copying it elements to newly created array
 * using range {-range-} positions of the original array and value to fill free space after copy {-ins-}.
 * Routine can only grows size of array.The original {-src-} will not be modified.
 *
 * @param { Array|Unroll } src - The Array or Unroll from which makes a shallow copy.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
 * If {-range-} is number, then it defines the end index, and the start index is 0.
 * If range[ 0 ] < 0, then start index sets to 0, end index incrementes by absolute value of range[ 0 ].
 * If range[ 0 ] > 0, then start index sets to 0.
 * If range[ 1 ] > src.length, end index sets to src.length.
 * If range[ 1 ] <= range[ 0 ], then routine returns copy of origin array.
 * @param { * } ins -  object of any type. Used to fill the space left after copying elements of the original array.
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src, 7, 'str' );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5, 'str', 'str' ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src, [ 1, 6 ], 'str' );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5, 'str' ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src, [ -5, 6 ], 7 );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5, 7, 7, 7, 7, 7, 7 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src, [ 4, 1 ], 'str' );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @returns { Array|Unroll } Returns a copy of Array / Unroll with changed length.
 * @function arrayGrow
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-src-} is not an array or unroll.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range elements is not number / undefined.
 * @namespace Tools
 */

function arrayGrow( src, range, ins )
{
  let result;

  _.assert( 1 <= arguments.length && arguments.length <= 3 );

  if( range === undefined )
  return src.slice();

  if( _.number.is( range ) )
  range = [ 0, range ];

  let f = range ? range[ 0 ] : undefined;
  let l = range ? range[ 1 ] : undefined;

  f = f !== undefined ? f : 0;
  l = l !== undefined ? l : src.length;

  _.assert( _.arrayIs( src ) );
  _.assert( _.intervalIs( range ) )

  if( l < f )
  l = f;

  if( f < 0 )
  {
    l -= f;
    f -= f;
  }

  if( f > 0 )
  f = 0;
  if( l < src.length )
  l = src.length;

  if( l === src.length )
  return src.slice();

  result = _.array.makeUndefined( src, l-f );

  let f2 = Math.max( f, 0 );
  let l2 = Math.min( src.length, l );
  for( let r = f2 ; r < l2 ; r++ )
  result[ r-f ] = src[ r ];

  if( ins !== undefined )
  {
    for( let r = l2 - f; r < result.length ; r++ )
    {
      result[ r ] = ins;
    }
  }

  return result;
}

//

/**
 * Routine arrayGrowInplace() changes length of provided array {-src-} using range {-range-} positions of the original
 * array and value to fill free space after copy {-ins-}. Routine can only grows size of array.
 *
 * @param { Array|Unroll } src - The Array or Unroll to grow length.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
 * If {-range-} is number, then it defines the end index, and the start index is 0.
 * If range[ 0 ] < 0, then start index sets to 0, end index incrementes by absolute value of range[ 0 ].
 * If range[ 0 ] > 0, then start index sets to 0.
 * If range[ 1 ] > src.length, end index sets to src.length.
 * If range[ 1 ] <= range[ 0 ], then routine returns copy of origin array.
 * @param { * } ins - The object of any type. Used to fill the space left of the original array.
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src, 7, 'str' );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5, 'str', 'str' ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src, [ 1, 6 ], 'str' );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5, 'str' ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src, [ -5, 6 ], 7 );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5, 7, 7, 7, 7, 7, 7 ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayGrow( src, [ 4, 1 ], 'str' );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log true
 *
 * @returns { Array|Unroll } Returns a provided Array / Unroll with changed length.
 * @function arrayGrowInplace
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-src-} is not an array or unroll.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range elements is not number / undefined.
 * @namespace Tools
 */

function arrayGrowInplace( src, range, ins )
{

  _.assert( 1 <= arguments.length && arguments.length <= 3 );

  if( range === undefined )
  return src;

  if( _.number.is( range ) )
  range = [ 0, range ];

  let f = range ? range[ 0 ] : undefined;
  let l = range ? range[ 1 ] : undefined;

  f = f !== undefined ? f : 0;
  l = l !== undefined ? l : src.length;

  _.assert( _.arrayIs( src ) );
  _.assert( _.intervalIs( range ) )

  if( f < 0 )
  {
    l -= f;
    f -= f;
  }

  if( l < f )
  l = f;

  if( f > 0 )
  f = 0;
  if( l < src.length )
  l = src.length;

  if( l === src.length )
  return src;

  if( !Object.isExtensible( src ) && src.length < l )
  _.assert( 0, 'Array is not extensible, cannot change length of array' );

  let resultLength = l - f;
  let f2 = Math.max( -range[ 0 ], 0 );
  let l2 = Math.min( src.length, l );
  l2 += f2;

  src.splice( f, 0, ... _.dup( ins, f2 ) );
  src.splice( l2, 0, ... _.dup( ins, resultLength <= l2 ? 0 : resultLength - l2 ) );
  return src;
}

//

function arrayGrow_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval - 1 ];

  _.assert( _.arrayIs( dst ) || dst === null, 'Expects {-dst-} of Array type or null' );
  _.assert( _.arrayIs( src ), 'Expects {-src-} of Array type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let f = cinterval[ 0 ] === undefined ?  0 : cinterval[ 0 ];
  let l = cinterval[ 1 ] === undefined ?  src.length - 1 : cinterval[ 1 ];

  if( f > 0 )
  f = 0;
  if( l < src.length - 1 )
  l = src.length - 1;

  if( f < 0 )
  {
    l -= f;
    f -= f;
  }

  if( l + 1 < f )
  l = f - 1;

  let f2 = Math.max( -cinterval[ 0 ], 0 );
  let l2 = Math.min( src.length - 1 + f2, l + f2 );

  let resultLength = l - f + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.array.make( resultLength );
  }
  else if( dst === src )
  {
    if( dst.length === resultLength )
    return dst;

    _.assert( Object.isExtensible( dst ), 'Array is not extensible, cannot change array' );

    dst.splice( f, 0, ... _.dup( ins, f2 ) );
    dst.splice( l2 + 1, 0, ... _.dup( ins, resultLength <= l2 ? 0 : resultLength - l2 - 1 ) );
    return dst;
  }
  else if( dst.length < resultLength && !Object.isExtensible( dst ) )
  {
    _.assert( 0, 'Array is not extensible, cannot change array' );
  }

  for( let r = f2 ; r < l2 + 1 ; r++ )
  result[ r ] = src[ r - f2 ];

  if( ins !== undefined )
  {
    for( let r = 0 ; r < f2 ; r++ )
    result[ r ] = ins;

    for( let r = l2 + 1 ; r < resultLength ; r++ )
    result[ r ] = ins;
  }

  return result;
}

// function arrayGrow_( dst, src, range, ins )
// {
//
//   [ dst, src, range, ins ] = _argumentsOnlyArray.apply( this, arguments );
//
//   if( range === undefined )
//   return returnDst();
//
//   if( _.number.is( range ) )
//   range = [ 0, range ];
//   _.assert( _.intervalIs( range ) || _.number.is( range ) || range === undefined );
//
//   let f = range[ 0 ] === undefined ?  0 : range[ 0 ];
//   let l = range[ 1 ] === undefined ?  0 : range[ 1 ];
//
//   if( l < f )
//   l = f;
//
//   if( f < 0 )
//   {
//     l -= f;
//     f -= f;
//   }
//
//   if( f > 0 )
//   f = 0;
//   if( l < src.length )
//   l = src.length;
//
//   if( l === src.length )
//   return returnDst();
//
//   let l2 = src.length;
//
//   let result;
//   if( dst !== false )
//   {
//     if( dst.length !== undefined )
//     result = dst;
//     else
//     result = src.slice();
//
//     if( !Object.isExtensible( dst ) && dst.length < l - f )
//     _.assert( 0, 'Array is not extensible, cannot change array' );
//
//     for( let i = 0; i < l2; i++ )
//     result[ i ] = src[ i ];
//   }
//   else
//   {
//     if( !Object.isExtensible( src ) && src.length < l - f )
//     _.assert( 0, 'Array is not extensible, cannot change array' );
//
//     result = src;
//   }
//
//   result.length = l;
//
//   if( ins !== undefined )
//   {
//     for( let r = l2; r < result.length ; r++ )
//     result[ r ] = ins;
//   }
//
//   return result;
//
//   /* */
//
//   function returnDst()
//   {
//     if( dst.length !== undefined )
//     dst.splice( 0, dst.length, ... src );
//     else
//     dst = dst === true ? src.slice() : src;
//
//     return dst;
//   }
// }

//

/**
 * Routine arrayRelength() changes length of provided array {-src-} by copying it elements to newly created array object
 * using range (range) positions of the original array and value to fill free space after copy (val).
 * Routine can grows and reduces size of Long. The original {-src-} will not be modified.
 *
 * @param { Array|Unroll } src - The Array or Unroll from which makes a shallow copy.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
 * If {-range-} is number, then it defines the start index, and the end index sets to src.length.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] <= range[ 0 ], then routine returns empty array.
 * @param { * } ins - The object of any type. Inserting begins from last index of {-src-} to end index.
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelength( src );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelength( src, 7, 'str' );
 * console.log( got );
 * // log []
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelength( src, [ 1, 6 ], 'str' );
 * console.log( got );
 * // log [ 2, 3, 4, 5, 'str' ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelength( src, [ -5, 6 ], 7 );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5, 7 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelength( src, [ 4, 1 ], 'str' );
 * console.log( got );
 * // log []
 * console.log( got === src );
 * // log false
 *
 * @returns { Array|Unroll } Returns a copy provided Array / Unroll with changed length.
 * @function arrayRelength
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-src-} is not an array or unroll.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range elements is not number / undefined.
 * @namespace Tools
 */

function arrayRelength( src, range, ins )
{
  let result;

  _.assert( 1 <= arguments.length && arguments.length <= 3 );

  if( range === undefined )
  return src.slice();

  if( _.number.is( range ) )
  range = [ range, src.length ];

  let f = range ? range[ 0 ] : undefined;
  let l = range ? range[ 1 ] : undefined;

  f = f !== undefined ? f : 0;
  l = l !== undefined ? l : src.length;

  _.assert( _.arrayIs( src ) );
  _.assert( _.intervalIs( range ) );

  if( l < f )
  l = f;

  if( f < 0 )
  f = 0;

  if( f === 0 && l === src.length )
  return src.slice( src );

  result = _.array.makeUndefined( src, l-f );

  let f2 = Math.max( f, 0 );
  let l2 = Math.min( src.length, l );
  for( let r = f2 ; r < l2 ; r++ )
  result[ r-f2 ] = src[ r ];

  if( ins !== undefined )
  {
    for( let r = l2 - f; r < result.length ; r++ )
    result[ r ] = ins;
  }

  return result;
}

//

/**
 * Routine arrayRelengthInplace() changes length of provided array {-src-} using range {-range-} positions of the original
 * array and value to fill free space after copy {-ins-}. Routine can grows and reduce size of Long.
 *
 * @param { Array|Unroll } src - The Array or Unroll to change length.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index of new array.
 * If {-range-} is number, then it defines the start index, and the end index sets to src.length.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] <= range[ 0 ], then routine returns empty array.
 * @param { * } ins - The object of any type. Inserting begins from last index of {-src-} to end index.
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelengthInplace( src );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelengthInplace( src, 7, 'str' );
 * console.log( got );
 * // log []
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelengthInplace( src, [ 1, 6 ], 'str' );
 * console.log( got );
 * // log [ 2, 3, 4, 5, 'str' ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelengthInplace( src, [ -5, 6 ], 7 );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 5, 7 ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * var src = [ 1, 2, 3, 4, 5 ];
 * var got = _.arrayRelengthInplace( src, [ 4, 1 ], 'str' );
 * console.log( got );
 * // log []
 * console.log( got === src );
 * // log false
 *
 * @returns { Array|Unroll } Returns a provided Array / Unroll with changed length.
 * @function arrayRelengthInplace
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If argument {-src-} is not an array or unroll.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range elements is not number / undefined.
 * @namespace Tools
 */

function arrayRelengthInplace( src, range, ins )
{
  _.assert( 1 <= arguments.length && arguments.length <= 3 );

  if( range === undefined )
  return src;

  if( _.number.is( range ) )
  range = [ range, src.length ];

  let f = range ? range[ 0 ] : undefined;
  let l = range ? range[ 1 ] : undefined;

  f = f !== undefined ? f : 0;
  l = l !== undefined ? l : src.length;

  _.assert( _.arrayIs( src ) );
  _.assert( _.intervalIs( range ) );

  if( l < f )
  l = f;

  if( f < 0 )
  f = 0;

  if( f === 0 && l === src.length )
  return src;

  if( !Object.isExtensible( src ) && src.length < l - f )
  _.assert( 0, 'Array is not extensible, cannot change length of array' );

  let f2 = Math.max( f, 0 );
  let l2 = Math.min( src.length, l );

  let result = src;

  result.splice.apply( result, [ 0, f ] );
  result.length = l - f;

  if( ins !== undefined )
  {
    for( let r = l2 - f; r < result.length ; r++ )
    result[ r ] = ins;
  }

  return result;
}

//

function arrayRelength_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval - 1 ];

  _.assert( _.arrayIs( dst ) || dst === null, 'Expects {-dst-} of Array type or null' );
  _.assert( _.arrayIs( src ), 'Expects {-src-} of Array type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] !== undefined ? cinterval[ 0 ] : 0;
  let last = cinterval[ 1 ] = cinterval[ 1 ] !== undefined ? cinterval[ 1 ] : src.length - 1;

  if( last < first )
  last = first - 1;

  if( first < 0 )
  {
    last -= first;
    first -= first;
  }

  let first2 = Math.max( Math.abs( cinterval[ 0 ] ), 0 );
  let last2 = Math.min( src.length - 1, last );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.array.makeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( dst.length === resultLength && cinterval[ 0 ] === 0 )
    {
      return dst;
    }
    if( resultLength === 0 )
    {
      return _.array.empty( dst );
    }

    if( dst.length < resultLength )
    _.assert( Object.isExtensible( dst ), 'dst is not extensible, cannot change dst' );

    if( cinterval[ 0 ] < 0 )
    {
      dst.splice( first, 0, ... _.dup( ins, first2 ) );
      dst.splice( last2 + 1, src.length - last2, ... _.dup( ins, last - last2 ) );
    }
    else
    {
      dst.splice( 0, first );
      dst.splice( last2 + 1 - first2, dst.length - last2, ... _.dup( ins, last - last2 ) );
    }
    return dst;
  }

  /* */

  if( result.length < resultLength )
  _.assert( Object.isExtensible( result ), 'dst is not extensible, cannot change dst' );

  if( resultLength === 0 )
  {
    return _.array.empty( result );
  }
  if( cinterval[ 0 ] < 0 )
  {
    result.splice( 0, first2, ... _.dup( ins, first2 ) );
    result.splice( first2, last2 - first2, ... src.slice( 0, last2 + 1 - first2 ) );
    result.splice( last2 + 1, result.length - last2, ... _.dup( ins, last - last2 ) );
  }
  else
  {
    result.splice( 0, last2 + 1, ... src.slice( first2, last2 + 1 ));
    result.splice( last2 + 1 - first2, result.length - last2, ... _.dup( ins, last - last2 ) );
  }

  return result;
}

// --
// array remove
// --

/**
 * ArrayRemove, arrayRemoveOnce, arrayRemoveOnceStrictly and arrayRemoved behave just like
 * arrayRemoveElement, arrayRemoveElementOnce, arrayRemoveElementOnceStrictly and arrayRemovedElement.
 */

function arrayRemove( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.arrayRemoved.apply( this, arguments );
  return dstArray;
}

//

function arrayRemoveOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.arrayRemovedOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayRemoveOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.arrayRemoveElementOnceStrictly.apply( this, arguments );
  return dstArray;
}

//

function arrayRemoved( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let removedElements = _.arrayRemovedElement.apply( this, arguments );
  return removedElements;
}

//

/**
 * ArrayRemovedOnce and arrayRemovedOnceStrictly behave just like arrayRemovedElementOnce and arrayRemovedElementOnceStrictly,
 * but return the index of the removed element, instead of the removed element
 */

function arrayRemovedOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let index = _.longLeftIndex.apply( _, arguments );
  if( index >= 0 )
  dstArray.splice( index, 1 );

  return index;
}

//

function arrayRemovedOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let index = _.longLeftIndex.apply( _, arguments );
  if( index >= 0 )
  {
    dstArray.splice( index, 1 );
  }
  else _.assert( 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );

  let newIndex = _.longLeftIndex.apply( _, arguments );
  _.assert( newIndex < 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + ' is several times in dstArray' );

  return index;
}

//

function arrayRemoveElement( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.arrayRemovedElement.apply( this, arguments );
  return dstArray;
}

//

/**
 * The arrayRemoveElementOnce() routine removes the first matching element from (dstArray)
 * that corresponds to the condition in the callback function and returns a modified array.
 *
 * It takes two (dstArray, ins) or three (dstArray, ins, onEvaluate) arguments,
 * checks if arguments passed two, it calls the routine
 * [arrayRemovedElementOnce( dstArray, ins )]{@link wTools.arrayRemovedElementOnce}
 * Otherwise, if passed three arguments, it calls the routine
 * [arrayRemovedElementOnce( dstArray, ins, onEvaluate )]{@link wTools.arrayRemovedElementOnce}
 * @see  wTools.arrayRemovedElementOnce
 * @param { Array } dstArray - The source array.
 * @param { * } ins - The value to remove.
 * @param { wTools~compareCallback } [ onEvaluate ] - The callback that compares (ins) with elements of the array.
 * By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayRemoveElementOnce( [ 1, 'str', 2, 3, 'str' ], 'str' );
 * // returns [ 1, 2, 3, 'str' ]
 *
 * @example
 * _.arrayRemoveElementOnce( [ 3, 7, 33, 13, 33 ], 13, function( el, ins ) {
 *   return el > ins;
 * });
 * // returns [ 3, 7, 13, 33 ]
 *
 * @returns { Array } - Returns the modified (dstArray) array with the new length.
 * @function arrayRemoveElementOnce
 * @throws { Error } If the first argument is not an array.
 * @throws { Error } If passed less than two or more than three arguments.
 * @throws { Error } If the third argument is not a function.
 * @namespace Tools
 */

function arrayRemoveElementOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];
  _.arrayRemovedElementOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayRemoveElementOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    let result = _.arrayRemovedElementOnce.apply( this, arguments );
    let index = _.longLeftIndex.apply( _, arguments );
    _.assert( index < 0 );
    _.assert( result >= 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
  }
  else
  {
    let result = _.arrayRemovedElement.apply( this, [ dstArray, ins ] );
  }
  return dstArray;
}

/*
function arrayRemoveElementOnceStrictly( dstArray, ins, evaluator1, evaluator2 )
{
  let result = arrayRemovedElementOnce.apply( this, arguments );
  _.assert( result >= 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
  return dstArray;
}
*/

//

function arrayRemovedElement( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let index = _.longLeftIndex.apply( this, arguments );
  let removedElements = 0;

  for( let i = 0; i < dstArray.length; i++ ) /* Dmytro : bad implementation, this cycle run routine longLeftIndex even if it not needs, better implementation commented below */
  {
    if( index !== -1 )
    {
      dstArray.splice( index, 1 );
      removedElements = removedElements + 1;
      i = i - 1 ;
    }
    index = _.longLeftIndex.apply( this, arguments ); /* Dmytro : this call uses not offset, it makes routine slower */
  }

  return removedElements;

  // let removedElements = 0;
  // let index = _.longLeftIndex.apply( this, arguments );
  // evaluator1 = _.number.is( evaluator1 ) ? undefined : evaluator1;
  //
  // while( index !== -1 )
  // {
  //   dstArray.splice( index, 1 );
  //   removedElements = removedElements + 1;
  //   index = _.longLeftIndex( dstArray, ins, index, evaluator1, evaluator2 );
  // }
  //
  // return removedElements;
}

//

function arrayRemovedElement_( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let removedElement;

  let index = _.longLeftIndex.apply( this, arguments );
  evaluator1 = _.number.is( evaluator1 ) ? undefined : evaluator1;

  if( index !== -1 )
  removedElement = dstArray[ index ];

  while( index !== -1 )
  {
    dstArray.splice( index, 1 );
    index = _.longLeftIndex( dstArray, ins, index, evaluator1, evaluator2 );
  }

  return removedElement;
}

//

/**
 * The callback function to compare two values.
 *
 * @callback wTools~compareCallback
 * @param { * } el - The element of the array.
 * @param { * } ins - The value to compare.
 */

/**
 * The arrayRemovedElementOnce() routine returns the index of the first matching element from (dstArray)
 * that corresponds to the condition in the callback function and remove this element.
 *
 * It takes two (dstArray, ins) or three (dstArray, ins, onEvaluate) arguments,
 * checks if arguments passed two, it calls built in function(dstArray.indexOf(ins))
 * that looking for the value of the (ins) in the (dstArray).
 * If true, it removes the value (ins) from (dstArray) array by corresponding index.
 * Otherwise, if passed three arguments, it calls the routine
 * [longLeftIndex( dstArray, ins, onEvaluate )]{@link wTools.longLeftIndex}
 * If callback function(onEvaluate) returns true, it returns the index that will be removed from (dstArray).
 * @see {@link wTools.longLeftIndex} - See for more information.
 *
 * @param { Array } dstArray - The source array.
 * @param { * } ins - The value to remove.
 * @param { wTools~compareCallback } [ onEvaluate ] - The callback that compares (ins) with elements of the array.
 * By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayRemovedElementOnce( [ 2, 4, 6 ], 4, function( el ) {
 *   return el;
 * });
 * // returns 1
 *
 * @example
 * _.arrayRemovedElementOnce( [ 2, 4, 6 ], 2 );
 * // returns 0
 *
 * @returns { Number } - Returns the index of the value (ins) that was removed from (dstArray).
 * @function arrayRemovedElementOnce
 * @throws { Error } If the first argument is not an array-like.
 * @throws { Error } If passed less than two or more than three arguments.
 * @throws { Error } If the third argument is not a function.
 * @namespace Tools
 */

function arrayRemovedElementOnce( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let index = _.longLeftIndex.apply( _, arguments );
  if( index >= 0 )
  dstArray.splice( index, 1 );

  return index;
  /* "!!! : breaking" */
  /* // arrayRemovedElementOnce should return the removed element
  let result;
  let index = _.longLeftIndex.apply( _, arguments );

  if( index >= 0 )
  {
    result = dstArray[ index ];
    dstArray.splice( index, 1 );
  }

  return result;
  */
}

//

function arrayRemovedElementOnce_( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let removedElement;
  let index = _.longLeftIndex.apply( _, arguments );
  if( index >= 0 )
  {
    removedElement = dstArray[ index ];
    dstArray.splice( index, 1 );
  }

  return removedElement;
}

//

function arrayRemovedElementOnceStrictly( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  let index = _.longLeftIndex.apply( _, arguments );
  if( index >= 0 )
  {
    result = dstArray[ index ];
    dstArray.splice( index, 1 );
  }
  else _.assert( 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );

  index = _.longLeftIndex.apply( _, arguments );
  _.assert( index < 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + ' is several times in dstArray' );

  return result;
}

//

function arrayRemovedElementOnceStrictly_( /* dstArray, ins, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let removedElement;
  let index = _.longLeftIndex.apply( _, arguments );
  if( index >= 0 )
  {
    removedElement = dstArray[ index ];
    dstArray.splice( index, 1 );
  }
  else _.assert( 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );

  index = _.longLeftIndex.apply( _, arguments );
  _.assert( index < 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + ' is several times in dstArray' );

  return removedElement;
}

/*
function arrayRemovedElementOnceStrictly( dstArray, ins, evaluator1, evaluator2 )
{

  let result;
  let index = _.longLeftIndex.apply( _, arguments );
  if( index >= 0 )
  {
    result = dstArray[ index ];
    dstArray.splice( index, 1 );
  }
  else _.assert( 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );

  return result;
}
*/

//

function arrayRemoveArray( dstArray, insArray )
{
  arrayRemovedArray.apply( this, arguments );
  return dstArray;
}

//

function arrayRemoveArrayOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  arrayRemovedArrayOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayRemoveArrayOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    let insArrayLength = insArray.length;
    result = arrayRemovedArrayOnce.apply( this, arguments );
    let index = - 1;
    for( let i = 0, len = insArray.length; i < len ; i++ )
    {
      index = dstArray.indexOf( insArray[ i ] );
      _.assert( index < 0 );
    }
    _.assert( result === insArrayLength );

  }
  else
  {
    result = arrayRemovedArray.apply( this, [ dstArray, insArray ] );
  }
  return dstArray;
}

/*
function arrayRemoveArrayOnceStrictly( dstArray, insArray, evaluator1, evaluator2 )
{
  let result = arrayRemovedArrayOnce.apply( this, arguments );
  _.assert( result === insArray.length );
  return dstArray;
}
*/

//

function arrayRemovedArray( dstArray, insArray )
{
  _.assert( arguments.length === 2 )
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
  _.assert( _.longLike( insArray ) );

  if( dstArray === insArray )
  return dstArray.splice( 0 ).length;

  let result = 0;
  let index = -1;

  for( let i = 0, len = insArray.length; i < len ; i++ )
  {
    index = dstArray.indexOf( insArray[ i ] );
    while( index !== -1 )
    {
      dstArray.splice( index, 1 );
      result += 1;
      index = dstArray.indexOf( insArray[ i ], index );
    }
  }

  return result;
}

//

/**
 * The callback function to compare two values.
 *
 * @callback arrayRemovedArrayOnce~onEvaluate
 * @param { * } el - The element of the (dstArray[n]) array.
 * @param { * } ins - The value to compare (insArray[n]).
 */

/**
 * The arrayRemovedArrayOnce() determines whether a (dstArray) array has the same values as in a (insArray) array,
 * and returns amount of the deleted elements from the (dstArray).
 *
 * It takes two (dstArray, insArray) or three (dstArray, insArray, onEqualize) arguments, creates variable (let result = 0),
 * checks if (arguments[..]) passed two, it iterates over the (insArray) array and calls for each element built in function(dstArray.indexOf(insArray[i])).
 * that looking for the value of the (insArray[i]) array in the (dstArray) array.
 * If true, it removes the value (insArray[i]) from (dstArray) array by corresponding index,
 * and incrementing the variable (result++).
 * Otherwise, if passed three (arguments[...]), it iterates over the (insArray) and calls for each element the routine
 *
 * If callback function(onEqualize) returns true, it returns the index that will be removed from (dstArray),
 * and then incrementing the variable (result++).
 *
 * @see wTools.longLeftIndex
 *
 * @param { longLike } dstArray - The target array.
 * @param { longLike } insArray - The source array.
 * @param { function } onEqualize - The callback function. By default, it checks the equality of two arguments.
 *
 * @example
 * _.arrayRemovedArrayOnce( [  ], [  ] );
 * // returns 0
 *
 * @example
 * _.arrayRemovedArrayOnce( [ 1, 2, 3, 4, 5 ], [ 6, 2, 7, 5, 8 ] );
 * // returns 2
 *
 * @example
 * _.arrayRemovedArrayOnce( [ 1, 2, 3, 4, 5 ], [ 6, 2, 7, 5, 8 ], function( a, b ) {
 *   return a < b;
 * } );
 * // returns 4
 *
 * @returns { number }  Returns amount of the deleted elements from the (dstArray).
 * @function arrayRemovedArrayOnce
 * @throws { Error } Will throw an Error if (dstArray) is not an array-like.
 * @throws { Error } Will throw an Error if (insArray) is not an array-like.
 * @throws { Error } Will throw an Error if (arguments.length < 2  || arguments.length > 3).
 * @namespace Tools
 */

function arrayRemovedArrayOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
  _.assert( _.longLike( insArray ) );

  if( dstArray === insArray )
  if( arguments.length === 2 )
  return dstArray.splice( 0 ).length;

  let result = 0;
  let index = -1;

  for( let i = insArray.length - 1; i >= 0 ; i-- )
  {
    index = _.longLeftIndex( dstArray, insArray[ i ], evaluator1, evaluator2 );

    if( index >= 0 )
    {
      dstArray.splice( index, 1 );
      result += 1;
    }
  }

  return result;
}

//

function arrayRemovedArrayOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    let insArrayLength = insArray.length;
    result = arrayRemovedArrayOnce.apply( this, arguments );
    let index = - 1;
    for( let i = 0, len = insArray.length; i < len ; i++ )
    {
      index = dstArray.indexOf( insArray[ i ] );
      _.assert( index < 0 );
    }
    _.assert( result === insArrayLength );

  }
  else
  {
    result = arrayRemovedArray.apply( this, [ dstArray, insArray ] );
  }
  return result;
}

//

function arrayRemoveArrays( dstArray, insArray )
{
  arrayRemovedArrays.apply( this, arguments );
  return dstArray;
}

//

function arrayRemoveArraysOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  arrayRemovedArraysOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayRemoveArraysOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    let expected = 0;
    for( let i = insArray.length - 1; i >= 0; i-- )
    {
      if( _.longLike( insArray[ i ] ) )
      expected += insArray[ i ].length;
      else
      expected += 1;
    }

    result = arrayRemovedArraysOnce.apply( this, arguments );

    _.assert( result === expected );
    _.assert( arrayRemovedArraysOnce.apply( this, arguments ) === 0 );
  }
  else
  {
    result = arrayRemovedArrays.apply( this, [ dstArray, insArray ] );
  }

  return dstArray;
}

/*
function arrayRemoveArraysOnceStrictly( dstArray, insArray, evaluator1, evaluator2 )
{
  let result = arrayRemovedArraysOnce.apply( this, arguments );

  let expected = 0;
  for( let i = insArray.length - 1; i >= 0; i-- )
  {
    if( _.longLike( insArray[ i ] ) )
    expected += insArray[ i ].length;
    else
    expected += 1;
  }

  _.assert( result === expected );

  return dstArray;
}
*/

//

function arrayRemovedArrays( dstArray, insArray )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.arrayIs( dstArray ), 'arrayRemovedArrays :', 'Expects array' );
  _.assert( _.longLike( insArray ), 'arrayRemovedArrays :', 'Expects longLike entity' );

  let result = 0;

  if( dstArray === insArray )
  {
    result = insArray.length;
    dstArray.splice( 0 );
    return result;
  }

  function _remove( argument )
  {
    let index = dstArray.indexOf( argument );
    while( index !== -1 )
    {
      dstArray.splice( index, 1 );
      result += 1;
      index = dstArray.indexOf( argument, index );
    }
  }

  for( let a = insArray.length - 1; a >= 0; a-- )
  {
    if( _.longLike( insArray[ a ] ) )
    {
      let array = insArray[ a ];
      for( let i = array.length - 1; i >= 0; i-- )
      _remove( array[ i ] );
    }
    else
    {
      _remove( insArray[ a ] );
    }
  }

  return result;
}

//

function arrayRemovedArraysOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( dstArray ), 'arrayRemovedArraysOnce :', 'Expects array' );
  _.assert( _.longLike( insArray ), 'arrayRemovedArraysOnce :', 'Expects longLike entity' );

  let result = 0;

  if( dstArray === insArray )
  if( arguments.length === 2 )
  {
    result = insArray.length;
    dstArray.splice( 0 );
    return result;
  }

  function _removeOnce( argument )
  {
    let index = _.longLeftIndex( dstArray, argument, evaluator1, evaluator2 );
    if( index >= 0 )
    {
      dstArray.splice( index, 1 );
      result += 1;
    }
  }

  for( let a = insArray.length - 1; a >= 0; a-- )
  {
    if( _.longLike( insArray[ a ] ) )
    {
      let array = insArray[ a ];
      for( let i = array.length - 1; i >= 0; i-- )
      _removeOnce( array[ i ] );
    }
    else
    {
      _removeOnce( insArray[ a ] );
    }
  }

  return result;
}

//

function arrayRemovedArraysOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result;
  if( Config.debug )
  {
    let expected = 0;
    for( let i = insArray.length - 1; i >= 0; i-- )
    {
      if( _.longLike( insArray[ i ] ) )
      expected += insArray[ i ].length;
      else
      expected += 1;
    }

    result = arrayRemovedArraysOnce.apply( this, arguments );

    _.assert( result === expected );
    _.assert( arrayRemovedArraysOnce.apply( this, arguments ) === 0 );
  }
  else
  {
    result = arrayRemovedArrays.apply( this, [ dstArray, insArray ] );
  }

  return result;
}

//

/**
 * The arrayRemoveDuplicates( dstArray, evaluator ) routine returns the dstArray with the duplicated elements removed.
 *
 * @param { ArrayIs } dstArray - The source and destination array.
 * @param { Function } [ evaluator = function( e ) { return e } ] - A callback function.
 *
 * @example
 * _.arrayRemoveDuplicates( [ 1, 1, 2, 'abc', 'abc', 4, true, true ] );
 * // returns [ 1, 2, 'abc', 4, true ]
 *
 * @example
 * _.arrayRemoveDuplicates( [ 1, 2, 3, 4, 5 ] );
 * // returns [ 1, 2, 3, 4, 5 ]
 *
 * @returns { Number } - Returns the source array without the duplicated elements.
 * @function arrayRemoveDuplicates
 * @throws { Error } If passed arguments is less than one or more than two.
 * @throws { Error } If the first argument is not an array.
 * @throws { Error } If the second argument is not a Function.
 * @namespace Tools
 */

function arrayRemoveDuplicates( dstArray, evaluator )
{
  _.assert( 1 <= arguments.length || arguments.length <= 2 );
  _.assert( _.arrayIs( dstArray ), 'Expects Array' );

  for( let i = 0 ; i < dstArray.length ; i++ )
  {
    let index;
    do
    {
      index = _.longRightIndex( dstArray, dstArray[ i ], evaluator );
      if( index !== i )
      {
        dstArray.splice( index, 1 );
      }
    }
    while( index !== i );
  }

  return dstArray;
}

/*
/*
function arrayRemoveDuplicates( dstArray, evaluator )
{
  _.assert( 1 <= arguments.length || arguments.length <= 2 );
  _.assert( _.arrayIs( dstArray ), 'arrayRemoveDuplicates :', 'Expects Array' );

  for( let i1 = 0 ; i1 < dstArray.length ; i1++ )
  {
    let element1 = dstArray[ i1 ];
    let index = _.longRightIndex( dstArray, element1, evaluator );

    while ( index !== i1 )
    {
      dstArray.splice( index, 1 );
      index = _.longRightIndex( dstArray, element1, evaluator );
    }
  }

  return dstArray;
}
*/

// --
// array flatten
// --

/**
 * The arrayFlatten() routine returns an array that contains all the passed arguments.
 *
 * It creates two variables the (result) - array and the {-srcMap-} - elements of array-like object (arguments[]),
 * iterate over array-like object (arguments[]) and assigns to the {-srcMap-} each element,
 * checks if {-srcMap-} is not equal to the 'undefined'.
 * If true, it adds element to the result.
 * If {-srcMap-} is an Array and if element(s) of the {-srcMap-} is not equal to the 'undefined'.
 * If true, it adds to the (result) each element of the {-srcMap-} array.
 * Otherwise, if {-srcMap-} is an Array and if element(s) of the {-srcMap-} is equal to the 'undefined' it throws an Error.
 *
 * @param {...*} arguments - One or more argument(s).
 *
 * @example
 * _.arrayFlatten( 'str', {}, [ 1, 2 ], 5, true );
 * // returns [ 'str', {}, 1, 2, 5, true ]
 *
 * @returns { Array } - Returns an array of the passed argument(s).
 * @function arrayFlatten
 * @throws { Error } If (arguments[...]) is an Array and has an 'undefined' element.
 * @namespace Tools
 */

function arrayFlatten( dstArray, insArray )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayFlattened.apply( this, arguments );

  return dstArray;
}

//

function arrayFlattenOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  _.arrayFlattenedOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayFlattenOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.arrayFlattenedOnceStrictly.apply( this, arguments );
  return dstArray;
}

//

function arrayFlattened( dstArray, src )
{
  let result = 0;
  let length = dstArray.length;
  let visited = [];

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.object.isBasic( this ) );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${dstArray}"` );

  if( arguments.length === 1 )
  {
    for( let i = 0 ; i < dstArray.length ; i++ )
    {
      let e = dstArray[ i ];
      if( _.longLike( e ) || _.set.like( e ) )
      {
        dstArray.splice( i, 1 );
        if( e !== dstArray )
        i = containerReplace( e, i );
        i -= 1;
      }
      else
      {
        result += 1;
      }
    }

    return result;
  }

  /*
  Dmytro : stack is unstable if dstArray.push( dstArray )
  */
  if( _.longHas( dstArray, dstArray ) )
  {
    let i = _.longLeftIndex( dstArray, dstArray );

    while( i !== -1 )
    {
      dstArray.splice( i, 1 );
      i = _.longLeftIndex( dstArray, dstArray );
    }
  }

  if( _.longLike( src ) || _.set.like( src ) )
  {
    containerAppend( src );
  }
  else
  {
    dstArray.push( src );
    result += 1;
  }

  return result;

  /* */

  function containerAppend( src )
  {
    if( _.longHas( visited, src ) )
    return;
    visited.push( src );

    let count;
    if( src === dstArray )
    count = length;
    else
    count = src.length;

    for( let e of src )
    {
      if( count < 1 )
      break;
      count--;

      if( _.longLike( e ) || _.set.like( e ) )
      {
        containerAppend( e )
      }
      else
      {
        dstArray.push( e );
        result += 1;
      }
    }

    visited.pop();
  }

  /* */

  function containerReplace( src, index )
  {
    for( let e of src )
    {
      if( _.longLike( e ) || _.set.like( e ) )
      {
        index = containerReplace( e, index );
      }
      else
      {
        dstArray.splice( index, 0, e );
        result += 1;
        index += 1;
      }
    }
    return index;
  }

}

//

function arrayFlattenedOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result = 0;
  let length = dstArray.length;
  let visited = [];

  _.assert( arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  if( arguments.length === 1 )
  {
    _.arrayRemoveDuplicates( dstArray );

    for( let i = 0 ; i < dstArray.length ; i++ )
    {
      let e = dstArray[ i ];
      if( _.longLike( e ) || _.set.like( e ) )
      {
        dstArray.splice( i, 1 );
        if( e !== dstArray )
        i = containerReplace( e, i );
        i -= 1;
      }
      else
      {
        result += 1;
      }
    }

    return result;
  }

  if( _.longHas( dstArray, dstArray ) )
  {
    let i = _.longLeftIndex( dstArray, dstArray );

    while( i !== -1 )
    {
      dstArray.splice( i, 1 );
      i = _.longLeftIndex( dstArray, dstArray );
    }
  }

  if( _.longLike( insArray ) || _.set.like( insArray ) )
  {
    containerAppend( insArray );
  }
  else if( _.longLeftIndex( dstArray, insArray, evaluator1, evaluator2 ) === -1 )
  {
    dstArray.push( insArray );
    result += 1;
  }

  return result;

  /* */

  function containerAppend( src )
  {
    if( _.longHas( visited, src ) )
    return;
    visited.push( src );

    let count;
    if( src === dstArray )
    count = length;
    else
    count = src.length;


    for( let e of src )
    {
      if( count < 1 )
      break;
      count--;

      if( _.longLike( e ) || _.set.like( e ) )
      {
        containerAppend( e )
      }
      else if( _.longLeftIndex( dstArray, e, evaluator1, evaluator2 ) === -1 )
      {
        dstArray.push( e );
        result += 1;
      }
    }

    visited.pop();
  }

  /* */

  function containerReplace( src, index )
  {
    for( let e of src )
    {
      if( _.longLike( e ) || _.set.like( e ) )
      {
        index = containerReplace( e, index );
      }
      else if( _.longLeftIndex( dstArray, e ) === -1 )
      {
        dstArray.splice( index, 0, e );
        result += 1;
        index += 1;
      }
    }
    return index;
  }
}

// function arrayFlattenedOnce( dstArray, insArray, evaluator1, evaluator2 )
// {
//
//   _.assert( arguments.length && arguments.length <= 4 );
//   _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
//
//   if( arguments.length === 1 )
//   {
//     _.arrayRemoveDuplicates( dstArray );
//
//     for( let i = dstArray.length-1; i >= 0; --i )
//     if( _.longLike( dstArray[ i ] ) )
//     {
//       let insArray = dstArray[ i ];
//       dstArray.splice( i, 1 );
//       onLongOnce( insArray, i );
//     }
//     return dstArray;
//   }
//
//   let result = 0;
//
//   if( _.longLike( insArray ) )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       _.assert( insArray[ i ] !== undefined, 'The Array should have no undefined' );
//       if( _.longLike( insArray[ i ] ) )
//       {
//         let c = _.arrayFlattenedOnce( dstArray, insArray[ i ], evaluator1, evaluator2 );
//         result += c;
//       }
//       else
//       {
//         let index = _.longLeftIndex( dstArray, insArray[ i ], evaluator1, evaluator2 );
//         if( index === -1 )
//         {
//           dstArray.push( insArray[ i ] );
//           result += 1;
//         }
//       }
//     }
//   }
//   else
//   {
//
//     _.assert( insArray !== undefined, 'The Array should have no undefined' );
//
//     let index = _.longLeftIndex( dstArray, insArray, evaluator1, evaluator2 );
//     if( index === -1 )
//     {
//       dstArray.push( insArray );
//       result += 1;
//     }
//   }
//
//   return result;
//
//   /* */
//
//   function onLongOnce( insArray, insIndex )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       if( _.longLike( insArray[ i ] ) )
//       onLongOnce( insArray[ i ], insIndex )
//       else if( _.longLeftIndex( dstArray, insArray[ i ] ) === -1 )
//       dstArray.splice( insIndex++, 0, insArray[ i ] );
//     }
//   }
// }

//

function arrayFlattenedOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result = 0;
  let visited = [];

  _.assert( arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  let oldLength = dstArray.length;
  _.arrayRemoveDuplicates( dstArray );
  let newLength = dstArray.length;
  if( Config.debug )
  _.assert( oldLength === newLength, 'Elements in dstArray must not be repeated' );

  if( arguments.length === 1 )
  {
    for( let i = 0 ; i < dstArray.length ; i++ )
    {
      let e = dstArray[ i ];
      if( _.longLike( e ) || _.set.like( e ) )
      {
        dstArray.splice( i, 1 );
        if( e !== dstArray )
        i = containerReplace( e, i );
        i -= 1;
      }
      else
      {
        result += 1;
      }
    }

    return result;
  }

  if( _.longHas( dstArray, dstArray ) )
  {
    let i = _.longLeftIndex( dstArray, dstArray );

    while( i !== -1 )
    {
      dstArray.splice( i, 1 );
      i = _.longLeftIndex( dstArray, dstArray );
    }
  }

  if( _.longLike( insArray ) || _.set.like( insArray ) )
  {
    containerAppend( insArray );
  }
  else if( _.longLeftIndex( dstArray, insArray, evaluator1, evaluator2 ) === -1 )
  {
    _.assert( insArray !== undefined, 'The container should be no undefined' );

    dstArray.push( insArray );
    result += 1;
  }
  else if( Config.debug )
  _.assert( 0, 'Elements must not be repeated' );

  return result;

  /* */

  function containerAppend( src )
  {
    if( _.longHas( visited, src ) )
    return;
    visited.push( src );

    let count;
    if( src === dstArray )
    count = oldLength;
    else
    count = src.length;


    for( let e of src )
    {
      if( count < 1 )
      break;
      count--;

      _.assert( e !== undefined, 'The container should have no undefined' );

      if( _.longLike( e ) || _.set.like( e ) )
      {
        containerAppend( e )
      }
      else if( _.longLeftIndex( dstArray, e, evaluator1, evaluator2 ) === -1 )
      {
        dstArray.push( e );
        result += 1;
      }
      else if( Config.debug )
      _.assert( 0, 'Elements must not be repeated' );

    }

    visited.pop();
  }

  /* */

  function containerReplace( src, index )
  {
    for( let e of src )
    {
      if( _.longLike( e ) || _.set.like( e ) )
      {
        index = containerReplace( e, index );
      }
      else if( _.longLeftIndex( dstArray, e ) === -1 )
      {
        dstArray.splice( index, 0, e );
        result += 1;
        index += 1;
      }
    }
    return index;
  }

}

// function arrayFlattenedOnceStrictly( dstArray, insArray, evaluator1, evaluator2 )
// {
//
//   _.assert( arguments.length && arguments.length <= 4 );
//   _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
//
//   let oldLength = dstArray.length;
//   _.arrayRemoveDuplicates( dstArray );
//   let newLength = dstArray.length;
//   if( Config.debug )
//   _.assert( oldLength === newLength, 'Elements in dstArray must not be repeated' );
//
//
//   if( arguments.length === 1 )
//   {
//     for( let i = dstArray.length-1; i >= 0; --i )
//     if( _.longLike( dstArray[ i ] ) )
//     {
//       let insArray = dstArray[ i ];
//       dstArray.splice( i, 1 );
//       onLongOnce( insArray, i );
//     }
//     return dstArray;
//   }
//
//   let result = 0;
//
//   if( _.longLike( insArray ) )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       _.assert( insArray[ i ] !== undefined, 'The Array should have no undefined' );
//       if( _.longLike( insArray[ i ] ) )
//       {
//         let c = _.arrayFlattenedOnceStrictly( dstArray, insArray[ i ], evaluator1, evaluator2 );
//         result += c;
//       }
//       else
//       {
//         let index = _.longLeftIndex( dstArray, insArray[ i ], evaluator1, evaluator2 );
//         if( Config.debug )
//         _.assert( index === -1, 'Elements must not be repeated' );
//
//         if( index === -1 )
//         {
//           dstArray.push( insArray[ i ] );
//           result += 1;
//         }
//       }
//     }
//   }
//   else
//   {
//     _.assert( insArray !== undefined, 'The Array should have no undefined' );
//     let index = _.longLeftIndex( dstArray, insArray, evaluator1, evaluator2 );
//     if( Config.debug )
//     _.assert( index === -1, 'Elements must not be repeated' );
//
//     if( index === -1 )
//     {
//       dstArray.push( insArray );
//       result += 1;
//     }
//   }
//
//   return result;
//
//   /* */
//
//   function onLongOnce( insArray, insIndex )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       if( _.longLike( insArray[ i ] ) )
//       onLongOnce( insArray[ i ], insIndex )
//       else if( _.longLeftIndex( dstArray, insArray[ i ] ) === -1 )
//       dstArray.splice( insIndex++, 0, insArray[ i ] );
//       else if( Config.debug )
//       _.assert( _.longLeftIndex( dstArray, insArray[ i ] ) === -1, 'Elements must not be repeated' );
//     }
//   }
// }

//

function arrayFlattenDefined( dstArray, insArray )
{
  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayFlattenedDefined.apply( this, arguments );

  return dstArray;
}

//

function arrayFlattenDefinedOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  if( dstArray === null )
  {
    dstArray = [];
    arguments[ 0 ] = dstArray;
  }

  arrayFlattenedDefinedOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayFlattenDefinedOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  arrayFlattenedDefinedOnceStrictly.apply( this, arguments );
  return dstArray;
}

//

function arrayFlattenedDefined( dstArray, src )
{
  let result = 0;
  let length = dstArray.length;
  let visited = [];

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.object.isBasic( this ) );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  if( arguments.length === 1 )
  {
    for( let i = 0 ; i < dstArray.length ; i++ )
    {
      let e = dstArray[ i ];

      if( e === undefined )
      {
        dstArray.splice( i, 1 );
        i -= 1;
      }
      else if( _.longLike( e ) || _.set.like( e ) )
      {
        dstArray.splice( i, 1 );
        if( e !== dstArray )
        i = containerReplace( e, i );
        i -= 1;
      }
      else
      {
        result += 1;
      }
    }

    return result;
  }

  if( _.longHas( dstArray, dstArray ) )
  {
    let i = _.longLeftIndex( dstArray, dstArray );

    while( i !== -1 )
    {
      dstArray.splice( i, 1 );
      i = _.longLeftIndex( dstArray, dstArray );
    }
  }

  if( _.longLike( src ) || _.set.like( src ) )
  {
    containerAppend( src );
  }
  else if( src !== undefined )
  {
    dstArray.push( src );
    result += 1;
  }

  return result;

  /* */

  function containerAppend( src )
  {
    if( _.longHas( visited, src ) )
    return;
    visited.push( src );

    let count;
    if( src === dstArray )
    count = length;
    else
    count = src.length;

    for( let e of src )
    {
      if( count < 1 )
      break;
      count--;

      if( _.longLike( e ) || _.set.like( e ) )
      {
        containerAppend( e )
      }
      else
      {
        if( e !== undefined )
        {
          dstArray.push( e );
          result += 1;
        }
      }
    }

    visited.pop();
  }

  /* */

  function containerReplace( src, index )
  {
    for( let e of src )
    {
      if( _.longLike( e ) || _.set.like( e ) )
      {
        index = containerReplace( e, index );
      }
      else
      {
        if( e !== undefined )
        {
          dstArray.splice( index, 0, e );
          result += 1;
          index += 1;
        }
      }
    }
    return index;
  }

}

// function arrayFlattenedDefined( dstArray, insArray )
// {
//
//   _.assert( arguments.length >= 1 );
//   _.assert( _.object.isBasic( this ) );
//   _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
//
//   if( arguments.length === 1 )
//   {
//     for( let i = dstArray.length-1; i >= 0; --i )
//     if( _.longLike( dstArray[ i ] ) )
//     {
//       let insArray = dstArray[ i ];
//       dstArray.splice( i, 1 );
//       onLong( insArray, i );
//     }
//     return dstArray;
//   }
//
//   let result = 0;
//
//   for( let a = 1 ; a < arguments.length ; a++ )
//   {
//     let insArray = arguments[ a ];
//
//     if( _.longLike( insArray ) )
//     {
//       for( let i = 0, len = insArray.length; i < len; i++ )
//       {
//         if( _.longLike( insArray[ i ] ) )
//         {
//           let c = _.arrayFlattenedDefined( dstArray, insArray[ i ] );
//           result += c;
//         }
//         else
//         {
//           // _.assert( insArray[ i ] !== undefined, 'The Array should have no undefined' );
//           if( insArray[ i ] !== undefined )
//           {
//             dstArray.push( insArray[ i ] );
//             result += 1;
//           }
//         }
//       }
//     }
//     else
//     {
//       _.assert( insArray !== undefined, 'The Array should have no undefined' );
//       if( insArray !== undefined )
//       {
//         dstArray.push( insArray );
//         result += 1;
//       }
//     }
//
//   }
//
//   return result;
//
//   /* */
//
//   function onLong( insArray, insIndex )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       if( _.longLike( insArray[ i ] ) )
//       onLong( insArray[ i ], insIndex )
//       else
//       dstArray.splice( insIndex++, 0, insArray[ i ] );
//     }
//   }
//
// }

//

function arrayFlattenedDefinedOnce( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result = 0;
  let length = dstArray.length;
  let visited = [];

  _.assert( arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  if( arguments.length === 1 )
  {
    _.arrayRemoveDuplicates( dstArray );

    for( let i = 0 ; i < dstArray.length ; i++ )
    {
      let e = dstArray[ i ];
      if( e === undefined )
      {
        dstArray.splice( i, 1 );
        i -= 1;
      }
      else if( _.longLike( e ) || _.set.like( e ) )
      {
        dstArray.splice( i, 1 );
        if( e !== dstArray )
        i = containerReplace( e, i );
        i -= 1;
      }
      else
      {
        result += 1;
      }
    }

    return result;
  }

  if( _.longHas( dstArray, dstArray ) )
  {
    let i = _.longLeftIndex( dstArray, dstArray );

    while( i !== -1 )
    {
      dstArray.splice( i, 1 );
      i = _.longLeftIndex( dstArray, dstArray );
    }
  }

  if( _.longLike( insArray ) || _.set.like( insArray ) )
  {
    containerAppend( insArray );
  }
  else if( insArray !== undefined )
  {
    if( _.longLeftIndex( dstArray, insArray, evaluator1, evaluator2 ) === -1)
    {
      dstArray.push( insArray );
      result += 1;
    }
  }

  return result;

  /* */

  function containerAppend( src )
  {
    if( _.longHas( visited, src ) )
    return;
    visited.push( src );

    let count;
    if( src === dstArray )
    count = length;
    else
    count = src.length;


    for( let e of src )
    {
      if( count < 1 )
      break;
      count--;

      if( _.longLike( e ) || _.set.like( e ) )
      {
        containerAppend( e )
      }
      else if( e !== undefined )
      {
        if( _.longLeftIndex( dstArray, e, evaluator1, evaluator2 ) === -1 )
        {
          dstArray.push( e );
          result += 1;
        }
      }
    }

    visited.pop();
  }

  /* */

  function containerReplace( src, index )
  {
    for( let e of src )
    {
      if( _.longLike( e ) || _.set.like( e ) )
      {
        index = containerReplace( e, index );
      }
      else if( e !== undefined )
      {
        if( _.longLeftIndex( dstArray, e ) === -1 )
        {
          dstArray.splice( index, 0, e );
          result += 1;
          index += 1;
        }
      }
    }
    return index;
  }
}

// function arrayFlattenedDefinedOnce( dstArray, insArray, evaluator1, evaluator2 )
// {
//
//   _.assert( arguments.length && arguments.length <= 4 );
//   _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
//
//   if( arguments.length === 1 )
//   {
//     _.arrayRemoveDuplicates( dstArray );
//
//     for( let i = dstArray.length-1; i >= 0; --i )
//     if( _.longLike( dstArray[ i ] ) )
//     {
//       let insArray = dstArray[ i ];
//       dstArray.splice( i, 1 );
//       onLongOnce( insArray, i );
//     }
//     return dstArray;
//   }
//
//   let result = 0;
//
//   if( _.longLike( insArray ) )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       _.assert( insArray[ i ] !== undefined );
//       if( _.longLike( insArray[ i ] ) )
//       {
//         let c = _.arrayFlattenedDefinedOnce( dstArray, insArray[ i ], evaluator1, evaluator2 );
//         result += c;
//       }
//       else
//       {
//         let index = _.longLeftIndex( dstArray, insArray[ i ], evaluator1, evaluator2 );
//         if( index === -1 )
//         {
//           dstArray.push( insArray[ i ] );
//           result += 1;
//         }
//       }
//     }
//   }
//   else if( insArray !== undefined )
//   {
//
//     let index = _.longLeftIndex( dstArray, insArray, evaluator1, evaluator2 );
//     if( index === -1 )
//     {
//       dstArray.push( insArray );
//       result += 1;
//     }
//   }
//
//   return result;
//
//   /* */
//
//   function onLongOnce( insArray, insIndex )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       if( _.longLike( insArray[ i ] ) )
//       onLongOnce( insArray[ i ], insIndex )
//       else if( _.longLeftIndex( dstArray, insArray[ i ] ) === -1 )
//       dstArray.splice( insIndex++, 0, insArray[ i ] );
//     }
//   }
//
// }

//

function arrayFlattenedDefinedOnceStrictly( /* dstArray, insArray, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let insArray = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  let result = 0;
  let visited = [];

  _.assert( arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );

  let oldLength = dstArray.length;
  _.arrayRemoveDuplicates( dstArray );
  let newLength = dstArray.length;
  if( Config.debug )
  _.assert( oldLength === newLength, 'Elements in dstArray must not be repeated' );

  if( arguments.length === 1 )
  {
    for( let i = 0 ; i < dstArray.length ; i++ )
    {
      let e = dstArray[ i ];
      if( e === undefined )
      {
        dstArray.splice( i, 1 );
        i -= 1;
      }
      else if( _.longLike( e ) || _.set.like( e ) )
      {
        dstArray.splice( i, 1 );
        if( e !== dstArray )
        i = containerReplace( e, i );
        i -= 1;
      }
      else
      {
        result += 1;
      }
    }

    return result;
  }

  if( _.longHas( dstArray, dstArray ) )
  {
    let i = _.longLeftIndex( dstArray, dstArray );

    while( i !== -1 )
    {
      dstArray.splice( i, 1 );
      i = _.longLeftIndex( dstArray, dstArray );
    }
  }

  if( _.longLike( insArray ) || _.set.like( insArray ) )
  {
    containerAppend( insArray );
  }
  else if( insArray !== undefined )
  {
    if( _.longLeftIndex( dstArray, insArray, evaluator1, evaluator2 ) === -1 )
    {
      dstArray.push( insArray );
      result += 1;
    }
    else if( Config.debug )
    _.assert( 0, 'Elements must not be repeated' );
  }

  return result;

  /* */

  function containerAppend( src )
  {
    if( _.longHas( visited, src ) )
    return;
    visited.push( src );

    let count;
    if( src === dstArray )
    count = oldLength;
    else
    count = src.length;


    for( let e of src )
    {
      if( count < 1 )
      break;
      count--;

      if( _.longLike( e ) || _.set.like( e ) )
      {
        containerAppend( e )
      }
      else if( e !== undefined )
      {
        if( _.longLeftIndex( dstArray, e, evaluator1, evaluator2 ) === -1 )
        {
          dstArray.push( e );
          result += 1;
        }
        else if( Config.debug )
        _.assert( 0, 'Elements must not be repeated' );
      }
    }

    visited.pop();
  }

  /* */

  function containerReplace( src, index )
  {
    for( let e of src )
    {
      if( _.longLike( e ) || _.set.like( e ) )
      {
        index = containerReplace( e, index );
      }
      else if( e !== undefined )
      {
        if( _.longLeftIndex( dstArray, e ) === -1 )
        {
          dstArray.splice( index, 0, e );
          result += 1;
          index += 1;
        }
        else if( Config.debug )
        _.assert( 0, 'Elements must not be repeated' );
      }
    }
    return index;
  }

}

// function arrayFlattenedDefinedOnceStrictly( dstArray, insArray, evaluator1, evaluator2 )
// {
//
//   _.assert( arguments.length && arguments.length <= 4 );
//   _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
//
//   let oldLength = dstArray.length;
//   _.arrayRemoveDuplicates( dstArray );
//   let newLength = dstArray.length;
//   if( Config.debug )
//   _.assert( oldLength === newLength, 'Elements in dstArray must not be repeated' );
//
//
//   if( arguments.length === 1 )
//   {
//     for( let i = dstArray.length-1; i >= 0; --i )
//     if( _.longLike( dstArray[ i ] ) )
//     {
//       let insArray = dstArray[ i ];
//       dstArray.splice( i, 1 );
//       onLongOnce( insArray, i );
//     }
//     return dstArray;
//   }
//
//   let result = 0;
//
//   if( _.longLike( insArray ) )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       // _.assert( insArray[ i ] !== undefined );
//       if( insArray[ i ] === undefined )
//       {
//       }
//       else if( _.longLike( insArray[ i ] ) )
//       {
//         let c = _.arrayFlattenedDefinedOnceStrictly( dstArray, insArray[ i ], evaluator1, evaluator2 );
//         result += c;
//       }
//       else
//       {
//         let index = _.longLeftIndex( dstArray, insArray[ i ], evaluator1, evaluator2 );
//         if( Config.debug )
//         _.assert( index === -1, 'Elements must not be repeated' );
//         if( index === -1 )
//         {
//           dstArray.push( insArray[ i ] );
//           result += 1;
//         }
//       }
//     }
//   }
//   else if( insArray !== undefined )
//   {
//
//     let index = _.longLeftIndex( dstArray, insArray, evaluator1, evaluator2 );
//     if( Config.debug )
//     _.assert( index === -1, 'Elements must not be repeated' );
//
//     if( index === -1 )
//     {
//       dstArray.push( insArray );
//       result += 1;
//     }
//   }
//
//   return result;
//
//   /* */
//
//   function onLongOnce( insArray, insIndex )
//   {
//     for( let i = 0, len = insArray.length; i < len; i++ )
//     {
//       if( _.longLike( insArray[ i ] ) )
//       onLongOnce( insArray[ i ], insIndex )
//       else if( _.longLeftIndex( dstArray, insArray[ i ] ) === -1 )
//       dstArray.splice( insIndex++, 0, insArray[ i ] );
//       else if( Config.debug )
//       _.assert( _.longLeftIndex( dstArray, insArray[ i ] ) === -1, 'Elements must not be repeated' );
//     }
//   }
// }

// --
// array replace
// --

//

function arrayReplace( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );

  let index = -1;
  let result = 0;

  index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );

  while( index !== -1 )
  {
    dstArray.splice( index, 1, sub );
    result += 1;
    index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );
  }

  return dstArray;
}

/**
 * The arrayReplaceOnce() routine returns the index of the (dstArray) array which will be replaced by (sub),
 * if (dstArray) has the value (ins).
 *
 * It takes three arguments (dstArray, ins, sub), calls built in function(dstArray.indexOf(ins)),
 * that looking for value (ins) in the (dstArray).
 * If true, it replaces (ins) value of (dstArray) by (sub) and returns the index of the (ins).
 * Otherwise, it returns (-1) index.
 *
 * @param { Array } dstArray - The source array.
 * @param { * } ins - The value to find.
 * @param { * } sub - The value to replace.
 *
 * @example
 * _.arrayReplaceOnce( [ 2, 4, 6, 8, 10 ], 12, 14 );
 * // returns -1
 *
 * @example
 * _.arrayReplaceOnce( [ 1, undefined, 3, 4, 5 ], undefined, 2 );
 * // returns 1
 *
 * @example
 * _.arrayReplaceOnce( [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ], 'Dmitry', 'Bob' );
 * // returns 3
 *
 * @example
 * _.arrayReplaceOnce( [ true, true, true, true, false ], false, true );
 * // returns 4
 *
 * @returns { number }  Returns the index of the (dstArray) array which will be replaced by (sub),
 * if (dstArray) has the value (ins).
 * @function arrayReplaceOnce
 * @throws { Error } Will throw an Error if (dstArray) is not an array.
 * @throws { Error } Will throw an Error if (arguments.length) is less than three.
 * @namespace Tools
 */

function arrayReplaceOnce( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  arrayReplacedOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayReplaceOnceStrictly( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result;
  if( Config.debug )
  {
    result = arrayReplacedOnce.apply( this, arguments );
    _.assert( result >= 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
    result = arrayReplacedOnce.apply( this, arguments );
    _.assert( result < 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + 'is several times in dstArray' );
  }
  else
  {
    result = arrayReplacedOnce.apply( this, arguments );
  }
  return dstArray;
}

/*
function arrayReplaceOnceStrictly( dstArray, ins, sub, evaluator1, evaluator2 )
{
  let result = arrayReplacedOnce.apply( this, arguments );
  _.assert( result >= 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
  return dstArray;
}
*/

//

function arrayReplaced( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );

  let index = -1;
  let result = 0;

  index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );

  while( index !== -1 )
  {
    dstArray.splice( index, 1, sub );
    result += 1;
    index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );
  }

  return result;
}

//

function arrayReplacedOnce( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );

  if( _.longLike( ins ) )
  {
    _.assert( _.longLike( sub ) );
    _.assert( ins.length === sub.length );
  }

  let index = -1;

  index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );

  if( index >= 0 )
  dstArray.splice( index, 1, sub );

  return index;
}

//

function arrayReplacedOnceStrictly( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result;
  if( Config.debug )
  {
    result = arrayReplacedOnce.apply( this, arguments );
    _.assert( result >= 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
    let newResult = arrayReplacedOnce.apply( this, arguments );
    _.assert( newResult < 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + 'is several times in dstArray' );
  }
  else
  {
    result = arrayReplacedOnce.apply( this, arguments );
  }

  return result;
}

//

function arrayReplaceElement( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );

  let index = -1;
  let result = 0;

  index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );

  while( index !== -1 )
  {
    dstArray.splice( index, 1, sub );
    result += 1;
    index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );
  }

  return dstArray;
}

//

function arrayReplaceElementOnce( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  arrayReplacedElementOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayReplaceElementOnceStrictly( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result;
  if( Config.debug )
  {
    result = arrayReplacedElementOnce.apply( this, arguments );
    _.assert( result !== undefined, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
    result = arrayReplacedElementOnce.apply( this, arguments );
    _.assert( result === undefined, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + 'is several times in dstArray' );
  }
  else
  {
    result = arrayReplacedElementOnce.apply( this, arguments );
  }
  return dstArray;
}

//

function arrayReplacedElement( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );

  let index = -1;
  let result = 0;

  index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );

  while( index !== -1 )
  {
    dstArray.splice( index, 1, sub );
    result += 1;
    index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );
  }

  return result;
}

//

function arrayReplacedElementOnce( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );

  if( _.longLike( ins ) )
  {
    _.assert( _.longLike( sub ) );
    _.assert( ins.length === sub.length );
  }

  let index = -1;

  index = _.longLeftIndex( dstArray, ins, evaluator1, evaluator2 );

  if( index >= 0 )
  dstArray.splice( index, 1, sub );
  else
  return undefined;

  return ins;
}

//

function arrayReplacedElementOnceStrictly( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result;
  if( Config.debug )
  {
    result = arrayReplacedElementOnce.apply( this, arguments );
    _.assert( result !== undefined, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
    let newResult = arrayReplacedElementOnce.apply( this, arguments );
    _.assert( newResult === undefined, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + 'is several times in dstArray' );
  }
  else
  {
    result = arrayReplacedElementOnce.apply( this, arguments );
  }

  return result;
}

/*
function arrayReplacedOnceStrictly( dstArray, ins, sub, evaluator1, evaluator2 )
{
  let result = arrayReplacedOnce.apply( this, arguments );
  _.assert( result >= 0, () => 'Array does not have element ' + _.entity.exportStringDiagnosticShallow( ins ) );
  return result;
}
*/

//

function arrayReplaceArray( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  arrayReplacedArray.apply( this, arguments );
  return dstArray;
}

//

function arrayReplaceArrayOnce( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  arrayReplacedArrayOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayReplaceArrayOnceStrictly( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result;
  if( Config.debug )
  {
    let insArrayLength = ins.length;
    result = arrayReplacedArrayOnce.apply( this, arguments );
    _.assert( result === insArrayLength, '{-dstArray-} should have each element of {-insArray-}' );
    _.assert( insArrayLength === sub.length, '{-subArray-} should have the same length {-insArray-} has' );

    if( dstArray === ins )
    return dstArray;

    let newResult = arrayReplacedArrayOnce.apply( this, arguments );

    _.assert( newResult === 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + 'is several times in dstArray' );
  }
  else
  {
    result = arrayReplacedArrayOnce.apply( this, arguments );
  }

  return dstArray;
}

/*
function arrayReplaceArrayOnceStrictly( dstArray, ins, sub, evaluator1, evaluator2 )
{
  let result = arrayReplacedArrayOnce.apply( this, arguments );
  _.assert( result === ins.length, '{-dstArray-} should have each element of {-insArray-}' );
  _.assert( ins.length === sub.length, '{-subArray-} should have the same length {-insArray-} has' );
  return dstArray;
}
*/

//

function arrayReplacedArray( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );
  _.assert( _.longLike( ins ) );
  _.assert( _.longLike( sub ) );
  _.assert( ins.length === sub.length, '{-subArray-} should have the same length {-insArray-} has' );

  let result = 0;
  let index = -1;
  // let oldDstArray = dstArray.slice();  // Array with src values stored
  if( dstArray === ins )
  ins = ins.slice();

  for( let i = 0, len = ins.length; i < len; i++ )
  {
    // let dstArray2 = oldDstArray.slice(); // Array modified for each ins element
    index = _.longLeftIndex( dstArray, ins[ i ], evaluator1, evaluator2 );
    while( index !== -1 )
    {
      let subValue = sub[ i ];
      let insValue = ins[ i ];
      if( subValue === undefined )
      {
        dstArray.splice( index, 1 );
        // dstArray2.splice( index, 1 );
      }
      else
      {
        dstArray.splice( index, 1, subValue );
        // dstArray2.splice( index, 1, subValue );
      }

      result += 1;

      // if( dstArray === ins )
      // break;

      if( subValue === insValue )
      break;

      index = _.longLeftIndex( dstArray, insValue, evaluator1, evaluator2 );
    }
  }

  return result;
}

//

function arrayReplacedArrayOnce( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( _.longLike( ins ) );
  _.assert( _.longLike( sub ) );
  _.assert( ins.length === sub.length, '{-subArray-} should have the same length {-insArray-} has' );
  _.assert( 3 <= arguments.length && arguments.length <= 5 );

  let index = -1;
  let result = 0;

  //let oldDstArray = dstArray.slice();  // Array with src values stored
  for( let i = 0, len = ins.length; i < len; i++ )
  {
    index = _.longLeftIndex( dstArray, ins[ i ], evaluator1, evaluator2 );
    if( index >= 0 )
    {
      let subValue = sub[ i ];
      if( subValue === undefined )
      dstArray.splice( index, 1 );
      else
      dstArray.splice( index, 1, subValue );
      result += 1;
    }
  }

  return result;
}

//

function arrayReplacedArrayOnceStrictly( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result;
  if( Config.debug )
  {
    let insArrayLength = ins.length
    result = arrayReplacedArrayOnce.apply( this, arguments );
    _.assert( result === insArrayLength, '{-dstArray-} should have each element of {-insArray-}' );
    _.assert( insArrayLength === sub.length, '{-subArray-} should have the same length {-insArray-} has' );

    if( dstArray === ins )
    return result;

    let newResult = arrayReplacedArrayOnce.apply( this, arguments );
    _.assert( newResult === 0, () => 'One element of ' + _.entity.exportStringDiagnosticShallow( ins ) + 'is several times in dstArray' );
  }
  else
  {
    result = arrayReplacedArrayOnce.apply( this, arguments );
  }

  return result;
}

//

function arrayReplaceArrays( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  arrayReplacedArrays.apply( this, arguments );
  return dstArray;
}

//

function arrayReplaceArraysOnce( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  arrayReplacedArraysOnce.apply( this, arguments );
  return dstArray;
}

//

function arrayReplaceArraysOnceStrictly( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result;
  if( Config.debug )
  {
    let expected = 0;
    for( let i = ins.length - 1; i >= 0; i-- )
    {
      if( _.longLike( ins[ i ] ) )
      expected += ins[ i ].length;
      else
      expected += 1;
    }

    result = arrayReplacedArraysOnce.apply( this, arguments );

    _.assert( result === expected, '{-dstArray-} should have each element of {-insArray-}' );
    _.assert( ins.length === sub.length, '{-subArray-} should have the same length {-insArray-} has' );

    if( dstArray === ins )
    return dstArray;

    let newResult = arrayReplacedArrayOnce.apply( this, arguments );
    _.assert( newResult === 0, () => 'One element of ' + _.entity.exportStringDiagnosticShallow( ins ) + 'is several times in dstArray' );
  }
  else
  {
    result = arrayReplacedArraysOnce.apply( this, arguments );
  }

  return dstArray;

}

//

function arrayReplacedArrays( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );
  _.assert( _.arrayIs( dstArray ), 'arrayReplacedArrays :', 'Expects array' );
  _.assert( _.longLike( sub ), 'arrayReplacedArrays :', 'Expects longLike entity' );
  _.assert( _.longLike( ins ), 'arrayReplacedArrays :', 'Expects longLike entity' );
  _.assert( ins.length === sub.length, '{-subArray-} should have the same length {-insArray-} has' );

  let result = 0;

  function _replace( /* dstArray, argument, subValue, evaluator1, evaluator2 */ )
  {
    let dstArray = arguments[ 0 ];
    let argument = arguments[ 1 ];
    let subValue = arguments[ 2 ];
    let evaluator1 = arguments[ 3 ];
    let evaluator2 = arguments[ 4 ];
    // let dstArray2 = oldDstArray.slice();
    //let index = dstArray.indexOf( argument );
    let index = _.longLeftIndex( dstArray, argument, evaluator1, evaluator2 );

    while( index !== -1 )
    {
      // dstArray2.splice( index, 1, subValue );
      dstArray.splice( index, 1, subValue );
      result += 1;
      if( subValue === argument )
      break;
      index = _.longLeftIndex( dstArray, argument, evaluator1, evaluator2 );
    }
  }

  let insCopy = Object.create( null );
  let subCopy = Object.create( null );

  if( dstArray === ins )
  {
    ins = ins.slice();
  }
  else
  {
    for( let i = ins.length - 1; i >= 0; i-- )
    {
      if( _.longLike( ins[ i ] ) )
      if( ins[ i ] === dstArray )
      insCopy[ i ] = ins[ i ].slice();

      if( _.longLike( sub[ i ] ) )
      if( sub[ i ] === dstArray )
      subCopy[ i ] = sub[ i ].slice();
    }
  }

  for( let a = 0, len = ins.length; a < len; a++ )
  {
    if( _.longLike( ins[ a ] ) )
    {
      let insArray = insCopy[ a ] || ins[ a ];
      let subArray = sub[ a ] || subCopy[ a ];

      for( let i = 0, len2 = insArray.length; i < len2; i++ )
      _replace( dstArray, insArray[ i ], subArray[ i ], evaluator1, evaluator2 );
    }
    else
    {
      _replace( dstArray, ins[ a ], sub[ a ], evaluator1, evaluator2 );
    }
  }

  return result;
}

//

function arrayReplacedArraysOnce( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  _.assert( 3 <= arguments.length && arguments.length <= 5 );
  _.assert( _.arrayIs( dstArray ), 'arrayReplacedArrays :', 'Expects array' );
  _.assert( _.longLike( sub ), 'arrayReplacedArrays :', 'Expects longLike entity' );
  _.assert( _.longLike( ins ), 'arrayReplacedArrays :', 'Expects longLike entity' );
  _.assert( ins.length === sub.length, '{-subArray-} should have the same length {-insArray-} has' );

  let result = 0;
  // let oldDstArray = dstArray.slice();  // Array with src values stored

  function _replace( /* dstArray, argument, subValue, evaluator1, evaluator2 */ )
  {
    let dstArray = arguments[ 0 ];
    let argument = arguments[ 1 ];
    let subValue = arguments[ 2 ];
    let evaluator1 = arguments[ 3 ];
    let evaluator2 = arguments[ 4 ];
    // let dstArray2 = oldDstArray.slice();
    //let index = dstArray.indexOf( argument );
    // let index = _.longLeftIndex( dstArray2, argument, evaluator1, evaluator2 );
    let index = _.longLeftIndex( dstArray, argument, evaluator1, evaluator2 );

    if( index !== -1 )
    {
      // dstArray2.splice( index, 1, subValue );
      dstArray.splice( index, 1, subValue );
      result += 1;
    }
  }

  for( let a = 0, len = ins.length; a < len ; a++ )
  {
    if( _.longLike( ins[ a ] ) )
    {
      let insArray = ins[ a ];
      let subArray = sub[ a ];

      for( let i = 0, len2 = insArray.length; i < len2; i++ )
      _replace( dstArray, insArray[ i ], subArray[ i ], evaluator1, evaluator2 );
    }
    else
    {
      _replace( dstArray, ins[ a ], sub[ a ], evaluator1, evaluator2 );
    }
  }

  return result;
}

//

function arrayReplacedArraysOnceStrictly( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let result;
  if( Config.debug )
  {
    result = arrayReplacedArraysOnce.apply( this, arguments );

    let expected = 0;
    for( let i = ins.length - 1; i >= 0; i-- )
    {
      if( _.longLike( ins[ i ] ) )
      expected += ins[ i ].length;
      else
      expected += 1;
    }

    _.assert( result === expected, '{-dstArray-} should have each element of {-insArray-}' );
    _.assert( ins.length === sub.length, '{-subArray-} should have the same length {-insArray-} has' );

    if( dstArray === ins )
    return result;

    let newResult = arrayReplacedArrayOnce.apply( this, arguments );
    _.assert( newResult === 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( ins ) + 'is several times in dstArray' );
  }
  else
  {
    result = arrayReplacedArraysOnce.apply( this, arguments );
  }

  return result;

}

//

/**
 * The arrayUpdate() routine adds a value (sub) to an array (dstArray) or replaces a value (ins) of the array (dstArray) by (sub),
 * and returns the last added index or the last replaced index of the array (dstArray).
 *
 * It creates the variable (index) assigns and calls to it the function(arrayReplaceOnce( dstArray, ins, sub ).
 * [arrayReplaceOnce( dstArray, ins, sub )]{@link wTools.arrayReplaceOnce}.
 * Checks if (index) equal to the -1.
 * If true, it adds to an array (dstArray) a value (sub), and returns the last added index of the array (dstArray).
 * Otherwise, it returns the replaced (index).
 *
 * @see wTools.arrayReplaceOnce
 *
 * @param { Array } dstArray - The source array.
 * @param { * } ins - The value to change.
 * @param { * } sub - The value to add or replace.
 *
 * @example
 * let add = _.arrayUpdate( [ 'Petre', 'Mikle', 'Oleg' ], 'Dmitry', 'Dmitry' );
 * // returns 3
 * console.log( add );
 * // log [ 'Petre', 'Mikle', 'Oleg', 'Dmitry' ]
 *
 * @example
 * let add = _.arrayUpdate( [ 1, 2, 3, 4, 5 ], 6, 6 );
 * // returns 5
 * console.log( add );
 * // log [ 1, 2, 3, 4, 5, 6 ]
 *
 * @example
 * let replace = _.arrayUpdate( [ true, true, true, true, false ], false, true );
 * // returns 4
 * console.log( replace );
 * // log [ true, true true, true, true ]
 *
 * @returns { number } Returns the last added or the last replaced index.
 * @function arrayUpdate
 * @throws { Error } Will throw an Error if (dstArray) is not an array-like.
 * @throws { Error } Will throw an Error if (arguments.length) is less or more than three.
 * @namespace Tools
 */

function arrayUpdate( /* dstArray, ins, sub, evaluator1, evaluator2 */ )
{
  let dstArray = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let sub = arguments[ 2 ];
  let evaluator1 = arguments[ 3 ];
  let evaluator2 = arguments[ 4 ];

  let index = arrayReplacedOnce.apply( this, arguments );

  if( index === -1 )
  {
    dstArray.push( sub );
    index = dstArray.length - 1;
  }

  return index;
}

// --
// extension
// --

let ToolsExtension =
{

  // array checker

  constructorLikeArray,

  arrayFromCoercing, /* aaa : check coverage */ /* Dmytro : coverage extended */
  arrayFromStr,

  // arrayAs,
  // arrayAsShallowing,

  // array transformer

  // arraySlice,
  // arrayEmpty,
  arrayExtendAppending,
  arrayExtendPrepending,

  arrayBut,
  arrayButInplace, /* !!! : use instead of arrayBut, arrayButInplace */
  arrayBut_, /* qqq : for Dmytro : use in wTools */
  arrayShrink,
  arrayShrinkInplace, /* !!! : use instead of arrayShrink, arrayShrinkInplace */
  arrayShrink_, /* qqq : for Dmytro : use in wTools */
  arrayGrow,
  arrayGrowInplace, /* !!! : use instead of arrayGrow, arrayGrowInplace */
  arrayGrow_, /* qqq : for Dmytro : use in wTools */
  arrayRelength,
  arrayRelengthInplace, /* !!! : use instead of arrayRelength, arrayRelengthInplace */
  arrayRelength_, /* qqq : for Dmytro : use in wTools */

  // array prepend on l3

  // array append on l3

  // array remove

  arrayRemove,
  arrayRemoveOnce,
  arrayRemoveOnceStrictly,
  arrayRemoved,
  arrayRemovedOnce,
  arrayRemovedOnceStrictly,

  arrayRemoveElement,
  arrayRemoveElementOnce,
  arrayRemoveElementOnceStrictly,
  arrayRemovedElement, /* !!! : use instead of arrayRemovedElement */
  arrayRemovedElement_,
  arrayRemovedElementOnce, /* !!! : use instead of arrayRemovedElementOnce */
  arrayRemovedElementOnce_,
  arrayRemovedElementOnceStrictly, /* !!! : use instead of arrayRemovedElementOnceStrictly */
  arrayRemovedElementOnceStrictly_,

  arrayRemoveArray,
  arrayRemoveArrayOnce,
  arrayRemoveArrayOnceStrictly,
  arrayRemovedArray,
  arrayRemovedArrayOnce,
  arrayRemovedArrayOnceStrictly,

  arrayRemoveArrays,
  arrayRemoveArraysOnce,
  arrayRemoveArraysOnceStrictly,
  arrayRemovedArrays,
  arrayRemovedArraysOnce,
  arrayRemovedArraysOnceStrictly,

  arrayRemoveDuplicates,

  // array flatten

  arrayFlatten,
  arrayFlattenOnce,
  arrayFlattenOnceStrictly,
  arrayFlattened,
  arrayFlattenedOnce,
  arrayFlattenedOnceStrictly,

  arrayFlattenDefined,
  arrayFlattenDefinedOnce,
  arrayFlattenDefinedOnceStrictly,
  arrayFlattenedDefined,
  arrayFlattenedDefinedOnce,
  arrayFlattenedDefinedOnceStrictly,

  // array replace

  arrayReplace,
  arrayReplaceOnce,
  arrayReplaceOnceStrictly,
  arrayReplaced,
  arrayReplacedOnce,
  arrayReplacedOnceStrictly,

  arrayReplaceElement,
  arrayReplaceElementOnce,
  arrayReplaceElementOnceStrictly,
  arrayReplacedElement,
  arrayReplacedElementOnce,
  arrayReplacedElementOnceStrictly,

  arrayReplaceArray,
  arrayReplaceArrayOnce,
  arrayReplaceArrayOnceStrictly,
  arrayReplacedArray,
  arrayReplacedArrayOnce,
  arrayReplacedArrayOnceStrictly,

  arrayReplaceArrays,
  arrayReplaceArraysOnce,
  arrayReplaceArraysOnceStrictly,
  arrayReplacedArrays,
  arrayReplacedArraysOnce,
  arrayReplacedArraysOnceStrictly,

  arrayUpdate,

  // to replace

  /*
  | routine          | makes new dst container                  | saves dst container                                     |
  | ---------------- | ---------------------------------------- | ------------------------------------------------------- |
  | arrayBut_        | _.arrayBut_( null, src, range )          | _.arrayBut_( src )                                      |
  |                  |                                          | _.arrayBut_( src, range )                               |
  |                  |                                          | _.arrayBut_( dst, dst, range )                          |
  |                  |                                          | _.arrayBut_( dst, src )                                 |
  |                  |                                          | _.arrayBut_( dst, src, range )                          |
  | ---------------  | ---------------------------------------- | ------------------------------------------------------- |
  | arrayShrink_     | _.arrayShrink_( null, src, range )       | _.arrayShrink_( src )                                   |
  |                  |                                          | _.arrayShrink_( src, range )                            |
  |                  |                                          | _.arrayShrink_( dst, dst, range )                       |
  |                  |                                          | _.arrayShrink_( dst, src )                              |
  |                  |                                          | _.arrayShrink_( dst, src, range )                       |
  | ---------------  | ---------------------------------------- | ------------------------------------------------------- |
  | arrayGrow_       | _.arrayGrow_( null, src, range )         | _.arrayGrow_( src )                                     |
  |                  |                                          | _.arrayGrow_( src, range )                              |
  |                  |                                          | _.arrayGrow_( dst, dst, range )                         |
  |                  |                                          | _.arrayGrow_( dst, src )                                |
  |                  |                                          | _.arrayGrow_( dst, src, range )                         |
  | ---------------  | ---------------------------------------- | ------------------------------------------------------- |
  | arrayRelength_   | _.arrayRelength_( null, src, range )     | _.arrayRelength_( src )                                 |
  |                  |                                          | _.arrayRelength_( src, range )                          |
  |                  |                                          | _.arrayRelength_( dst, dst, range )                     |
  |                  |                                          | _.arrayRelength_( dst, src )                            |
  |                  |                                          | _.arrayRelength_( dst, src, range )                     |
  | ---------------- | ---------------------------------------- | ------------------------------------------------------- |
  */

}

_.props.supplement( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Array.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Array_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Array_s */ })();

/* */  /* begin of file ArraySet_s */ ( function ArraySet_s() { function ArraySet_s_naked() { ( function _l5_ArraySet_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.arraySet = _.arraySet || Object.create( null );

// --
// array set
// --

// /**
//  * Returns new array that contains difference between two arrays: ( src1 ) and ( src2 ).
//  * If some element is present in both arrays, this element and all copies of it are ignored.
//  * @param { longIs } src1 - source array;
//  * @param { longIs} src2 - array to compare with ( src1 ).
//  *
//  * @example
//  * _.arraySet.diff_( null, [ 1, 2, 3 ], [ 4, 5, 6 ] );
//  * // returns [ 1, 2, 3, 4, 5, 6 ]
//  *
//  * @example
//  * _.arraySet.diff_( null, [ 1, 2, 4 ], [ 1, 3, 5 ] );
//  * // returns [ 2, 4, 3, 5 ]
//  *
//  * @returns { Array } Array with unique elements from both arrays.
//  * @function arraySetDiff
//  * @throws { Error } If arguments count is not 2.
//  * @throws { Error } If one or both argument(s) are not longIs entities.
//  * @namespace Tools
//  */
//
// function arraySetDiff( src1, src2 )
// {
//   let result = [];
//
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//   _.assert( _.longIs( src1 ) );
//   _.assert( _.longIs( src2 ) );
//
//   for( let i = 0 ; i < src1.length ; i++ )
//   {
//     if( src2.indexOf( src1[ i ] ) === -1 )
//     result.push( src1[ i ] );
//   }
//
//   for( let i = 0 ; i < src2.length ; i++ )
//   {
//     if( src1.indexOf( src2[ i ] ) === -1 )
//     result.push( src2[ i ] );
//   }
//
//   return result;
// }

//

function _has( /* src, e, onEvaluate1, onEvaluate2 */ )
{
  let src = arguments[ 0 ];
  let e = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  _.assert( onEvaluate2 === undefined || _.routine.is( onEvaluate2 ) );

  let fromIndex = 0;
  if( _.number.is( onEvaluate1 ) )
  {
    fromIndex = onEvaluate1;
    onEvaluate1 = onEvaluate2;
    onEvaluate2 = undefined;
  }

  if( _.routine.is( onEvaluate1 ) )
  {
    if( onEvaluate1.length === 2 )
    {
      _.assert( !onEvaluate2 );

      for( let el of src )
      {
        if( fromIndex === 0 )
        {
          if( onEvaluate1( el, e ) )
          return true;
        }
        else
        {
          fromIndex -= 1;
        }
      }

      return false;
    }
    else if( onEvaluate1.length === 1 )
    {
      _.assert( !onEvaluate2 || onEvaluate2.length === 1 );

      if( onEvaluate2 )
      e = onEvaluate2( e );
      else
      e = onEvaluate1( e );

      for( let el of src )
      {
        if( fromIndex === 0 )
        {
          if( onEvaluate1( el ) === e )
          return true;
        }
        else
        {
          fromIndex -= 1;
        }
      }

      return false;
    }
    else _.assert( 0 );
  }
  else if( onEvaluate1 === undefined || onEvaluate1 === null )
  {
    if( _.longLike( src ) )
    return src.includes( e );
    else if( _.set.like( src ) )
    return src.has( e );
  }
  else _.assert( 0 );
}

//

/* qqq : for junior : should work
_.arraySet.diff_( null, hashMap1.keys(), hashMap2.keys() )
*/
/* qqq : reimplement. dst should be map. first discuss */
function diff_( /* dst, src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let dst = arguments[ 0 ];
  let src1 = arguments[ 1 ];
  let src2 = arguments[ 2 ];
  let onEvaluate1 = arguments[ 3 ];
  let onEvaluate2 = arguments[ 4 ];

  _.assert( 2 <= arguments.length && arguments.length <= 5 );
  _.assert( _.longIs( dst ) || _.set.is( dst ) || dst === null );
  _.assert( _.longIs( src1 ) || _.set.is( src1 ) );
  _.assert( _.longIs( src2 ) || _.set.is( src2 ) || _.routine.is( src2 ) || src2 === undefined );

  if( dst === null )
  dst = new src1.constructor();

  if( _.routine.is( src2 ) || src2 === undefined )
  {
    onEvaluate2 = onEvaluate1;
    onEvaluate1 = src2;
    src2 = src1;
    src1 = dst;
  }

  let temp = [];
  if( dst === src1 )
  {
    if( _.longLike( dst ) )
    {
      for( let e of src2 )
      if( _.longLeftIndex( dst, e, onEvaluate1, onEvaluate2 ) === -1 )
      temp.push( e );
      for( let i = dst.length - 1; i >= 0; i-- )
      if( _has( src2, dst[ i ], onEvaluate1, onEvaluate2 ) )
      dst.splice( i, 1 )
      for( let i = 0; i < temp.length; i++ )
      dst.push( temp[ i ] );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of src2 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      temp.push( e );
      for( let e of dst )
      if( _has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.delete( e );
      for( let i = 0; i < temp.length; i++ )
      dst.add( temp[ i ] );
    }
  }
  else if( dst === src2 )
  {
    if( _.longLike( dst ) )
    {
      for( let e of src1 )
      if( _.longLeftIndex( dst, e, onEvaluate1, onEvaluate2 ) === -1 )
      temp.push( e );
      for( let i = dst.length - 1; i >= 0; i-- )
      if( _has( src1, dst[ i ], onEvaluate1, onEvaluate2 ) )
      dst.splice( i, 1 )
      for( let i = 0; i < temp.length; i++ )
      dst.push( temp[ i ] );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of src1 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      temp.push( e );
      for( let e of dst )
      if( _has( src1, e, onEvaluate1, onEvaluate2 ) )
      dst.delete( e );
      for( let i = 0; i < temp.length; i++ )
      dst.add( temp[ i ] );
    }
  }
  else
  {
    if( _.longLike( dst ) )
    {
      for( let e of src1 )
      if( !_has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.push( e );
      for( let e of src2 )
      if( !_has( src1, e, onEvaluate1, onEvaluate2 ) )
      dst.push( e );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of src1 )
      if( !_has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.add( e );
      for( let e of src2 )
      if( !_has( src1, e, onEvaluate1, onEvaluate2 ) )
      dst.add( e );
    }
  }

  return dst;
}

// //
//
// /**
//  * Returns new array that contains elements from ( src ) that are not present in ( but ).
//  * All copies of ignored element are ignored too.
//  * @param { longIs } src - source array;
//  * @param { longIs} but - array of elements to ignore.
//  *
//  * @example
//  * _.arraySetBut( [ 1, 1, 1 ], [ 1 ] );
//  * // returns []
//  *
//  * @example
//  * _.arraySetBut( [ 1, 1, 2, 2, 3, 3 ], [ 1, 3 ] );
//  * // returns [ 2, 2 ]
//  *
//  * @returns { Array } Source array without elements from ( but ).
//  * @function arraySetBut
//  * @throws { Error } If arguments count is not 2.
//  * @throws { Error } If one or both argument(s) are not longIs entities.
//  * @namespace Tools
//  */
//
// function arraySetBut( dst )
// {
//   let args = _.longSlice( arguments );
//
//   if( dst === null )
//   if( args.length > 1 )
//   {
//     dst = _.longSlice( args[ 1 ] );
//     args.splice( 1, 1 );
//   }
//   else
//   {
//     return [];
//   }
//
//   args[ 0 ] = dst;
//
//   _.assert( arguments.length >= 1, 'Expects at least one argument' );
//   for( let a = 0 ; a < args.length ; a++ )
//   _.assert( _.longIs( args[ a ] ) );
//
//   for( let i = dst.length-1 ; i >= 0 ; i-- )
//   {
//     for( let a = 1 ; a < args.length ; a++ )
//     {
//       let but = args[ a ];
//       if( but.indexOf( dst[ i ] ) !== -1 )
//       {
//         dst.splice( i, 1 );
//         break;
//       }
//     }
//   }
//
//   return dst;
// }

//

function but_( /* dst, src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let dst = arguments[ 0 ];
  let src1 = arguments[ 1 ];
  let src2 = arguments[ 2 ];
  let onEvaluate1 = arguments[ 3 ];
  let onEvaluate2 = arguments[ 4 ];

  if( arguments.length === 1 )
  {
    if( dst === null )
    return [];
    else if( _.longLike( dst ) || _.set.like( dst ) )
    return dst;
    else
    _.assert( 0 );
  }

  if( ( dst === null && _.routine.is( src2 ) ) || ( dst === null && src2 === undefined ) )
  {
    if( _.longLike( src1 ) )
    return _.longSlice( src1 )
    else if( _.set.like( src1 ) )
    return new Set( src1 )
    _.assert( 0 );
  }

  _.assert( 2 <= arguments.length && arguments.length <= 5 );
  _.assert( _.longIs( dst ) || _.set.is( dst ) || dst === null );
  _.assert( _.longIs( src1 ) || _.set.is( src1 ) );
  _.assert( _.longIs( src2 ) || _.set.is( src2 ) || _.routine.is( src2 ) || src2 === undefined );


  if( dst === null )
  dst = new src1.constructor();

  if( _.routine.is( src2 ) || src2 === undefined )
  {
    onEvaluate2 = onEvaluate1;
    onEvaluate1 = src2;
    src2 = src1;
    src1 = dst;
  }

  if( dst === src1 )
  {
    if( _.longLike( dst ) )
    {
      for( let i = dst.length - 1; i >= 0; i-- )
      if( _has( src2, dst[ i ], onEvaluate1, onEvaluate2 ) )
      dst.splice( i, 1 );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of dst )
      if( _has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.delete( e );
    }
  }
  else
  {
    if( _.longLike( dst ) )
    {
      for( let e of src1 )
      if( !_has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.push( e );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of src1 )
      if( !_has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.add( e );
    }
  }

  return dst;
}

// //
//
// /**
//  * Returns array that contains elements from ( src ) that exists at least in one of arrays provided after first argument.
//  * If element exists and it has copies, all copies of that element will be included into result array.
//  * @param { longIs } src - source array;
//  * @param { ...longIs } - sequence of arrays to compare with ( src ).
//  *
//  * @example
//  * _.arraySetIntersection( [ 1, 2, 3 ], [ 1 ], [ 3 ] );
//  * // returns [ 1, 3 ]
//  *
//  * @example
//  * _.arraySetIntersection( [ 1, 1, 2, 2, 3, 3 ], [ 1 ], [ 2 ], [ 3 ], [ 4 ] );
//  * // returns [ 1, 1, 2, 2, 3, 3 ]
//  *
//  * @returns { Array } Array with elements that are a part of at least one of the provided arrays.
//  * @function arraySetIntersection
//  * @throws { Error } If one of arguments is not an longIs entity.
//  * @namespace Tools
//  */
//
// function arraySetIntersection( dst )
// {
//
//   let first = 1;
//   if( dst === null )
//   if( arguments.length > 1 )
//   {
//     dst = _.longSlice( arguments[ 1 ] );
//     first = 2;
//   }
//   else
//   {
//     return [];
//   }
//
//   _.assert( arguments.length >= 1, 'Expects at least one argument' );
//   _.assert( _.longIs( dst ) );
//   for( let a = 1 ; a < arguments.length ; a++ )
//   _.assert( _.longIs( arguments[ a ] ) );
//
//   for( let i = dst.length-1 ; i >= 0 ; i-- )
//   {
//
//     for( let a = first ; a < arguments.length ; a++ )
//     {
//       let ins = arguments[ a ];
//       if( ins.indexOf( dst[ i ] ) === -1 )
//       {
//         dst.splice( i, 1 );
//         break;
//       }
//     }
//
//   }
//
//   return dst;
// }

//

function intersection_( /* dst, src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let dst = arguments[ 0 ];
  let src1 = arguments[ 1 ];
  let src2 = arguments[ 2 ];
  let onEvaluate1 = arguments[ 3 ];
  let onEvaluate2 = arguments[ 4 ];

  if( arguments.length === 1 )
  {
    if( dst === null )
    return [];
    else if( _.longIs( dst ) || _.set.is( dst ) )
    return dst;
    else
    _.assert( 0 );
  }
  if( ( dst === null && _.routine.is( src2 ) ) || ( dst === null && src2 === undefined ) )
  {
    if( _.longIs( src1 ) )
    return _.longSlice( src1 )
    else if( _.set.is( src1 ) )
    return new Set( src1 )
    _.assert( 0 );
  }

  _.assert( 2 <= arguments.length && arguments.length <= 5 );
  _.assert( _.longIs( dst ) || _.set.is( dst ) || dst === null );
  _.assert( _.longIs( src1 ) || _.set.is( src1 ) );
  _.assert( _.longIs( src2 ) || _.set.is( src2 ) || _.routine.is( src2 ) || src2 === undefined );


  if( dst === null )
  dst = new src1.constructor();

  if( _.routine.is( src2 ) || src2 === undefined )
  {
    onEvaluate2 = onEvaluate1;
    onEvaluate1 = src2;
    src2 = src1;
    src1 = dst;
  }

  if( dst === src1 )
  {
    if( _.longLike( dst ) )
    {
      for( let i = dst.length - 1; i >= 0; i-- )
      if( !_has( src2, dst[ i ], onEvaluate1, onEvaluate2 ) )
      dst.splice( i, 1 );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of dst )
      if( !_has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.delete( e );
    }
  }
  else
  {
    if( _.longLike( dst ) )
    {
      for( let e of src1 )
      if( _has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.push( e );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of src1 )
      if( _has( src2, e, onEvaluate1, onEvaluate2 ) )
      dst.add( e );
    }
  }

  return dst;
}

// //
//
// function arraySetUnion( dst )
// {
//   let args = _.longSlice( arguments );
//
//   if( dst === null )
//   if( arguments.length > 1 )
//   {
//     dst = [];
//     // dst = _.longSlice( args[ 1 ] );
//     // args.splice( 1, 1 );
//   }
//   else
//   {
//     return [];
//   }
//
//   _.assert( arguments.length >= 1, 'Expects at least one argument' );
//   _.assert( _.longIs( dst ) );
//   for( let a = 1 ; a < args.length ; a++ )
//   _.assert( _.longIs( args[ a ] ) );
//
//   for( let a = 1 ; a < args.length ; a++ )
//   {
//     let ins = args[ a ];
//     for( let i = 0 ; i < ins.length ; i++ )
//     {
//       if( dst.indexOf( ins[ i ] ) === -1 )
//       dst.push( ins[ i ] )
//     }
//   }
//
//   return dst;
// }

//

function union_( /* dst, src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let dst = arguments[ 0 ];
  let src1 = arguments[ 1 ];
  let src2 = arguments[ 2 ];
  let onEvaluate1 = arguments[ 3 ];
  let onEvaluate2 = arguments[ 4 ];

  if( arguments.length === 1 )
  {
    if( dst === null )
    return [];
    else if( _.longIs( dst ) || _.set.is( dst ) )
    return dst;
    else
    _.assert( 0 );
  }

  _.assert( 2 <= arguments.length && arguments.length <= 5 );
  _.assert( _.longIs( dst ) || _.set.is( dst ) || dst === null );
  _.assert( _.longIs( src1 ) || _.set.is( src1 ) );
  _.assert( _.longIs( src2 ) || _.set.is( src2 ) || _.routine.is( src2 ) || src2 === undefined );


  if( dst === null )
  dst = new src1.constructor();

  if( _.routine.is( src2 ) || src2 === undefined )
  {
    onEvaluate2 = onEvaluate1;
    onEvaluate1 = src2;
    src2 = src1;
    src1 = dst;
  }

  if( dst === src1 )
  {
    if( _.longLike( dst ) )
    {
      for( let e of src2 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      dst.push( e );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of src2 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      dst.add( e );
    }
  }
  else if( dst === src2 )
  {
    if( _.longLike( dst ) )
    {
      for( let e of src1 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      dst.push( e );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of src1 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      dst.add( e );
    }
  }
  else
  {
    if( _.longLike( dst ) )
    {
      for( let e of src1 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      dst.push( e );
      for( let e of src2 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      dst.push( e );
    }
    else if( _.set.like( dst ) )
    {
      for( let e of src1 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      dst.add( e );
      for( let e of src2 )
      if( !_has( dst, e, onEvaluate1, onEvaluate2 ) )
      dst.add( e );
    }
  }

  return dst;
}

//

/*
function arraySetContainAll( src )
{
  let result = [];

  _.assert( _.longIs( src ) );

  for( let a = 1 ; a < arguments.length ; a++ )
  {

    _.assert( _.longIs( arguments[ a ] ) );

    if( src.length > arguments[ a ].length )
    return false;

    for( let i = 0 ; i < src.length ; i++ )
    {

      throw _.err( 'Not tested' );
      if( arguments[ a ].indexOf( src[ i ] ) !== -1 )
      {
        throw _.err( 'Not tested' );
        return false;
      }

    }

  }

  return true;
}
*/

// //
//
// /**
//  * The arraySetContainAll() routine returns true, if at least one of the following arrays (arguments[...]),
//  * contains all the same values as in the {-srcMap-} array.
//  *
//  * @param { longIs } src - The source array.
//  * @param { ...longIs } arguments[...] - The target array.
//  *
//  * @example
//  * _.arraySetContainAll( [ 1, 'b', 'c', 4 ], [ 1, 2, 3, 4, 5, 'b', 'c' ] );
//  * // returns true
//  *
//  * @example
//  * _.arraySetContainAll( [ 'abc', 'def', true, 26 ], [ 1, 2, 3, 4 ], [ 26, 'abc', 'def', true ] );
//  * // returns false
//  *
//  * @returns { boolean } Returns true, if at least one of the following arrays (arguments[...]),
//  * contains all the same values as in the {-srcMap-} array.
//  * If length of the {-srcMap-} is more than the next argument, it returns false.
//  * Otherwise, it returns false.
//  * @function arraySetContainAll
//  * @throws { Error } Will throw an Error if {-srcMap-} is not an array-like.
//  * @throws { Error } Will throw an Error if (arguments[...]) is not an array-like.
//  * @namespace Tools
//  */
//
// function arraySetContainAll( src )
// {
//   _.assert( _.longIs( src ) );
//   for( let a = 1 ; a < arguments.length ; a++ )
//   _.assert( _.longIs( arguments[ a ] ) );
//
//   for( let a = 1 ; a < arguments.length ; a++ )
//   {
//     let ins = arguments[ a ];
//
//     for( let i = 0 ; i < ins.length ; i++ )
//     {
//       if( src.indexOf( ins[ i ] ) === -1 )
//       return false;
//     }
//
//   }
//
//   return true;
// }

//

function containAll_( /* src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let src1 = arguments[ 0 ];
  let src2 = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( src2 ) || _.set.is( src2 ) );

  let result = true;
  if( _.arrayIs( src1 ) )
  {
    for( let e of src2 )
    if( _.longLeftIndex( src1, e, onEvaluate1, onEvaluate2 ) === -1 )
    result = false;
  }
  else if( _.set.is( src1 ) )
  {
    let startFrom = 0;
    if( _.number.is( onEvaluate1 ) )
    {
      startFrom = onEvaluate1;
      onEvaluate1 = onEvaluate2;
      onEvaluate2 = undefined;
    }

    if( !src1.size && ( src2.length || src2.size ) )
    return false;

    for( let e of src2 )
    {
      if( result === false )
      {
        break;
      }
      else
      {
        let from = startFrom;
        result = undefined;
        setElementsCheck( from, e );
      }
    }
    return result === undefined ? true : result;
  }
  else
  {
    _.assert( 0, '{-src1-} should be instance of Array or Set' );
  }

  return result;

  /* */

  function setElementsCheck( from, e )
  {
    for( let el of src1 )
    {
      if( from === 0 )
      {
        if( _.entity.equal( el, e, onEvaluate1, onEvaluate2 ) )
        {
          result = true;
          break;
        }
        else
        {
          result = false
        }
      }
      else
      {
        from--;
      }
    }
  }
}

// //
//
// /**
//  * The arraySetContainAny() routine returns true, if at least one of the following arrays (arguments[...]),
//  * contains the first matching value from {-srcMap-}.
//  *
//  * @param { longIs } src - The source array.
//  * @param { ...longIs } arguments[...] - The target array.
//  *
//  * @example
//  * _.arraySetContainAny( [ 33, 4, 5, 'b', 'c' ], [ 1, 'b', 'c', 4 ], [ 33, 13, 3 ] );
//  * // returns true
//  *
//  * @example
//  * _.arraySetContainAny( [ 'abc', 'def', true, 26 ], [ 1, 2, 3, 4 ], [ 26, 'abc', 'def', true ] );
//  * // returns true
//  *
//  * @example
//  * _.arraySetContainAny( [ 1, 'b', 'c', 4 ], [ 3, 5, 'd', 'e' ], [ 'abc', 33, 7 ] );
//  * // returns false
//  *
//  * @returns { Boolean } Returns true, if at least one of the following arrays (arguments[...]),
//  * contains the first matching value from {-srcMap-}.
//  * Otherwise, it returns false.
//  * @function arraySetContainAny
//  * @throws { Error } Will throw an Error if {-srcMap-} is not an array-like.
//  * @throws { Error } Will throw an Error if (arguments[...]) is not an array-like.
//  * @namespace Tools
//  */
//
// function arraySetContainAny( src )
// {
//   _.assert( _.longIs( src ) );
//   for( let a = 1 ; a < arguments.length ; a++ )
//   _.assert( _.longIs( arguments[ a ] ) );
//
//   if( src.length === 0 )
//   return true;
//
//   for( let a = 1 ; a < arguments.length ; a++ )
//   {
//     let ins = arguments[ a ];
//
//     let i;
//     for( i = 0 ; i < ins.length ; i++ )
//     {
//       if( src.indexOf( ins[ i ] ) !== -1 )
//       break;
//     }
//
//     if( i === ins.length )
//     return false;
//
//   }
//
//   return true;
// }

//

function containAny_( /* src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let src1 = arguments[ 0 ];
  let src2 = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( src2 ) || _.set.is( src2 ) );

  if( _.arrayIs( src1 ) )
  {
    for( let e of src2 )
    if( _.longLeftIndex( src1, e, onEvaluate1, onEvaluate2 ) !== -1 )
    return true;
  }
  else if( _.set.is( src1 ) )
  {
    let startFrom = 0;
    if( _.number.is( onEvaluate1 ) )
    {
      startFrom = onEvaluate1;
      onEvaluate1 = onEvaluate2;
      onEvaluate2 = undefined;
    }

    for( let e of src2 )
    {
      let from = startFrom;
      for( let el of src1 )
      {
        if( from === 0 )
        {
          if( _.entity.equal( el, e, onEvaluate1, onEvaluate2 ) )
          return true;
        }
        else
        {
          from--;
        }
      }
    }
  }
  else
  {
    _.assert( 0, '{-src1-} should be instance of Array or Set' );
  }

  return false;
}

// //
//
// function arraySetContainNone( src )
// {
//   _.assert( _.longIs( src ) );
//
//   for( let a = 1 ; a < arguments.length ; a++ )
//   {
//
//     _.assert( _.longIs( arguments[ a ] ) );
//
//     for( let i = 0 ; i < src.length ; i++ )
//     {
//
//       if( arguments[ a ].indexOf( src[ i ] ) !== -1 )
//       {
//         return false;
//       }
//
//     }
//
//   }
//
//   return true;
// }

//

function containNone_( /* src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let src1 = arguments[ 0 ];
  let src2 = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( src2 ) || _.set.is( src2 ) );

  if( _.arrayIs( src1 ) )
  {
    for( let e of src2 )
    if( _.longLeftIndex( src1, e, onEvaluate1, onEvaluate2 ) !== -1 )
    return false;
  }
  else if( _.set.is( src1 ) )
  {
    let startFrom = 0;
    if( _.number.is( onEvaluate1 ) )
    {
      startFrom = onEvaluate1;
      onEvaluate1 = onEvaluate2;
      onEvaluate2 = undefined;
    }

    for( let e of src2 )
    {
      let from = startFrom;
      for( let el of src1 )
      {
        if( from === 0 )
        {
          if( _.entity.equal( el, e, onEvaluate1, onEvaluate2 ) )
          return false;
        }
        else
        {
          from--;
        }
      }
    }
  }
  else
  {
    _.assert( 0, '{-src1-} should be instance of Array or Set' );
  }

  return true;
}

//

function containSetsAll( /* src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let src1 = arguments[ 0 ];
  let src2 = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( src1 ) || _.set.is( src1 ) );
  _.assert( _.arrayIs( src2 ) || _.set.is( src2 ) );

  for( let e of src2 )
  if( containAll_( src1, e, onEvaluate1, onEvaluate2 ) === false )
  return false;

  return true;
}

//

function containSetsAny( /* src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let src1 = arguments[ 0 ];
  let src2 = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( src1 ) || _.set.is( src1 ) );
  _.assert( _.arrayIs( src2 ) || _.set.is( src2 ) );

  for( let e of src2 )
  if( containAny_( src1, e, onEvaluate1, onEvaluate2 ) === true )
  return true;

  return false;
}

//

function containSetsNone( /* src1, src2, onEvaluate1, onEvaluate2 */ )
{
  let src1 = arguments[ 0 ];
  let src2 = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.arrayIs( src1 ) || _.set.is( src1 ) );
  _.assert( _.arrayIs( src2 ) || _.set.is( src2 ) );

  for( let e of src2 )
  if( containNone_( src1, e, onEvaluate1, onEvaluate2 ) === false )
  return false;

  return true;
}

//

/**
 * Returns true if ( ins1 ) and ( ins2) arrays have same length and elements, elements order doesn't matter.
 * Inner arrays of arguments are not compared and result of such combination will be false.
 * @param { longIs } ins1 - source array;
 * @param { longIs} ins2 - array to compare with.
 *
 * @example
 * _.arraySet.identical( [ 1, 2, 3 ], [ 4, 5, 6 ] );
 * // returns false
 *
 * @example
 * _.arraySet.identical( [ 1, 2, 4 ], [ 4, 2, 1 ] );
 * // returns true
 *
 * @returns { Boolean } Result of comparison as boolean.
 * @function identical
 * @throws { Error } If one of arguments is not an ArrayLike entity.
 * @throws { Error } If arguments length is not 2.
 * @namespace Tools
 */

function identical( ins1, ins2 )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( ins1 ) );
  _.assert( _.longIs( ins2 ) );

  if( ins1.length !== ins2.length )
  return false;

  let result = _.arraySet.diff_( null, ins1, ins2 );

  return result.length === 0;
}

//

function left( /* arr, ins, fromIndex, onEvaluate1, onEvaluate2 */ )
{
  let arr = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let fromIndex = arguments[ 2 ];
  let onEvaluate1 = arguments[ 3 ];
  let onEvaluate2 = arguments[ 4 ];

  _.assert( 2 <= arguments.length && arguments.length <= 5 );

  if( _.set.like( arr ) )
  {
    let result = Object.create( null );
    result.index = -1;
    let index = 0;
    let from = 0;

    if( _.routine.is( fromIndex ) )
    {
      onEvaluate2 = onEvaluate1;
      onEvaluate1 = fromIndex;
    }
    else if( _.number.is( fromIndex ) )
    {
      from = fromIndex;
    }

    for( let e of arr )
    {
      if( from === 0 )
      {
        if( _.entity.equal( e, ins, onEvaluate1, onEvaluate2 ) )
        {
          result.index = index;
          result.element = e;
          break;
        }
      }
      else
      {
        from--;
      }
      index++;
    }

    return result;
  }
  else if( _.longLike( arr ) )
  {
    return _.longLeft.apply( this, arguments );
  }
  else
  _.assert( 0 );

}

//

function right( /* arr, ins, fromIndex, onEvaluate1, onEvaluate2 */ )
{
  let arr = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let fromIndex = arguments[ 2 ];
  let onEvaluate1 = arguments[ 3 ];
  let onEvaluate2 = arguments[ 4 ];

  _.assert( 2 <= arguments.length && arguments.length <= 5 );

  if( _.set.like( arr ) )
  {
    let result = Object.create( null );
    result.index = -1;
    let to = arr.size;
    let index = 0;

    if( _.routine.is( fromIndex ) )
    {
      onEvaluate2 = onEvaluate1;
      onEvaluate1 = fromIndex;
    }
    else if( _.number.is( fromIndex ) )
    {
      to = fromIndex;
    }
    else if( fromIndex !== undefined )
    _.assert( 0 );

    for( let e of arr )
    {
      if( index < to )
      {
        if( _.entity.equal( e, ins, onEvaluate1, onEvaluate2 ) )
        {
          result.index = index;
          result.element = e;
        }
      }
      index += 1;
    }

    return result;
  }
  else if( _.longLike( arr ) )
  {
    return _.longRight.apply( this, arguments );
  }
  else
  _.assert( 0 );

}

// --
// implementation
// --

let ToolsExtension =
{

  // array set

  // arraySetDiff, /* !!! : use instead of arraySetDiff */
  arraySetDiff_ : diff_,
  // arraySetBut, /* !!! : use instead of arraySetBut */
  arraySetBut_ : but_,
  // arraySetIntersection, /* !!! : use instead of arraySetIntersection */
  arraySetIntersection_ : intersection_,
  // arraySetUnion, /* !!! : use instead of arraySetUnion */
  arraySetUnion_ : union_,

  // arraySetContainAll, /* !!! : use instead of arraySetContainAll */
  arraySetContainAll_ : containAll_,
  // arraySetContainAny, /* !!! : use instead of arraySetContainAny */
  arraySetContainAny_ : containAny_,
  // arraySetContainNone, /* !!! : use instead of arraySetContainNone */
  arraySetContainNone_ : containNone_,
  arraySetContainSetsAll : containSetsAll,
  arraySetContainSetsAny : containSetsAny,
  arraySetContainSetsNone : containSetsNone,
  arraySetIdentical : identical,

  arraySetLeft : left,
  arraySetRight : right,

  // to replace

  /*
  | routine                 | makes new dst container                       | saves dst container                           |
  | ----------------------- | --------------------------------------------- | --------------------------------------------- |
  | arraySetDiff_           | _.arraySet.diff_( null )                       | _.arraySet.diff_( src1, src2 )                 |
  |                         | _.arraySet.diff_( null, src1 )                 | _.arraySet.diff_( src1, src1, src2 )           |
  |                         | _.arraySet.diff_( null, src1, src2 )           | _.arraySet.diff_( src2, src1, src2 )           |
  |                         |                                               | _.arraySet.diff_( dst, src1, src2 )            |
  | ----------------------- | --------------------------------------------- | --------------------------------------------- |
  | arraySetBut_            | _.arraySet.but_( null )                        | _.arraySet.but_( src1 )                        |
  |                         | _.arraySet.but_( null, src1 )                  | _.arraySet.but_( src1, src2 )                  |
  |                         | _.arraySet.but_( null, src1, src2 )            | _.arraySet.but_( src1, src1, src2 )            |
  |                         |                                               | _.arraySet.but_( src2, src1, src2 )            |
  |                         |                                               | _.arraySet.but_( dst, src1, src2 )             |
  | ----------------------- | --------------------------------------------- | --------------------------------------------- |
  | arraySetIntersection_   | _.arraySet.intersection_( null )               | _.arraySet.intersection_( src1 )               |
  |                         | _.arraySet.intersection_( null, src1 )         | _.arraySet.intersection_( src1, src2 )         |
  |                         | _.arraySet.intersection_( null, src1, src2 )   | _.arraySet.intersection_( src1, src1, src2 )   |
  |                         |                                               | _.arraySet.intersection_( src2, src1, src2 )   |
  |                         |                                               | _.arraySet.intersection_( dst, src1, src2 )    |
  | ----------------------- | --------------------------------------------- | --------------------------------------------- |
  | arraySetUnion_          | _.arraySet.union_( null )                      | _.arraySet.union_( src1 )                      |
  |                         | _.arraySet.union_( null, src1 )                | _.arraySet.union_( src1, src2 )                |
  |                         | _.arraySet.union_( null, src1, src2 )          | _.arraySet.union_( src1, src1, src2 )          |
  |                         |                                               | _.arraySet.union_( src2, src1, src2 )          |
  |                         |                                               | _.arraySet.union_( dst, src1, src2 )           |
  | ----------------------- | --------------------------------------------- | --------------------------------------------- |

  */

}

//

let Extension =
{

  // array set

  // arraySetDiff, /* !!! : use instead of arraySetDiff */
  diff_,
  // arraySetBut, /* !!! : use instead of arraySetBut */
  but_,
  // arraySetIntersection, /* !!! : use instead of arraySetIntersection */
  intersection_,
  // arraySetUnion, /* !!! : use instead of arraySetUnion */
  union_,

  // arraySetContainAll, /* !!! : use instead of arraySetContainAll */
  containAll_,
  // arraySetContainAny, /* !!! : use instead of arraySetContainAny */
  containAny_,
  // arraySetContainNone, /* !!! : use instead of arraySetContainNone */
  containNone_,
  containSetsAll,
  containSetsAny,
  containSetsNone,
  identical,

  left,
  right,

  // to replace

}

Object.assign( Self, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/ArraySet.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ArraySet_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ArraySet_s */ })();

/* */  /* begin of file Auxiliary_s */ ( function Auxiliary_s() { function Auxiliary_s_naked() { ( function _l5_Auxiliary_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// extension
// --

var AuxiliaryExtension =
{

}

Object.assign( _.aux, AuxiliaryExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Auxiliary.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Auxiliary_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Auxiliary_s */ })();

/* */  /* begin of file BigInt_s */ ( function BigInt_s() { function BigInt_s_naked() { ( function _l5_BigInt_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function from( src )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  if( _.strIs( src ) )
  return BigInt( src );
  if( _.number.is( src ) )
  return BigInt( src );
  _.assert( _.bigInt.is( src ), 'Cant convert' )
  return src;
}

//

function bigIntsFrom( src )
{
  if( _.number.is( src ) )
  {
    return BigInt( src );
  }
  else if( _.bigInt.is( src ) )
  {
    return src;
  }
  else if( _.longIs( src ) )
  {
    let result = [];
    for( let i = 0 ; i < src.length ; i++ )
    result[ i ] = _.bigInt.from( src[ i ] );
    return result
  }
  else _.assert( 0, 'Cant convert' );
}

// --
// bigInt extension
// --

let BigIntExtension =
{
  from,
}

Object.assign( _.bigInt, BigIntExtension );

// --
// bigInts extension
// --

let BigIntsExtension =
{
  from : bigIntsFrom
}

Object.assign( _.bigInts, BigIntsExtension );

// --
// tools extension
// --

let ToolsExtension =
{
  bigIntFrom : from,
  bigIntsFrom,
}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/BigInt.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BigInt_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BigInt_s */ })();

/* */  /* begin of file Blank_s */ ( function Blank_s() { function Blank_s_naked() { ( function _l5_Blank_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let BlankExtension =
{

}

Object.assign( _.blank, BlankExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Blank.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Blank_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Blank_s */ })();

/* */  /* begin of file Bool_s */ ( function Bool_s() { function Bool_s_naked() { ( function _l5_Bool_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// bool
// --

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let BoolExtension =
{
}

Object.assign( _.bool, BoolExtension );

//

let BoolsExtension =
{
}

Object.assign( _.bool.s, BoolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Bool.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Bool_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Bool_s */ })();

/* */  /* begin of file Buffer_s */ ( function Buffer_s() { function Buffer_s_naked() { ( function _l5_Buffer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// buffer checker
// --

// --
// extension
// --

let BufferExtension =
{
}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{
}

_.props.supplement( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Buffer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Buffer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Buffer_s */ })();

/* */  /* begin of file Constructible_s */ ( function Constructible_s() { function Constructible_s_naked() { ( function _l5_Constructible_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.constructible = _.constructible || Object.create( null );

// --
// dichotomy
// --

// --
// extension
// --

let Extension =
{
}

//

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Constructible.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Constructible_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Constructible_s */ })();

/* */  /* begin of file Container_s */ ( function Container_s() { function Container_s_naked() { ( function _l5_Container_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

let ContainerExtension =
{

}

_.props.supplement( _.container, ContainerExtension );

//

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Container.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Container_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Container_s */ })();

/* */  /* begin of file Countable_s */ ( function Countable_s() { function Countable_s_naked() { ( function _l5_Countable_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

// --
// extension
// --

var Extension =
{
}

//

Object.assign( _.countable, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Countable.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Countable_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Countable_s */ })();

/* */  /* begin of file Ct_s */ ( function Ct_s() { function Ct_s_naked() { ( function _l5_Ct_s_()
{

'use strict';

//

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

let Extension =
{
}

_.props.supplement( _.ct, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Ct.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Ct_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Ct_s */ })();

/* */  /* begin of file Date_s */ ( function Date_s() { function Date_s_naked() { ( function _l5_Date_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.date = _.date || Object.create( null );

// --
// dichotomy
// --

/**
 * The routine dateToStr() converts Date object {-date-} to formatted string.
 * The format is : YYYY.MM.DD
 *
 * @example
 * let date = new Date();
 * console.log( _.time.dateToStr( date ) );
 * // log : '2020.10.20'
 *
 * @param { Date } date - The date to convert.
 * @returns { String } - Returns date in string format.
 * @function dateToStr
 * @namespace wTools.time
 * @extends Tools
 */

function toStr( date )
{
  debugger;
  let y = date.getFullYear();
  let m = date.getMonth() + 1;
  let d = date.getDate();
  if( m < 10 ) m = '0' + m;
  if( d < 10 ) d = '0' + d;
  let result = [ y, m, d ].join( '.' );
  return result;
}

// --
// extension
// --

let ToolsExtension =
{
  dateToStr : toStr
}

//

let Extension =
{
  toStr,
}

//

Object.assign( _, ToolsExtension );
Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Date.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Date_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Date_s */ })();

/* */  /* begin of file Diagnostic_s */ ( function Diagnostic_s() { function Diagnostic_s_naked() { ( function _l5_Diagnostic_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.diagnostic = _.diagnostic || Object.create( null );

// --
// diagnostic
// --

// --
// try
// --

function tryCatch( routine )
{
  _.assert( arguments.length === 1 );
  _.assert( _.routine.is( routine ) )
  try
  {
    return routine();
  }
  catch( err )
  {
    throw _._err({ args : [ err ] });
  }
}

//

function tryCatchBrief( routine )
{
  _.assert( arguments.length === 1 );
  _.assert( _.routine.is( routine ) )

  try
  {
    return routine();
  }
  catch( err )
  {
    throw _._err({ args : [ err ], brief : 1 });
  }
}

// //
//
// function tryCatchDebug( routine )
// {
//   _.assert( arguments.length === 1 );
//   _.assert( _.routine.is( routine ) )
//   try
//   {
//     return routine();
//   }
//   catch( err )
//   {
//     throw _._err({ args : [ err ], debugging : 1 });
//   }
// }

// --
// declare
// --

let ToolsExtension =
{

  tryCatch,
  tryCatchBrief,

}

Object.assign( _, ToolsExtension );

//

let Extension =
{

}

//

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Diagnostic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Diagnostic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Diagnostic_s */ })();

/* */  /* begin of file Entity_s */ ( function Entity_s() { function Entity_s_naked() { ( function _l5_Entity_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// exporter
// --

function exportStringDiagnosticShallow( src, opts )
{
  let result = '';
  _.assert( arguments.length === 1 || arguments.length === 2 );
  result = _.entity.exportStringDiagnosticShallow( src );
  return result;
}

//

/* xxx : qqq : for junior : take into account throwing cases */
/* qqq : for junior : optimize. ask how to */
function _exportStringShallow( src, o )
{

  _.assert( arguments.length === 2 );
  _.assert( _.number.is( o.widthLimit ) && o.widthLimit >= 0 );
  _.assert( _.number.is( o.heightLimit ) && o.heightLimit >= 0 );
  _.assert( o.src === undefined )
  _.assert( o.format === 'string.diagnostic' || o.format === 'string.code' );

  let result = '';
  let method = o.format === 'string.diagnostic' ? 'exportStringDiagnosticShallow' : 'exportStringCodeShallow';

  try
  {

    let namespace = this.namespaceForExporting( src );
    if( namespace === null )
    {
      _.assert( 0, 'not tested' );
      namespace = _.blank;
    }

    result = namespace[ method ]( src );
    result = _.strShort_({ src : result, widthLimit : o.widthLimit, heightLimit : o.heightLimit }).result;

  }
  catch( err )
  {
    debugger;
    throw err;
  }

  return result;
}

_exportStringShallow.defaults =
{
  format : null,
  widthLimit : 0,
  heightLimit : 0,
}

//

function exportStringCodeShallow( src, o ) /* */
{
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects one or two arguments' );

  o = _.routine.options_( exportStringCodeShallow, o || null );
  o.format = o.format || exportStringCodeShallow.defaults.format;

  return _.entity._exportStringShallow( src, o );
}

exportStringCodeShallow.defaults =
{
  format : 'string.code', /* [ 'string.diagnostic', 'string.code' ] */ /* qqq for junior : implement and cover */
  widthLimit : 0, /* qqq for junior : implement and cover, use strShort_ */
  heightLimit : 0, /* qqq for junior : implement and cover */
}

//

function exportStringDiagnosticShallow( src, o ) /* */
{
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects one or two arguments' );
  o = _.aux.supplement( o || null, exportStringDiagnosticShallow.defaults );
  o.format = o.format || exportStringDiagnosticShallow.defaults.format;
  return _.entity._exportStringShallow( src, o );
}

exportStringDiagnosticShallow.defaults =
{
  format : 'string.diagnostic', /* [ 'string.diagnostic', 'string.code' ] */ /* qqq for junior : implement and cover */
  widthLimit : 0, /* qqq for junior : implement and cover, use strShort_ */
  heightLimit : 0, /* qqq for junior : implement and cover */
}

// --
//
// --

function cloneDeep( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( !src || _.primitive.is( src ) )
  {
    return src;
  }
  else if( _.replicate )
  {
    debugger;
    return _.replicate({ src });
  }
  else if( _.routine.is( src[ _.class.cloneDeepSymbol ] ) ) /* aaa2 : cover */ /* Dmytro : coverage extended for objects with method under symbol cloneShallowSymbol */
  {
    return src[ _.class.cloneDeepSymbol ]();
  }
  else if( _.routine.is( src.cloneDeep ) ) /* aaa2 : cover */ /* Dmytro : coverage extended for objects with method cloneShallow */
  {
    return src.cloneDeep();
  }
  else if( _.arrayIs( src ) )
  {
    return Array.from( src );
  }
  else if( _.longLike( src ) )
  {
    let toolsNamespace = this.Tools ? this.Tools : this;
    return toolsNamespace.long.make( src );
  }
  else if( _.hashMap.like( src ) || _.set.like( src ) )
  {
    return new src.constructor( src );
  }
  else if( _.aux.is( src ) )
  {
    return _.aux.cloneShallow( src );
  }
  else if( _.routine.is( src.constructor ) ) /* aaa2 : cover */ /* Dmytro : coverage extended for entities with constructor */
  {
    return new src.constructor( src );
  }
  else _.assert( 0, `Not clear how to make a new element of \`${_.entity.strType( src )}\` with \`_.entity.cloneDeep()\`` );

}

//

/**
 * Copies entity( src ) into( dst ) or returns own copy of( src ).Result depends on several moments:
 * -If( src ) is a Object - returns clone of( src ) using ( onRecursive ) callback function if its provided;
 * -If( dst ) has own 'copy' routine - copies( src ) into( dst ) using this routine;
 * -If( dst ) has own 'set' routine - sets the fields of( dst ) using( src ) passed to( dst.set );
 * -If( src ) has own 'clone' routine - returns clone of( src ) using ( src.clone ) routine;
 * -If( src ) has own 'slice' routine - returns result of( src.slice ) call;
 * -Else returns a copy of entity( src ).
 *
 * @param {object} dst - Destination object.
 * @param {object} src - Source object.
 * @param {routine} onRecursive - The callback function to copy each [ key, value ].
 * @see {@link wTools.mapCloneAssigning} Check this function for more info about( onRecursive ) callback.
 * @returns {object} Returns result of entities copy operation.
 *
 * @example
 * let dst = { set : function( src ) { this.str = src.src } };
 * let src = { src : 'string' };
 *  _.entity.assign2( dst, src );
 * console.log( dst.str )
 * // log "string"
 *
 * @example
 * let dst = { copy : function( src ) { for( let i in src ) this[ i ] = src[ i ] } }
 * let src = { src : 'string', num : 123 }
 *  _._.entity.assign2( dst, src );
 * console.log( dst )
 * // log Object { src: "string", num: 123 }
 *
 * @example
 *  _._.entity.assign2( null, new String( 'string' ) );
 * // returns 'string'
 *
 * @function assign
 * @throws {exception} If( arguments.length ) is not equal to 3 or 2.
 * @throws {exception} If( onRecursive ) is not a Routine.
 * @namespace Tools.entity
 *
 */

function assign2( dst, src, onRecursive )
{
  let result;

  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );
  _.assert( arguments.length < 3 || _.routine.is( onRecursive ) );

  if( src === null )
  {

    result = src;

  }
  else if( dst && _.routine.is( dst.copy ) )
  {

    dst.copy( src );

  }
  else if( src && _.routine.is( src.clone ) )
  {

    if( dst instanceof src.constructor )
    {
      throw _.err( 'not tested' );
      result = src.clone( dst );
    }
    else if( _.primitive.is( dst ) || _.longIs( dst ) )
    {
      result = src.clone();
    }
    else _.assert( 0, 'unknown' );

  }
  else if( src && _.routine.is( src.slice ) )
  {

    result = src.slice();

  }
  else if( dst && _.routine.is( dst.set ) )
  {

    dst.set( src );

  }
  else if( _.object.isBasic( src ) )
  {

    if( onRecursive )
    {
      result = _.mapCloneAssigning
      ({
        srcMap : src,
        dstMap : _.primitive.is( dst ) ? Object.create( null ) : dst,
        onField : onRecursive
      });
    }
    else
    {
      result = _.mapCloneAssigning({ srcMap : src });
    }

  }
  else
  {

    result = src;

  }

  return result;
}

//

/**
 * Short-cut for _.entity.assign2 function. Copies specified( name ) field from
 * source container( srcContainer ) into( dstContainer ).
 *
 * @param {object} dstContainer - Destination object.
 * @param {object} srcContainer - Source object.
 * @param {string} name - Field name.
 * @param {mapCloneAssigning.onField} onRecursive - The callback function to copy each [ key, value ].
 * @see {@link wTools.mapCloneAssigning} Check this function for more info about( onRecursive ) callback.
 * @returns {object} Returns result of entities copy operation.
 *
 * @example
 * let dst = {};
 * let src = { a : 'string' };
 * let name = 'a';
 * _.entity.assign2FieldFromContainer( dst, src, name );
 * console.log( dst.a === src.a );
 * // log true
 *
 * @example
 * let dst = {};
 * let src = { a : 'string' };
 * let name = 'a';
 * function onRecursive( dstContainer, srcContainer, key )
 * {
 *   _.assert( _.strIs( key ) );
 *   dstContainer[ key ] = srcContainer[ key ];
 * };
 * _.entity.assign2FieldFromContainer( dst, src, name, onRecursive );
 * console.log( dst.a === src.a );
 * // log true
 *
 * @function assignFieldFromContainer
 * @throws {exception} If( arguments.length ) is not equal to 3 or 4.
 * @namespace Tools.entity
 *
 */

function assign2FieldFromContainer( /* dstContainer, srcContainer, name, onRecursive */ )
{
  let dstContainer = arguments[ 0 ];
  let srcContainer = arguments[ 1 ];
  let name = arguments[ 2 ];
  let onRecursive = arguments[ 3 ];
  let result;

  _.assert( _.strIs( name ) || _.symbol.is( name ) );
  _.assert( arguments.length === 3 || arguments.length === 4 );

  let dstValue = Object.hasOwnProperty.call( dstContainer, name ) ? dstContainer[ name ] : undefined;
  let srcValue = srcContainer[ name ];

  if( onRecursive )
  result = _.entity.assign2( dstValue, srcValue, onRecursive );
  else
  result = _.entity.assign2( dstValue, srcValue );

  if( result !== undefined )
  dstContainer[ name ] = result;

  return result;
}

//

/**
 * Short-cut for _.entity.assign2 function. Assigns value of( srcValue ) to container( dstContainer ) field specified by( name ).
 *
 * @param {object} dstContainer - Destination object.
 * @param {object} srcValue - Source value.
 * @param {string} name - Field name.
 * @param {mapCloneAssigning.onField} onRecursive - The callback function to copy each [ key, value ].
 * @see {@link wTools.mapCloneAssigning} Check this function for more info about( onRecursive ) callback.
 * @returns {object} Returns result of entity field assignment operation.
 *
 * @example
 * let dstContainer = { a : 1 };
 * let srcValue = 15;
 * let name = 'a';
 * _.entity.assign2Field( dstContainer, srcValue, name );
 * console.log( dstContainer.a );
 * // log 15
 *
 * @function assignField
 * @throws {exception} If( arguments.length ) is not equal to 3 or 4.
 * @namespace Tools
 *
 */

function assign2Field( /* dstContainer, srcValue, name, onRecursive */ )
{
  let dstContainer = arguments[ 0 ];
  let srcValue = arguments[ 1 ];
  let name = arguments[ 2 ];
  let onRecursive = arguments[ 3 ];

  let result;

  _.assert( _.strIs( name ) || _.symbol.is( name ) );
  _.assert( arguments.length === 3 || arguments.length === 4 );

  let dstValue = dstContainer[ name ];

  if( onRecursive )
  {
    throw _.err( 'not tested' );
    result = _.entity.assign2( dstValue, srcValue, onRecursive );
  }
  else
  {
    result = _.entity.assign2( dstValue, srcValue );
  }

  if( result !== undefined )
  dstContainer[ name ] = result;

  return result;
}

// --
// tools extension
// --

let ToolsExtension =
{

}

//

Object.assign( _, ToolsExtension );

// --
// entity extension
// --

let EntityExtension =
{

  // exporter

  exportStringDiagnosticShallow,

  _exportStringShallow,
  exportString : exportStringDiagnosticShallow,
  exportStringCodeShallow,
  exportStringDiagnosticShallow,

  // etc

  cloneDeep,

  assign2, /* xxx : refactor */
  assign2FieldFromContainer, /* dubious */
  assign2Field, /* dubious */

}

//

Object.assign( _.entity, EntityExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Entity.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Entity_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Entity_s */ })();

/* */  /* begin of file Err_s */ ( function Err_s() { function Err_s_naked() { ( function _l5_Err_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

let Extension =
{
}

Object.assign( _.error, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Err.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Err_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Err_s */ })();

/* */  /* begin of file Escape_s */ ( function Escape_s() { function Escape_s_naked() { ( function _l5_Escape_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

var Extension =
{
}

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Escape.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Escape_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Escape_s */ })();

/* */  /* begin of file Event_s */ ( function Event_s() { function Event_s_naked() { ( function _l5_Event_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

let Extension =
{
}

Object.assign( _.event, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Event.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Event_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Event_s */ })();

/* */  /* begin of file Functional_s */ ( function Functional_s() { function Functional_s_naked() { ( function _l5_Functional_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// scalar
// --

/**
 * Produce a single array from all arguments if cant return single argument as a scalar.
 * If {-scalarAppend-} gets a single argument it returns the argument as is.
 * If {-scalarAppend-} gets an argument and one or more undefined it returns the argument as is.
 * If {-scalarAppend-} gets more than one or less than one defined arguments then it returns array having all defined arguments.
 * If some argument is a Long ( for example array ) then each element of the Long is treated as an argument, not recursively.
 *
 * @function scalarAppend.
 * @namespace Tools
 */

function scalarAppend( dst, src )
{

  _.assert( arguments.length === 2 );

  if( dst === undefined )
  {
    if( _.longIs( src ) )
    {
      dst = [];
    }
    else
    {
      if( src === undefined )
      return [];
      else
      return src;
    }
  }

  if( _.longIs( dst ) )
  {

    if( !_.arrayIs( dst ) )
    dst = _.array.from( dst );

    if( src === undefined )
    {}
    else if( _.longIs( src ) )
    _.arrayAppendArray( dst, src );
    else
    dst.push( src );

  }
  else
  {

    if( src === undefined )
    {}
    else if( _.longIs( src ) )
    dst = _.arrayAppendArray( [ dst ], src );
    else
    dst = [ dst, src ];

  }

  return dst;
}

//

function scalarAppendOnce( dst, src )
{

  _.assert( arguments.length === 2 );

  if( dst === undefined )
  {
    if( _.longIs( src ) )
    {
      dst = [];
    }
    else
    {
      if( src === undefined )
      return [];
      else
      return src;
    }
  }

  if( _.longIs( dst ) )
  {

    if( !_.arrayIs( dst ) )
    dst = _.array.from( dst );

    if( src === undefined )
    {}
    else if( _.longIs( src ) )
    _.arrayAppendArrayOnce( dst, src );
    else
    _.arrayAppendElementOnce( dst, src );

  }
  else
  {

    if( src === undefined )
    {}
    else if( _.longIs( src ) )
    dst = _.arrayAppendArrayOnce( [ dst ], src );
    else
    dst = _.arrayAppendElementOnce( [ dst ], src );

  }

  return dst;
}

//

function scalarPrepend( dst, src )
{

  _.assert( arguments.length === 2 );

  if( dst === undefined )
  {
    if( _.longIs( src ) )
    {
      dst = [];
    }
    else
    {
      if( src === undefined )
      return [];
      else
      return src;
    }
  }

  if( _.longIs( dst ) )
  {

    if( !_.arrayIs( dst ) )
    dst = _.array.from( dst );

    if( src === undefined )
    {}
    else if( _.longIs( src ) )
    _.arrayPrependArray( dst, src );
    else
    dst.splice( 0, 0, src );

  }
  else
  {

    if( src === undefined )
    {}
    else if( _.longIs( src ) )
    dst = _.arrayPrependArray( [ dst ], src );
    else
    dst = [ src, dst ];

  }

  return dst;
}

//

function scalarPrependOnce( dst, src )
{

  _.assert( arguments.length === 2 );

  if( dst === undefined )
  {
    if( _.longIs( src ) )
    {
      dst = [];
    }
    else
    {
      if( src === undefined )
      return [];
      else
      return src;
    }
  }

  if( _.longIs( dst ) )
  {

    if( !_.arrayIs( dst ) )
    dst = _.array.from( dst );

    if( src === undefined )
    {}
    else if( _.longIs( src ) )
    _.arrayPrependArrayOnce( dst, src );
    else
    _.arrayPrependElementOnce( dst, src );

  }
  else
  {

    if( src === undefined )
    {}
    else if( _.longIs( src ) )
    dst = _.arrayPrependArrayOnce( [ dst ], src );
    else
    dst = _.arrayPrependElementOnce( [ dst ], src );

  }

  return dst;
}

/**
 * The scalarToVector() routine returns a new array
 * which containing the static elements only type of Number.
 *
 * It takes two arguments (dst) and (length)
 * checks if the (dst) is a Number, If the (length) is greater than or equal to zero.
 * If true, it returns the new array of static (dst) numbers.
 * Otherwise, if the first argument (dst) is an Array,
 * and its (dst.length) is equal to the (length),
 * it returns the original (dst) Array.
 * Otherwise, it throws an Error.
 *
 * @param { ( Number | Array ) } dst - A number or an Array.
 * @param { Number } length - The length of the new array.
 *
 * @example
 * _.scalarToVector( 3, 7 );
 * // returns [ 3, 3, 3, 3, 3, 3, 3 ]
 *
 * @example
 * _.scalarToVector( [ 3, 7, 13 ], 3 );
 * // returns [ 3, 7, 13 ]
 *
 * @returns { Number[] | Array } - Returns the new array of static numbers or the original array.
 * @function scalarToVector
 * @throws { Error } If missed argument, or got less or more than two arguments.
 * @throws { Error } If type of the first argument is not a number or array.
 * @throws { Error } If the second argument is less than 0.
 * @throws { Error } If (dst.length) is not equal to the (length).
 * @namespace Tools
 */

// function arrayFromNumber( dst, length )
function scalarToVector( dst, length )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  // _.assert( _.number.is( dst ) || _.arrayIs( dst ), 'Expects array of number as argument' );
  _.assert( dst !== undefined, 'Expects array or scalar' );
  _.assert( length >= 0 );

  if( _.arrayIs( dst ) )
  {
    _.assert( dst.length === length, () => 'Expects array of length ' + length + ' but got ' + dst.length );
  }
  else
  {
    dst = _.longFill( [], dst, [ 0, length ] );
  }

  return dst;
}

//

function scalarFrom( src )
{
  if( _.longIs( src ) && src.length === 1 )
  return src[ 0 ];
  return src;
}

//

function scalarFromOrNull( src )
{
  if( _.longIs( src ) )
  {
    if( src.length === 1 )
    return src[ 0 ];
    else if( src.length === 0 )
    return null;
  }
  return src;
}

// --
// multiplier
// --

function dup( ins, times, result )
{
  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );
  _.assert( _.number.is( times ) || _.longIs( times ), 'dup expects times as number or array' );

  if( _.number.is( times ) )
  {
    if( !result )
    result = new Array( times );
    for( let t = 0 ; t < times ; t++ )
    result[ t ] = ins;
    return result;
  }
  else if( _.longIs( times ) )
  {
    _.assert( times.length === 2 );
    let l = times[ 1 ] - times[ 0 ];
    if( !result )
    result = new Array( times[ 1 ] );
    for( let t = 0 ; t < l ; t++ )
    result[ times[ 0 ] + t ] = ins;
    return result;
  }
  else _.assert( 0, 'unexpected' );

}

//

function multiple( src, times )
{
  _.assert( arguments.length === 2 );
  if( _.argumentsArray.like( src ) )
  _.assert( src.length === times, () => 'Vector should have ' + times + ' elements, but have ' + src.length );
  else
  src = _.dup( src, times );
  return src;
}

//

function multipleAll( dsts )
{
  let length;

  _.assert( arguments.length === 1 );

  for( let d = 0 ; d < dsts.length ; d++ )
  if( _.arrayIs( dsts[ d ] ) )
  {
    length = dsts[ d ].length;
    break;
  }

  if( length === undefined )
  return dsts;

  for( let d = 0 ; d < dsts.length ; d++ )
  dsts[ d ] = _.multiple( dsts[ d ], length );

  return dsts;
}

// --
// entity iterator
// --

function entityEach( src, onEach )
{

  _.assert( arguments.length === 2 );
  _.assert( onEach.length <= 3 );
  _.assert( _.routine.is( onEach ) );

  /* */

  /* qqq for junior : add branch for countable case */
  if( _.longIs( src ) )
  {

    for( let k = 0 ; k < src.length ; k++ )
    {
      onEach( src[ k ], k, src );
    }

  }
  else if( _.aux.is( src ) )
  {

    for( let k in src )
    {
      onEach( src[ k ], k, src );
    }

  }
  else
  {
    onEach( src, undefined, undefined );
  }

  /* */

  return src;
}

//

function entityEachOwn( src, onEach )
{

  _.assert( arguments.length === 2 );
  _.assert( onEach.length <= 3 );
  _.assert( _.routine.is( onEach ) );

  /* */

  /* qqq for junior : add branch for countable case */
  if( _.longIs( src ) )
  {

    for( let k = 0 ; k < src.length ; k++ )
    {
      onEach( src[ k ], k, src );
    }

  }
  else if( _.aux.is( src ) || _.object.like( src ) )
  {

    for( let k in src )
    {
      if( !Object.hasOwnProperty.call( src, k ) )
      continue;
      onEach( src[ k ], k, src );
    }

  }
  else
  {
    onEach( src, undefined, undefined );
  }

  /* */

  return src;
}

//

/*

LongLike / Aux / HashMapLike / SetLike


_.only( Array::dst, Map::src );
_.only( Array::dst, Set::src );

*/

/**
 * The routine entityOnly() provides the filtering of elements of destination container
 * {-dst-} by checking values in the source container {-src-}. The routine checks values
 * with the same keys in both containers. If a received {-src-} element has falsy value, then
 * element with the same key deletes from the {-dst-} container.
 *
 * If {-dst-} container is null, routine makes new container with type of {-src-} container, and fill it obtained values.
 * If {-src-} is undefined, routine filters {-dst-} container obtaining values from {-dst-}.
 * Note: containers should have same type.
 *
 * Also, {-dst-} and {-src-} might be not iteratable element, for example, primitive.
 * If {-dst-} is not iteratable, then routine check value of {-src-}.
 *
 * @param { ArrayLike|Set|Map|Object|* } dst - Container or another single element for filtering.
 * If {-dst-} is null, then makes new container of {-src-} type.
 * @param { ArrayLike|Set|Map|Object|* } src - Container or another single element for filtering.
 * If {-src-} is undefined, then {-dst-} filters by its own values.
 * @param { Function } onEach - The callback that obtain value for every {-src-} element. The
 * callback accepts three parameters - element, key, source container.
 *
 * @example
 * _.entityOnly( 'str', 1 );
 * // returns 'str'
 *
 * @example
 * _.entityOnly( 'str', 1, ( e, k, src ) => e - 1 );
 * // returns undefined
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityOnly( null, src );
 * // returns [ 1, true ]
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityOnly( null, src, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityOnly( dst );
 * // returns [ true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityOnly( dst, undefined, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ];
 * _.entityOnly( dst, src );
 * // returns [ '', 0, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ];
 * _.entityOnly( dst, undefined, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @returns { ArrayLike|Set|Map|Object|* } - Returns filtered container.
 * If {-dst-} is not iteratable value, routine returns original {-dst-} or undefined.
 * @function entityOnly
 * @throws { Error } If arguments.length is less then one or more than three arguments.
 * @throws { Error } If {-dst-} is not null or {-dst-} and {-src-} containers has different types.
 * @throws { Error } If {-onEach-} is not undefined, not a routine, not selector.
 * @throws { Error } If onEach.length is more then three.
 * @throws { Error } If {-onEach-} is selector and it does not begin with '*\/'.
 * @namespace Tools
 */

function entityOnly( dst, src, onEach )
{

  if( arguments.length > 2 )
  onEach = arguments[ arguments.length-1 ];

  if( src === undefined )
  src = dst;

  if( _.strIs( onEach ) )
  {
    let selector = onEach;
    /* xxx : qqq : for Dmytro : fix that. ask how to */
    _.assert( _.routine.is( _.select ) );
    _.assert( _.strBegins( selector, '*/' ), () => `Selector should begins with "*/", but "${selector}" does not` );
    selector = _.strRemoveBegin( selector, '*/' );
    onEach = function( e, k )
    {
      return _.select( e, selector );
    }
  }

  let dstTypeStr = typeStr( dst );
  let srcTypeStr = typeStr( src );

  _.assert( dst === null || dstTypeStr === srcTypeStr );
  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  _.assert( onEach === undefined || ( _.routine.is( onEach ) && onEach.length <= 3 ), 'Expects optional routine or selector {- onEach -}' );

  /* */

  /*

    let srcHas = null;
    if ...
    srcHas = srcHasMap;
    else ...
    srcHas = srcHasSet;

  */

  /* */

  if( dst !== null )
  // if( dst === src )
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutineDeleting();
      else
      withRoutineDeleting();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutineDeleting();
      else
      withoutRoutineDeleting();
    }

  }
  else
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutine();
      else
      withRoutine();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutine();
      else
      withoutRoutine(); /* don't change the subroutine */
    }

  }

  /* */

  return dst;

  /* */

  function setWithRoutine()
  {
    dst = new Set( src );

    for( let value of src )
    {
      let res = onEach( value, undefined, src );
      if( !res )
      dst.delete( value );
    }
  }

  /* */

  function setWithoutRoutine()
  {
    dst = new Set( src );

    let unnecessaries = [ null, 0, undefined, false, '' ];
    for( let key of unnecessaries )
    if( dst.has( key ) )
    dst.delete( key );
  }

  /* */

  function hashMapWithRoutine()
  {
    dst = new HashMap( src );

    for( let [ key, value ] of src )
    {
      let res = onEach( value, key, src );
      if( !res )
      dst.delete( key );
    }
  }

  /* */

  function hashMapWithoutRoutine()
  {
    dst = new HashMap( src );

    for( let [ key, value ] of dst )
    if( !value )
    dst.delete( key );
  }

  /* */

  function withRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0 ; k < src.length ; k++ )
      {
        let res = onEach( src[ k ], k, src );
        if( res )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res = onEach( src[ k ], k, src );
        if( res )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res = onEach( src, undefined, undefined );
      if( res )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function withoutRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0 ; k < src.length ; k++ )
      {
        let res = src[ k ];
        if( res )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res = src[ k ];
        if( res )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res = src;
      if( res )
      dst = res;
      else
      dst = undefined;
    }

  }

  /* */

  function setWithRoutineDeleting()
  {
    for( let value of src )
    {
      let res = onEach( value, undefined, src );
      if( !res )
      dst.delete( value );
    }
  }

  /* */

  function setWithoutRoutineDeleting()
  {
    let unnecessaries = [ null, 0, undefined, false, '' ];
    for( let key of unnecessaries )
    {
      if( src.has( key ) )
      dst.delete( key );
    }
  }

  /* */

  function hashMapWithRoutineDeleting()
  {
    for( let [ key, value ] of src )
    {
      let res = onEach( value, key, src )
      if( !res )
      dst.delete( key );
    }
  }

  /* */

  function hashMapWithoutRoutineDeleting()
  {
    for( let [ key, value ] of src )
    if( !value )
    dst.delete( key );
  }

  /* */

  function withRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      for( let k = dst.length - 1; k >= 0; k-- )
      {
        let res = onEach( src[ k ], k, src );
        if( !res )
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in dst )
      {
        let res = onEach( src[ k ], k, src );
        if( !res )
        delete dst[ k ];
      }

    }
    else
    {
      let res = onEach( src, undefined, undefined );
      if( !res )
      dst = undefined;
    }

  }

  /* */

  function withoutRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      for( let k = dst.length - 1; k >= 0; k-- )
      {
        let res = src[ k ];
        if( !res )
        dst.splice( k, 1 );
      }
    }
    else if( _.aux.is( dst ) )
    {

      for( let k in dst )
      {
        let res = src[ k ];
        if( !res )
        delete dst[ k ];
      }

    }
    else
    {
      let res = src;
      if( !res )
      dst = undefined;
    }

  }

  function typeStr( e )
  {
    let type;
    if( _.longIs( e ) )
    type = 'long';
    else if( _.aux.is( e ) )
    type = 'map';
    else if( _.set.is( e ) )
    type = 'set';
    else if( _.hashMap.is( e ) )
    type = 'hashMap';
    else
    type = 'primitive';

    return type;
  }

}

//

/**
 * The routine entityBut() provides the filtering of elements of destination container
 * {-dst-} by checking values in the source container {-src-}. The routine checks values
 * with the same keys in both containers. If a received {-src-} element has not falsy value, then
 * element with the same key deletes from the {-dst-} container.
 *
 * If {-dst-} container is null, routine makes new container with type of {-src-} container, and fill it obtained values.
 * If {-src-} is undefined, routine filters {-dst-} container obtaining values from {-dst-}.
 * Note: containers should have same type.
 *
 * Also, {-dst-} and {-src-} might be not iteratable element, for example, primitive.
 * If {-dst-} is not iteratable, then routine check value of {-src-}.
 *
 * @param { ArrayLike|Set|Map|Object|* } dst - Container or another single element for filtering.
 * If {-dst-} is null, then makes new container of {-src-} type.
 * @param { ArrayLike|Set|Map|Object|* } src - Container or another single element for filtering.
 * If {-src-} is undefined, then {-dst-} filters by its own values.
 * @param { Function } onEach - The callback that obtain value for every {-src-} element. The
 * callback accepts three parameters - element, key, source container.
 *
 * @example
 * _.entityBut( 'str', 1 )
 * // returns undefined
 *
 * @example
 * _.entityBut( 'str', 1, ( e, k, src ) => e - 1 )
 * // returns 'str'
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityBut( null, src );
 * // returns [ 0, null, undefined ]
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityBut( null, src, ( e, k ) => k );
 * // returns [ 1 ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityBut( dst );
 * // returns [ '', 0, null, undefined ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityBut( dst, undefined, ( e, k ) => k );
 * // returns [ '' ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ]
 * _.entityBut( dst, src );
 * // returns [ null, undefined ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ]
 * _.entityBut( dst, undefined, ( e, k ) => k );
 * // returns [ '' ]
 *
 * @returns { ArrayLike|Set|Map|Object|* } - Returns filtered container.
 * If {-dst-} is not iteratable value, routine returns original {-dst-} or undefined.
 * @function entityBut
 * @throws { Error } If arguments.length is less then one or more than three arguments.
 * @throws { Error } If {-dst-} is not null or {-dst-} and {-src-} containers has different types.
 * @throws { Error } If {-onEach-} is not undefined, not a routine, not selector.
 * @throws { Error } If onEach.length is more then three.
 * @throws { Error } If {-onEach-} is selector and it does not begin with '*\/'.
 * @namespace Tools
 */

function entityBut( dst, src, onEach )
{

  if( arguments.length > 2 )
  onEach = arguments[ arguments.length-1 ];

  if( src === undefined )
  src = dst;

  if( _.strIs( onEach ) )
  {
    let selector = onEach;
    _.assert( _.routine.is( _.select ) );
    _.assert( _.strBegins( selector, '*/' ), () => `Selector should begins with "*/", but "${selector}" does not` );
    selector = _.strRemoveBegin( selector, '*/' );
    onEach = function( e, k )
    {
      return _.select( e, selector );
    }
  }

  let dstTypeStr = typeStr( dst );
  let srcTypeStr = typeStr( src );

  _.assert( dst === null || dstTypeStr === srcTypeStr );
  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  _.assert( onEach === undefined || ( _.routine.is( onEach ) && onEach.length <= 3 ), 'Expects optional routine or selector {- onEach -}' );

  /* */

  if( dst !== null )
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutineDeleting();
      else
      withRoutineDeleting();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutineDeleting();
      else
      withoutRoutineDeleting();
    }

  }
  else
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutine();
      else
      withRoutine();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutine();
      else
      withoutRoutine(); /* don't change the subroutine */
    }

  }

  /* */

  return dst;

  /* */

  function setWithRoutine()
  {
    dst = new Set( null );

    for( let value of src )
    {
      let res = onEach( value, undefined, src );
      if( !res )
      dst.add( value );
    }
  }

  /* */

  function setWithoutRoutine()
  {
    dst = new Set( null );

    // Dmytro : it'll be faster, but can't keep order of elements
    // let unnecessaries = [ undefined, 0, null, false, '' ];
    // for( let key of unnecessaries )
    // if( src.has( key ) )
    // dst.add( key );
    for( let e of src )
    if( !e )
    dst.add( e );
  }

  /* */

  function hashMapWithRoutine()
  {
    dst = new HashMap( null );

    for( let [ key, value ] of src )
    {
      let res = onEach( value, key, src );
      if( !res )
      dst.set( key, value );
    }
  }

  /* */

  function hashMapWithoutRoutine()
  {
    dst = new HashMap( null );

    for( let [ key, value ] of src )
    if( !value )
    dst.set( key, value );
  }

  /* */

  function withRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0 ; k < src.length ; k++ )
      {
        let res = onEach( src[ k ], k, src );
        if( !res )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res = onEach( src[ k ], k, src );
        if( !res )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res = onEach( src, undefined, undefined );
      if( !res )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function withoutRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0 ; k < src.length ; k++ )
      {
        let res = src[ k ];
        if( !res )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res = src[ k ];
        if( !res )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res = src;
      if( !res )
      dst = res;
      else
      dst = undefined;
    }

  }

  /* */

  function setWithRoutineDeleting()
  {
    for( let value of src )
    {
      let res = onEach( value, undefined, src );
      if( res )
      dst.delete( value );
    }
  }

  /* */

  function setWithoutRoutineDeleting()
  {
    for( let value of src )
    {
      if( value )
      dst.delete( value );
    }
  }

  /* */

  function hashMapWithRoutineDeleting()
  {
    for( let [ key, value ] of src )
    {
      let res = onEach( value, key, src )
      if( res )
      dst.delete( key );
    }
  }

  /* */

  function hashMapWithoutRoutineDeleting()
  {
    for( let [ key, value ] of src )
    if( value )
    dst.delete( key );
  }

  /* */

  function withRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      for( let k = dst.length - 1; k >= 0; k-- )
      {
        let res = onEach( src[ k ], k, src );
        if( res )
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in dst )
      {
        let res = onEach( src[ k ], k, src );
        if( res )
        delete dst[ k ];
      }

    }
    else
    {
      let res = onEach( src, undefined, undefined );
      if( res )
      dst = undefined;
    }

  }

  /* */

  function withoutRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      for( let k = dst.length - 1; k >= 0; k-- )
      {
        let res = src[ k ];
        if( res )
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in dst )
      {
        let res = src[ k ];
        if( res )
        delete dst[ k ];
      }

    }
    else
    {
      let res = src;
      if( res )
      dst = undefined;
      else
      dst = dst;
    }

  }

  /* xxx */
  function typeStr( e )
  {
    let type;
    if( _.longIs( e ) )
    type = 'long';
    else if( _.aux.is( e ) )
    type = 'map';
    else if( _.set.is( e ) )
    type = 'set';
    else if( _.hashMap.is( e ) )
    type = 'hashMap';
    else
    type = 'primitive';

    return type;
  }

}

//

/**
 * The routine entityAnd() provides the filtering of elements of destination container
 * {-dst-} by checking values with the same keys in the {-dst-} and source {-src-} containers.
 * If one of received values is falsy, then element with deletes from the {-dst-} container.
 *
 * If {-dst-} container is null, routine makes new container with type of {-src-} container, and fill it obtained values.
 * If {-src-} is undefined, routine filters {-dst-} container obtaining values from {-dst-}.
 * Note: containers should have same type.
 *
 * Also, {-dst-} and {-src-} might be not iteratable element, for example, primitive.
 * If {-dst-} is not iteratable, then routine check value of {-src-}.
 *
 * @param { ArrayLike|Set|Map|Object|* } dst - Container or another single element for filtering.
 * If {-dst-} is null, then makes new container of {-src-} type.
 * @param { ArrayLike|Set|Map|Object|* } src - Container or another single element for filtering.
 * If {-src-} is undefined, then {-dst-} filters by its own values.
 * @param { Function } onEach - The callback that obtain value for every {-dst-} and {-src-} element
 * with the same keys. The callback accepts three parameters - element, key, source container.
 *
 * @example
 * _.entityAnd( 'str', 1 );
 * // returns 'str'
 *
 * @example
 * _.entityAnd( 'str', 1, ( e, k, src ) => e - 1 );
 * // returns undefined
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityAnd( null, src );
 * // returns [ 1, true ]
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityAnd( null, src, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityAnd( dst );
 * // returns [ true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityAnd( dst, undefined, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ];
 * _.entityAnd( dst, src );
 * // returns []
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ];
 * _.entityAnd( dst, undefined, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @returns { ArrayLike|Set|Map|Object|* } - Returns filtered container.
 * If {-dst-} is not iteratable value, routine returns original {-dst-} or undefined.
 * @function entityAnd
 * @throws { Error } If arguments.length is less then one or more than three arguments.
 * @throws { Error } If {-dst-} is not null or {-dst-} and {-src-} containers has different types.
 * @throws { Error } If {-onEach-} is not undefined, not a routine, not selector.
 * @throws { Error } If onEach.length is more then three.
 * @throws { Error } If {-onEach-} is selector and it does not begin with '*\/'.
 * @namespace Tools
 */

function entityAnd( dst, src, onEach )
{

  if( arguments.length > 2 )
  onEach = arguments[ arguments.length-1 ];

  if( src === undefined )
  src = dst;

  if( _.strIs( onEach ) )
  {
    let selector = onEach;
    _.assert( _.routine.is( _.select ) );
    _.assert( _.strBegins( selector, '*/' ), () => `Selector should begins with "*/", but "${selector}" does not` );
    selector = _.strRemoveBegin( selector, '*/' );
    onEach = function( e, k )
    {
      return _.select( e, selector );
    }
  }

  let dstTypeStr = typeStr( dst );
  let srcTypeStr = typeStr( src );

  _.assert( dst === null || dstTypeStr === srcTypeStr );
  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  _.assert( onEach === undefined || ( _.routine.is( onEach ) && onEach.length <= 3 ), 'Expects optional routine or selector {- onEach -}' );

  /* */

  if( dst !== null )
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutineDeleting();
      else
      withRoutineDeleting();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutineDeleting();
      else
      withoutRoutineDeleting();
    }

  }
  else
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutine();
      else
      withRoutine();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutine();
      else
      withoutRoutine(); /* don't change the subroutine */
    }

  }

  return dst;

  /* */

  function setWithRoutine()
  {
    dst = new Set( null );

    for( let value of src )
    {
      let res = onEach( value, undefined, src );
      if( res )
      dst.add( value );
    }
  }

  /* */

  function setWithoutRoutine()
  {
    dst = new Set( src );

    let unnecessaries = [ null, 0, undefined, false, '' ];
    for( let key of unnecessaries )
    if( src.has( key ) )
    dst.delete( key );
  }

  /* */

  function hashMapWithRoutine()
  {
    dst = new HashMap( null );

    for( let [ key, value ] of src )
    {
      let res = onEach( value, key, src );
      if( res )
      dst.set( key, value );
    }
  }

  /* */

  function hashMapWithoutRoutine()
  {
    dst = new HashMap( null );

    for( let [ key, value ] of src )
    if( value )
    dst.set( key, value );
  }

  /* */

  function withRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0; k < src.length; k++ )
      {
        let res = onEach( src[ k ], k, src );
        if( res )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res = onEach( src[ k ], k, src );
        if( res )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res = onEach( src, undefined, undefined );
      if( res )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function withoutRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0; k < src.length; k++ )
      {
        let res = src[ k ];
        if( res )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res = src[ k ];
        if( res )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res = src;
      if( res )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function setWithRoutineDeleting()
  {

    for( let value of dst )
    {
      let res1, res2;
      let from = [ ... src ]

      res1 = onEach( value, undefined, dst );
      if( res1 && from.lastIndexOf( value ) !== -1 )
      res2 = onEach( value, undefined, from );
      else if( res1 )
      res2 = onEach( undefined, undefined, src );

      if( !res1 || !res2 )
      dst.delete( value );
    }
  }

  /* */

  function setWithoutRoutineDeleting()
  {
    for( let value of dst )
    {
      if( !value || !src.has( value ) )
      dst.delete( value );
    }
  }

  /* */

  function hashMapWithRoutineDeleting()
  {
    for( let [ key, value ] of dst )
    {
      let res1, res2;
      res1 = onEach( value, key, dst )
      if( res1 !== undefined && src.has( key ) )
      res2 = onEach( src.get( key ), key, src );

      if( !res1 || !res2 )
      dst.delete( key );
    }
  }

  /* */

  function hashMapWithoutRoutineDeleting()
  {
    for( let [ key, value ] of dst )
    if( !value || !src.get( key ) )
    dst.delete( key );
  }

  /* */

  function withRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      dst = _.arrayIs( dst ) ? dst : _.array.make( dst );
      for( let k = dst.length - 1; k >= 0; k-- )
      {
        let res1, res2;
        res1 = onEach( dst[ k ], k, dst );
        if( res1 )
        res2 = onEach( src[ k ], k, src );
        if( !res1 || !res2 )
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in dst )
      {
        let res1, res2;
        res1 = onEach( dst[ k ], k, dst );
        if( res1 )
        res2 = onEach( src[ k ], k, src );
        if( !res1 || !res2 )
        delete dst[ k ];
      }

    }
    else
    {
      let res1, res2;
      res1 = onEach( dst, undefined, undefined );
      if( res1 )
      res2 = onEach( src, undefined, undefined );
      if( !res1 || !res2 )
      dst = undefined;
    }

  }

  /* */

  function withoutRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      dst = _.arrayIs( dst ) ? dst : _.array.make( dst );
      for( let k = dst.length - 1; k >= 0; k-- )
      {
        let res1 = dst[ k ];
        let res2 = src[ k ];
        if( !res1 || !res2 )
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in dst )
      {
        let res1 = dst[ k ];
        let res2 = src[ k ];
        if( !res1 || !res2 )
        delete dst[ k ];
      }

    }
    else
    {
      let res1 = dst;
      let res2 = src;
      if( !res1 || !res2 )
      dst = undefined;
    }

  }

  function typeStr( e )
  {
    let type;
    if( _.longIs( e ) )
    type = 'long';
    else if( _.aux.is( e ) )
    type = 'map';
    else if( _.set.is( e ) )
    type = 'set';
    else if( _.hashMap.is( e ) )
    type = 'hashMap';
    else
    type = 'primitive';

    return type;
  }

}

//

/**
 * The routine entityOr() provides the filtering of elements of destination container
 * {-dst-} by checking values with the same keys in the {-dst-} and source {-src-} containers.
 * If checking of {-dst-} element returs true, routine save {-dst-} element.
 * If checking of {-dst-} element return false and checking of {-src-} element returns true,
 * routine replace {-dst-} element by {-src-} element.
 * Else, routine deletes {-dst-} element.
 *
 * If {-dst-} container is null, routine makes new container with type of {-src-} container, and fill it obtained values.
 * If {-src-} is undefined, routine filters {-dst-} container obtaining values from {-dst-}.
 * Note: containers should have same type.
 *
 * Also, {-dst-} and {-src-} might be not iteratable element, for example, primitive.
 * If {-dst-} is not iteratable, then routine check value of {-src-}.
 *
 * @param { ArrayLike|Set|Map|Object|* } dst - Container or another single element for filtering.
 * If {-dst-} is null, then makes new container of {-src-} type.
 * @param { ArrayLike|Set|Map|Object|* } src - Container or another single element for filtering.
 * If {-src-} is undefined, then {-dst-} filters by its own values.
 * @param { Function } onEach - The callback that obtain value for every {-dst-} and {-src-} element
 * with the same keys. The callback accepts three parameters - element, key, source container.
 *
 * @example
 * _.entityOr( 'str', undefined );
 * // returns 'str'
 *
 * @example
 * _.entityOr( false, 1, ( e, k, src ) => e - 1 );
 * // returns 1
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityOr( null, src );
 * // returns [ 1, true ]
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityOr( null, src, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityOr( dst );
 * // returns [ true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityOr( dst, undefined, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ];
 * _.entityOr( dst, src );
 * // returns [ 1, 2, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ];
 * _.entityOr( dst, undefined, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @returns { ArrayLike|Set|Map|Object|* } - Returns filtered container.
 * If {-dst-} is not iteratable value, routine returns original {-dst-} or undefined.
 * @function entityOr
 * @throws { Error } If arguments.length is less then one or more than three arguments.
 * @throws { Error } If {-dst-} is not null or {-dst-} and {-src-} containers has different types.
 * @throws { Error } If {-onEach-} is not undefined, not a routine, not selector.
 * @throws { Error } If onEach.length is more then three.
 * @throws { Error } If {-onEach-} is selector and it does not begin with '*\/'.
 * @namespace Tools
 */

function entityOr( dst, src, onEach )
{

  if( arguments.length > 2 )
  onEach = arguments[ arguments.length-1 ];

  if( src === undefined )
  src = dst;

  if( _.strIs( onEach ) )
  {
    let selector = onEach;
    _.assert( _.routine.is( _.select ) );
    _.assert( _.strBegins( selector, '*/' ), () => `Selector should begins with "*/", but "${selector}" does not` );
    selector = _.strRemoveBegin( selector, '*/' );
    onEach = function( e, k )
    {
      return _.select( e, selector );
    }
  }

  let dstTypeStr = typeStr( dst );
  let srcTypeStr = typeStr( src );

  _.assert( dst === null || dstTypeStr === srcTypeStr );
  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  _.assert( onEach === undefined || ( _.routine.is( onEach ) && onEach.length <= 3 ), 'Expects optional routine or selector {- onEach -}' );

  /* */

  if( dst !== null )
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutineDeleting();
      else
      withRoutineDeleting();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutineDeleting();
      else
      withoutRoutineDeleting();
    }

  }
  else
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutine();
      else
      withRoutine();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutine();
      else
      withoutRoutine(); /* don't change the subroutine */
    }

  }

  return dst;

  /* */

  function setWithRoutine()
  {
    dst = new Set( null );

    for( let value of src )
    {
      let res = onEach( value, undefined, src );
      if( res )
      dst.add( value );
    }
  }

  /* */

  function setWithoutRoutine()
  {
    dst = new Set( src );

    let unnecessaries = [ null, 0, undefined, false, '' ];
    for( let key of unnecessaries )
    if( src.has( key ) )
    dst.delete( key );
  }

  /* */

  function hashMapWithRoutine()
  {
    dst = new HashMap( null );

    for( let [ key, value ] of src )
    {
      let res = onEach( value, key, src );
      if( res )
      dst.set( key, value );
    }
  }

  /* */

  function hashMapWithoutRoutine()
  {
    dst = new HashMap( null );

    for( let [ key, value ] of src )
    if( value )
    dst.set( key, value );
  }

  /* */

  function withRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0; k < src.length; k++ )
      {
        let res = onEach( src[ k ], k, src );
        if( res )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res = onEach( src[ k ], k, src );
        if( res )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res = onEach( src, undefined, undefined );
      if( res )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function withoutRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0; k < src.length; k++ )
      {
        let res = src[ k ];
        if( res )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res = src[ k ];
        if( res )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res = src;
      if( res )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function setWithRoutineDeleting()
  {
    for( let key of dst )
    {
      let res1, res2;
      res1 = onEach( key, undefined, dst );
      if( !res1 && src.has( key ) )
      res2 = onEach( key, undefined, src );
      else
      res2 = onEach( undefined, undefined, src );

      if( !res1 && !res2 )
      dst.delete( key );
    }
  }

  /* */

  function setWithoutRoutineDeleting()
  {
    for( let value of dst )
    {
      if( !value )
      dst.delete( value );
    }
  }

  /* */

  function hashMapWithRoutineDeleting()
  {
    for( let [ key, value ] of dst )
    {
      let res1, res2
      res1 = onEach( value, key, dst )
      if( !res1 && src.has( key ) )
      res2 = onEach( src.get( key ), key, src );
      else
      res2 = onEach( undefined, undefined, src );

      if( res1 )
      dst.set( key, value );
      else if( res2 )
      dst.set( key, src.get( key ) );
      else
      dst.delete( key );
    }
  }

  /* */

  function hashMapWithoutRoutineDeleting()
  {
    for( let [ key, value ] of dst )
    {
      if( !value )
      {
        let res = src.get( key );

        if( res )
        dst.set( key, res );
        else
        dst.delete( key );
      }
    }
  }

  /* */

  function withRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      dst = _.arrayIs( dst ) ? dst : _.array.make( dst );
      for( let k = dst.length - 1; k >= 0; k-- )
      {
        let res1, res2;
        res1 = onEach( dst[ k ], k, dst );
        if( !res1 )
        res2 = onEach( src[ k ], k, src );

        if( res1 )
        dst[ k ] = dst[ k ];
        else if( res2 )
        dst[ k ] = src[ k ];
        else
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in dst )
      {
        let res1, res2;
        res1 = onEach( dst[ k ], k, dst );
        if( !res1 )
        res2 = onEach( src[ k ], k, src );

        if( res1 )
        dst[ k ] = dst[ k ];
        else if( res2 )
        dst[ k ] = src[ k ];
        else
        delete dst[ k ];
      }

    }
    else
    {
      let res1, res2;
      res1 = onEach( dst, undefined, undefined );
      if( !res1 )
      res2 = onEach( src, undefined, undefined );

      if( res1 )
      dst = dst;
      else if( res2 )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function withoutRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      dst = _.arrayIs( dst ) ? dst : _.array.make( dst );
      for( let k = dst.length - 1; k >= 0; k-- )
      {
        let res1 = dst[ k ];
        let res2 = src[ k ];

        if( res1 )
        dst[ k ] = dst[ k ];
        else if( res2 )
        dst[ k ] = src[ k ];
        else
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in dst )
      {
        let res1 = dst[ k ];
        let res2 = src[ k ];

        if( res1 )
        dst[ k ] = dst[ k ];
        else if( res2 )
        dst[ k ] = src[ k ];
        else
        delete dst[ k ];
      }

    }
    else
    {
      let res1 = dst;
      let res2 = src;

      if( res1 )
      dst = dst;
      else if( res2 )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function typeStr( e )
  {
    let type;
    if( _.longIs( e ) )
    type = 'long';
    else if( _.aux.is( e ) )
    type = 'map';
    else if( _.set.is( e ) )
    type = 'set';
    else if( _.hashMap.is( e ) )
    type = 'hashMap';
    else
    type = 'primitive';

    return type;
  }

}

//

/**
 * The routine entityXor() provides the filtering of elements of destination container
 * {-dst-} by checking values with the same keys in the {-dst-} and source {-src-} containers.
 * If both received values from {-dst-} and {-src-} has the same boolean value, then routine
 * deletes {-dst-} element.
 * Else routine sets in {-dst-} element, which received boolean value is true.
 *
 * If {-dst-} container is null, routine makes new container with type of {-src-} container, and fill it obtained values.
 * If {-src-} is undefined, routine filters {-dst-} container obtaining values from {-dst-}.
 * Note: containers should have same type.
 *
 * Also, {-dst-} and {-src-} might be not iteratable element, for example, primitive.
 * If {-dst-} is not iteratable, then routine check value of {-src-}.
 *
 * @param { ArrayLike|Set|Map|Object|* } dst - Container or another single element for filtering.
 * If {-dst-} is null, then makes new container of {-src-} type.
 * @param { ArrayLike|Set|Map|Object|* } src - Container or another single element for filtering.
 * If {-src-} is undefined, then {-dst-} filters by its own values.
 * @param { Function } onEach - The callback that obtain value for every {-dst-} and {-src-} element
 * with the same keys. The callback accepts three parameters - element, key, source container.
 *
 * @example
 * _.entityXor( 'str', undefined );
 * // returns 'str'
 *
 * @example
 * _.entityXor( 'str', 1, ( e, k, src ) => e - 1 );
 * // returns false
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityXor( null, src );
 * // returns [ 1, 0, null, undefined, true ]
 *
 * @example
 * let src = [ 1, 0, null, undefined, true ];
 * _.entityXor( null, src, ( e, k ) => k );
 * // returns [ 0, null, undefined, true ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityXor( dst );
 * // returns []
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * _.entityXor( dst, undefined, ( e, k ) => k );
 * // returns []
 *
 * @example
 * let dst = [ '', 0, null, 1, true ];
 * let src = [ 1, 2, false, 1, 'str' ];
 * _.entityXor( dst, src );
 * // returns [ 1, 2 ]
 *
 * @example
 * let dst = [ '', 0, null, undefined, true ];
 * let src = [ 1, 2, false, undefined, 0 ];
 * _.entityXor( dst, undefined, ( e, k ) => k );
 * // returns []
 *
 * @returns { ArrayLike|Set|Map|Object|* } - Returns filtered container.
 * If {-dst-} is not iteratable value, routine returns original {-dst-} or undefined.
 * @function entityXor
 * @throws { Error } If arguments.length is less then one or more than three arguments.
 * @throws { Error } If {-dst-} is not null or {-dst-} and {-src-} containers has different types.
 * @throws { Error } If {-onEach-} is not undefined, not a routine, not selector.
 * @throws { Error } If onEach.length is more then three.
 * @throws { Error } If {-onEach-} is selector and it does not begin with '*\/'.
 * @namespace Tools
 */

function entityXor( dst, src, onEach )
{

  if( arguments.length > 2 )
  onEach = arguments[ arguments.length-1 ];

  if( src === undefined )
  src = dst;

  if( _.strIs( onEach ) )
  {
    let selector = onEach;
    _.assert( _.routine.is( _.select ) );
    _.assert( _.strBegins( selector, '*/' ), () => `Selector should begins with "*/", but "${selector}" does not` );
    selector = _.strRemoveBegin( selector, '*/' );
    onEach = function( e, k )
    {
      return _.select( e, selector );
    }
  }

  let dstTypeStr = typeStr( dst );
  let srcTypeStr = typeStr( src );

  _.assert( dst === null || dstTypeStr === srcTypeStr );
  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  _.assert( onEach === undefined || ( _.routine.is( onEach ) && onEach.length <= 3 ), 'Expects optional routine or selector {- onEach -}' );

  /* */

  if( dst !== null )
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutineDeleting();
      else
      withRoutineDeleting();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutineDeleting();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutineDeleting();
      else
      withoutRoutineDeleting();
    }

  }
  else
  {

    if( _.routine.is( onEach ) )
    {
      if( srcTypeStr === 'set' )
      setWithRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithRoutine();
      else
      withRoutine();
    }
    else
    {
      if( srcTypeStr === 'set' )
      setWithoutRoutine();
      else if( srcTypeStr === 'hashMap' )
      hashMapWithoutRoutine();
      else
      withoutRoutine(); /* don't change the subroutine */
    }

  }

  return dst;

  /* */

  function setWithRoutine()
  {
    dst = new Set( null );

    for( let value of src )
    {
      let res1 = onEach( undefined, undefined, dst );
      let res2 = onEach( value, undefined, src );

      if( ( res1 && !res2 ) || ( !res1 && res2 ) )
      dst.add( value );
    }
  }

  /* */

  function setWithoutRoutine()
  {
    dst = new Set( src );

    let unnecessaries = [ null, 0, undefined, false, '' ];
    for( let e of unnecessaries )
    dst.delete( e );
  }

  /* */

  function hashMapWithRoutine()
  {
    dst = new HashMap( null );

    for( let [ key, value ] of src )
    {
      let res1 = onEach( undefined, undefined, dst );
      let res2 = onEach( value, key, src );

      if( ( res1 && !res2 ) || ( !res1 && res2 ) )
      dst.set( key, value );
    }
  }

  /* */

  function hashMapWithoutRoutine()
  {
    dst = new HashMap( src );

    let unnecessaries = [ null, 0, undefined, false, '' ];
    for( let k of unnecessaries )
    {
      if( !dst.get( k ) )
      dst.delete( k );
    }
  }

  /* */

  function withRoutine()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {

      dst = [];
      for( let k = 0; k < src.length; k++ )
      {
        let res1 = onEach( undefined, undefined, dst );
        let res2 = onEach( src[ k ], k, src );

        if( ( res1 && !res2 ) || ( !res1 && res2 ) )
        dst.push( src[ k ] );
      }

    }
    else if( _.aux.is( src ) )
    {

      dst = Object.create( null );
      for( let k in src )
      {
        let res1 = onEach( undefined, undefined, dst );
        let res2 = onEach( src[ k ], k, src );

        if( ( res1 && !res2 ) || ( !res1 && res2 ) )
        dst[ k ] = src[ k ];
      }

    }
    else
    {
      let res1 = onEach( null );
      let res2 = onEach( src, undefined, undefined );
      if( ( res1 && !res2 ) || ( !res1 && res2 ) )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function withoutRoutine()
  {

    if( _.longIs( src ) )
    {
      dst = [];
      for( let e of src )
      if( e )
      dst.push( e );
    }
    else if( _.aux.is( src ) )
    {
      dst = Object.assign( Object.create( null ), src );
      let  unnecessaries = [ null, 0, undefined, false, '' ];
      for( let k of unnecessaries )
      {
        if( !dst[ k ] )
        delete dst[ k ];
      }
    }
    else
    {
      if( src !== undefined )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function setWithRoutineDeleting()
  {
    for( let key of dst )
    {
      let res = onEach( key, undefined, dst );
      if( !res )
      dst.delete( key );
    }

    for( let key of src )
    {
      let res1, res2;
      if( dst.has( key ) )
      res1 = onEach( key, key, dst );
      else
      res1 = onEach( undefined, undefined, dst );
      res2 = onEach( key, key, src );

      if( res1 && !res2 )
      {}
      else if( !res1 && res2 )
      dst.add( key );
      else
      dst.delete( key );
    }
  }

  /* */

  function setWithoutRoutineDeleting()
  {
    for( let key of dst )
    if( !key )
    dst.delete( key );
    for( let key of src )
    {
      if( dst.has( key ) )
      dst.delete( key );
      else if( key )
      dst.add( key );
    }
  }

  /* */

  function hashMapWithRoutineDeleting()
  {
    for( let [ key, value ] of dst )
    {
      let res = onEach( value, key, dst )
      if( !res )
      dst.delete( key );
    }
    for( let [ key, value ] of src )
    {
      let res1, res2
      if( dst.has( key ) )
      res1 = onEach( dst.get( key ), key, dst );
      else
      res1 = onEach( undefined, undefined, dst );
      res2 = onEach( value, key, src )

      if( res1 && !res2 )
      {}
      else if( !res1 && res2 )
      dst.set( key, value );
      else
      dst.delete( key );
    }
  }

  /* */

  function hashMapWithoutRoutineDeleting()
  {
    for( let [ key, value ] of dst )
    if( !value )
    dst.delete( key );
    for( let [ key, value ] of src )
    {
      let res1 = dst.get( key );
      let res2 = value;

      if( res1 && !res2 )
      {}
      else if( !res1 && res2 )
      dst.set( key, value );
      else
      dst.delete( key );
    }
  }

  /* */

  function withRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      dst = _.arrayIs( dst ) ? dst : _.array.make( dst );
      for( let k = src.length - 1; k >= 0; k-- )
      {
        let res1 = onEach( dst[ k ], k, dst );
        let res2 = onEach( src[ k ], k, src );

        if( res1 && !res2 )
        {}
        else if( !res1 && res2 )
        dst[ k ] = src[ k ];
        else
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in src )
      {
        let res1 = onEach( dst[ k ], k, dst );
        let res2 = onEach( src[ k ], k, src );

        if( res1 && !res2 )
        {}
        else if( !res1 && res2 )
        dst[ k ] = src[ k ];
        else
        delete dst[ k ];
      }

    }
    else
    {
      let res1 = onEach( dst, undefined, undefined );
      let res2 = onEach( src, undefined, undefined );

      if( res1 && !res2 )
      {}
      else if( !res1 && res2 )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function withoutRoutineDeleting()
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( dst ) )
    {

      dst = _.arrayIs( dst ) ? dst : _.array.make( dst );
      for( let k = src.length - 1; k >= 0; k-- )
      {
        let res1 = dst[ k ];
        let res2 = src[ k ];

        if( res1 && !res2 )
        {}
        else if( !res1 && res2 )
        dst[ k ] = src[ k ];
        else
        dst.splice( k, 1 );
      }

    }
    else if( _.aux.is( dst ) )
    {

      for( let k in src )
      {
        let res1 = dst[ k ];
        let res2 = src[ k ];

        if( res1 && !res2 )
        {}
        else if( !res1 && res2 )
        dst[ k ] = src[ k ];
        else
        delete dst[ k ];
      }

    }
    else
    {
      let res1 = dst;
      let res2 = src;

      if( res1 && !res2 )
      {}
      else if( !res1 && res2 )
      dst = src;
      else
      dst = undefined;
    }

  }

  /* */

  function typeStr( e )
  {
    let type;
    if( _.longIs( e ) )
    type = 'long';
    else if( _.aux.is( e ) )
    type = 'map';
    else if( _.set.is( e ) )
    type = 'set';
    else if( _.hashMap.is( e ) )
    type = 'hashMap';
    else
    type = 'primitive';

    return type;
  }

}

//

function entityAll( src, onEach )
{
  let result = true;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( onEach === undefined || ( _.routine.is( onEach ) && onEach.length <= 3 ) );

  /* */

  if( _.routine.is( onEach ) )
  {

    /* qqq for junior : add branch for countable case */
    if( _.set.like( src ) )
    {

      for( let e of src )
      {
        result = onEach( e, undefined, src );
        if( !result )
        return result;
      }

    }
    else if( _.hashMap.is( src ) )
    {

      for( let [ key, value ] of src )
      {
        result = onEach( value, key, src );
        if( !result )
        return result;
      }

    }
    else if( _.longIs( src ) )
    {

      /* qqq for junior : add branch for countable case */
      for( let k = 0 ; k < src.length ; k++ )
      {
        result = onEach( src[ k ], k, src );
        if( !result )
        return result;
      }

    }
    else if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        result = onEach( src[ k ], k, src );
        if( !result )
        return result;
      }

    }
    else
    {
      result = onEach( src, undefined, undefined );
      if( !result )
      return result;
    }

  }
  else
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) || _.set.like( src ) )
    {

      for( let e of src )
      {
        result = e;
        if( !result )
        return result;
      }

    }
    else if( _.hashMap.is( src ) )
    {

      for( let [ key, value ] of src )
      {
        result = value;
        if( !result )
        return result;
      }

    }
    else if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        result = src[ k ];
        if( !result )
        return result;
      }

    }
    else
    {
      result = src;
      if( !result )
      return result;
    }

  }

  /* */

  return true;
}

//

function entityAny( src, onEach )
{
  let result = undefined;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( onEach === undefined || ( _.routine.is( onEach ) && onEach.length <= 3 ) );

  /* */

  if( _.routine.is( onEach ) )
  {

    /* qqq for junior : add branch for countable case */
    if( _.set.like( src ) )
    {

      for( let e of src )
      {
        result = onEach( e, undefined, src );
        if( result )
        return result;

      }

    }
    else if( _.hashMap.is( src ) )
    {

      for( let [ key, value ] of src )
      {
        result = onEach( value, key, src );
        if( result )
        return result;

      }

    }
    else if( _.longIs( src ) )
    {

      /* qqq for junior : add branch for countable case */
      for( let k = 0 ; k < src.length ; k++ )
      {
        result = onEach( src[ k ], k, undefined );
        if( result )
        return result;
      }

    }
    else if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        result = onEach( src[ k ], k, undefined );
        if( result )
        return result;
      }

    }
    else
    {
      result = onEach( src, undefined, undefined );
      if( result )
      return result;
    }

  }
  else
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) || _.set.like( src ) )
    {

      for( let e of src )
      {
        result = e;
        if( result )
        return result;
      }

    }
    else if( _.hashMap.is( src ) )
    {

      for( let [ key, value ] of src )
      {
        result = value;
        if( result )
        return result;
      }

    }
    else if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        result = src[ k ];
        if( result )
        return result;
      }

    }
    else
    {
      result = src;
      if( result )
      return result;
    }

  }

  /* */

  /* qqq : for Dmytro : should return undefined in such cases */
  // return false;
  return undefined;
}

//

function entityNone( src, onEach )
{
  let result = true;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( onEach === undefined || ( _.routine.is( onEach ) && onEach.length <= 3 ) );

  /* */

  if( _.routine.is( onEach ) )
  {

    /* qqq for junior : add branch for countable case */
    if( _.set.like( src ) )
    {

      for( let e of src )
      {
        result = onEach( e, undefined, src );
        if( result )
        return !result;
      }

    }
    else if( _.hashMap.is( src ) )
    {

      for( let [ key, value ] of src )
      {
        result = onEach( value, key, src );
        if( result )
        return !result;
      }

    }
    else if( _.longIs( src ) )
    {

      /* qqq for junior : add branch for countable case */
      for( let k = 0 ; k < src.length ; k++ )
      {
        result = onEach( src[ k ], k, src );
        if( result )
        return !result;
      }

    }
    else if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        result = onEach( src[ k ], k, src );
        if( result )
        return !result;
      }

    }
    else
    {
      result = onEach( src, undefined, undefined );
      if( result )
      return !result;
    }

  }
  else
  {

    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) || _.set.like( src ) )
    {

      for( let e of src )
      {
        result = e;
        if( result )
        return !result;
      }

    }
    else if( _.hashMap.is( src ) )
    {

      for( let [ key, value ] of src )
      {
        result = value;
        if( result )
        return !result;
      }

    }
    else if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        result = src[ k ];
        if( result )
        return !result;
      }

    }
    else
    {
      result = src;
      if( result )
      return !result;
    }

  }

  /* */

  return true;
}

//

/**
 * Returns generated function that takes single argument( e ) and can be called to check if object( e )
 * has at least one key/value pair that is represented in( condition ).
 * If( condition ) is provided as routine, routine uses it to check condition.
 * Generated function returns origin( e ) if conditions is true, else undefined.
 *
 * @param {object|function} condition - Map to compare with( e ) or custom function.
 * @returns {function} Returns condition check function.
 *
 * @example
 * let check = _._filter_functor( { a : 1, b : 1, c : 1 } );
 * check( { a : 1 } );
 * // returns Object {a: 1}
 *
 * @example
 * function condition( src ){ return src.y === 1 }
 * let check = _._filter_functor( condition );
 * check( { a : 2 } );
 * // returns false
 *
 * @function _filter_functor
 * @throws {exception} If no argument provided.
 * @throws {exception} If( condition ) is not a Routine or Object.
 * @namespace Tools
 */

function _filter_functor( condition, levels )
{
  let result;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.routine.is( condition ) || _.object.isBasic( condition ) );

  if( _.object.isBasic( condition ) )
  {
    let template = condition;
    condition = function condition( e, k, src )
    {
      _.assert( arguments.length === 3 );
      if( e === template )
      return e;
      if( !_.object.like( e ) )
      return;
      let satisfied = _.objectSatisfy
      ({
        template,
        src : e,
        levels
      });
      if( satisfied )
      return e;
    };
  }

  return condition;
}

//

/**
 * Function that produces an elements for entityMap result
 * @callback wTools.onEach
 * @param {*} val - The current element being processed in the entity.
 * @param {string|number} key - The index (if entity is array) or key of processed element.
 * @param {Array|Object} src - The src passed to entityMap.
 */

/**
 * Creates new instance with same as( src ) type. Elements of new instance results of calling a provided ( onEach )
 * function on every element of src. If entity is array, the new array has the same length as source.
 *
 * @example
 * let numbers = [ 3, 4, 6 ];
 * function sqrt( v )
 * {
 *   return v * v;
 * };
 *
 * _.container.map_( null, numbers, sqrt );
 * // returns [ 9, 16, 36 ]
 * // numbers is still [ 3, 4, 6 ]
 *
 * @example
 * function checkSidesOfTriangle( v, i, src )
 * {
 *   let sumOthers = 0,
 *     l = src.length,
 *     j;
 *
 *   for( j = 0; j < l; j++ )
 *   {
 *     if( i === j ) continue;
 *     sumOthers += src[ j ];
 *   }
 *   return v < sumOthers;
 * }
 *
 * _.container.map_( null, numbers, checkSidesOfTriangle );
 * // returns [ true, true, true ]
 *
 * @param {ArrayLike|ObjectLike} src - Entity, on each elements of which will be called ( onEach ) function.
 * @param {wTools.onEach} onEach - Function that produces an element of the new entity.
 * @returns {ArrayLike|ObjectLike} New entity.
 * @thorws {Error} If number of arguments less or more than 2.
 * @thorws {Error} If( src ) is not Array or ObjectLike.
 * @thorws {Error} If( onEach ) is not function.
 * @function entityMap
 * @namespace Tools
 */

//

function map_( dst, src, onEach )
{
  if( arguments.length === 2 )
  {
    _.assert( arguments.length === 2, 'Expects three arguments' );
    onEach = src;
    src = dst;
  }
  else
  {
    _.assert( arguments.length === 3, 'Expects three arguments' );
  }
  _.assert( _.routine.is( onEach ) );

  /* */

  let result;

  if( dst === src )
  {

    result = src;
    /* qqq for junior : add branch for countable case */
    if( _.longIs( src ) )
    {
      for( let s = 0 ; s < src.length ; s++ )
      {
        let r = onEach( src[ s ], s, src );
        if( r !== undefined )
        result[ s ] = r;
      }
    }
    else if( _.aux.is( src ) )
    {
      for( let s in src )
      {
        let r = onEach( src[ s ], s, src );
        if( r !== undefined )
        result[ s ] = r;
      }
    }
    else
    {
      result = src;
      let r = onEach( src, undefined, undefined );
      if( r !== undefined )
      result = r;
    }

  }
  else
  {

    result = dst;
    if( _.longIs( src ) )
    {
      if( dst === null )
      result = _.entity.makeUndefined( src, src.length );
      else
      _.assert( _.longIs( dst ), '{-dst-} container should be long like' );

      /* qqq for junior : add branch for countable case */
      for( let s = 0 ; s < src.length ; s++ )
      {
        let r = onEach( src[ s ], s, src );
        if( r !== undefined )
        result[ s ] = r;
      }
    }
    else if( _.aux.is( src ) )
    {
      if( dst === null )
      result = _.entity.makeUndefined( src );
      else
      _.assert( _.aux.is( dst ), '{-dst-} container should be map like' );

      for( let s in src )
      {
        let r = onEach( src[ s ], s, src );
        if( r !== undefined )
        result[ s ] = r;
      }
    }
    else
    {
      let r = onEach( src, undefined, undefined );
      if( r === undefined )
      return dst;

      if( _.longIs( dst ) )
      result = _.arrayAppendElement( dst, r );
      else if( _.aux.is( dst ) )
      result = _.props.extend( dst, r );
      else if( _.primitive.is( dst ) )
      result = r;
      else
      _.assert( 0, 'Not clear how to add result in destination container {-dst-}' );
    }

  }

  return result;
}

//

function filter_( dst, src, onEach )
{

  if( arguments.length === 2 )
  {
    _.assert( arguments.length === 3, 'Expects three arguments' );
    onEach = src;
    src = dst;
  }
  else
  {
    _.assert( arguments.length === 3, 'Expects two or three arguments' );
  }
  onEach = _._filter_functor( onEach, 1 );

  _.assert( _.routine.is( onEach ) );

  /* */

  let result;

  if( dst === src )
  {

    result = src;
    if( _.longIs( src ) )
    {
      /* qqq for junior : add branch for countable case */
      /* qqq : should be direct! check other cycles */
      for( let s = src.length - 1 ; s >= 0 ; s-- )
      {
        let r = onEach.call( src, src[ s ], s, src );
        if( _.unrollIs( r ) )
        _.longBut_( result, s, r );
        else if( r !== undefined )
        result[ s ] = r;
        else
        result.splice( s, 1 );
      }
    }
    else if( _.aux.is( src ) )
    {
      for( let s in src )
      {
        let r = onEach.call( src, src[ s ], s, src );
        if( r === undefined )
        delete src[ s ];
        else
        src[ s ] = r;
      }
    }
    else
    {
      result = onEach.call( null, src, null, null );
    }

  }
  else
  {

    result = dst;
    if( _.longIs( src ) )
    {
      if( dst === null )
      {
        if( _.argumentsArray.is( src ) )
        result = [];
        else
        result = _.long.make( src, 0 );
      }
      else
      {
        _.assert( _.longIs( dst ), '{-dst-} container should be long like' );
      }

      let s, d;
      /* qqq for junior : add branch for countable case */
      for( s = 0, d = 0 ; s < src.length ; s++ )
      {
        let r = onEach.call( src, src[ s ], s, src );
        if( _.unrollIs( r ) )
        {
          _.longBut_( result, d, r );
          d += r.length;
        }
        else if( r !== undefined )
        {
          result[ d ] = r;
          d += 1;
        }
      }
    }
    else if( _.aux.is( src ) )
    {
      if( dst === null )
      result = _.entity.makeUndefined( src );
      else
      _.assert( _.aux.is( dst ), '{-dst-} container should be map like' );

      for( let s in src )
      {
        let r = onEach.call( src, src[ s ], s, src );
        if( r !== undefined )
        result[ s ] = r;
      }
    }
    else
    {
      let r = onEach.call( null, src, null, null );

      if( r !== undefined )
      {
        if( _.longIs( dst ) )
        result = _.arrayAppendElement( dst, r );
        else if( _.aux.is( dst ) )
        result = _.props.extend( dst, r );
        else if( _.primitive.is( dst ) )
        result = r;
        else
        _.assert( 0, 'Not clear how to add result in destination container {-dst-}' );
      }
    }

  }

  return result;
}

//

function entityFirst( src, onEach )
{
  let result;

  onEach = _._filter_functor( onEach, 1 );

  _.assert( arguments.length === 2 );
  _.assert( _.routine.is( onEach ) );

  /* */

  if( _.longIs( src ) )
  {

    /* qqq for junior : add branch for countable case */
    for( let s = 0 ; s < src.length ; s++ )
    {
      let r = onEach.call( src, src[ s ], s, src );
      if( r !== undefined )
      return r;
    }

  }
  else if( _.aux.is( src ) )
  {

    for( let s in src )
    {
      let r = onEach.call( src, src[ s ], s, src );
      if( r !== undefined )
      return r;
    }

  }
  else
  {

    result = onEach.call( null, src, null, null );

  }

  /* */

  return result;
}

//

function entityLast( src, onEach )
{
  let result;

  onEach = _._filter_functor( onEach, 1 );

  _.assert( arguments.length === 2 );
  _.assert( _.routine.is( onEach ) );
  // _.assert( src !== undefined, 'Expects src' );

  /* */

  if( _.longIs( src ) )
  {

    /* qqq for junior : add branch for countable case */
    for( let s = src.length - 1 ; s >= 0 ; s-- )
    {
      let r = onEach.call( src, src[ s ], s, src );
      if( r !== undefined )
      return r;
    }

  }
  else if( _.aux.is( src ) )
  {

    for( let s in src )
    {
      let r = onEach.call( src, src[ s ], s, src );
      if( r !== undefined )
      result = r;
    }

  }
  else
  {

    result = onEach.call( null, src, null, null );

  }

  /* */

  return result;
}

//

/**
 * The result of _most routine object.
 * @typedef {Object} wTools.entityMostResult
 * @property {Number} index - Index of found element.
 * @property {String|Number} key - If the search was on map, the value of this property sets to key of found element.
 * Else if search was on array - to index of found element.
 * @property {Number} value - The found result of onEvaluate, if onEvaluate don't set, this value will be same as element.
 * @property {Number} element - The appropriate element for found value.
 */

/**
 * Returns object( wTools.entityMostResult ) that contains min or max element of entity, it depends on( returnMax ).
 *
 * @param {ArrayLike|Object} src - Source entity.
 * @param {Function} onEvaluate  - ( onEach ) function is called for each element of( src ).If undefined routine uses it own function.
 * @param {Boolean} returnMax  - If true - routine returns maximum, else routine returns minimum value from entity.
 * @returns {wTools.entityMostResult} Object with result of search.
 *
 * @example
 * _._most([ 1, 3, 3, 9, 10 ], undefined, 0 );
 * // returns { index: 0, key: 0, value: 1, element: 1 }
 *
 * @example
 * _._most( [ 1, 3, 3, 9, 10 ], undefined, 1 );
 * // returns { index: 4, key: 4, value: 10, element: 10 }
 *
 * @example
 * _._most( { a : 1, b : 2, c : 3 }, undefined, 0 );
 * // returns { index: 4, key: 4, value: 10, element: 10 }
 *
 * @private
 * @function _most
 * @throws {Exception} If( arguments.length ) is not equal 3.
 * @throws {Exception} If( onEvaluate ) function is not implemented.
 * @namespace Tools
 */

//

function _most( o )
{
  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( _.mapIs( o ), 'Expect map, but got ' + _.entity.strType( o ) );
  _.routine.options( _most, o );

  if( !o.onEach )
  o.onEach = _most.defaults.onEach;

  if( !o.onEvaluate )
  {
    _.assert( o.returnMax !== null, 'o.returnMax should has value' );
    if( o.returnMax )
    o.onEvaluate = ( a, b ) => a - b > 0;
    else
    o.onEvaluate = ( a, b ) => b - a > 0;
  }

  _.assert( 1 <= o.onEach.length && o.onEach.length <= 3 );
  _.assert( o.onEvaluate.length === 1 || o.onEvaluate.length === 2 );

  let result = { index : -1, key : undefined, value : undefined, element : undefined };

  /* qqq for junior : add branch for countable case */
  if( _.longIs( o.src ) )
  {
    if( o.src.length === 0 )
    return result;

    let s = 0;
    if( o.onEvaluate.length === 1 )
    for( ; s < o.src.length; s++ )
    {
      let value = o.onEach( o.src[ s ], s, o.src );
      if( o.onEvaluate( value ) )
      {
        result.value = value;
        result.key = s;
        break;
      }
    }
    else
    {
      result.key = s;
      result.value = o.onEach( o.src[ s ], s, o.src );
    }

    /* qqq for junior : add branch for countable case */
    for( ; s < o.src.length; s++ )
    resultValue( o.src[ s ], s, o.src );
    result.index = result.key;
    result.element = o.src[ result.key ];
  }
  else if( _.aux.is( o.src ) )
  {
    let index = 0;
    if( o.onEvaluate.length === 1 )
    {
      for( let s in o.src )
      {
        if( result.value === undefined )
        {
          let value = o.onEach( o.src[ s ], s, o.src );
          if( o.onEvaluate( value ) )
          {
            result.value = value;
            result.index = index;
            result.key = s;
          }
        }
        else
        {
          if( resultValue( o.src[ s ], s, o.src ) )
          result.index = index;
        }

        index++;

      }
      result.element = o.src[ result.key ];
    }
    else
    {
      for( let s in o.src )
      {
        result.index = 0;
        result.key = s;
        result.value = o.onEach( o.src[ s ], s, o.src );
        break;
      }

      for( let s in o.src )
      {
        if( resultValue( o.src[ s ], s, o.src ) )
        result.index = index;

        index++;
      }
      result.element = o.src[ result.key ];
    }

  }
  else
  _.assert( 0 );

  return result;

  /* */

  function resultValue( e, k, s )
  {
    let value = o.onEach( e, k, s );
    if( o.onEvaluate.length === 1 )
    {
      if( o.onEvaluate( value ) === o.onEvaluate( result.value ) )
      {
        result.key = k;
        result.value = value;
        return true;
      }
    }
    else if( o.onEvaluate( value, result.value ) )
    {
      result.key = k;
      result.value = value;
      return true;
    }

    return false;
  }

}

_most.defaults =
{
  src : null,
  onEach : ( e ) => e,
  onEvaluate : null,
  returnMax : null
}

//

/**
 * Short-cut for _most() routine. Returns object( wTools.entityMostResult ) with smallest value from( src ).
 *
 * @param {ArrayLike|Object} src - Source entity.
 * @param {Function} onEvaluate  - ( onEach ) function is called for each element of( src ).If undefined routine uses it own function.
 * @returns {wTools.entityMostResult} Object with result of search.
 *
 * @example
 *  let obj = { a : 25, b : 16, c : 9 };
 *  _.entityMin( obj, Math.sqrt );
 *  // returns { index : 2, key : 'c', value 3: , element : 9  };
 *
 * @see wTools.onEach
 * @see wTools.entityMostResult
 * @function entityMin
 * @throws {Exception} If missed arguments.
 * @throws {Exception} If passed extra arguments.
 * @namespace Tools
 */

function entityMin( src, onEach )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return _most
  ({
    src,
    onEach : onEach || null,
    returnMax : 0
  });
}

//

/**
 * Short-cut for _most() routine. Returns object( wTools.entityMostResult ) with biggest value from( src ).
 *
 * @param {ArrayLike|Object} src - Source entity.
 * @param {Function} onEvaluate  - ( onEach ) function is called for each element of( src ).If undefined routine uses it own function.
 * @returns {wTools.entityMostResult} Object with result of search.
 *
 * @example
 *  let obj = { a: 25, b: 16, c: 9 };
 *  _.entityMax( obj );
 *  // returns { index: 0, key: "a", value: 25, element: 25 };
 *
 * @see wTools.onEach
 * @see wTools.entityMostResult
 * @function entityMax
 * @throws {Exception} If missed arguments.
 * @throws {Exception} If passed extra arguments.
 * @namespace Tools
 */

function entityMax( src, onEach )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return _most
  ({
    src,
    onEach : onEach || null,
    returnMax : 1
  });
}

// --
// extension
// --

let ContainerExtension =
{

  // scalar

  scalarAppend,
  scalarPrepend,
  scalarAppendOnce,
  scalarPrependOnce,

  scalarToVector,
  scalarFrom,
  scalarFromOrNull,

  // multiplier

  dup,
  multiple,
  multipleAll,

  // entity iterator

  each : entityEach,
  eachOwn : entityEachOwn,

  /* qqq : for Dmytro : implementations with dst-null convention? */
  only : entityOnly,
  but : entityBut,
  and : entityAnd,
  or : entityOr,
  xor : entityXor,

  all : entityAll,
  any : entityAny,
  none : entityNone,

  _filter_functor,

  map_,
  filter_,
  first : entityFirst,
  last : entityLast,

  //

  _most,
  min : entityMin,
  max : entityMax,

}

_.props.supplement( _.container, ContainerExtension );

//

let ToolsExtension =
{

  // scalar

  scalarAppend,
  scalarPrepend,
  scalarAppendOnce,
  scalarPrependOnce,

  scalarToVector,
  scalarFrom,
  scalarFromOrNull,

  // multiplier

  dup,
  multiple,
  multipleAll,

  // entity iterator

  entityEach,
  each : entityEach,
  entityEachOwn,
  eachOwn : entityEachOwn,

  // entityEachKey,
  // eachKey : entityEachKey,

  entityOnly,
  only : entityOnly,
  entityBut,
  but : entityBut,
  entityAnd,
  and : entityAnd,
  entityOr,
  or : entityOr,
  entityXor,
  xor : entityXor,

  entityAll,
  all : entityAll,
  entityAny,
  any : entityAny,
  entityNone,
  none : entityNone,

  _filter_functor,

  // entityMap,
  // map : entityMap,/* !!! : use instead of entityMap */
  // container.map_,
  // map_,
  // entityFilter,
  // filter : entityFilter, /* !!! : use instead of entityFilter */
  // container.filter_,
  filter_,
  // entityFirst,
  // first : entityFirst,
  // entityLast,
  // last : entityLast,

  //

  _most,
  _entityMost : _most,
  entityMin,
  min : entityMin,
  entityMax,
  max : entityMax,

}

_.props.supplement( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Functional.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Functional_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Functional_s */ })();

/* */  /* begin of file Fuzzy_s */ ( function Fuzzy_s() { function Fuzzy_s_naked() { ( function _l5_Fuzzy_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.fuzzy = _.fuzzy || Object.create( null );

// --
// fuzzy
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( _, ToolsExtension );
Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Fuzzy.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Fuzzy_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Fuzzy_s */ })();

/* */  /* begin of file Global_s */ ( function Global_s() { function Global_s_naked() { ( function _l5_Global_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.global = _.global || Object.create( null );
const __ = _realGlobal_.wTools;
__.global = __.global || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{

}

//

_.props.supplement( _.global, Extension );
_.props.supplement( __.global, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Global.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Global_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Global_s */ })();

/* */  /* begin of file HashMap_s */ ( function HashMap_s() { function HashMap_s_naked() { ( function _l5_HashMap_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function extend( dst, src )
{
  _.assert( arguments.length === 2 );
  _.assert( dst === null || _.hashMap.like( dst ) || _.aux.is( dst ) );
  _.assert( _.hashMapLike( src ) || _.aux.is( src ) );

  if( dst === null )
  dst = new HashMap;

  if( dst === src )
  return dst;

  if( _.hashMap.like( dst ) )
  {
    if( _.hashMapLike( src ) )
    {
      for( let [ k, e ] of src )
      dst.set( k, e );
    }
    else
    {
      for( let k in src )
      {
        dst.set( k, src[ k ] );
      }
    }
  }
  else
  {
    if( _.hashMap.like( src ) )
    {
      for( let [ k, e ] of src )
      {
        _.assert( _.strIs( k ) );
        dst[ k ] = e;
      }
    }
    else
    {
      for( let k in src )
      {
        dst[ k ] = src[ k ];
      }
    }
  }

  return dst;
}

// //
//
// function fromMap( dstMap, srcMap )
// {
//   if( arguments.length === 1 )
//   {
//     srcMap = arguments[ 0 ];
//     dstMap = null;
//   }
//
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   _.assert( !_.primitive.is( srcMap ) );
//   _.assert( dstMap === null || _.hashMapIs( dstMap ) );
//
//   if( dstMap === null )
//   dstMap = new HashMap;
//
//   for( let k in srcMap )
//   {
//     dstMap.set( k, srcMap[ k ] );
//   }
//
//   return dstMap;
// }

// --
// extension
// --

let ToolsExtension =
{
  hashMapExtend : extend,
}

//

let Extension =
{

  extend, /* qqq : cover */
  // fromMap, /* qqq : cover */

}

Object.assign( _, ToolsExtension );
Object.assign( _.hashMap, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/HashMap.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, HashMap_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file HashMap_s */ })();

/* */  /* begin of file Interval_s */ ( function Interval_s() { function Interval_s_naked() { ( function _l5_Interval_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _global_.wTools;

// --
// range
// --

// --
// implementation
// --

let Extension =
{
}

//

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Interval.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Interval_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Interval_s */ })();

/* */  /* begin of file Intervalc_s */ ( function Intervalc_s() { function Intervalc_s_naked() { ( function _l5_Intervalc_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// dichotomy
// --

function isEmpty( cinterval )
{
  _.assert( arguments.length === 1 );
  if( !_.intervalIs( cinterval ) )
  return false;
  return cinterval[ 0 ] === cinterval[ 1 ] + 1;
}

//

function isPopulated( cinterval )
{
  _.assert( arguments.length === 1 );
  if( !_.intervalIs( cinterval ) )
  return false;
  return cinterval[ 0 ] !== cinterval[ 1 ] + 1;
}

//

function has( cinterval, src )
{

  // if( _.longIs( src ) )
  // src = src.length;

  _.assert( arguments.length === 2 );
  _.assert( _.intervalIs( cinterval ) );
  // _.assert( _.number.is( src ) || _.intervalIs( src ) );

  if( _.intervalIs( src ) )
  {
    if( src[ 0 ] < cinterval[ 0 ] )
    return false;
    if( src[ 1 ] > cinterval[ 1 ] )
    return false;
  }
  else if( _.number.is( src ) )
  {
    if( src < cinterval[ 0 ] )
    return false;
    if( src > cinterval[ 1 ] )
    return false;
  }
  else
  {
    _.assert( 0, 'Expects number or interval {-src-}.' );
  }

  return true;
}

//

// function inInclusive( cinterval, srcNumber )
// {
//
//   if( _.longIs( srcNumber ) )
//   srcNumber = srcNumber.length;
//
//   _.assert( arguments.length === 2 );
//   _.assert( _.intervalIs( cinterval ) );
//   _.assert( _.number.is( srcNumber ) );
//
//   if( srcNumber < cinterval[ 0 ] )
//   return false;
//   if( srcNumber >= cinterval[ 1 ] + 1 )
//   return false;
//
//   return true;
// }
//
// //
//
// function inExclusive( cinterval, srcNumber )
// {
//   if( _.longIs( srcNumber ) )
//   srcNumber = srcNumber.length;
//
//   _.assert( arguments.length === 2 );
//   _.assert( _.intervalIs( cinterval ) );
//   _.assert( _.number.is( srcNumber ) );
//
//   if( srcNumber <= cinterval[ 0 ] )
//   return false;
//   if( srcNumber > cinterval[ 1 ] + 1 )
//   return false;
//
//   return true;
// }
//
// //
//
// function inInclusiveLeft( cinterval, srcNumber )
// {
//   if( _.longIs( srcNumber ) )
//   srcNumber = srcNumber.length;
//
//   _.assert( arguments.length === 2 );
//   _.assert( _.intervalIs( cinterval ) );
//   _.assert( _.number.is( srcNumber ) );
//
//   if( srcNumber < cinterval[ 0 ] )
//   return false;
//   if( srcNumber >= cinterval[ 1 ] + 1 )
//   return false;
//
//   return true;
// }
//
// //
//
// function inInclusiveRight( cinterval, srcNumber )
// {
//   if( _.longIs( srcNumber ) )
//   srcNumber = srcNumber.length;
//
//   _.assert( arguments.length === 2 );
//   _.assert( _.intervalIs( cinterval ) );
//   _.assert( _.number.is( srcNumber ) );
//
//   if( srcNumber < cinterval[ 0 ] )
//   return false;
//   if( srcNumber >= cinterval[ 1 ] + 1 )
//   return false;
//
//   return true;
// }

//

function sureIn( src, cinterval )
{
  _.assert( arguments.length >= 2 );
  if( _.longIs( src ) )
  src = src.length;
  // let args = _.unroll.from
  // ([
  //   _.cinterval.has( cinterval, src ),
  //   () => 'Out of cinterval' + _.rangeToStr( cinterval ), _.unrollSelect( arguments, 2 )
  // ]);
  // debugger
  let args =
  [
    _.cinterval.has( cinterval, src )
    ,() => 'Out of cinterval' + _.rangeToStr( cinterval )
    , Array.prototype.slice.call( arguments, 2 )
  ];
  _.sure.apply( _, args );
  return true;
}

//

function assertIn( src, cinterval )
{
  _.assert( arguments.length >= 2 );
  if( _.longIs( src ) )
  src = src.length;
  let args =
  [
    _.cinterval.has( cinterval, src )
    ,() => 'Out of cinterval' + _.rangeToStr( cinterval )
    , Array.prototype.slice.call( arguments, 2 )
  ];
  // let args = _.unroll.from
  // ([
  //   _.cinterval.has( cinterval, src ),
  //   () => 'Out of cinterval' + _.rangeToStr( cinterval ), _.unrollSelect( arguments, 2 )
  // ]);
  _.assert.apply( _, args );
  return true;
}

// --
// maker
// --

function fromLeft( cinterval )
{
  _.assert( arguments.length === 1 );

  if( _.number.is( cinterval ) )
  return [ cinterval, Infinity ];

  _.assert( _.longIs( cinterval ) );

  if( cinterval.length === 1 )
  cinterval = [ cinterval[ 0 ], Infinity ];
  else
  _.assert( cinterval.length === 2 );

  if( !_.number.is( cinterval[ 0 ] ) )
  {
    _.assert( cinterval[ 0 ] === undefined );
    cinterval[ 0 ] = 0;
  }
  if( !_.number.is( cinterval[ 1 ] ) )
  {
    _.assert( cinterval[ 1 ] === undefined );
    cinterval[ 1 ] = Infinity;
  }

  return cinterval;
}

//

function fromRight( cinterval )
{
  _.assert( arguments.length === 1 );

  if( _.number.is( cinterval ) )
  return [ 0, cinterval ];

  _.assert( _.longIs( cinterval ) );

  if( cinterval.length === 1 )
  cinterval = [ cinterval[ 0 ], Infinity ];
  else
  _.assert( cinterval.length === 2 );

  if( !_.number.is( cinterval[ 0 ] ) )
  {
    _.assert( cinterval[ 0 ] === undefined );
    cinterval[ 0 ] = 0;
  }
  if( !_.number.is( cinterval[ 1 ] ) )
  {
    _.assert( cinterval[ 1 ] === undefined );
    cinterval[ 1 ] = Infinity;
  }

  return cinterval;
}

//

function fromSingle( cinterval )
{
  _.assert( arguments.length === 1 );

  if( _.number.is( cinterval ) )
  return [ cinterval, cinterval ];

  _.assert( _.longIs( cinterval ) );
  _.assert( cinterval.length === 1 || cinterval.length === 2 );

  if( cinterval[ 0 ] === undefined )
  {
    if( cinterval[ 1 ] === undefined )
    return [ 0, 0 ];

    _.assert( _.number.is( cinterval[ 1 ] ) );
    return [ cinterval[ 1 ], cinterval[ 1 ] ];
  }

  _.assert( _.number.is( cinterval[ 0 ] ) );

  if( cinterval[ 1 ] === undefined )
  return [ cinterval[ 0 ], cinterval[ 0 ] ];

  _.assert( _.number.is( cinterval[ 1 ] ) );

  return cinterval;
}

//

function clamp( dstRange, clampRange )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.intervalIs( dstRange ) );

  if( _.number.is( clampRange ) )
  {
    dstRange[ 0 ] = clampRange;
    dstRange[ 1 ] = clampRange;
  }
  else
  {
    _.assert( _.intervalIs( clampRange ) );

    if( dstRange[ 0 ] < clampRange[ 0 ] )
    dstRange[ 0 ] = clampRange[ 0 ];
    else if( dstRange[ 0 ] > clampRange[ 1 ] )
    dstRange[ 0 ] = clampRange[ 1 ];

    if( dstRange[ 1 ] < clampRange[ 0 ] )
    dstRange[ 1 ] = clampRange[ 0 ];
    else if( dstRange[ 1 ] > clampRange[ 1 ] )
    dstRange[ 1 ] = clampRange[ 1 ];
  }

  return dstRange;
}

//

function countElements( cinterval, increment )
{

  _.assert( _.intervalIs( cinterval ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( increment === undefined )
  increment = 1;

  _.assert( _.number.is( increment ), 'Increment should has a number value' );

  if( increment )
  {
    let result = ( cinterval[ 1 ] - cinterval[ 0 ] + 1 ) / increment;
    if( result > 0 )
    {
      if( result < 1 )
      return 1;
      return Math.floor( result );
    }
    else if( result < 0 )
    {
      if( result > -1 )
      return -1;
      return Math.ceil( result );
    }
  }

  return 0;
}

//

// function firstGet( cinterval, options )
function firstGet( cinterval )
{

  _.assert( arguments.length === 1 );

  // _.assert( arguments.length === 1 || arguments.length === 2 );
  // if( options )
  // {
  //   _.assert( _.aux.is( options ) );
  //   if( options.increment === undefined )
  //   options.increment = 1;
  // }

  if( _.longIs( cinterval ) )
  {
    _.assert( _.intervalIs( cinterval ) );
    return cinterval[ 0 ];
  }
  else if( _.mapIs( cinterval ) ) /* xxx : remove? */
  {
    return cinterval.first;
  }
  _.assert( 0, 'unexpected type of cinterval', _.entity.strType( cinterval ) );
}

//

// function lastGet( cinterval, options )
function lastGet( cinterval )
{

  _.assert( arguments.length === 1 );

  // _.assert( arguments.length === 1 || arguments.length === 2 );
  // if( options )
  // {
  //   _.assert( _.object.like( options ) );
  //   if( options.increment === undefined )
  //   options.increment = 1;
  // }

  if( _.longIs( cinterval ) )
  {
    _.assert( _.intervalIs( cinterval ) );
    return cinterval[ 1 ];
  }
  else if( _.mapIs( cinterval ) )
  {
    return cinterval.last;
  }
  _.assert( 0, 'unexpected type of cinterval', _.entity.strType( cinterval ) );

}

//

function toStr( range )
{
  _.assert( _.intervalIs( range ) );
  _.assert( arguments.length === 1 );
  return range[ 0 ] + '..' + range[ 1 ];
}

// --
// define
// --

class Crange
{
  static[ Symbol.hasInstance ]( instance )
  {
    return is( instance );
  }
}

let Handler =
{
  construct( original, args )
  {
    return Crange.fromLeft( ... args );
  }
};

const Self = new Proxy( Crange, Handler );
Self.original = Crange;

// --
// implementation
// --

let Extension =
{

  // dichotomy

  is : _.intervalIs,
  isValid : _.intervalIsValid,
  defined : _.intervalIsValid,
  isEmpty,
  isPopulated,

  // inInclusive,
  // inExclusive,
  // inInclusiveLeft,
  // inInclusiveRight,
  // has : inInclusiveLeft,
  has,

  sureIn,
  assertIn,

  // maker

  fromLeft,
  fromRight,
  fromSingle,

  clamp,
  countElements,
  firstGet,
  lastGet,

  toStr,

}

//

_.props.supplement( Self, Extension );
_.assert( _.cinterval !== undefined );
_.props.supplement( Self, _.cinterval );
_.cinterval = Self;

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Intervalc.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervalc_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervalc_s */ })();

/* */  /* begin of file Intervall_s */ ( function Intervall_s() { function Intervall_s_naked() { ( function _l5_Intervall_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// dichotomy
// --

function isEmpty( linterval )
{
  _.assert( arguments.length === 1 );
  if( !_.intervalIs( linterval ) )
  return false;
  return linterval[ 1 ] === 0;
}

//

function isPopulated( linterval )
{
  _.assert( arguments.length === 1 );
  if( !_.intervalIs( linterval ) )
  return false;
  return linterval[ 1 ] !== 0;
}

//

function has( linterval, src )
{
  _.assert( arguments.length === 2 );
  _.assert( _.intervalIs( linterval ) );

  if( _.intervalIs( src ) )
  {
    if( src[ 0 ] < linterval[ 0 ] )
    return false;
    if( src[ 1 ] > linterval[ 1 ] )
    return false;
  }
  else if( _.number.is( src ) )
  {
    if( src < linterval[ 0 ] )
    return false;
    if( src > linterval[ 0 ] + linterval[ 1 ] )
    return false;
  }
  else
  {
    _.assert( 0, 'Expects interval or number {-src-}.' );
  }

  return true;
}

//

function sureIn( src, linterval )
{
  _.assert( arguments.length >= 2 );
  if( _.longIs( src ) )
  src = src.length;
  // let args = _.unroll.from([ _.linterval.has( linterval, src ), () => 'Out of linterval' + _.rangeToStr( linterval ), _.unrollSelect( arguments, 2 ) ]);
  // debugger;
  let args =
  [
    _.linterval.has( linterval, src )
    ,() => 'Out of linterval' + _.rangeToStr( linterval )
    , Array.prototype.slice.call( arguments, 2 )
  ];
  _.sure.apply( _, args );
  return true;
}

//

function assertIn( src, linterval )
{
  _.assert( arguments.length >= 2 );
  if( _.longIs( src ) )
  src = src.length;
  // let args = _.unroll.from([ _.linterval.has( linterval, src ), () => 'Out of linterval' + _.rangeToStr( linterval ), _.unrollSelect( arguments, 2 ) ]);
  // debugger;
  let args =
  [
    _.linterval.has( linterval, src )
    ,() => 'Out of linterval' + _.rangeToStr( linterval )
    , Array.prototype.slice.call( arguments, 2 )
  ];
  _.assert.apply( _, args );
  return true;
}

// --
// maker
// --

function fromSingle( linterval )
{
  _.assert( arguments.length === 1 );

  if( _.number.is( linterval ) )
  return [ linterval, 1 ];

  _.assert( _.longIs( linterval ) );
  _.assert( linterval.length === 1 || linterval.length === 2 );

  if( linterval[ 0 ] === undefined )
  {
    if( linterval[ 1 ] === undefined )
    return [ 0, 1 ];

    _.assert( linterval[ 1 ] === 1, 'Expects length of 1' );
    return [ 0, 1 ];
  }

  _.assert( _.number.is( linterval[ 0 ] ) );

  if( linterval[ 1 ] === undefined )
  return [ linterval[ 0 ], 1 ];

  _.assert( _.number.is( linterval[ 1 ] ) );

  return linterval;
}

//

function clamp( dstRange, clampRange )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.intervalIs( dstRange ) );

  if( _.number.is( clampRange ) )
  {
    dstRange[ 0 ] = clampRange;
    dstRange[ 1 ] = 0;
  }
  else
  {
    _.assert( _.intervalIs( clampRange ) );

    if( dstRange[ 0 ] < 0 )
    dstRange[ 0 ] = 0;
    else if( dstRange[ 0 ] > clampRange[ 0 ] )
    dstRange[ 0 ] = clampRange[ 0 ];

    if( dstRange[ 1 ] < 0 )
    dstRange[ 1 ] = 0;
    else if( dstRange[ 1 ] > clampRange[ 1 ] )
    dstRange[ 1 ] = clampRange[ 1 ];
  }

  return dstRange;
}

//

function countElements( linterval, increment )
{

  _.assert( _.intervalIs( linterval ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( increment === undefined )
  increment = 1;

  _.assert( _.number.is( increment ), 'Increment should has a number value' );

  if( increment )
  {
    let result = linterval[ 1 ] / increment;
    if( result > 0 )
    {
      if( result < 1 )
      return 1;
      return Math.floor( result );
    }
    else if( result < 0 )
    {
      if( result > -1 )
      return -1;
      return Math.ceil( result );
    }
  }

  return 0;
}

//

function lastGet( linterval, options )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );

  // options = options || Object.create( null ); /* Dmytro : I don't know why routine makes this side effect */
  // if( options.increment === undefined )       /* The creating of new map has no sense, improved below */
  // options.increment = 1;

  if( options )
  {
    _.assert( _.object.like( options ) );
    if( options.increment === undefined )
    options.increment = 1;
  }

  if( _.longIs( linterval ) )
  {
    _.assert( _.intervalIs( linterval ) );
    return linterval[ 0 ] + linterval[ 1 ] - 1;
  }
  else if( _.mapIs( linterval ) )
  {
    return linterval.last;
  }
  _.assert( 0, 'unexpected type of linterval', _.entity.strType( linterval ) );

}

// --
// define
// --

class Lrange
{
  static[ Symbol.hasInstance ]( instance )
  {
    return is( instance );
  }
}

let Handler =
{
  construct( original, args )
  {
    return Lrange.fromLeft( ... args );
  }
};

const Self = new Proxy( Lrange, Handler );
Self.original = Lrange;

// --
// implementation
// --

let Extension =
{

  // dichotomy

  is : _.intervalIs,
  isValid : _.intervalIsValid,
  defined : _.intervalIsValid,
  isEmpty,
  isPopulated,

  has,

  sureIn,
  assertIn,

  // maker

  fromLeft : _.cinterval.fromLeft,
  fromRight : _.cinterval.fromRight,
  fromSingle,

  clamp,
  countElements,
  firstGet : _.cinterval.firstGet,
  lastGet,

  toStr : _.cinterval.toStr,

}

//

_.props.supplement( Self, Extension );
_.assert( _.linterval !== undefined );
_.props.supplement( Self, _.linterval );
_.linterval = Self;

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Intervall.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervall_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervall_s */ })();

/* */  /* begin of file Intervalo_s */ ( function Intervalo_s() { function Intervalo_s_naked() { ( function _l5_Intervalo_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// dichotomy
// --

function isEmpty( ointerval )
{
  _.assert( arguments.length === 1 );
  if( !_.intervalIs( ointerval ) )
  return false;
  return ointerval[ 0 ] === ointerval[ 1 ];
}

//

function isPopulated( ointerval )
{
  _.assert( arguments.length === 1 );
  if( !_.intervalIs( ointerval ) )
  return false;
  return ointerval[ 0 ] !== ointerval[ 1 ];
}

//

function has( ointerval, src )
{
  _.assert( arguments.length === 2 );
  _.assert( _.intervalIs( ointerval ) );

  if( _.intervalIs( src ) )
  {
    if( src[ 0 ] < ointerval[ 0 ] )
    return false;
    if( src[ 1 ] > ointerval[ 1 ] )
    return false;
  }
  else if( _.number.is( src ) )
  {
    if( src < ointerval[ 0 ] )
    return false;
    if( src >= ointerval[ 1 ] )
    return false;
  }
  else
  {
    _.assert( 0, 'Expects interval or number {-src-}.' );
  }

  return true;
}

//

function sureIn( src, ointerval )
{
  _.assert( arguments.length >= 2 );
  if( _.longIs( src ) )
  src = src.length;
  // let args = _.unroll.from([ _.ointerval.has( ointerval, src ), () => 'Out of ointerval' + _.rangeToStr( ointerval ), _.unrollSelect( arguments, 2 ) ]);
  // debugger;
  let args =
  [
    _.ointerval.has( ointerval, src )
    ,() => 'Out of ointerval' + _.rangeToStr( ointerval )
    , Array.prototype.slice.call( arguments, 2 )
  ];
  _.sure.apply( _, args );
  return true;
}

//

function assertIn( src, ointerval )
{
  _.assert( arguments.length >= 2 );
  if( _.longIs( src ) )
  src = src.length;
  // let args = _.unroll.from([ _.ointerval.has( ointerval, src ), () => 'Out of ointerval' + _.rangeToStr( ointerval ), _.unrollSelect( arguments, 2 ) ]);
  // debugger;
  let args =
  [
    _.ointerval.has( ointerval, src )
    ,() => 'Out of ointerval' + _.rangeToStr( ointerval )
    , Array.prototype.slice.call( arguments, 2 )
  ];
  _.assert.apply( _, args );
  return true;
}

// --
// maker
// --

function fromSingle( ointerval )
{
  _.assert( arguments.length === 1 );

  if( _.number.is( ointerval ) )
  return [ ointerval, ointerval + 1 ];

  _.assert( _.longIs( ointerval ) );
  _.assert( ointerval.length === 1 || ointerval.length === 2 );

  if( ointerval[ 0 ] === undefined )
  {
    if( ointerval[ 1 ] === undefined )
    return [ 0, 1 ];

    _.assert( _.number.is( ointerval[ 1 ] ) );
    return [ ointerval[ 1 ] - 1, ointerval[ 1 ] ];
  }

  _.assert( _.number.is( ointerval[ 0 ] ) );

  if( ointerval[ 1 ] === undefined )
  return [ ointerval[ 0 ], ointerval[ 0 ] + 1 ];

  _.assert( _.number.is( ointerval[ 1 ] ) );

  return ointerval;
}

//

function clamp( dstRange, clampRange )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.intervalIs( dstRange ) );

  if( _.number.is( clampRange ) )
  {
    dstRange[ 0 ] = clampRange;
    dstRange[ 1 ] = clampRange;
  }
  else
  {
    _.assert( _.intervalIs( clampRange ) );

    if( dstRange[ 0 ] < clampRange[ 0 ] )
    dstRange[ 0 ] = clampRange[ 0 ];
    else if( dstRange[ 0 ] > clampRange[ 1 ] )
    dstRange[ 0 ] = clampRange[ 1 ];

    if( dstRange[ 1 ] < clampRange[ 0 ] )
    dstRange[ 1 ] = clampRange[ 0 ];
    else if( dstRange[ 1 ] > clampRange[ 1 ] )
    dstRange[ 1 ] = clampRange[ 1 ];
  }

  return dstRange;
}

//

function countElements( ointerval, increment )
{

  _.assert( _.intervalIs( ointerval ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( increment === undefined )
  increment = 1;

  _.assert( _.number.is( increment ), 'Increment should has a number value' );

  if( increment )
  {
    let result = ( ointerval[ 1 ] - ointerval[ 0 ] ) / increment;
    if( result > 0 )
    {
      if( result < 1 )
      return 1;
      return Math.floor( result );
    }
    else if( result < 0 )
    {
      if( result > -1 )
      return -1;
      return Math.ceil( result );
    }
  }

  return 0;
}

//

function lastGet( ointerval, options )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );

  // options = options || Object.create( null ); /* Dmytro : I don't know why routine makes this side effect */
  // if( options.increment === undefined )       /* The creating of new map has no sense, improved below */
  // options.increment = 1;

  if( options )
  {
    _.assert( _.object.like( options ) );
    if( options.increment === undefined )
    options.increment = 1;
  }

  if( _.longIs( ointerval ) )
  {
    _.assert( _.intervalIs( ointerval ) );
    return ointerval[ 1 ] - 1;
  }
  else if( _.mapIs( ointerval ) )
  {
    return ointerval.last;
  }
  _.assert( 0, 'unexpected type of ointerval', _.entity.strType( ointerval ) );

}

// --
// define
// --

class Orange
{
  static[ Symbol.hasInstance ]( instance )
  {
    return is( instance );
  }
}

let Handler =
{
  construct( original, args )
  {
    return Orange.fromLeft( ... args );
  }
};

const Self = new Proxy( Orange, Handler );
Self.original = Orange;

// --
// implementation
// --

let Extension =
{

  // dichotomy

  is : _.intervalIs,
  isValid : _.intervalIsValid,
  defined : _.intervalIsValid,
  isEmpty,
  isPopulated,

  has,

  sureIn,
  assertIn,

  // maker

  fromLeft : _.cinterval.fromLeft,
  fromRight : _.cinterval.fromRight,
  fromSingle,

  clamp,
  countElements,
  firstGet : _.cinterval.firstGet,
  lastGet,

  toStr : _.cinterval.toStr,

}

//

_.props.supplement( Self, Extension );
_.assert( _.ointerval !== undefined );
_.props.supplement( Self, _.ointerval );
_.ointerval = Self;
// _.assert( _.auxIs( _.ointerval ) ); /* xxx : uncomment? */

/* xxx : qqq : for Dmytro : bad : [ 1, 3 ] instanceof _.ointerval is not covered and does not work! */

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Intervalo.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervalo_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervalo_s */ })();

/* */  /* begin of file Introspector_s */ ( function Introspector_s() { function Introspector_s_naked() { ( function _Introspector_s_()
{

'use strict';

const _global = _global_;
const _ = _global.wTools;
const Self = _.introspector = _.introspector || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

let Extension =
{
}

_.props.supplement( _.introspector, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Introspector.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Introspector_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Introspector_s */ })();

/* */  /* begin of file Itself_s */ ( function Itself_s() { function Itself_s_naked() { ( function _l5_Itself_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let ItselfExtension =
{
}

Object.assign( _.itself, ItselfExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Itself.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Itself_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Itself_s */ })();

/* */  /* begin of file Logic_s */ ( function Logic_s() { function Logic_s_naked() { ( function _l5_Logic_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// logic
// --

// --
// extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

//

let LogicExtension =
{
}

Object.assign( _.logic, LogicExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Logic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Logic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Logic_s */ })();

/* */  /* begin of file Long_s */ ( function Long_s() { function Long_s_naked() { ( function _l5_Long_s_()
{

'use strict';

const _ArrayIndexOf = Array.prototype.indexOf;
const _ArrayIncludes = Array.prototype.includes;
if( !_ArrayIncludes )
_ArrayIncludes = function( e ){ _ArrayIndexOf.call( this, e ) }

const _global = _global_;
const _ = _global_.wTools;

/*
               |  can grow   |  can shrink  |   range
grow                +                -         positive
only                -                +         positive
relength            +                +         positive
but                 -                +         negative
*/

/* array / long / buffer */
/* - / inplace */

// --
// long
// --

function _longMake_functor( onMake )
{

  _.assert( _.routine.is( onMake ) );

  return function _longMake( src, ins )
  {
    let result;

    /* */

    let length = ins;

    if( _.longLike( length ) )
    length = length.length;

    if( length === undefined || length === null )
    {
      if( src === null )
      {
        length = 0;
      }
      else if( _.longLike( src ) )
      {
        length = src.length;
      }
      else if( _.number.is( src ) )
      {
        length = src;
        src = null;
      }
      else if( _.routine.is( src ) )
      {
        length = 0;
      }
      else _.assert( 0 );
    }

    if( !length )
    length = 0;

    /* */

    if( ins === undefined || ins === null )
    {
      if( _.longLike( src ) )
      {
        if( ins === null )
        {
          ins = src;
        }
        else
        {
          ins = src;
          // src = null;
        }
      }
      else
      {
        ins = null;
      }
    }
    else if( !_.longLike( ins ) )
    {
      if( _.longIs( src ) )
      ins = src;
      else
      ins = null;
    }

    /**/

    let minLength;
    if( ins )
    minLength = Math.min( ins.length, length );
    else
    minLength = 0;

    /**/

    if( _.argumentsArray.is( src ) )
    src = null;

    let self = this;
    if( src === null )
    src = function( src )
    {
      return self.tools.long.default.make( src );
    };

    _.assert( arguments.length === 1 || arguments.length === 2 );
    _.assert( _.number.isFinite( length ) );
    _.assert( _.routine.is( src ) || _.longLike( src ), () => 'Expects long, but got ' + _.entity.strType( src ) );

    result = onMake.call( this, src, ins, length, minLength );

    _.assert( _.longLike( result ) );

    return result;
  }

}

//

/**
 * The routine longMake() returns a new Long with the same type as source Long {-src-}. New Long makes from inserted Long {-ins-}
 * or if {-ins-} is number, the Long makes from {-src-} with length equal to {-ins-}. If {-ins-} is not provided, routine  makes
 * container with default Long type. New Long contains {-src-} elements.
 *
 * @param { Long|Function|Null } src - Instance of Long or constructor, defines type of returned Long. If null is provided, routine returns
 * container with default Long type.
 * @param { Number|Long|Null } ins - Defines length of new Long. If Long is provided, routine makes new Long from {-ins-} with {-src-} type.
 * If null is provided, then routine makes container with default Long type.
 *
 * Note. Default Long type defines by descriptor {-longDescriptor-}. If descriptor not provided directly, then it is Array descriptor.
 *
 * @example
 * _.long.make();
 * // returns []
 *
 * @example
 * _.long.make( null );
 * // returns []
 *
 * @example
 * _.long.make( null, null );
 * // returns []
 *
 * @example
 * _.long.make( 3 );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * _.long.make( 3, null );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * _.long.make( [ 1, 2, 3, 4 ] );
 * // returns [ 1, 2, 3, 4 ];
 *
 * @example
 * _.long.make( [ 1, 2, 3, 4 ], null );
 * // returns [ 1, 2, 3, 4 ];
 *
 * @example
 * _.long.make( [ 1, 2 ], 4 );
 * // returns [ 1, 2, undefined, undefined ];
 *
 * @example
 * let got = _.long.make( _.unroll.make( [] ), [ 1, 2, 3 ] );
 * console.log( got );
 * // log [ 1, 2, 3 ];
 * console.log( _.unrollIs( got ) );
 * // log true
 *
 * @example
 * let got = _.long.make( new F32x( [ 1, 2, 3 ] ), 1 );
 * console.log( got );
 * // log Float32Array[ 1 ];
 *
 * @example
 * let got = _.long.make( Array, null );
 * console.log( got );
 * // log [];
 *
 * @example
 * let got = _.long.make( Array, 3 );
 * console.log( got );
 * // log [ undefined, undefined, undefined ];
 *
 * @returns { Long } - Returns a Long with type of source Long {-src-} which makes from {-ins-}. If {-ins-} is not
 * provided, then routine returns container with default Long type.
 * @function longMake
 * @throws { Error } If arguments.length is more then two.
 * @throws { Error } If {-src-} is not a Long, not a constructor, not null.
 * @throws { Error } If {-ins-} is not a number, not a Long, not null, not undefined.
 * @throws { Error } If {-ins-} or ins.length has a not finite value.
 * @namespace Tools
 */

/* aaa : extend coverage and documentation of longMake */
/* Dmytro : extended coverage and documentation of routine longMake */
/* aaa : longMake does not create unrolls, but should */
/* Dmytro : longMake creates unrolls */

// let longMake = _longMake_functor( function( /* src, ins, length, minLength */ )
// {
//   let src = arguments[ 0 ];
//   let ins = arguments[ 1 ];
//   let length = arguments[ 2 ];
//   let minLength = arguments[ 3 ];
//
//   let result;
//   if( _.routine.is( src ) )
//   {
//     if( ins && ins.length === length )
//     {
//       if( src === Array )
//       {
//         if( _.longLike( ins ) )
//         {
//           if( ins.length === 1 )
//           result = [ ins[ 0 ] ];
//           else if( !_.argumentsArray.like( ins ) )
//           result = new( _.constructorJoin( src, [ ... ins ] ) );
//           else
//           result = new( _.constructorJoin( src, ins ) );
//         }
//         else
//         {
//           result = new src( ins );
//         }
//       }
//       else
//       {
//         result = new src( ins );
//       }
//     }
//     else
//     {
//       result = new src( length );
//       // let minLength = Math.min( length, ins.length );
//       for( let i = 0 ; i < minLength ; i++ )
//       result[ i ] = ins[ i ];
//     }
//   }
//   else if( _.arrayIs( src ) )
//   {
//     _.assert( length >= 0 );
//     result = _.unrollIs( src ) ? _.unroll.make( length ) : new src.constructor( length );
//     // let minLength = Math.min( length, ins.length );
//     for( let i = 0 ; i < minLength ; i++ )
//     result[ i ] = ins[ i ];
//   }
//   else
//   {
//     if( ins && length === ins.length )
//     {
//       result = new src.constructor( ins );
//     }
//     else
//     {
//       result = new src.constructor( length );
//       // let minLength = Math.min( length, ins.length );
//       for( let i = 0 ; i < minLength ; i++ )
//       result[ i ] = ins[ i ];
//     }
//   }
//
//   return result;
// });

// function longMake( src, ins )
// {
//   let result;
//   let length = ins;
//
//   if( _.longLike( length ) )
//   length = length.length;
//
//   if( length === undefined )
//   {
//     if( src === null )
//     {
//       length = 0;
//     }
//     else if( _.longLike( src ) )
//     {
//       length = src.length;
//     }
//     else if( _.number.is( src ) )
//     {
//       length = src;
//       src = null;
//     }
//     else _.assert( 0 );
//   }
//
//   // if( !_.longLike( ins ) )
//   // {
//   //   if( _.longLike( src ) )
//   //   ins = src;
//   //   else
//   //   ins = [];
//   // }
//
//   if( !_.longLike( ins ) )
//   {
//     if( _.longLike( src ) )
//     {
//       ins = src;
//       src = null;
//     }
//     else
//     {
//       ins = [];
//     }
//   }
//
//   if( !length )
//   length = 0;
//
//   if( _.argumentsArray.is( src ) )
//   src = null;
//
//   if( src === null )
//   src = this.tools.long.default.make;
//
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   _.assert( _.number.isFinite( length ) );
//   _.assert( _.routine.is( src ) || _.longLike( src ), () => 'Expects long, but got ' + _.entity.strType( src ) );
//
//   if( _.routine.is( src ) )
//   {
//     if( ins.length === length )
//     {
//       if( src === Array )
//       {
//         if( _.longLike( ins ) )
//         {
//           if( ins.length === 1 )
//           result = [ ins[ 0 ] ];
//           else if( !_.argumentsArray.like( ins ) )
//           result = new( _.constructorJoin( src, [ ... ins ] ) );
//           else
//           result = new( _.constructorJoin( src, ins ) );
//         }
//         else
//         {
//           result = new src( ins );
//         }
//       }
//       else
//       {
//         result = new src( ins );
//       }
//     }
//     else
//     {
//       result = new src( length );
//       let minLen = Math.min( length, ins.length );
//       for( let i = 0 ; i < minLen ; i++ )
//       result[ i ] = ins[ i ];
//     }
//   }
//   else if( _.arrayIs( src ) )
//   {
//     if( length === ins.length )
//     {
//       result = _.unrollIs( src ) ? _.unroll.make( ins ) : new( _.constructorJoin( src.constructor, ins ) );
//     }
//     else
//     {
//       _.assert( length >= 0 );
//       result = _.unrollIs( src ) ? _.unroll.make( length ) : new src.constructor( length );
//       let minLen = Math.min( length, ins.length );
//       for( let i = 0 ; i < minLen ; i++ )
//       result[ i ] = ins[ i ];
//     }
//   }
//   else
//   {
//     if( length === ins.length )
//     {
//       result = new src.constructor( ins );
//     }
//     else
//     {
//       result = new src.constructor( length );
//       let minLen = Math.min( length, ins.length );
//       for( let i = 0 ; i < minLen ; i++ )
//       result[ i ] = ins[ i ];
//     }
//   }
//
//   _.assert( result instanceof this.tools.long.default.InstanceConstructor );
//   // _.assert( _.longLike( result ) );
//
//   return result;
// }

//

/* aaa : implement test */
/* Dmytro : implemented */

function longMakeEmpty( src )
{
  if( arguments.length === 0 )
  return this.tools.long.default.make( 0 );

  _.assert( arguments.length === 1 );

  if( _.unrollIs( src ) )
  {
    return _.unroll.make( 0 );
  }
  else if( src === null || _.argumentsArray.is( src ) )
  {
    return this.tools.long.default.make( 0 );
  }
  // else if( _.longLike( src ) )
  else if( _.vector.like( src ) )
  {
    return new src.constructor();
  }
  // else if( _.routine.is( src ) ) /* aaa : it was covered badly! */ /* Dmytro : coverage is extended */
  else if( _.routine.is( src.constructor ) )
  {
    let result = new src();
    // let result = new src.onstructor(); /* Dmytro : src is a class, it calls without constructor property */
    // _.assert( _.long.lengthOf( result ) === 0, 'Constructor should return empty long' );
    _.assert( result.length === 0, 'Constructor should return empty long' );
    return result;
  }
  _.assert( 0, `Unknown long subtype ${_.entity.strType( src )}` );
}

// function longMakeEmpty( src )
// {
//   let result;
//   let length = 0;
//
//   if( src === null )
//   src = [];
//
//   if( _.argumentsArray.is( src ) )
//   src = [];
//
//   _.assert( arguments.length === 1 );
//
//   result = new src.constructor();
//
//   _.assert( _.longIs( result ) );
//   _.assert( result.length === 0 );
//
//   return result;
// }

// //
//
// let _longMakeOfLength = _longMake_functor( function( /* src, ins, length, minLength */ )
// {
//   let src = arguments[ 0 ];
//   let ins = arguments[ 1 ];
//   let length = arguments[ 2 ];
//   let minLength = arguments[ 3 ];
//
//   let result;
//   if( _.routine.is( src ) )
//   {
//     result = new src( length );
//   }
//   else if( _.arrayIs( src ) )
//   {
//     if( length === src.length )
//     {
//       result = new( _.constructorJoin( src.constructor, src ) );
//     }
//     else if( length < src.length )
//     {
//       result = src.slice( 0, length );
//     }
//     else
//     {
//       result = new src.constructor( length );
//       for( let i = 0 ; i < minLength ; i++ )
//       result[ i ] = src[ i ];
//     }
//   }
//   else
//   {
//     if( length === src.length )
//     {
//       result = new src.constructor( ins );
//     }
//     else
//     {
//       result = new src.constructor( length );
//       for( let i = 0 ; i < minLength ; i++ )
//       result[ i ] = src[ i ];
//     }
//   }
//
//   return result;
// });

// function _longMakeOfLength( src, len )
// {
//   let result;
//
//   // if( src === null )
//   // src = [];
//
//   if( _.longLike( len ) )
//   len = len.length;
//
//   if( len === undefined )
//   {
//     if( src === null )
//     {
//       len = 0;
//     }
//     else if( _.longLike( src ) )
//     {
//       len = src.length;
//     }
//     else if( _.number.is( src ) )
//     {
//       len = src;
//       src = null;
//     }
//     else _.assert( 0 );
//   }
//
//   if( !len )
//   len = 0;
//
//   if( _.argumentsArray.is( src ) )
//   src = this.tools.long.default.name === 'ArgumentsArray' ? this.tools.long.default.make : this.tools.long.default.make( src );
//
//   if( src === null )
//   src = this.tools.long.default.make;
//
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   _.assert( _.number.isFinite( len ) );
//   _.assert( _.routine.is( src ) || _.longLike( src ), () => 'Expects long, but got ' + _.entity.strType( src ) );
//
//   if( _.routine.is( src ) )
//   {
//     result = new src( len );
//   }
//   else if( _.arrayIs( src ) )
//   {
//     if( len === src.length )
//     {
//       result = new( _.constructorJoin( src.constructor, src ) );
//     }
//     else if( len < src.length )
//     {
//       result = src.slice( 0, len );
//     }
//     else
//     {
//       result = new src.constructor( len );
//       let minLen = Math.min( len, src.length );
//       for( let i = 0 ; i < minLen ; i++ )
//       result[ i ] = src[ i ];
//     }
//   }
//   else
//   {
//     if( len === src.length )
//     {
//       result = new src.constructor( len );
//     }
//     else
//     {
//       result = new src.constructor( len );
//       let minLen = Math.min( len, src.length );
//       for( let i = 0 ; i < minLen ; i++ )
//       result[ i ] = src[ i ];
//     }
//   }
//
//   _.assert( _.longLike( result ), 'Instance should be a long' );
//
//   return result;
// }

//

/**
 * The routine longMakeUndefined() returns a new Long with the same type as source Long {-src-}. New Long has length equal to {-ins-}
 * argument. If {-ins-} is not provided, then new container has default Long type and length of source Long {-src-}.
 *
 * @param { Long|Function|Null } src - Long or constructor, defines type of returned Long. If null is provided, then routine returns
 * container with default Long type.
 * @param { Number|Long } ins - Defines length of new Long. If {-ins-} is Long, then routine makes new Long with length equal to ins.length.
 *
 * Note. Default Long type defines by descriptor {-longDescriptor-}. If descriptor not provided directly, then it is Array descriptor.
 *
 * @example
 * _.long.makeUndefined();
 * // returns []
 *
 * @example
 * _.long.makeUndefined( null );
 * // returns []
 *
 * @example
 * _.long.makeUndefined( null, null );
 * // returns []
 *
 * @example
 * _.long.makeUndefined( 3 );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * _.long.makeUndefined( 3, undefined );
 * // returns [ undefined, undefined, undefined ]
 *
 * @example
 * _.long.makeUndefined( [ 1, 2, 3, 4 ] );
 * // returns [ undefined, undefined, undefined, undefined ];
 *
 * @example
 * _.long.makeUndefined( [ 1, 2, 3, 4 ], null );
 * // returns [ undefined, undefined, undefined, undefined ];
 *
 * @example
 * _.long.makeUndefined( [ 1, 2, 3, 4 ], 2 );
 * // returns [ undefined, undefined ];
 *
 * @example
 * let got = _.long.makeUndefined( _.unroll.make( [] ), [ 1, 2, 3 ] );
 * console.log( got );
 * // log [ undefined, undefined, undefined ];
 * console.log( _.unrollIs( got ) );
 * // log true
 *
 * @example
 * let got = _.long.makeUndefined( new F32x( [ 1, 2, 3, 4 ] ), 2 );
 * console.log( got );
 * // log Float32Array[ undefined, undefined ];
 *
 * @example
 * let got = _.long.makeUndefined( Array, null );
 * console.log( got );
 * // log [];
 *
 * @example
 * let got = _.long.makeUndefined( Array, 3 );
 * console.log( got );
 * // log [ undefined, undefined, undefined ];
 *
 * @returns { Long } - Returns a Long with type of source Long {-src-} with a certain length defined by {-ins-}.
 * If {-ins-} is not defined, then routine returns container with default Long type. Length of the new container defines by {-src-}.
 * @function longMakeUndefined
 * @throws { Error } If arguments.length is more then two.
 * @throws { Error } If the {-src-} is not a Long, not a constructor, not null.
 * @throws { Error } If the {-ins-} is not a number, not a Long, not null, not undefined.
 * @throws { Error } If the {-ins-} or ins.length has a not finite value.
 * @namespace Tools
 */

/*
aaa : extend coverage and documentation of longMakeUndefined
Dmytro : extended coverage and documentation
aaa : longMakeUndefined does not create unrolls, but should
Dmytro : longMakeUndefined creates unrolls.
*/

// let longMakeUndefined = _longMake_functor( function( /* src, ins, length, minLength */ )
// {
//   let src = arguments[ 0 ];
//   let ins = arguments[ 1 ];
//   let length = arguments[ 2 ];
//   let minLength = arguments[ 3 ];
//
//   let result;
//   if( _.routine.is( src ) )
//   result = new src( length );
//   else if( _.unrollIs( src ) )
//   result = _.unroll.make( length );
//   else if( src === null )
//   result = this.tools.long.default.make( length );
//   else
//   result = new src.constructor( length );
//
//   return result;
// })

// function longMakeUndefined( ins, len )
// {
//   let result, length;
//
//   /* aaa3 : ask. use default long container */
//   /* Dmytro : explained, used this.tools.longDescriptor */
//   // if( ins === null )
//   // result = [];
//
//   if( len === undefined )
//   {
//     if( ins === null )
//     {
//       length = 0;
//     }
//     else if( _.number.is( ins ) )
//     {
//       length = ins;
//       ins = null;
//     }
//     else
//     {
//       length = ins.length;
//     }
//   }
//   else
//   {
//     if( _.longLike( len ) )
//     length = len.length;
//     else if( _.number.is( len ) )
//     length = len;
//     else _.assert( 0 );
//   }
//
//   if( _.argumentsArray.is( ins ) )
//   ins = null;
//
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   _.assert( _.number.isFinite( length ) );
//   _.assert( _.routine.is( ins ) || _.longLike( ins ) || ins === null, () => 'Expects long, but got ' + _.entity.strType( ins ) );
//
//   if( _.routine.is( ins ) )
//   result = new ins( length );
//   else if( _.unrollIs( ins ) )
//   result = _.unroll.make( length );
//   else if( ins === null ) /* aaa3 : ask */
//   result = this.tools.long.default.make( length );
//   else
//   result = new ins.constructor( length );
//
//   return result;
// }

//

/* aaa3 : teach to accept only length */
/* aaa3 : use default long type if type is not clear */
/* aaa3 : allow buffers which are long */
/* aaa3 : relevant to all routines longMake* of such kind */
/* Dmytro : all requirements implemented and covered */

// let longMakeZeroed = _longMake_functor( function( /* src, ins, length, minLength */ )
// {
//   let src = arguments[ 0 ];
//   let ins = arguments[ 1 ];
//   let length = arguments[ 2 ];
//   let minLength = arguments[ 3 ];
//
//   let result;
//   if( _.routine.is( src ) )
//   result = new src( length );
//   else if( _.unrollIs( src ) )
//   result = _.unroll.make( length );
//   else if( src === null )
//   result = this.tools.long.default.make( length );
//   else
//   result = new src.constructor( length );
//
//   if( !_.bufferTypedIs( result ) )
//   {
//     for( let i = 0 ; i < length ; i++ )
//     result[ i ] = 0;
//   }
//
//   return result;
// })

// function longMakeZeroed( ins, src )
// {
//   let result, length;
//
//   if( _.routine.is( ins ) )
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//
//   if( src === undefined )
//   {
//     length = ins.length;
//   }
//   else
//   {
//     if( _.longLike( src ) )
//     length = src.length;
//     else if( _.number.is( src ) )
//     length = src;
//     else _.assert( 0, 'Expects long or number as the second argument, got', _.entity.strType( src ) );
//   }
//
//   if( _.argumentsArray.is( ins ) )
//   ins = [];
//
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   _.assert( _.number.isFinite( length ) );
//   _.assert( _.routine.is( ins ) || _.longLike( ins ), () => 'Expects long, but got ' + _.entity.strType( ins ) );
//
//   if( _.routine.is( ins ) )
//   result = new ins( length );
//   else if( _.unrollIs( ins ) )
//   result = _.unroll.make( length );
//   else
//   result = new ins.constructor( length );
//
//   if( !_.bufferTypedIs( result ) )
//   for( let i = 0 ; i < length ; i++ )
//   result[ i ] = 0;
//
//   return result;
// }

function longMakeFilling( type, value, length )
{
  let result;

  // _.assert( arguments.length === 2 || arguments.length === 3 ); /* Dmytro : double check */

  if( arguments.length === 2 )
  {
    value = arguments[ 0 ];
    length = arguments[ 1 ];
    if( _.longIs( length ) )
    {
      if( _.argumentsArray.is( length ) )
      type = null;
      else
      type = length.constructor;
    }
    else
    {
      type = null;
    }
  }
  else if( arguments.length !== 3 )
  {
    _.assert( 0, 'Expects two or three arguments' );
  }

  /* Dmytro : missed */
  if( _.longIs( length ) )
  length = length.length;

  _.assert( value !== undefined );
  _.assert( _.number.is( length ) );
  _.assert( type === null || _.routine.is( type ) || _.longIs( type ) );

  result = this.long.make( type, length );
  for( let i = 0 ; i < length ; i++ )
  result[ i ] = value;

  return result;
}

//

/* aaa : add good coverage for longFrom. */
/* Dmytro : covered, two test routines implemented */

function longFrom( src )
{
  _.assert( arguments.length === 1 );
  if( src instanceof this.tools.long.default.InstanceConstructor )
  if( !_.unrollIs( src ) && _.longIs( src ) )
  return src;
  return this.longMake.call( this, src );
}

//

/**
 * The routine longFromCoercing() returns Long from provided argument {-src-}. The feature of routine is possibility of
 * converting an object-like {-src-} into Long. Also, routine longFromCoercing() converts string with number literals
 * to a Long.
 * If routine convert {-src-}, then result returns in container with default Long type.
 *
 * @param { Long|ObjectLike|String } src - An instance to convert into Long.
 * If {-src-} is a Long and it type is equal to current default Long type, then routine convert not {-src-}.
 *
 * Note. Default Long type defines by descriptor {-longDescriptor-}. If descriptor not provided directly, then it is Array descriptor.
 *
 * @example
 * let src = [ 3, 7, 13, 'abc', false, undefined, null, {} ];
 * let got = _.longFromCoercing( src );
 * // returns [ 3, 7, 13, 'abc', false, undefined, null, {} ]
 * console.log( got === src );
 * // log true
 *
 * @example
 * let src = _.argumentsArray.make( [ 3, 7, 13, 'abc', false, undefined, null, {} ] );
 * let got = _.longFromCoercing( src );
 * // returns [ 3, 7, 13, 'abc', false, undefined, null, {} ]
 * console.log( got === src );
 * // log false
 *
 * @example
 * let src = { a : 3, b : 7, c : 13 };
 * let got = _.longFromCoercing( src );
 * // returns [ [ 'a', 3 ], [ 'b', 7 ], [ 'c', 13 ] ]
 *
 * @example
 * let src = "3, 7, 13, 3.5abc, 5def, 7.5ghi, 13jkl";
 * let got = _.longFromCoercing( src );
 * // returns [ 3, 7, 13, 3.5, 5, 7.5, 13 ]
 *
 * @returns { Long } - Returns a Long. If {-src-} is Long with default Long type, then routine returns original {-src-}.
 * Otherwise, it makes new container with default Long type.
 * @function longFromCoercing
 * @throws { Error } If arguments.length is less or more then one.
 * @throws { Error } If {-src-} is not a Long, not an object-like, not a string.
 * @namespace Tools
 */

function longFromCoercing( src )
{

  _.assert( arguments.length === 1, 'Expects single argument' );

  if( this.long.default.InstanceConstructor )
  if( src instanceof this.long.default.InstanceConstructor && _.longIs( src ) )
  return src;

  /* Dmytro : this condition make recursive call with array from argumentsArray. But first condition return any long object
     ( ArgumentsArray.type is  Object ), and next make other long types without recursive call */
  // if( _.argumentsArray.is( src ) )
  // return this.longFromCoercing( Array.prototype.slice.call( src ) );

  if( _.longIs( src ) )
  return this.long.default.from( src );

  if( _.object.isBasic( src ) )
  return this.longFromCoercing( _.props.pairs( src ) );

  /* aaa : cover */
  /* Dmytro : covered */
  if( _.strIs( src ) )
  return this.longFromCoercing( this.arrayFromStr( src ) );

  _.assert( 0, `Unknown data type : ${ _.entity.strType( src ) }` );
}

//

/**
 * The routine longFill() fills elements the given Long {-src-} by static value. The range of replaced elements
 * defines by a parameter {-range-}. If it possible, routine longFill() saves original container {-src-}.
 *
 * @param { Long } src - The source Long.
 * @param { * } value - Any value to fill the elements in the {-src-}.
 * If {-value-} is not provided, the routine fills elements of source Long by 0.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
 * If {-range-} is number, then it defines the end index, and the start index is 0.
 * If range[ 0 ] < 0, then start index sets to 0, end index increments by absolute value of range[ 0 ].
 * If range[ 1 ] <= range[ 0 ], then routine returns a copy of original Long.
 * If {-range-} is not provided, routine fills all elements of the {-src-}.
 *
 * @example
 * _.longFill( [ 1, 2, 3, 4, 5 ] );
 * // returns [ 0, 0, 0, 0, 0 ]
 *
 * @example
 * _.longFill( [ 1, 2, 3, 4, 5 ], 'a' );
 * // returns [ 'a', 'a', 'a', 'a', 'a' ]
 *
 * @example
 * _.longFill( [ 1, 2, 3, 4, 5 ], 'a', 2 );
 * // returns [ 'a', 'a', 3, 4, 5 ]
 *
 * @example
 * _.longFill( [ 1, 2, 3, 4, 5 ], 'a', [ 1, 3 ] );
 * // returns [ 1, 'a', 'a', 4, 5 ]
 *
 * @example
 * _.longFill( [ 1, 2, 3, 4, 5 ], 'a', [ -1, 3 ] );
 * // returns [ 'a', 'a', 'a', 'a', 5 ]
 *
 * @example
 * _.longFill( [ 1, 2, 3, 4, 5 ], 'a', [ 4, 3 ] );
 * // returns [ 1, 2, 3, 4, 5 ]
 *
 * @returns { Long } - If it is possible, returns the source Long filled with a static value.
 * Otherwise, returns copy of the source Long filled with a static value.
 * @function longFill
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If {-src-} is not a Long.
 * @throws { Error } If {-range-} is not a Range or not a Number.
 * @namespace Tools
 */

function longFill( src, value, range )
{

  if( range === undefined )
  range = [ 0, src.length ];
  if( _.number.is( range ) )
  range = [ 0, range ];

  _.assert( 1 <= arguments.length && arguments.length <= 3 );
  _.assert( _.longIs( src ) );
  _.assert( _.intervalIs( range ) );

  if( value === undefined )
  value = 0;

  // src = _.longGrowInplace( src, range );
  src = _.longGrow_( src, src, [ range[ 0 ], range[ 1 ] - 1 ] );

  let offset = Math.max( -range[ 0 ], 0 );

  if( range[ 0 ] < 0 )
  {
    range[ 1 ] -= range[ 0 ];
    range[ 0 ] = 0;
  }

  if( _.routine.is( src.fill ) )
  {
    src.fill( value, range[ 0 ], range[ 1 ] + offset );
  }
  else
  {
    for( let t = range[ 0 ] ; t < range[ 1 ] + offset ; t++ )
    src[ t ] = value;
  }

  return src;
}

//

function longFill_( src, ins, cinterval )
{

  if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval - 1 ];

  _.assert( 1 <= arguments.length && arguments.length <= 3 );
  _.assert( _.longIs( src ) );
  _.assert( _.intervalIs( cinterval ) );

  if( ins === undefined )
  ins = 0;

  src = _.longGrow_( src, src, cinterval );

  let offset = Math.max( -cinterval[ 0 ], 0 );

  if( cinterval[ 0 ] < 0 )
  {
    cinterval[ 1 ] -= cinterval[ 0 ];
    cinterval[ 0 ] = 0;
  }

  if( _.routine.is( src.fill ) )
  {
    src.fill( ins, cinterval[ 0 ], cinterval[ 1 ] + 1 + offset );
  }
  else
  {
    for( let t = cinterval[ 0 ] ; t < cinterval[ 1 ] + 1 + offset ; t++ )
    src[ t ] = ins;
  }

  return src;
}

//

/**
 * The longDuplicate() routine returns an array with duplicate values of a certain number of times.
 *
 * @param { objectLike } [ o = {  } ] o - The set of arguments.
 * @param { longIs } o.src - The given initial array.
 * @param { longIs } o.result - To collect all data.
 * @param { Number } [ o.nScalarsPerElement = 1 ] o.nScalarsPerElement - The certain number of times
 * to append the next value from (srcArray or o.src) to the (o.result).
 * If (o.nScalarsPerElement) is greater that length of a (srcArray or o.src) it appends the 'undefined'.
 * @param { Number } [ o.nDupsPerElement = 2 ] o.nDupsPerElement = 2 - The number of duplicates per element.
 *
 * @example
 * _.longDuplicate( [ 'a', 'b', 'c' ] );
 * // returns [ 'a', 'a', 'b', 'b', 'c', 'c' ]
 *
 * @example
 * let options = {
 *   src : [ 'abc', 'def' ],
 *   result : [  ],
 *   nScalarsPerElement : 2,
 *   nDupsPerElement : 3
 * };
 * _.longDuplicate( options, {} );
 * // returns [ 'abc', 'def', 'abc', 'def', 'abc', 'def' ]
 *
 * @example
 * let options = {
 *   src : [ 'abc', 'def' ],
 *   result : [  ],
 *   nScalarsPerElement : 3,
 *   nDupsPerElement : 3
 * };
 * _.longDuplicate( options, { a : 7, b : 13 } );
 * // returns [ 'abc', 'def', undefined, 'abc', 'def', undefined, 'abc', 'def', undefined ]
 *
 * @returns { Array } Returns an array with duplicate values of a certain number of times.
 * @function longDuplicate
 * @throws { Error } Will throw an Error if ( o ) is not an objectLike.
 * @namespace Tools
 */

function longDuplicate( o ) /* xxx : review interface */
{
  // _.assert( arguments.length === 1 || arguments.length === 2 );

  _.assert( _.mapIs( o ) );

  // if( arguments.length === 2 )
  // {
  //   o = { src : arguments[ 0 ], nDupsPerElement : arguments[ 1 ] };
  // }
  // else if( arguments.length === 1 )
  // {
  //   if( !_.mapIs( o ) )
  //   o = { src : o };
  // }
  // else _.assert( 0 );

  if( o.nScalarsPerElement === 0 )
  if( o.src.length === 0 )
  o.nScalarsPerElement = 1;
  else
  o.nScalarsPerElement = o.src.length;

  _.routine.options( longDuplicate, o );
  _.assert( _.number.is( o.nDupsPerElement ) );
  _.assert( _.longIs( o.src ), 'Expects Long {-o.src-}' );
  _.assert( _.intIs( o.src.length / o.nScalarsPerElement ) );

  if( o.nDupsPerElement === 1 )
  {
    if( o.dst )
    {
      _.assert( _.longIs( o.dst ) || _.bufferTypedIs( o.dst ), 'Expects o.dst as longIs or TypedArray if nDupsPerElement equals 1' );

      if( _.bufferTypedIs( o.dst ) )
      o.dst = _.longJoin( o.dst, o.src );
      else if( _.longIs( o.dst ) )
      o.dst.push.apply( o.dst, o.src );
    }
    else
    {
      o.dst = o.src;
    }
    return o.dst;
  }

  let length = o.src.length * o.nDupsPerElement;
  let numberOfElements = o.src.length / o.nScalarsPerElement;

  if( o.dst )
  _.assert( o.dst.length >= length );

  o.dst = o.dst || _.long.makeUndefined( o.src, length );

  let rlength = o.dst.length;

  for( let c = 0, cl = numberOfElements ; c < cl ; c++ )
  {

    for( let d = 0, dl = o.nDupsPerElement ; d < dl ; d++ )
    {

      for( let e = 0, el = o.nScalarsPerElement ; e < el ; e++ )
      {
        let indexDst = c*o.nScalarsPerElement*o.nDupsPerElement + d*o.nScalarsPerElement + e;
        let indexSrc = c*o.nScalarsPerElement+e;
        o.dst[ indexDst ] = o.src[ indexSrc ];
      }

    }

  }

  _.assert( o.dst.length === rlength );

  return o.dst;
}

longDuplicate.defaults = /* qqq : cover. take into account extreme cases */
{
  src : null,
  dst : null,
  nScalarsPerElement : 1,
  nDupsPerElement : 2,
}

//

/*
aaa : find and let me know what is _.buffer* analog of _longClone |
aaa Dmytro : module has not _.buffer* analog of routine _longClone. The closest functionality has routine bufferMake( ins, src )
zzz
*/

// function _longClone( src ) /* qqq for Dmyto : _longClone should not accept untyped buffers. _bufferClone should accept untyped buffer */
function _longClone( src ) /* qqq for Dmyto : _longClone should not accept untyped buffers. _bufferClone should accept untyped buffer */
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.longLike( src ) || _.bufferAnyIs( src ) );
  // _.assert( !_.bufferNodeIs( src ), 'not tested' );

  if( _.unrollIs( src ) )
  return _.unroll.make( src );
  else if( _.arrayIs( src ) )
  return src.slice();
  else if( _.argumentsArray.is( src ) )
  return Array.prototype.slice.call( src );
  else if( _.bufferRawIs( src ) )
  return new U8x( new U8x( src ) ).buffer;
  else if( _.bufferTypedIs( src ) || _.bufferNodeIs( src ) )
  return new src.constructor( src );
  else if( _.bufferViewIs( src ) )
  return new src.constructor( src.buffer, src.byteOffset, src.byteLength );

  _.assert( 0, 'unknown kind of buffer', _.entity.strType( src ) );
}

//

/**
 * Returns a copy of original array( array ) that contains elements from index( f ) to index( l ),
 * but not including ( l ).
 *
 * If ( l ) is omitted or ( l ) > ( array.length ), _longShallow extracts through the end of the sequence ( array.length ).
 * If ( f ) > ( l ), end index( l ) becomes equal to begin index( f ).
 * If ( f ) < 0, zero is assigned to begin index( f ).

 * @param { Array/BufferNode } array - Source array or buffer.
 * @param { Number } [ f = 0 ] f - begin zero-based index at which to begin extraction.
 * @param { Number } [ l = array.length ] l - end zero-based index at which to end extraction.
 *
 * @example
 * _._longShallow( [ 1, 2, 3, 4, 5, 6, 7 ], 2, 6 );
 * // returns [ 3, 4, 5, 6 ]
 *
 * @example
 * // begin index is less then zero
 * _._longShallow( [ 1, 2, 3, 4, 5, 6, 7 ], -1, 2 );
 * // returns [ 1, 2 ]
 *
 * @example
 * // end index is bigger then length of array
 * _._longShallow( [ 1, 2, 3, 4, 5, 6, 7 ], 5, 100 );
 * // returns [ 6, 7 ]
 *
 * @returns { Array } Returns a shallow copy of elements from the original array.
 * @function _longShallow
 * @throws { Error } Will throw an Error if ( array ) is not an Array or BufferNode.
 * @throws { Error } Will throw an Error if ( f ) is not a Number.
 * @throws { Error } Will throw an Error if ( l ) is not a Number.
 * @throws { Error } Will throw an Error if no arguments provided.
 * @namespace Tools
 */

/* aaa : optimize */
/* Dmytro : optimized */

// function longSlice( array, f, l )
function _longShallow( src, f, l )
{
  _.assert( 1 <= arguments.length && arguments.length <= 3 );
  _.assert( _.longIs( src ), 'Expects long {-src-}' );
  _.assert( f === undefined || _.number.is( f ) );
  _.assert( l === undefined || _.number.is( l ) );

  /* xxx qqq for Dmytro : check and cover */

  f = f === undefined ? 0 : f;
  l = l === undefined ? src.length : l;

  if( f < 0 )
  f = src.length + f;
  if( l < 0 )
  l = src.length + l;

  if( f < 0 )
  f = 0;
  if( f > l )
  l = f;

  if( _.bufferTypedIs( src ) )
  return _.longOnly_( null, src, [ f, l - 1 ] );
  return Array.prototype.slice.call( src, f, l );

  // if( _.bufferTypedIs( src ) )
  // return src.subsrc( f, l );
  // else if( _.srcLikeResizable( src ) )
  // return src.slice( f, l );
  // else if( _.argumentssrcIs( src ) )
  // return src.prototype.slice.call( src, f, l );
  // else
  // _.assert( 0 );
}

//

/**
 * The longRepresent() routine returns a shallow copy of a portion of an array
 * or a new TypedArray that contains
 * the elements from (begin) index to the (end) index,
 * but not including (end).
 *
 * @param { Array } src - Source array.
 * @param { Number } begin - Index at which to begin extraction.
 * @param { Number } end - Index at which to end extraction.
 *
 * @example
 * _.longRepresent( [ 1, 2, 3, 4, 5 ], 2, 4 );
 * // returns [ 3, 4 ]
 *
 * @example
 * _.longRepresent( [ 1, 2, 3, 4, 5 ], -4, -2 );
 * // returns [ 2, 3 ]
 *
 * @example
 * _.longRepresent( [ 1, 2, 3, 4, 5 ] );
 * // returns [ 1, 2, 3, 4, 5 ]
 *
 * @returns { Array } - Returns a shallow copy of a portion of an array into a new Array.
 * @function longRepresent
 * @throws { Error } If the passed arguments is more than three.
 * @throws { Error } If the first argument is not an array.
 * @namespace Tools
 */

/* qqq2 : review. ask */
/* qqq2 : implement bufferRepresent_( any buffer )
should return undefined if cant create representation
let representation = _.bufferRepresent_( src );
representation[ 4 ] = x; // src changed too
*/

/* qqq2 : implement longRepresent_( src, cinterval ~ [ first, last ] ) */
/* xxx qqq for Dmytro : implement longRepresent_ */

function longRepresent( src, begin, end )
{

  _.assert( arguments.length <= 3 );
  _.assert( _.longLike( src ), 'Unknown type of (-src-) argument' );
  _.assert( _.routine.is( src.slice ) || _.routine.is( src.subarray ) );

  if( _.routine.is( src.subarray ) )
  return src.subarray( begin, end );

  return src.slice( begin, end );
}

// function longSlice( array, f, l )
// {
//   let result;
//
//   if( _.argumentsArray.is( array ) )
//   if( f === undefined && l === undefined )
//   {
//     if( array.length === 2 )
//     return [ array[ 0 ], array[ 1 ] ];
//     else if( array.length === 1 )
//     return [ array[ 0 ] ];
//     else if( array.length === 0 )
//     return [];
//   }
//
//   _.assert( _.longIs( array ) );
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( _.arrayLikeResizable( array ) )
//   {
//     _.assert( f === undefined || _.number.is( f ) );
//     _.assert( l === undefined || _.number.is( l ) );
//     result = array.slice( f, l );
//     return result;
//   }
//
//   f = f !== undefined ? f : 0;
//   l = l !== undefined ? l : array.length;
//
//   _.assert( _.number.is( f ) );
//   _.assert( _.number.is( l ) );
//
//   if( f < 0 )
//   f = array.length + f;
//   if( l < 0 )
//   l = array.length + l;
//
//   if( f < 0 )
//   f = 0;
//   if( l > array.length )
//   l = array.length;
//   if( l < f )
//   l = f;
//
//   result = _.long.makeUndefined( array, l-f );
//   // if( _.bufferTypedIs( array ) )
//   // result = new array.constructor( l-f );
//   // else
//   // result = new Array( l-f );
//
//   for( let r = f ; r < l ; r++ )
//   result[ r-f ] = array[ r ];
//
//   return result;
// }

//

/**
 * The routine longJoin() makes new container with type defined by first argument. Routine clones content of provided arguments
 * into created container.
 *
 * @param { Long|Buffer } arguments[ 0 ] - Long or Buffer, defines type of returned container. If provided only {-arguments[ 0 ]-}, then
 * routine makes shallow copy of it.
 * @param { * } ... - Arguments to make copy into new container. Can have any types exclude undefined.
 *
 * @example
 * let src = [];
 * let got = _.longJoin( src );
 * console.log( got );
 * // log []
 * console.log( src === got );
 * // log false
 *
 * @example
 * var src = new U8x( [ 1, 2, 3, 4 ] );
 * var got = _.longJoin( src );
 * console.log( got );
 * // log Uint8Array [ 1, 2, 3, 4 ];
 * console.log( src === got );
 * // log false
 *
 * @example
 * let src = _.unroll.make( [] );
 * let got = _.longJoin( src, 1, 'str', new F32x( [ 3 ] ) );
 * console.log( got );
 * // log [ 1, 'str', 3 ]
 * console.log( _.unrollIs( got ) );
 * // log true
 * console.log( src === got );
 * // log false
 *
 * @example
 * let src = new BufferRaw( 3 );
 * let got = _.longJoin( src, 1, 2, _.argumentsArray.make( [ 3, 4 ] ) );
 * console.log( got );
 * // log ArrayBuffer { [Uint8Contents]: <00 00 00 01 02 03 04>, byteLength: 7 }
 * console.log( src === got );
 * // log false
 *
 * @returns { Long|Buffer } - Returns a Long or a Buffer with type of first argument. Returned container filled by content of provided arguments.
 * @function longJoin
 * @throws { Error } If arguments.length is less than one.
 * @throws { Error } If the {-arguments[ 0 ]-} is not a Long or not a Buffer.
 * @throws { Error } If {-arguments-} has undefined value.
 * @namespace Tools
 */

function longJoin()
{
  _.assert( arguments.length >= 1, 'Expects at least one argument' );

  if( arguments.length === 1 )
  {
    return _._longClone( arguments[ 0 ] );
  }

  /* eval length */

  let length = 0;

  for( let a = 0 ; a < arguments.length ; a++ )
  {
    let argument = arguments[ a ];

    _.assert( argument !== undefined, 'argument is not defined' );
    // if( argument === undefined )
    // throw _.err( 'argument is not defined' );

    if( _.longLike( argument ) || _.bufferNodeIs( argument ) )
    length += argument.length;
    else if( _.bufferRawIs( argument ) || _.bufferViewIs( argument ) )
    length += argument.byteLength;
    else
    length += 1;
  }

  /* make result */

  let result, bufferDst;
  let offset = 0;

  if( _.bufferRawIs( arguments[ 0 ] ) )
  {
    result = new BufferRaw( length );
    bufferDst = new U8x( result );
  }
  else if( _.bufferViewIs( arguments[ 0 ] ) )
  {
    result = new BufferView( new BufferRaw( length ) );
    bufferDst = new U8x( result.buffer );
  }
  else
  {
    if( _.arrayIs( arguments[ 0 ] ) || _.bufferTypedIs( arguments[ 0 ] ) || _.argumentsArray.is( arguments[ 0 ] ) )
    result = _.long.makeUndefined( arguments[ 0 ], length );
    else if( _.bufferNodeIs( arguments[ 0 ] ) )
    result = BufferNode.alloc( length );
    else
    _.assert( 0, 'Unexpected data type' );

    bufferDst = result;
  }

  /* copy */

  for( let a = 0; a < arguments.length ; a++ )
  {
    let srcTyped;
    let argument = arguments[ a ];
    if( _.bufferRawIs( argument ) )
    srcTyped = new U8x( argument );
    else if( _.bufferViewIs( argument ) )
    srcTyped = new U8x( argument.buffer );
    else if( _.bufferTypedIs( argument ) )
    srcTyped = argument;
    else if( _.longLike( argument ) || _.bufferNodeIs( argument ) )
    srcTyped = argument;
    else
    srcTyped = [ argument ];

    for( let i = 0; i < srcTyped.length; i++ )
    bufferDst[ i + offset ] = srcTyped[ i ];

    offset += srcTyped.length;
  }

  // for( let a = 0, c = 0 ; a < arguments.length ; a++ )
  // {
  //   let argument = arguments[ a ];
  //   if( _.bufferRawIs( argument ) )
  //   {
  //     bufferDst.set( new U8x( argument ), offset );
  //     offset += argument.byteLength;
  //   }
  //   else if( _.bufferTypedIs( arguments[ 0 ] ) )
  //   {
  //     result.set( argument, offset );
  //     offset += argument.length;
  //   }
  //   else if( _.longLike( argument ) )
  //   for( let i = 0 ; i < argument.length ; i++ )
  //   {
  //     result[ c ] = argument[ i ];
  //     c += 1;
  //   }
  //   else
  //   {
  //     result[ c ] = argument;
  //     c += 1;
  //   }
  // }

  return result;
}

//

function longEmpty( dstLong )
{
  if( _.arrayIs( dstLong ) )
  {
    // dstLong.slice( 0, dstLong.length ); // Dmytro : slice() method make copy of array, splice() method removes elements
    dstLong.splice( 0, dstLong.length );
    return dstLong;
  }
  _.assert( 0, () => `Cant change length of fixed-length container ${_.entity.strType( dstLong )}` );
}

// //
//
// /**
//  * The routine longBut() returns a shallow copy of provided Long {-array-}. Routine removes existing
//  * elements in bounds defined by {-range-} and inserts new elements from {-val-}. The original
//  * source Long {-array-} will not be modified.
//  *
//  * @param { Long } array - The Long from which makes a shallow copy.
//  * @param { Range|Number } range - The two-element array that defines the start index and the end index for removing elements.
//  * If {-range-} is number, then it defines the start index, and the end index is start index incremented by one.
//  * If {-range-} is undefined, routine returns copy of {-array-}.
//  * If range[ 0 ] < 0, then start index sets to 0.
//  * If range[ 1 ] > array.length, end index sets to array.length.
//  * If range[ 1 ] <= range[ 0 ], then routine removes not elements, the insertion of elements begins at start index.
//  * @param { Long } val - The Long with elements for insertion. Inserting begins at start index.
//  * If quantity of removed elements is not equal to val.length, then returned Long will have length different to array.length.
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longBut( src );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.unroll.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longBut( src, 2, [ 'str' ] );
//  * console.log( got );
//  * // log [ 1, 2, 'str', 4, 5 ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = new F32x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longBut( src, [ 1, 4 ], [ 5, 6, 7 ] );
//  * console.log( got );
//  * // log Float32Array[ 1, 5, 6, 7, 5 ]
//  * console.log( _.bufferTypedIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longBut( src, [ -5, 10 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 'str' ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longBut( src, [ 4, 1 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 'str', 5 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @returns { Long } - Returns a copy of source Long with removed or replaced existing elements and / or added new elements. The copy has same type as source Long.
//  * @function longBut
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-array-} is not a Long.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not number / undefined.
//  * @throws { Error } If argument {-val-} is not Long / undefined.
//  * @namespace Tools
//  */
//
// /*
// qqq : routine longBut requires good test coverage and documentation | Dmytro : extended routine coverage by using given clarifications, documented
//  */

// function longBut( array, range, val )
// {
//
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( range === undefined )
//   return _.longJoin( array );
//   // return _.long.make( array );
//
//   if( _.arrayIs( array ) )
//   return _.arrayBut( array, range, val );
//
//   if( _.number.is( range ) )
//   range = [ range, range + 1 ];
//
//   _.assert( _.longLike( array ) );
//   _.assert( val === undefined || _.longLike( val ) );
//   _.assert( _.intervalIs( range ) );
//   // _.assert( _.longLike( range ), 'not tested' );
//   // _.assert( !_.longLike( range ), 'not tested' );
//
//   // if( _.number.is( range ) )
//   // range = [ range, range + 1 ];
//
//   _.ointerval.clamp/*rangeClamp*/( range, [ 0, array.length ] );
//   if( range[ 1 ] < range[ 0 ] )
//   range[ 1 ] = range[ 0 ];
//
//   let d = range[ 1 ] - range[ 0 ];
//   let len = ( val ? val.length : 0 );
//   let d2 = d - len;
//   let l2 = array.length - d2;
//
//   let result = _.long.makeUndefined( array, l2 );
//
//   // _.assert( 0, 'not tested' )
//
//   for( let i = 0 ; i < range[ 0 ] ; i++ )
//   result[ i ] = array[ i ];
//
//   for( let i = range[ 1 ] ; i < array.length ; i++ )
//   result[ i-d2 ] = array[ i ];
//
//   if( val )
//   {
//     for( let i = 0 ; i < val.length ; i++ )
//     result[ range[ 0 ]+i ] = val[ i ];
//   }
//
//   return result;
// }

// //
//
// /**
//  * The routine longButInplace() returns a Long {-array-} with removed existing elements in bounds
//  * defined by {-range-} and inserted new elements from {-val-}.
//  * If provided Long is resizable, routine modifies this Long in place, otherwise, return copy.
//  *
//  * @param { Long } array - The Long to remove, replace or add elements.
//  * @param { Range|Number } range - The two-element array that defines the start index and the end index for removing elements.
//  * If {-range-} is number, then it defines the start index, and the end index defines as start index incremented by one.
//  * If {-range-} is undefined, routine returns {-src-}.
//  * If range[ 0 ] < 0, then start index sets to 0.
//  * If range[ 1 ] > array.length, end index sets to array.length.
//  * If range[ 1 ] <= range[ 0 ], then routine removes no elements, the insertion of elements begins at start index.
//  * @param { Long } ins - The Long with elements for insertion. Inserting begins at start index.
//  * If quantity of removed elements is not equal to val.length, then returned array will have length different to original array.length.
//  *
//  * @example
//  * var src = new U8x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longButInplace( src );
//  * console.log( got );
//  * // log Uint8Array[ 1, 2, 3, 4, 5 ]
//  * console.log( _.bufferTypedIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log true
//  *
//  * @example
//  * var src = new I32x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longButInplace( src, 2, [ 6, 7 ] );
//  * console.log( got );
//  * // log Int8Array[ 1, 2, 6, 7, 4, 5 ]
//  * console.log( _.bufferTypedIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.unroll.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longButInplace( src, [ 1, 4 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 1, 'str', 5 ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log true
//  *
//  * @example
//  * var src = _.argumentsArray.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longButInplace( src, [ -5, 10 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 'str' ]
//  * console.log( _.argumentsArray.is( got ) );
//  * // log false
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longButInplace( src, [ 4, 1 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 'str', 5 ]
//  * console.log( got === src );
//  * // log true
//  *
//  * @returns { Long } Returns Long with removed or replaced existing elements and / or added new elements.
//  * If long is resizable, routine returns modified source long, otherwise, returns a copy.
//  * @function longButInplace
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-array-} is not a long.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not number / undefined.
//  * @throws { Error } If argument {-val-} is not long / undefined.
//  * @namespace Tools
//  */
//
// /*
// aaa : routine longButInplace requires good test coverage and documentation | Dmytro : implemented and covered routine longButInplace, documented
//  */
//
// function longButInplace( array, range, val )
// {
//
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( _.arrayLikeResizable( array ) )
//   return _.arrayButInplace( array, range, val );
//
//   if( range === undefined )
//   return array;
//   if( _.number.is( range ) )
//   range = [ range, range + 1 ];
//
//   _.assert( _.longLike( array ) );
//   _.assert( _.intervalIs( range ) );
//
//   _.ointerval.clamp/*rangeClamp*/( range, [ 0, array.length ] );
//   if( range[ 1 ] < range[ 0 ] )
//   range[ 1 ] = range[ 0 ];
//
//   if( range[ 0 ] === range[ 1 ] && val === undefined )
//   return array;
//   else
//   return _.longBut( array, range, val );
//
//   // let result;
//   //
//   // _.assert( _.longLike( src ) );
//   // _.assert( ins === undefined || _.longLike( ins ) );
//   // _.assert( _.longLike( range ), 'not tested' );
//   // _.assert( !_.longLike( range ), 'not tested' );
//   //
//   // _.assert( 0, 'not implemented' )
//
//   //
//   // if( _.number.is( range ) )
//   // range = [ range, range + 1 ];
//   //
//   // _.ointerval.clamp/*rangeClamp*/( range, [ 0, src.length ] );
//   // if( range[ 1 ] < range[ 0 ] )
//   // range[ 1 ] = range[ 0 ];
//   //
//   // let d = range[ 1 ] - range[ 0 ];
//   // let range[ 1 ] = src.length - d + ( ins ? ins.length : 0 );
//   //
//   // result = _.long.makeUndefined( src, range[ 1 ] );
//   //
//   // _.assert( 0, 'not tested' )
//   //
//   // for( let i = 0 ; i < range[ 0 ] ; i++ )
//   // result[ i ] = src[ i ];
//   //
//   // for( let i = range[ 1 ] ; i < range[ 1 ] ; i++ )
//   // result[ i-d ] = src[ i ];
//   //
//   // return result;
// }
//
// //
//
// // function _relength_head( dst, src, range, ins )
// // {
// //   _.assert( 1 <= arguments.length && arguments.length <= 4 );
// //
// //   /* aaa : suspicious */ /* Dmytro : removed */
// //
// //   if( dst === null )
// //   {
// //     dst = true;
// //   }
// //   else if( dst === src )
// //   {
// //     dst = false;
// //   }
// //   else if( arguments.length === 4 )
// //   {
// //     _.assert( _.longLike( dst ), '{-dst-} should be Long' );
// //   }
// //   else
// //   {
// //     /* aaa2 : wrong. src could pass check intervalIs if length is 2 */
// //     /* Dmytro : this check means: if length > 1 and second argument is not a range, then it is source container, and third argument is range */
// //     // if( arguments.length > 1 && !_.intervalIs( src ) && !_.number.is( src ) )
// //     // {
// //     //   _.assert( _.longLike( dst ) );
// //     // }
// //     // else
// //     // {
// //     //   ins = range;
// //     //   range = src;
// //     //   src = dst;
// //     //   dst = false;
// //     // }
// //
// //     ins = range;
// //     range = src;
// //     src = dst;
// //     dst = false;
// //   }
// //
// //   _.assert( _.longLike( src ) );
// //
// //   return [ dst, src, range, ins ];
// // }

//

/* aaa2 : rename arguments. ask */ /* Dmytro : renamed and standardized for each routine */

function longBut_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  if( cinterval === undefined )
  {
    cinterval = [ 0, -1 ];
    ins = undefined;
  }
  else if( _.number.is( cinterval ) )
  {
    cinterval = [ cinterval, cinterval ];
  }

  _.assert( _.longIs( dst ) || dst === null, 'Expects {-dst-} of any long type or null' );
  _.assert( _.longIs( src ), 'Expects {-src-} of any long type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );
  _.assert( _.longLike( ins ) || ins === undefined || ins === null, 'Expects long {-ins-} for insertion' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] !== undefined ? cinterval[ 0 ] : 0;
  let last = cinterval[ 1 ] = cinterval[ 1 ] !== undefined ? cinterval[ 1 ] : src.length - 1;

  if( first < 0 )
  first = 0;
  if( first > src.length )
  first = src.length;
  if( last > src.length - 1 )
  last = src.length - 1;

  if( last + 1 < first )
  last = first - 1;

  let delta = last - first + 1;
  let insLength = ins ? ins.length : 0;
  let delta2 = delta - insLength;
  let resultLength = src.length - delta2;

  let result = dst;
  if( dst === null )
  {
    result = _.long.makeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( ( dst.length === resultLength ) && delta === 0 )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      ins ? dst.splice( first, delta, ... ins ) : dst.splice( first, delta );
      return dst;
    }
    else if( dst.length !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.long.makeUndefined( dst, resultLength );
    }
  }
  else if( dst.length !== resultLength )
  {
    dst = _.long.makeUndefined( dst, resultLength );
  }

  /* */

  for( let i = 0 ; i < first ; i++ )
  result[ i ] = src[ i ];

  for( let i = last + 1 ; i < src.length ; i++ )
  result[ i - delta2 ] = src[ i ];

  if( ins )
  {
    for( let i = 0 ; i < ins.length ; i++ )
    result[ first + i ] = ins[ i ];
  }

  return result;
}

// //
//
// /**
//  * The routine longOnly() returns a copy of a portion of provided Long {-array-} into a new Long
//  * selected by {-range-}. The original {-array-} will not be modified.
//  *
//  * @param { Long } array - The Long from which makes a shallow copy.
//  * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
//  * If {-range-} is number, then it defines the start index, and the end index sets to array.length.
//  * If {-range-} is undefined, routine returns copy of {-array-}.
//  * If range[ 0 ] < 0, then start index sets to 0.
//  * If range[ 1 ] > array.length, end index sets to array.length.
//  * If range[ 1 ] <= range[ 0 ], then routine returns empty Long.
//  * @param { * } val - The object of any type for insertion.
//  *
//  * @example
//  * var src = new F32x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.+( src );
//  * console.log( got );
//  * // log Float32Array[ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.unroll.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longOnly( src, 2, [ 'str' ] );
//  * console.log( got );
//  * // log [ 3, 4, 5 ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longOnly( src, [ 1, 4 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 2, 3, 4 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.argumentsArray.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longOnly( src, [ -5, 10 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5 ]
//  * console.log( _.argumentsArray.is( got ) );
//  * // log false
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longOnly( src, [ 4, 1 ], [ 'str' ] );
//  * console.log( got );
//  * // log []
//  * console.log( got === src );
//  * // log false
//  *
//  * @returns { Long } Returns a copy of source Long containing the extracted elements. The copy has same type as source Long.
//  * @function longOnly
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-array-} is not a Long.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not number / undefined.
//  * @namespace Tools
//  */
//
// /*
//   qqq : extend documentation and test coverage of longOnly | Dmytro : documented, covered.
// */
//
// function longOnly( array, range, val )
// {
//   let result;
//
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( range === undefined )
//   // return _.long.make( array, array.length ? array.length : 0 );
//   return _.longJoin( array );
//
//   if( _.number.is( range ) )
//   range = [ range, array.length ];
//
//   // let f = range ? range[ 0 ] : undefined;
//   // let l = range ? range[ 1 ] : undefined;
//   //
//   // f = f !== undefined ? f : 0;
//   // l = l !== undefined ? l : array.length;
//
//   _.assert( _.longLike( array ) );
//   _.assert( _.intervalIs( range ) )
//
//   // if( f < 0 )
//   // {
//   //   l -= f;
//   //   f -= f;
//   // }
//
//   _.ointerval.clamp/*rangeClamp*/( range, [ 0, array.length ] );
//   if( range[ 1 ] < range[ 0 ] )
//   range[ 1 ] = range[ 0 ];
//
//   // if( l < f )
//   // l = f;
//
//   // if( f < 0 )
//   // f = 0;
//   // if( l > array.length )
//   // l = array.length;
//
//   if( range[ 0 ] === 0 && range[ 1 ] === array.length )
//   // return _.long.make( array, array.length );
//   return _.longJoin( array );
//
//   result = _.long.makeUndefined( array, range[ 1 ]-range[ 0 ] );
//
//   let f2 = Math.max( range[ 0 ], 0 );
//   let l2 = Math.min( array.length, range[ 1 ] );
//   for( let r = f2 ; r < l2 ; r++ )
//   result[ r-f2 ] = array[ r ];
//
//   if( val !== undefined )
//   {
//     for( let r = 0 ; r < -range[ 0 ] ; r++ )
//     {
//       result[ r ] = val;
//     }
//     for( let r = l2 - range[ 0 ]; r < result.length ; r++ )
//     {
//       result[ r ] = val;
//     }
//   }
//
//   return result;
// }

// //
//
// /**
//  * The routine longOnlyInplace() returns a portion of provided Long {-array-} selected by {-range-}.
//  * If provided Long is resizable, routine modifies this Long in place, otherwise, return copy.
//  *
//  * @param { Long } array - The Long from which selects elements.
//  * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
//  * If {-range-} is number, then it defines the start index, and the end index sets to array.length.
//  * If {-range-} is undefined, routine returns {-array-}.
//  * If range[ 0 ] < 0, then start index sets to 0.
//  * If range[ 1 ] > array.length, end index sets to array.length.
//  * If range[ 1 ] <= range[ 0 ], then routine returns empty Long.
//  * @param { * } val - The object of any type for insertion.
//  *
//  * @example
//  * var src = new F32x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longOnlyInplace( src );
//  * console.log( got );
//  * // log Float32Array[ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log true
//  *
//  * @example
//  * var src = _.unroll.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longOnlyInplace( src, 2, [ 'str' ] );
//  * console.log( got );
//  * // log [ 3, 4, 5 ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log true
//  *
//  * @example
//  * var src = new U8x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longOnlyInplace( src, [ 1, 4 ], [ 1 ] );
//  * console.log( got );
//  * // log Uint8Array[ 2, 3, 4 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.argumentsArray.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longOnlyInplace( src, [ -5, 10 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5 ]
//  * console.log( _.argumentsArray.is( got ) );
//  * // log false
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longOnlyInplace( src, [ 4, 1 ], [ 'str' ] );
//  * console.log( got );
//  * // log []
//  * console.log( got === src );
//  * // log false
//  *
//  * @returns { Long } Returns a Long containing the selected elements. If Long is resizable,
//  * routine returns modified source Long, otherwise, returns a copy.
//  * @function longOnlyInplace
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-array-} is not a Long.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not number / undefined.
//  * @namespace Tools
//  */
//
// /*
//   qqq : extend documentation and test coverage of longOnlyInplace | Dmytro : documented, covered
//   qqq : implement arrayShrink | Dmytro : implemented
//   qqq : implement arrayShrinkInplace | Dmytro : implemented
// */
//
// function longOnlyInplace( array, range, val )
// {
//
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( _.arrayLikeResizable( array ) )
//   return _.arrayShrinkInplace( array, range, val );
//
//   if( range === undefined )
//   return array;
//   if( _.number.is( range ) )
//   range = [ range, array.length ];
//
//   _.assert( _.longLike( array ) );
//   _.assert( _.intervalIs( range ) );
//
//   _.ointerval.clamp/*rangeClamp*/( range, [ 0, array.length ] );
//   if( range[ 1 ] < range[ 0 ] )
//   range[ 1 ] = range[ 0 ];
//
//   if( range[ 0 ] === 0 && range[ 1 ] === array.length )
//   return array;
//   else
//   return _.longOnly( array, range, val );
//   // let result;
//   //
//   // if( range === undefined )
//   // return array;
//   //
//   // if( _.number.is( range ) )
//   // range = [ range, array.length ];
//   //
//   // // let f = range ? range[ 0 ] : undefined;
//   // // let l = range ? range[ 1 ] : undefined;
//   // //
//   // // f = f !== undefined ? f : 0;
//   // // l = l !== undefined ? l : array.length;
//   //
//   // _.assert( _.longLike( array ) );
//   // _.assert( _.intervalIs( range ) )
//   // // _.assert( _.number.is( f ) );
//   // // _.assert( _.number.is( l ) );
//   // _.assert( 1 <= arguments.length && arguments.length <= 3 );
//   // // _.assert( 1 <= arguments.length && arguments.length <= 4 );
//   //
//   // _.ointerval.clamp/*rangeClamp*/( range, [ 0, array.length ] );
//   // if( range[ 1 ] < range[ 0 ] )
//   // range[ 1 ] = range[ 0 ];
//   //
//   // // if( l < f )
//   // // l = f;
//   // //
//   // // if( f < 0 )
//   // // f = 0;
//   // // if( l > array.length )
//   // // l = array.length;
//   //
//   // if( range[ 0 ] === 0 && range[ 1 ] === array.length )
//   // // if( range[ 0 ] === 0 && l === array.length ) // Dmytro : l is not defined
//   // return array;
//   //
//   // // if( _.bufferTypedIs( array ) )
//   // // result = new array.constructor( l-f );
//   // // else
//   // // result = new Array( l-f );
//   //
//   // result = _.long.makeUndefined( array, range[ 1 ]-range[ 0 ] );
//   //
//   // /* */
//   //
//   // let f2 = Math.max( range[ 0 ], 0 );
//   // let l2 = Math.min( array.length, range[ 1 ] );
//   // for( let r = f2 ; r < l2 ; r++ )
//   // result[ r-range[ 0 ] ] = array[ r ];
//   //
//   // /* */
//   //
//   // if( val !== undefined )
//   // {
//   //   for( let r = 0 ; r < -range[ 0 ] ; r++ )
//   //   {
//   //     result[ r ] = val;
//   //   }
//   //   for( let r = l2 - range[ 0 ]; r < result.length ; r++ )
//   //   {
//   //     result[ r ] = val;
//   //   }
//   // }
//   //
//   // /* */
//   //
//   // return result;
// }

//

function longOnly_( dst, src, cinterval )
{
  _.assert( 1 <= arguments.length && arguments.length <= 3, 'Expects not {-ins-} element' );

  if( arguments.length < 3 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
  }

  if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval ];

  _.assert( _.longIs( dst ) || dst === null, 'Expects {-dst-} of any long type or null' );
  _.assert( _.longIs( src ), 'Expects {-src-} of any long type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] !== undefined ? cinterval[ 0 ] : 0;
  let last = cinterval[ 1 ] = cinterval[ 1 ] !== undefined ? cinterval[ 1 ] : src.length - 1;

  if( first < 0 )
  first = 0;
  if( last > src.length - 1 )
  last = src.length - 1;

  if( last + 1 < first )
  last = first - 1;

  let first2 = Math.max( first, 0 );
  let last2 = Math.min( src.length - 1, last );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.long.makeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( dst.length === resultLength )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      _.assert( Object.isExtensible( dst ), 'Array is not extensible, cannot change array' );
      if( resultLength === 0 )
      return _.longEmpty( dst );

      dst.splice( last2 + 1, dst.length - last + 1 );
      dst.splice( 0, first2 );
      return dst;
    }
    else if( dst.length !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.long.makeUndefined( dst, resultLength );
    }
  }
  else if( dst.length !== resultLength )
  {
    if( !_.arrayLikeResizable( result ) )
    result = _.bufferMakeUndefined( dst, resultLength );
    else
    result.splice( resultLength );
  }

  for( let r = first2 ; r < last2 + 1 ; r++ )
  result[ r - first2 ] = src[ r ];

  return result;
}

// //
//
// /**
//  * Routine longGrow() changes length of provided Long {-array-} by copying it elements to newly created Long of the same
//  * type using range {-range-} positions of the original Long and value to fill free space after copy {-val-}.
//  * Routine can only grows size of Long. The original {-array-} will not be modified.
//  *
//  * @param { Long } array - The Long from which makes a shallow copy.
//  * @param { Range } The two-element array that defines the start index and the end index for copying elements.
//  * If {-range-} is number, then it defines the end index, and the start index is 0.
//  * If range[ 0 ] < 0, then start index sets to 0, end index incrementes by absolute value of range[ 0 ].
//  * If range[ 0 ] > 0, then start index sets to 0.
//  * If range[ 1 ] > array.length, end index sets to array.length.
//  * If range[ 1 ] <= range[ 0 ], then routine returns a copy of original Long.
//  * @param { * } val - The object of any type. Used to fill the space left after copying elements of the original Long.
//  *
//  * @example
//  * var src = new F32x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longGrow( src );
//  * console.log( got );
//  * // log Float32Array[ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.unroll.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longGrow( src, 7, 'str' );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 'str', 'str' ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = new U8x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longGrow( src, [ 1, 6 ], 7 );
//  * console.log( got );
//  * // log Uint8Array[ 1, 2, 3, 4, 5, 7 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.argumentsArray.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longGrow( src, [ -5, 6 ], 7 );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 7, 7, 7, 7, 7, 7 ]
//  * console.log( _.argumentsArray.is( got ) );
//  * // log false
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longGrow( src, [ 4, 1 ], 'str' );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @returns { Long } Returns a copy of provided Long with changed length.
//  * @function longGrow
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-array-} is not a Long.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not number / undefined.
//  * @namespace Tools
//  */
//
// /*
//   aaa : extend documentation and test coverage of longGrowInplace | Dmytro : extended documentation, covered routine longGrow, longGrowInplace
//   aaa : implement arrayGrow | Dmytro : implemented
//   aaa : implement arrayGrowInplace | Dmytro : implemented
// */
//
// function longGrow( array, range, val )
// {
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( range === undefined )
//   return _.longJoin( array );
//
//   if( _.number.is( range ) )
//   range = [ 0, range ];
//
//   let f = range[ 0 ] !== undefined ? range[ 0 ] : 0;
//   let l = range[ 1 ] !== undefined ? range[ 1 ] : array.length;
//
//   _.assert( _.longLike( array ) );
//   _.assert( _.intervalIs( range ) )
//
//   if( l < f )
//   l = f;
//
//   if( f < 0 )
//   {
//     l -= f;
//     f -= f;
//   }
//
//   if( f > 0 )
//   f = 0;
//   if( l < array.length )
//   l = array.length;
//
//   if( l === array.length && -range[ 0 ] <= 0 )
//   return _.longJoin( array );
//
//   /* */
//
//   let f2 = Math.max( -range[ 0 ], 0 );
//   let l2 = Math.min( array.length, l );
//
//   let result = _.long.makeUndefined( array, range[ 1 ] > array.length ? l : array.length + f2 );
//   for( let r = f2 ; r < l2 + f2 ; r++ )
//   result[ r ] = array[ r - f2 ];
//
//   /* */
//
//   if( val !== undefined )
//   {
//     for( let r = 0 ; r < f2 ; r++ )
//     result[ r ] = val;
//     for( let r = l2 + f2; r < result.length ; r++ )
//     result[ r ] = val;
//   }
//
//   /* */
//
//   return result;
// }
//
// //
//
// /**
//  * Routine longGrowInplace() changes length of provided Long {-array-} using range {-range-} positions of the original
//  * Long and value to fill free space after copy {-val-}. If provided Long is resizable, routine modifies this
//  * Long in place, otherwise, return copy. Routine can only grows size of Long.
//  *
//  * @param { Long } array - The Long to grow length.
//  * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
//  * If {-range-} is number, then it defines the end index, and the start index is 0.
//  * If range[ 0 ] < 0, then start index sets to 0, end index incrementes by absolute value of range[ 0 ].
//  * If range[ 0 ] > 0, then start index sets to 0.
//  * If range[ 1 ] > array.length, end index sets to array.length.
//  * If range[ 1 ] <= range[ 0 ], then routine returns origin array.
//  * @param { * } val - The object of any type. Used to fill the space left of the original Long.
//  *
//  * @example
//  * var src = new F32x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longGrowInplace( src );
//  * console.log( got );
//  * // log Float32Array[ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log true
//  *
//  * @example
//  * var src = _.unroll.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longGrowInplace( src, 7, 'str' );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 'str', 'str' ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log true
//  *
//  * @example
//  * var src = new U8x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longGrowInplace( src, [ 1, 6 ], 7 );
//  * console.log( got );
//  * // log Uint8Array[ 1, 2, 3, 4, 5, 7 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.argumentsArray.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longGrowInplace( src, [ -5, 6 ], 7 );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 7, 7, 7, 7, 7, 7 ]
//  * console.log( _.argumentsArray.is( got ) );
//  * // log false
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longGrowInplace( src, [ 4, 1 ], 'str' );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log true
//  *
//  * @returns { Long } Returns a Long with changed length.
//  * If Long is resizable, routine returns modified source Long, otherwise, returns a copy.
//  * @function longGrowInplace
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-array-} is not a Long.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not number / undefined.
//  * @namespace Tools
//  */
//
// function longGrowInplace( array, range, val )
// {
//
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( _.arrayLikeResizable( array ) )
//   return _.arrayGrowInplace( array, range, val );
//
//   if( range === undefined )
//   return array;
//   if( _.number.is( range ) )
//   range = [ 0, range ];
//
//   let f = range[ 0 ] !== undefined ? range[ 0 ] : 0;
//   let l = range[ 1 ] !== undefined ? range[ 1 ] : array.length;
//
//   _.assert( _.longLike( array ) );
//   _.assert( _.intervalIs( range ) )
//
//   if( l < f )
//   l = f;
//   if( f < 0 )
//   {
//     l -= f;
//     f -= f;
//   }
//   if( f > 0 )
//   f = 0;
//   if( l < array.length )
//   l = array.length;
//
//   if( l === array.length && -range[ 0 ] <= 0 )
//   return array;
//   else
//   return _.longGrow( array, range, val );
// }

//

function longGrow_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval - 1 ];

  _.assert( _.longIs( dst ) || dst === null, 'Expects {-dst-} of any long type or null' );
  _.assert( _.longIs( src ), 'Expects {-src-} of any long type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] !== undefined ? cinterval[ 0 ] : 0;
  let last = cinterval[ 1 ] = cinterval[ 1 ] !== undefined ? cinterval[ 1 ] : src.length - 1;

  if( first > 0 )
  first = 0;
  if( last < src.length - 1 )
  last = src.length - 1;

  if( first < 0 )
  {
    last -= first;
    first -= first;
  }

  if( last + 1 < first )
  last = first - 1;

  let first2 = Math.max( -cinterval[ 0 ], 0 );
  let last2 = Math.min( src.length - 1 + first2, last + first2 );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.long.makeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( dst.length === resultLength )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      _.assert( Object.isExtensible( dst ), 'Array is not extensible, cannot change array' );
      dst.splice( 0, 0, ... _.dup( ins, first2 ) );
      dst.splice( last2 + 1, 0, ... _.dup( ins, resultLength <= last2 ? 0 : resultLength - last2 - 1 ) );
      return dst;
    }
    else if( dst.length !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.long.makeUndefined( dst, resultLength );
    }
  }
  else if( dst.length !== resultLength )
  {
    if( !_.arrayLikeResizable( result ) )
    result = _.bufferMakeUndefined( dst, resultLength );
    else
    result.splice( resultLength );
  }

  for( let r = first2 ; r < last2 + 1 ; r++ )
  result[ r ] = src[ r - first2 ];

  if( ins !== undefined )
  {
    for( let r = 0 ; r < first2 ; r++ )
    result[ r ] = ins;
    for( let r = last2 + 1 ; r < resultLength ; r++ )
    result[ r ] = ins;
  }

  return result;
}

// //
//
// /**
//  * Routine longRelength() changes length of provided Long {-array-} by copying its elements to newly created Long of the same
//  * type as source Long. Routine uses range {-range-} positions of the original Long and value {-val-} to fill free space after copy.
//  * Routine can grows and reduces size of Long. The original {-array-} will not be modified.
//  *
//  * @param { Long } array - The Long from which makes a shallow copy.
//  * @param { Range } The two-element array that defines the start index and the end index for copying elements.
//  * If {-range-} is number, then it defines the start index, and the end index sets to array.length.
//  * If range[ 0 ] < 0, then start index sets to 0.
//  * If range[ 1 ] <= range[ 0 ], then routine returns empty Long.
//  * @param { * } val - The object of any type. Used to fill the space left after copying elements of the original Long.
//  *
//  * @example
//  * var src = new F32x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longRelength( src );
//  * console.log( got );
//  * // log Float32Array[ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.unroll.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longRelength( src, 7, 'str' );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 'str', 'str' ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = new U8x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longRelength( src, [ 1, 6 ], 7 );
//  * console.log( got );
//  * // log Uint8Array[ 2, 3, 4, 5, 7 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.argumentsArray.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longRelength( src, [ -5, 6 ], 7 );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 7 ]
//  * console.log( _.argumentsArray.is( got ) );
//  * // log false
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longRelength( src, [ 4, 1 ], 'str' );
//  * console.log( got );
//  * // log []
//  * console.log( got === src );
//  * // log false
//  *
//  * @returns { Long } Returns a copy of provided Long with changed length.
//  * @function longRelength
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-array-} is not a Long.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not number / undefined.
//  * @namespace Tools
//  */
//
// function longRelength( array, range, val )
// {
//
//   let result;
//
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( range === undefined )
//   return _.longJoin( array );
//   // return _.long.make( array );
//
//   if( _.number.is( range ) )
//   range = [ range, array.length ];
//
//   let f = range[ 0 ] !== undefined ? range[ 0 ] : 0;
//   let l = range[ 1 ] !== undefined ? range[ 1 ] : src.length;
//
//   _.assert( _.longLike( array ) );
//   _.assert( _.intervalIs( range ) )
//
//   if( l < f )
//   l = f;
//   if( f > array.length )
//   f = array.length
//
//   if( f < 0 )
//   f = 0;
//
//   if( f === 0 && l === array.length )
//   return _.long.make( array );
//
//   result = _.long.makeUndefined( array, l-f );
//
//   /* */
//
//   let f2 = Math.max( f, 0 );
//   let l2 = Math.min( array.length, l );
//   for( let r = f2 ; r < l2 ; r++ )
//   result[ r-f2 ] = array[ r ];
//
//   /* */
//
//   if( val !== undefined )
//   {
//     for( let r = l2 - range[ 0 ]; r < result.length ; r++ )
//     {
//       result[ r ] = val;
//     }
//   }
//
//   /* */
//
//   return result;
// }
//
// //
//
// /**
//  * Routine longRelengthInplace() changes length of provided Long {-array-} using range {-range-} positions of the original
//  * Long and value to fill free space after copy {-val-}. If provided Long is resizable, routine modifies this
//  * Long in place, otherwise, return copy. Routine can grows and reduce size of Long.
//  *
//  * @param { Long } array - The Long to change length.
//  * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements.
//  * If {-range-} is number, then it defines the start index, and the end index sets to src.length.
//  * If range[ 0 ] < 0, then start index sets to 0.
//  * If range[ 1 ] <= range[ 0 ], then routine returns empty array.
//  * @param { * } val - The object of any type. Used to fill the space left of the original Long.
//  *
//  * @example
//  * var src = new F32x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longRelengthInplace( src );
//  * console.log( got );
//  * // log Float32Array[ 1, 2, 3, 4, 5 ]
//  * console.log( got === src );
//  * // log true
//  *
//  * @example
//  * var src = _.unroll.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longRelengthInplace( src, 7, 'str' );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 'str', 'str' ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log true
//  *
//  * @example
//  * var src = new U8x( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longRelengthInplace( src, [ 1, 6 ], 7 );
//  * console.log( got );
//  * // log Uint8Array[ 2, 3, 4, 5, 7 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = _.argumentsArray.make( [ 1, 2, 3, 4, 5 ] );
//  * var got = _.longRelengthInplace( src, [ -5, 6 ], 7 );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 7 ]
//  * console.log( _.argumentsArray.is( got ) );
//  * // log false
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.longRelengthInplace( src, [ 4, 1 ], 'str' );
//  * console.log( got );
//  * // log []
//  * console.log( got === src );
//  * // log true
//  *
//  * @returns { Long } Returns a Long with changed length.
//  * If Long is resizable, routine returns modified source Long, otherwise, returns a copy.
//  * @function longRelengthInplace
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-array-} is not a Long.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not number / undefined.
//  * @namespace Tools
//  */
//
// function longRelengthInplace( array, range, val )
// {
//
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( _.arrayLikeResizable( array ) )
//   return _.arrayRelengthInplace( array, range, val );
//
//   if( range === undefined )
//   return array;
//   if( _.number.is( range ) )
//   range = [ range, array.length ];
//
//   let f = range[ 0 ] !== undefined ? range[ 0 ] : 0;
//   let l = range[ 1 ] !== undefined ? range[ 1 ] : src.length;
//
//   _.assert( _.longLike( array ) );
//   _.assert( _.intervalIs( range ) )
//
//   if( l < f )
//   l = f;
//   if( f > array.length )
//   f = array.length;
//   if( f < 0 )
//   f = 0;
//
//   if( f === 0 && l === array.length )
//   return array;
//   else
//   return _.longRelength( array, range, val );
//
// }

//

function longRelength_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval - 1 ];

  _.assert( _.longIs( dst ) || dst === null, 'Expects {-dst-} of any long type or null' );
  _.assert( _.longIs( src ), 'Expects {-src-} of any long type' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] !== undefined ? cinterval[ 0 ] : 0;
  let last = cinterval[ 1 ] = cinterval[ 1 ] !== undefined ? cinterval[ 1 ] : src.length - 1;

  if( last < first )
  last = first - 1;

  if( cinterval[ 1 ] < 0 && cinterval[ 0 ] < 0 )
  cinterval[ 0 ] -= cinterval[ 1 ] + 1;

  if( first < 0 )
  {
    last -= first;
    first -= first;
  }

  let first2 = Math.max( Math.abs( cinterval[ 0 ] ), 0 );
  let last2 = Math.min( src.length - 1, last );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.long.makeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( dst.length === resultLength && cinterval[ 0 ] === 0 )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      _.assert( Object.isExtensible( dst ), 'dst is not extensible, cannot change dst' );
      if( cinterval[ 0 ] < 0 )
      {
        dst.splice( first, 0, ... _.dup( ins, first2 ) );
        dst.splice( last2 + 1, src.length - last2, ... _.dup( ins, last - last2 ) );
      }
      else
      {
        dst.splice( 0, first );
        dst.splice( last2 + 1 - first2, src.length - last2, ... _.dup( ins, last - last2 ) );
      }
      return dst;
    }
    else if( dst.length !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.long.makeUndefined( dst, resultLength );
    }
  }
  else if( dst.length !== resultLength )
  {
    if( !_.arrayLikeResizable( result ) )
    result = _.bufferMakeUndefined( dst, resultLength );
    else
    result.splice( resultLength );
  }

  /* */

  if( resultLength === 0 )
  {
    return result;
  }
  if( cinterval[ 0 ] < 0 )
  {
    for( let r = first2 ; r < ( last2 + 1 + first2 ) && r < resultLength ; r++ )
    result[ r ] = src[ r - first2 ];
    if( ins !== undefined )
    {
      for( let r = 0 ; r < first2 ; r++ )
      result[ r ] = ins;
      for( let r = last2 + 1 + first2 ; r < resultLength ; r++ )
      result[ r ] = ins;
    }
  }
  else
  {
    for( let r = first2 ; r < last2 + 1 ; r++ )
    result[ r - first2 ] = src[ r ];

    if( ins !== undefined )
    {
      for( let r = last2 + 1 ; r < last + 1 ; r++ )
      result[ r - first2 ] = ins;
    }
  }

  return result;
}

// --
// array checker
// --

// /**
//  * The longCompare() routine returns the first difference between the values of the first array from the second.
//  *
//  * @param { longLike } src1 - The first array.
//  * @param { longLike } src2 - The second array.
//  *
//  * @example
//  * _.longCompare( [ 1, 5 ], [ 1, 2 ] );
//  * // returns 3
//  *
//  * @returns { Number } - Returns the first difference between the values of the two arrays.
//  * @function longCompare
//  * @throws { Error } Will throw an Error if (arguments.length) is less or more than two.
//  * @throws { Error } Will throw an Error if (src1 and src2) are not the array-like.
//  * @throws { Error } Will throw an Error if (src2.length) is less or not equal to the (src1.length).
//  * @namespace Tools
//  */
//
// function longCompare( src1, src2 )
// {
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//   _.assert( _.longLike( src1 ) && _.longLike( src2 ) );
//   _.assert( src2.length >= src1.length );
//
//   let result = 0;
//
//   for( let s = 0 ; s < src1.length ; s++ )
//   {
//
//     result = src1[ s ] - src2[ s ];
//     if( result !== 0 )
//     return result;
//
//   }
//
//   return result;
// }
//
// //
//
// /**
//  * The long.identicalShallow() routine checks the equality of two arrays.
//  *
//  * @param { longLike } src1 - The first array.
//  * @param { longLike } src2 - The second array.
//  *
//  * @example
//  * _.long.identicalShallow( [ 1, 2, 3 ], [ 1, 2, 3 ] );
//  * // returns true
//  *
//  * @returns { Boolean } - Returns true if all values of the two arrays are equal. Otherwise, returns false.
//  * @function long.identicalShallow
//  * @throws { Error } Will throw an Error if (arguments.length) is less or more than two.
//  * @namespace Tools
//  */
//
// /* xxx : vector? */
// /* qqq : extend test */
// function long.identicalShallow( src1, src2 )
// {
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//   // qqq : for junior : !
//   // _.assert( _.longLike( src1 ) );
//   // _.assert( _.longLike( src2 ) );
//
//   if( !_.longLike( src1 ) )
//   return false;
//   if( !_.longLike( src2 ) )
//   return false;
//
//   return _._long.identicalShallow( src1, src2 );
//
// }
//
// //
//
// function _long.identicalShallow( src1, src2 )
// {
//   let result = true;
//
//   if( src1.length !== src2.length )
//   return false;
//
//   for( let s = 0 ; s < src1.length ; s++ )
//   {
//     result = src1[ s ] === src2[ s ];
//     if( result === false )
//     return false;
//   }
//
//   return result;
// }

//

function longHas( /* array, element, evaluator1, evaluator2 */ )
{
  let array = arguments[ 0 ];
  let element = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.argumentsArray.like( array ) );

  if( !evaluator1 && !evaluator2 )
  {
    // return _ArrayIndexOf.call( array, element ) !== -1;
    return _ArrayIncludes.call( array, element );
  }
  else
  {
    if( _.longLeftIndex( array, element, evaluator1, evaluator2 ) >= 0 )
    return true;
    return false;
  }

}

//

/**
 * The routine longHasAny() checks if the source long {-src-} has at least one element of the long {-ins-}.
 * It can take equalizer or evaluators for comparing elements.
 *
 * It iterates over source long {-src-} each element of the long {-ins-} by the routine
 * [longLeftIndex()]{@link wTools.longLeftIndex}
 * Checks, if {-src-} has at least one element of the {-ins-}.
 * If true, it returns true.
 * Otherwise, it returns false.
 *
 * @see {@link wTools.longLeftIndex} - See for more information.
 *
 * @param { Long } src - The source array.
 * @param  { Long|Primitive } ins - The elements to check in the source array.
 * @param { Function } evaluator1 - A callback function. Can be an equalizer or evaluator.
 * @param { Function } evaluator2 - A callback function. Uses only as second evaluator.
 *
 * @example
 * _.longHasAny( [ 5, 'str', 42, false ], 7 );
 * // returns false
 *
 * @example
 * _.longHasAny( [ 5, 'str', 42, false ], [ false, 7, 10 ] );
 * // returns true
 *
 * @example
 * _.longHasAny( [ { a : 2 }, 'str', 42, false ], [ { a : 2 }, { a : 3 } ] );
 * // returns false
 *
 * @example
 * var evaluator = ( e ) => e.a;
 * _.longHasAny( [ { a : 2 }, 'str', 42, false ], [ { a : 2 }, { a : 3 } ], evaluator );
 * // returns true
 *
 * @example
 * var evaluator1 = ( e ) => e.a;
 * var evaluator2 = ( e ) => e.b;
 * _.longHasAny( [ { a : 2 }, 'str', 42, false ], [ { b : 2 }, { b : 3 } ], evaluator1, evaluator2 );
 * // returns true
 *
 * @example
 * var equalizer = ( eSrc, eIns ) => eSrc.a === eIns.b;
 * _.longHasAny( [ { a : 2 }, 'str', 42, false ], [ { b : 2 }, { b : 3 } ], equalizer );
 * // returns true
 *
 * @returns { Boolean } - Returns true, if {-src-} has at least one element of {-ins-}, otherwise false is returned.
 * @function longHasAny
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-src-} is not a Long.
 * @throws { Error } If {-ins-} is not a Long, not a primitive.
 * @throws { Error } If {-evaluator1-} is not a routine.
 * @throws { Error } If {-evaluator1-} is an evaluator and accepts less or more than one argument.
 * @throws { Error } If {-evaluator1-} is an equalizer and accepts less or more than two argument.
 * @throws { Error } If {-evaluator2-} is not a routine.
 * @throws { Error } If {-evaluator2-} is an evaluator and accepts less or more than one argument.
 * @namespace Tools
 */

function longHasAny( /* src, ins, evaluator1, evaluator2 */ )
{
  let src = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );
  _.assert( _.longLike( src ), `Expects long, but got ${ _.entity.strType( src ) }` );
  _.assert( _.longLike( ins ) || _.primitive.is( ins ) );

  if( _.primitive.is( ins ) )
  ins = [ ins ];

  let i = 0;
  let result;

  do
  {
    result = _.longLeftIndex( src, ins[ i ], 0, evaluator1, evaluator2 );
    i++;
  }
  while( result < 0 && i < ins.length )

  if( result !== -1 )
  return true;
  return false;
}

//

/**
 * The routine longHasAll() checks if the source long {-src-} has all elements of the long {-ins-}.
 * It can take equalizer or evaluators for comparing elements.
 *
 * It iterates over source long {-src-} each element of the long {-ins-} by the routine
 * [longLeftIndex()]{@link wTools.longLeftIndex}
 * Checks, if {-src-} has all elements of the {-ins-}.
 * If true, it returns true.
 * Otherwise, it returns false.
 *
 * @see {@link wTools.longLeftIndex} - See for more information.
 *
 * @param { Long } src - The source array.
 * @param  { Long|Primitive } ins - The elements to check in the source array.
 * @param { Function } evaluator1 - A callback function. Can be an equalizer or evaluator.
 * @param { Function } evaluator2 - A callback function. Uses only as second evaluator.
 *
 * @example
 * _.longHasAll( [ 5, 'str', 42, false ], 7 );
 * // returns false
 *
 * @example
 * _.longHasAny( [ 5, 'str', 42, false ], [ false, 5, 'str' ] );
 * // returns true
 *
 * @example
 * _.longHasAny( [ { a : 2 }, { a : 3 } 'var', 42, false ], [ { a : 2 }, { a : 3 } ] );
 * // returns false
 *
 * @example
 * var evaluator = ( e ) => e.a;
 * _.longHasAny( [ { a : 2 }, { a : 3 } 'str', 42, false ], [ { a : 2 }, { a : 3 } ], evaluator );
 * // returns true
 *
 * @example
 * var evaluator1 = ( eSrc ) => eSrc.a;
 * var evaluator2 = ( eIns ) => eIns.b;
 * _.longHasAny( [ { a : 2 }, { a : 3 } 'str', 42, false ], [ { b : 2 }, { b : 3 } ], evaluator1, evaluator2 );
 * // returns true
 *
 * @example
 * var equalizer = ( eSrc, eIns ) => eSrc.a === eIns.b;
 * _.longHasAny( [ { a : 2 }, { a : 3 } 'str', 42, false ], [ { b : 2 }, { b : 3 } ], equalizer );
 * // returns true
 *
 * @returns { Boolean } - Returns true, if {-src-} has all elements of {-ins-}, otherwise false is returned.
 * @function longHasAll
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-src-} is not a Long.
 * @throws { Error } If {-ins-} is not a Long, not a primitive.
 * @throws { Error } If {-evaluator1-} is not a routine.
 * @throws { Error } If {-evaluator1-} is an evaluator and accepts less or more than one argument.
 * @throws { Error } If {-evaluator1-} is an equalizer and accepts less or more than two argument.
 * @throws { Error } If {-evaluator2-} is not a routine.
 * @throws { Error } If {-evaluator2-} is an evaluator and accepts less or more than one argument.
 * @namespace Tools
 */

function longHasAll( /* src, ins, evaluator1, evaluator2 */ )
{
  let src = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );
  _.assert( _.longLike( src ), `Expects long, but got ${ _.entity.strType( src ) }` );
  _.assert( _.longLike( ins ) || _.primitive.is( ins ) );

  if( _.primitive.is( ins ) )
  ins = [ ins ];

  if( ins.length === 0 )
  return true;

  let i = 0;
  let result = 0;
  while( result >= 0 && i < ins.length )
  {
    result = _.longLeftIndex( src, ins[ i ], 0, evaluator1, evaluator2 );
    i++;
  }

  if( result !== -1 )
  return true;
  return false;
}

//

/**
 * The routine longHasNone() checks if the source long {-src-} has no one element of the long {-ins-}.
 * It can take equalizer or evaluators for the comparing elements.
 *
 * It iterates over source long {-src-} each element of the long {-ins-} by the routine
 * [longLeftIndex()]{@link wTools.longLeftIndex}
 * Checks, if {-src-} has no one elements of the {-ins-}.
 * If true, it returns true.
 * Otherwise, it returns false.
 *
 * @see {@link wTools.longLeftIndex} - See for more information.
 *
 * @param { Long } src - The source array.
 * @param  { Long|Primitive } ins - The elements to check in the source array.
 * @param { Function } evaluator1 - A callback function. Can be an equalizer or evaluator.
 * @param { Function } evaluator2 - A callback function. Uses only as second evaluator.
 *
 * @example
 * _.longHasNone( [ 5, 'str', 42, false ], 7 );
 * // returns true
 *
 * @example
 * _.longHasNone( [ 5, 'str', 42, false ], [ false, 5, 'str' ] );
 * // returns false
 *
 * @example
 * _.longHasNone( [ { a : 2 }, { a : 3 } 'var', 42, false ], [ { a : 2 }, { a : 3 } ] );
 * // returns true
 *
 * @example
 * var evaluator = ( e ) => e.a;
 * _.longHasNone( [ { a : 2 }, { a : 3 } 'str', 42, false ], [ { a : 2 }, { a : 4 } ], evaluator );
 * // returns false
 *
 * @example
 * var evaluator1 = ( eSrc ) => eSrc.a;
 * var evaluator2 = ( eIns ) => eIns.b;
 * _.longHasNone( [ { a : 2 }, { a : 3 } 'str', 42, false ], [ { b : 2 }, { b : 4 } ], evaluator1, evaluator2 );
 * // returns false
 *
 * @example
 * var equalizer = ( eSrc, eIns ) => eSrc.a === eIns.b;
 * _.longHasNone( [ { a : 2 }, { a : 3 } 'str', 42, false ], [ { b : 2 }, { b : 4 } ], equalizer );
 * // returns false
 *
 * @returns { Boolean } - Returns true, if {-src-} has no one element of {-ins-}, otherwise false is returned.
 * @function longHasAll
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-src-} is not a Long.
 * @throws { Error } If {-ins-} is not a Long, not a primitive.
 * @throws { Error } If {-evaluator1-} is not a routine.
 * @throws { Error } If {-evaluator1-} is an evaluator and accepts less or more than one argument.
 * @throws { Error } If {-evaluator1-} is an equalizer and accepts less or more than two argument.
 * @throws { Error } If {-evaluator2-} is not a routine.
 * @throws { Error } If {-evaluator2-} is an evaluator and accepts less or more than one argument.
 * @namespace Tools
 */

function longHasNone( /* src, ins, evaluator1, evaluator2 */ )
{
  let src = arguments[ 0 ];
  let ins = arguments[ 1 ];
  let evaluator1 = arguments[ 2 ];
  let evaluator2 = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );
  _.assert( _.longLike( src ), `Expects long, but got ${ _.entity.strType( src ) }` );
  _.assert( _.longLike( ins ) || _.primitive.is( ins ) );

  if( _.primitive.is( ins ) )
  ins = [ ins ];

  let i = 0;
  let result;

  do
  {
    result = _.longLeftIndex( src, ins[ i ], 0, evaluator1, evaluator2 );
    i++;
  }
  while( result < 0 && i < ins.length )

  if( result !== -1 )
  return false;
  return true;
}

//

/* aaa : cover please | Dmytro : covered */

function longHasDepth( arr, level = 1 )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.intIs( level ) );

  if( !_.longLike( arr ) )
  return false;

  if( level <= 0 )
  return true;

  for( let a = 0 ; a < arr.length ; a += 1 )
  if( _.longLike( arr[ a ] ) )
  {
    if( _.longHasDepth( arr[ a ], level - 1 ) )
    return true;
  }

  return false;
}

//

function longAll( src )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.longLike( src ) );

  for( let s = 0 ; s < src.length ; s += 1 )
  {
    if( !src[ s ] )
    return false;
  }

  return true;
}

//

function longAny( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.longLike( src ) );

  for( let s = 0 ; s < src.length ; s += 1 )
  if( src[ s ] )
  return true;

  return false;
}

//

function longNone( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.longLike( src ) );

  for( let s = 0 ; s < src.length ; s += 1 )
  if( src[ s ] )
  return false;

  return true;
}

// --
// long sequential search
// --

/**
 * The routine longCountElement() returns the count of matched elements {-element-} in the {-srcArray-} array.
 * Returns 0 if no {-element-} is matched. It can take equalizer or evaluators to check specific equalities.
 *
 * @param { Long } srcArray - The source array.
 * @param { * } element - The value to count matches.
 * @param { Function } onEvaluate1 - It's a callback. If the routine has two parameters, it is used as an equalizer, and if it has only one, then routine used as the evaluator.
 * @param { Function } onEvaluate2 - The second part of evaluator. Accepts the value to search.
 *
 * @example
 * // simple exapmle, no matches
 * _.longCountElement( [ 1, 2, 'str', 10, 10, true ], 3 );
 * // returns 0
 *
 * @example
 * // simple exapmle
 * _.longCountElement( [ 1, 2, 'str', 10, 10, true ], 10 );
 * // returns 2
 *
 * @example
 * // with equalizer
 * _.longCountElement( [ 1, 2, 'str', 10, 10, true ], 10, ( a, b ) => _.typeOf( a ) === _.typeOf( b ) );
 * // returns 4
 *
 * @example
 * // with single evaluator
 * _.longCountElement( [ [ 10 ], [ 10 ], [ 'str' ], [ 10 ], [ false ] ], [ 'str' ], ( e ) => e[ 0 ] );
 * // returns 1
 *
 * @example
 * // with two part of evaluator
 * _.longCountElement( [ [ 10 ], [ 10 ], [ 'str' ], [ 10 ], [ false ] ], 10, ( e ) => e[ 0 ], ( e ) => e );
 * // returns 4
 *
 * @returns { Number } - Returns the count of matched elements {-element-} in the {-srcArray-}.
 * @function longCountElement
 * @throws { Error } If passed arguments is less than two or more than four.
 * @throws { Error } If the first argument is not a Long.
 * @throws { Error } If the third or fourth argument is not a routine.
 * @throws { Error } If the routine in third argument has less than one or more than two arguments.
 * @throws { Error } If the routine in third argument has two arguments and fourth argument is passed into routine longCountElement.
 * @throws { Error } If the routine in fourth argument has less than one or more than one arguments.
 * @namespace Tools
 */

/*
aaa : are all combinations of call of routine arrayCountElement covered? | Dmytro : yes, all combinations of call is implemented
*/

function longCountElement( /* srcArray, element, onEvaluate1, onEvaluate2 */ )
{
  let srcArray = arguments[ 0 ];
  let element = arguments[ 1 ];
  let onEvaluate1 = arguments[ 2 ];
  let onEvaluate2 = arguments[ 3 ];

  let result = 0;

  _.assert( 2 <= arguments.length && arguments.length <= 4 );
  _.assert( _.longLike( srcArray ), 'Expects long' );

  let left = _.longLeftIndex( srcArray, element, onEvaluate1, onEvaluate2 );
  // let index = srcArray.indexOf( element );

  while( left >= 0 )
  {
    result += 1;
    left = _.longLeftIndex( srcArray, element, left+1, onEvaluate1, onEvaluate2 );
    // index = srcArray.indexOf( element, index+1 );
  }

  return result;
}

//

/**
 * The routine longCountTotal() adds all the elements in {-srcArray-}, elements can be numbers or booleans ( it considers them 0 or 1 ).
 *
 * @param { Array } srcArray - The source array.
 *
 * @example
 * _.longCountTotal( [ 1, 2, 10, 10 ] );
 * // returns 23
 *
 * @example
 * _.longCountTotal( [ true, false, false ] );
 * // returns 1
 *
 * @returns { Number } - Returns the sum of the elements in {-srcArray-}.
 * @function longCountTotal
 * @throws { Error } If passed arguments is different than one.
 * @throws { Error } If the first argument is not a Long.
 * @throws { Error } If {-srcArray-} doesnt contain number-like elements.
 * @namespace Tools
 */

function longCountTotal( srcArray )
{
  let result = 0;

  _.assert( arguments.length === 1 );
  _.assert( _.longLike( srcArray ), 'Expects long' );

  for( let i = 0 ; i < srcArray.length ; i++ )
  {
    _.assert( _.bool.is( srcArray[ i ] ) || _.number.is( srcArray[ i ] ) || srcArray[ i ] === null );
    result += srcArray[ i ];
  }

  return result;
}

//

/**
 * The longCountUnique() routine returns the count of matched pairs ([ 1, 1, 2, 2, ., . ]) in the array {-srcMap-}.
 *
 * @param { longLike } src - The source array.
 * @param { Function } [ onEvaluate = function( e ) { return e } ] - A callback function.
 *
 * @example
 * _.longCountUnique( [ 1, 1, 2, 'abc', 'abc', 4, true, true ] );
 * // returns 3
 *
 * @example
 * _.longCountUnique( [ 1, 2, 3, 4, 5 ] );
 * // returns 0
 *
 * @returns { Number } - Returns the count of matched pairs ([ 1, 1, 2, 2, ., . ]) in the array {-srcMap-}.
 * @function longCountUnique
 * @throws { Error } If passed arguments is less than one or more than two.
 * @throws { Error } If the first argument is not an array-like object.
 * @throws { Error } If the second argument is not a Function.
 * @namespace Tools
 */

function longCountUnique( src, onEvaluate )
{
  let found = [];
  onEvaluate = onEvaluate || function( e ){ return e };

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.longLike( src ), 'longCountUnique :', 'Expects ArrayLike' );
  _.assert( _.routine.is( onEvaluate ) );
  _.assert( onEvaluate.length === 1 );

  for( let i1 = 0 ; i1 < src.length ; i1++ )
  {
    let element1 = onEvaluate( src[ i1 ] );
    if( found.indexOf( element1 ) !== -1 )
    continue;

    for( let i2 = i1+1 ; i2 < src.length ; i2++ )
    {

      let element2 = onEvaluate( src[ i2 ] );
      if( found.indexOf( element2 ) !== -1 )
      continue;

      if( element1 === element2 )
      found.push( element1 );

    }

  }

  return found.length;
}

// --
// extension
// --

let Extension =
{

  _longMake_functor,

  // longMake,
  // longMakeEmpty,
  // _longMakeOfLength,
  // longMakeUndefined,
  // longMakeZeroed, /* xxx : review */
  // longMakeFilling,
  /* qqq : check routine longMakeFilling, and add perfect coverage */
  /* qqq : implement routine arrayMakeFilling, and add perfect coverage */

  longFrom, /* aaa2 : cover please | Dmytro : covered */
  longFromCoercing, /* aaa2 : cover please | Dmytro : covered */

  longFill, /* !!! */
  longFill_,
  longDuplicate,

  _longClone,
  _longShallow,
  longSlice : _longShallow,
  longRepresent, /* qqq2 : review. ask */
  longJoin, /* qqq for Dmytro : look, analyze and cover _.buferJoin */
  longEmpty,

  // longBut,
  // longButInplace, /* !!! : use instead of longBut, longButInplace */ /* Dmytro : the coverage of the alternative covers inplace and not inplace versions */
  longBut_,
  // longOnly,
  // longOnlyInplace, /* !!! : use instead of longOnly, longOnlyInplace */ /* Dmytro : the coverage of the alternative covers inplace and not inplace versions */
  longOnly_,
  // longGrow,
  // longGrowInplace, /* !!! : use instead of longGrow, longGrowInplace */ /* Dmytro : the coverage of the alternative covers inplace and not inplace versions */
  longGrow_,
  // longRelength,
  // longRelengthInplace, /* !!! : use instead of longRelength, longRelengthInplace */ /* Dmytro : the coverage of the alternative covers inplace and not inplace versions */
  longRelength_,

  // array checker

  // longCompare,

  // long.identicalShallow,
  // _long.identicalShallow,
  // long.identical : long.identicalShallow,
  // longEquivalentShallow : long.identicalShallow,

  longHas,
  longHasAny,
  longHasAll,
  longHasNone,
  longHasDepth,

  longAll,
  longAny,
  longNone,

  // long sequential search

  longCountElement,
  longCountTotal,
  longCountUnique,

  // to replace

  /*
  | routine          | makes new dst container                  | saves dst container                                     |
  | ---------------- | ---------------------------------------- | ------------------------------------------------------- |
  | longBut_         | _.longBut_( null, src, range )           | _.longBut_( src )                                       |
  |                  | _.longBut_( dst, src, range )            | _.longBut_( src, range )                                |
  |                  | if dst not resizable and change length   | _.longBut_( dst, dst )                                  |
  |                  |                                          | _.longBut_( dst, dst, range ) if dst is resizable       |
  |                  |                                          | or dst not change length                                |
  |                  |                                          | _.longBut_( dst, src, range ) if dst is resizable       |
  |                  |                                          | or dst not change length                                |
  | ---------------  | ---------------------------------------- | ------------------------------------------------------  |
  | longOnly_      | _.longOnly_( null, src, range )        | _.longOnly_( src )                                    |
  |                  | _.longOnly_( dst, src, range )         | _.longOnly_( src, range )                             |
  |                  | if dst not resizable and change length   | _.longOnly_( dst, dst )                               |
  |                  |                                          | _.longOnly_( dst, dst, range ) if dst is resizable    |
  |                  |                                          | or dst not change length                                |
  |                  |                                          | _.longOnly_( dst, src, range ) if dst is resizable    |
  |                  |                                          | or dst not change length                                |
  | ---------------  | ---------------------------------------- | ------------------------------------------------------  |
  | longGrow_        | _.longGrow_( null, src, range )          | _.longGrow_( src )                                      |
  |                  | _.longGrow_( dst, src, range )           | _.longGrow_( src, range )                               |
  |                  | if dst not resizable and change length   | _.longGrow_( dst, dst )                                 |
  |                  | qqq2 : should throw error                | _.longGrow_( dst, dst, range ) if dst is resizable      |
  |                  |  if not resizable                        | or dst not change length                                |
  |                  |                                          | _.longGrow_( dst, src, range ) if dst is resizable      |
  |                  |                                          | or dst not change length                                |
  | ---------------  | ---------------------------------------- | ------------------------------------------------------  |
  | longRelength_    | _.longRelength_( null, src, range )      | _.longRelength_( src )                                  |
  |                  | _.longRelength_( dst, src, range )       | _.longRelength_( src, range )                           |
  |                  | if dst not resizable and change length   | _.longRelength_( dst, dst )                             |
  |                  |                                          | _.longRelength_( dst, dst, range ) if dst is resizable  |
  |                  |                                          | or dst not change length                                |
  |                  |                                          | _.longRelength_( dst, src, range ) if dst is resizable  |
  |                  |                                          | or dst not change length                                |
  | ---------------  | ---------------------------------------- | ------------------------------------------------------- |
  */

}

_.props.supplement( _, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Long.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Long_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Long_s */ })();

/* */  /* begin of file Map_s */ ( function Map_s() { function Map_s_naked() { ( function _l5_Map_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

/* qqq for junior : check each _.aux.is() call, extend tests for each branch | aaa : Done. */
/* qqq for junior : check each !_.primitive.is() call, extend tests for each branch | aaa : Done. */
/* qqq for junior : check each _.vector.is() call, extend tests for each branch | aaa : Done. */

// --
// map selector
// --

/**
 * The mapFirstPair() routine returns first pair [ key, value ] as array.
 *
 * @param { objectLike } srcMap - An object like entity of get first pair.
 *
 * @example
 * _.mapFirstPair( { a : 3, b : 13 } );
 * // returns [ 'a', 3 ]
 *
 * @example
 * _.mapFirstPair( {  } );
 * // returns 'undefined'
 *
 * @example
 * _.mapFirstPair( [ [ 'a', 7 ] ] );
 * // returns [ '0', [ 'a', 7 ] ]
 *
 * @returns { Array } Returns pair [ key, value ] as array if {-srcMap-} has fields, otherwise, undefined.
 * @function mapFirstPair
 * @throws { Error } Will throw an Error if (arguments.length) less than one, if {-srcMap-} is not an object-like.
 * @namespace Tools
 */

function mapFirstPair( srcMap )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.object.like( srcMap ) );

  for( let s in srcMap )
  {
    return [ s, srcMap[ s ] ];
  }

  return [];
}

//

function mapAllValsSet( dstMap, val )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  for( let k in dstMap )
  {
    dstMap[ k ] = val;
  }

  return dstMap;
}

//

function mapValsWithKeys( srcMap, keys )
{
  let result = Object.create( null );

  _.assert( _.argumentsArray.like( keys ) );

  for( let k = 0 ; k < keys.length ; k++ )
  {
    let key = keys[ k ];
    _.assert( _.strIs( key ) || _.number.is( key ) );
    result[ key ] = srcMap[ key ];
  }

  return result;
}

//

/**
 * The mapValWithIndex() returns value of {-srcMap-} by corresponding (index).
 *
 * It takes {-srcMap-} and (index), creates a variable ( i = 0 ),
 * checks if ( index > 0 ), iterate over {-srcMap-} object-like and match
 * if ( i == index ).
 * If true, it returns value of {-srcMap-}.
 * Otherwise it increment ( i++ ) and iterate over {-srcMap-} until it doesn't match index.
 *
 * @param { objectLike } srcMap - An object-like.
 * @param { number } index - To find the position an element.
 *
 * @example
 * _.mapValWithIndex( [ 3, 13, 'c', 7 ], 3 );
 * // returns 7
 *
 * @returns { * } Returns value of {-srcMap-} by corresponding (index).
 * @function mapValWithIndex
 * @throws { Error } Will throw an Error if( arguments.length > 2 ) or {-srcMap-} is not an Object.
 * @namespace Tools
 */

function mapValWithIndex( srcMap, index )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( index < 0 )
  return;

  let i = 0;
  for( let s in srcMap )
  {
    if( i === index )
    return srcMap[ s ];
    i++;
  }
}

//

/**
 * The mapKeyWithIndex() returns key of {-srcMap-} by corresponding (index).
 *
 * It takes {-srcMap-} and (index), creates a variable ( i = 0 ),
 * checks if ( index > 0 ), iterate over {-srcMap-} object-like and match
 * if ( i == index ).
 * If true, it returns value of {-srcMap-}.
 * Otherwise it increment ( i++ ) and iterate over {-srcMap-} until it doesn't match index.
 *
 * @param { objectLike } srcMap - An object-like.
 * @param { number } index - To find the position an element.
 *
 * @example
 * _.mapKeyWithIndex( [ 'a', 'b', 'c', 'd' ], 1 );
 * // returns '1'
 *
 * @returns { string } Returns key of {-srcMap-} by corresponding (index).
 * @function mapKeyWithIndex
 * @throws { Error } Will throw an Error if( arguments.length > 2 ) or {-srcMap-} is not an Object.
 * @namespace Tools
 */

function mapKeyWithIndex( srcMap, index )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.number.intIs( index ) );
  _.assert( _.map.like( srcMap ) );

  if( index < 0 )
  return;

  let i = 0;
  for( let s in srcMap )
  {
    if( i === index )
    return s;
    i++;
  }
}

//

function mapKeyWithValue( srcMap, value )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.map.like( srcMap ) );

  for( let s in srcMap )
  if( srcMap[ s ] === value )
  return s;
}

//

// function mapIndexWithKey( srcMap, key )
// {
//
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//
//   for( let s in srcMap )
//   {
//     if( s === key )
//     return s;
//   }
//
//   return;
// }
//
// //
//
// function mapIndexWithValue( srcMap, value )
// {
//
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//
//   for( let s in srcMap )
//   {
//     if( srcMap[ s ] === value )
//     return s;
//   }
//
//   return;
// }

//

function mapOnlyNulls( srcMap )
{
  let result = Object.create( null );

  _.assert( arguments.length === 1 );
  _.assert( _.map.like( srcMap ) );

  for( let s in srcMap )
  {
    if( srcMap[ s ] === null )
    result[ s ] = null;
  }

  return result;
}

//

function mapButNulls( srcMap )
{
  let result = Object.create( null );

  _.assert( arguments.length === 1 );

  for( let s in srcMap )
  {
    if( srcMap[ s ] !== null )
    result[ s ] = srcMap[ s ];
  }

  return result;
}

// --
// map checker
// --

// /**
//  * The mapsAreIdentical() returns true, if the second object (src2)
//  * has the same values as the first object(src1).
//  *
//  * It takes two objects (scr1, src2), checks
//  * if both object have the same length and [key, value] return true
//  * otherwise it returns false.
//  *
//  * @param { objectLike } src1 - First object.
//  * @param { objectLike } src2 - Target object.
//  * Objects to compare values.
//  *
//  * @example
//  * _.map.identical( { a : 7, b : 13 }, { a : 7, b : 13 } );
//  * // returns true
//  *
//  * @example
//  * _.map.identical( { a : 7, b : 13 }, { a : 33, b : 13 } );
//  * // returns false
//  *
//  * @example
//  * _.map.identical( { a : 7, b : 13, c : 33 }, { a : 7, b : 13 } );
//  * // returns false
//  *
//  * @returns { boolean } Returns true, if the second object (src2)
//  * has the same values as the first object(src1).
//  * @function mapsAreIdentical
//  * @throws Will throw an error if ( arguments.length !== 2 ).
//  * @namespace Tools
//  */
//
// /* xxx qqq : for junior : duplicate in _.props.identical() | aaa : Done */
// /* xxx qqq : for junior : move to _.aux.identical() | aaa : Done */
// function mapsAreIdentical( src1, src2 )
// {
//
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//   _.assert( !_.primitive.is( src1 ) );
//   _.assert( !_.primitive.is( src2 ) );
//
//   if( Object.keys( src1 ).length !== Object.keys( src2 ).length )
//   return false;
//
//   for( let s in src1 )
//   {
//     if( src1[ s ] !== src2[ s ] )
//     return false;
//   }
//
//   return true;
// }
//
// //
//
// /**
//  * The mapContain() returns true, if the first object {-srcMap-}
//  * has the same values as the second object(ins).
//  *
//  * It takes two objects (scr, ins),
//  * checks if the first object {-srcMap-} has the same [key, value] as
//  * the second object (ins).
//  * If true, it returns true,
//  * otherwise it returns false.
//  *
//  * @param { objectLike } src - Target object.
//  * @param { objectLike } ins - Second object.
//  * Objects to compare values.
//  *
//  * @example
//  * _.map.contain( { a : 7, b : 13, c : 15 }, { a : 7, b : 13 } );
//  * // returns true
//  *
//  * @example
//  * _.map.contain( { a : 7, b : 13 }, { a : 7, b : 13, c : 15 } );
//  * // returns false
//  *
//  * @returns { boolean } Returns true, if the first object {-srcMap-}
//  * has the same values as the second object(ins).
//  * @function mapContain
//  * @throws Will throw an error if ( arguments.length !== 2 ).
//  * @namespace Tools
//  */
//
// function mapContain( src, ins )
// {
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//
//   /*
//     if( Object.keys( src ).length < Object.keys( ins ).length )
//     return false;
//   */
//
//   for( let s in ins )
//   {
//
//     if( ins[ s ] === undefined )
//     continue;
//
//     if( src[ s ] !== ins[ s ] )
//     return false;
//
//   }
//
//   return true;
// }

//

/**
 * Checks if object( o.src ) has at least one key/value pair that is represented in( o.template ).
 * Also works with ( o.template ) as routine that check( o.src ) with own rules.
 * @param {wTools.objectSatisfyOptions} o - Default options {@link wTools.objectSatisfyOptions}.
 * @returns { boolean } Returns true if( o.src ) has same key/value pair(s) with( o.template )
 * or result if ( o.template ) routine call is true.
 *
 * @example
 * _.objectSatisfy( {a : 1, b : 1, c : 1 }, { a : 1, b : 2 } );
 * // returns true
 *
 * @example
 * _.objectSatisfy( { template : {a : 1, b : 1, c : 1 }, src : { a : 1, b : 2 } } );
 * // returns true
 *
 * @example
 * function routine( src ){ return src.a === 12 }
 * _.objectSatisfy( { template : routine, src : { a : 1, b : 2 } } );
 * // returns false
 *
 * @function objectSatisfy
 * @throws {exception} If( arguments.length ) is not equal to 1 or 2.
 * @throws {exception} If( o.template ) is not a Object.
 * @throws {exception} If( o.template ) is not a Routine.
 * @throws {exception} If( o.src ) is undefined.
 * @namespace Tools
*/

function objectSatisfy( o )
{

  if( arguments.length === 2 )
  o = { template : arguments[ 0 ], src : arguments[ 1 ] };

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.object.isBasic( o.template ) || _.routine.is( o.template ) );
  _.assert( o.src !== undefined );
  _.routine.options( objectSatisfy, o );

  return _objectSatisfy( o.template, o.src, o.src, o.levels, o.strict );

  /* */

  function _objectSatisfy( /* template, src, root, levels, strict */ )
  {
    let template = arguments[ 0 ];
    let src = arguments[ 1 ];
    let root = arguments[ 2 ];
    let levels = arguments[ 3 ];
    let strict = arguments[ 4 ];

    if( !strict && src === undefined )
    return true;

    if( template === src )
    return true;

    if( levels === 0 )
    {
      if
      (
        _.object.isBasic( template )
        && _.object.isBasic( src )
        && _.routine.is( template.identicalWith )
        && src.identicalWith === template.identicalWith
      )
      return template.identicalWith( src );
      else
      return template === src;
    }
    else if( levels < 0 )
    {
      return false;
    }

    if( _.routine.is( template ) )
    return template( src );

    if( !_.object.isBasic( src ) )
    return false;

    if( _.object.isBasic( template ) )
    {
      for( let t in template )
      {
        let satisfy = false;
        satisfy = _objectSatisfy( template[ t ], src[ t ], root, levels-1, strict );
        if( !satisfy )
        return false;
      }
      return true;
    }

    return false;
  }

}

objectSatisfy.defaults =
{
  template : null,
  src : null,
  levels : 1,
  strict : 1,
}

//

function mapOwnKey( srcMap, key )
{
  // if( srcMap === null )
  // return false;
  // if( srcMap === undefined )
  // return false;
  if( _.primitive.is( srcMap ) )
  return false;
  return Object.hasOwnProperty.call( srcMap, key );
}

//

function mapHasKey( srcMap, key )
{
  if( _.primitive.is( srcMap ) )
  return false;
  if( !Reflect.has( srcMap, key ) )
  return false;
  return true;
}

//

/**
 * The mapOnlyOwnKey() returns true if (object) has own property.
 *
 * It takes (name) checks if (name) is a String,
 * if (object) has own property with the (name).
 * If true, it returns true.
 *
 * @param { Object } object - Object that will be check.
 * @param { name } name - Target property.
 *
 * @example
 * _.mapOnlyOwnKey( { a : 7, b : 13 }, 'a' );
 * // returns true
 *
 * @example
 * _.mapOnlyOwnKey( { a : 7, b : 13 }, 'c' );
 * // returns false
 *
 * @returns { boolean } Returns true if (object) has own property.
 * @function mapOnlyOwnKey
 * @throws { mapOnlyOwnKey } Will throw an error if the (name) is unknown.
 * @namespace Tools
 */

//

function mapOnlyOwnKey( object, key )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( key ) || _.symbolIs( key ), `Expects either string or symbol, but got ${_.entity.strType( key )}`,  );

  if( _.strIs( key ) )
  return Object.hasOwnProperty.call( object, key );
  else if( _.symbol.is( key ) )
  return Object.hasOwnProperty.call( object, key );
  // else if( _.aux.is( key ) )
  // return Object.hasOwnProperty.call( object, _.nameUnfielded( key ).coded );

  // _.assert( 0, 'Unknown type of key :', _.entity.strType( key ) );
}

//

function mapHasVal( object, val )
{
  let vals = _.props.vals( object );
  return vals.indexOf( val ) !== -1;
}

//

function mapOnlyOwnVal( object, val )
{
  let vals = _.props.onlyOwnVals( object );
  return vals.indexOf( val ) !== -1;
}

//

/**
 * The mapHasAll() returns true if object( src ) has all enumerable keys from object( screen ).
 * Values of properties are not checked, only names.
 *
 * Uses for..in to get each key name from object( screen ) and checks if source( src ) has property with same name.
 * Returns true if all keys from( screen ) exists on object( src ), otherwise returns false.
 *
 * @param { ObjectLike } src - Map that will be checked for keys from( screen ).
 * @param { ObjectLike } screen - Map that hold keys.
 *
 * @example
 * _.mapHasAll( {}, {} );
 * // returns true
 *
 * @example
 * _.mapHasAll( {}, { a : 1 } );
 * // returns false
 *
 * @returns { boolean } Returns true if object( src ) has all enumerable keys from( screen ).
 * @function mapHasAll
 * @throws { Exception } Will throw an error if the ( src ) is not a ObjectLike entity.
 * @throws { Exception } Will throw an error if the ( screen ) is not a ObjectLike entity.
 * @namespace Tools
 */

function mapHasAll( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( !( screen[ s ] in src ) )
    return false;
  }
  else if( _.countable.is( screen ) )
  {
    for( let value of screen )
    if( !( value in src ) )
    return false;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( !( k in src ) )
    return false;
  }

  return true;

}

//

/**
 * The mapHasAny() returns true if object( src ) has at least one enumerable key from object( screen ).
 * Values of properties are not checked, only names.
 *
 * Uses for..in to get each key name from object( screen ) and checks if source( src ) has at least one property with same name.
 * Returns true if any key from( screen ) exists on object( src ), otherwise returns false.
 *
 * @param { ObjectLike } src - Map that will be checked for keys from( screen ).
 * @param { ObjectLike|Vector } screen - Map or vector that hold keys.
 *
 * @example
 * _.mapHasAny( {}, {} );
 * // returns false
 *
 * @example
 * _.mapHasAny( { a : 1, b : 2 }, { a : 1 } );
 * // returns true
 *
 * @example
 * _.mapHasAny( { a : 1, b : 2 }, { c : 1 } );
 * // returns false
 *
 * @returns { boolean } Returns true if object( src ) has at least one enumerable key from( screen ).
 * @function mapHasAny
 * @throws { Exception } Will throw an error if the ( src ) is not a ObjectLike entity.
 * @throws { Exception } Will throw an error if the ( screen ) is not a ObjectLike entity.
 * @namespace Tools
 */

/* xxx qqq : for junior : teach to accept vector | aaa : Done. */
/* xxx qqq : for junior : duplicate in _.props.hasAny() | aaa : Done */
function mapHasAny( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( screen[ s ] in src )
    return true;
  }
  else if( _.countable.is( screen ) )
  {
    for( let value of screen )
    if( value in src )
    return true;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( k in src )
    return true;
  }

  return false;
}

//

/**
 * The mapHasAny() returns true if object( src ) has no one enumerable key from object( screen ).
 * Values of properties are not checked, only names.
 *
 * Uses for..in to get each key name from object( screen ) and checks if source( src ) has no one property with same name.
 * Returns true if all keys from( screen ) not exists on object( src ), otherwise returns false.
 *
 * @param { ObjectLike } src - Map that will be checked for keys from( screen ).
 * @param { ObjectLike } screen - Map that hold keys.
 *
 * @example
 * _.mapHasNone( {}, {} );
 * // returns true
 *
 * @example
 * _.mapHasNone( { a : 1, b : 2 }, { a : 1 } );
 * // returns false
 *
 * @example
 * _.mapHasNone( { a : 1, b : 2 }, { c : 1 } );
 * // returns true
 *
 * @returns { boolean } Returns true if object( src ) has at least one enumerable key from( screen ).
 * @function mapHasNone
 * @throws { Exception } Will throw an error if the ( src ) is not a ObjectLike entity.
 * @throws { Exception } Will throw an error if the ( screen ) is not a ObjectLike entity.
 * @namespace Tools
 */

/* qqq : for junior : teach to accept vector | aaa : Done */
/* xxx qqq : for junior : duplicate in _.props.hasNone() | aaa : Done */
function mapHasNone( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( screen[ s ] in src )
    return false;
  }
  else if( _.countable.is( screen ) )
  {
    for( let value of screen )
    if( value in src )
    return false;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( k in src )
    return false;
  }

  return true;
}

//

/**
 * The mapOnlyOwnAll() returns true if object( src ) has all own keys from object( screen ).
 * Values of properties are not checked, only names.
 *
 * Uses for..in to get each key name from object( screen ) and checks if source( src ) has own property with that key name.
 * Returns true if all keys from( screen ) exists on object( src ), otherwise returns false.
 *
 * @param { Object } src - Map that will be checked for keys from( screen ).
 * @param { Object } screen - Map that hold keys.
 *
 * @example
 * _.mapOnlyOwnAll( {}, {} );
 * // returns true
 *
 * @example
 * _.mapOnlyOwnAll( { a : 1, b : 2 }, { a : 1 } );
 * // returns true
 *
 * @example
 * _.mapOnlyOwnAll( { a : 1, b : 2 }, { c : 1 } );
 * // returns false
 *
 * @returns { boolean } Returns true if object( src ) has own properties from( screen ).
 * @function mapOnlyOwnAll
 * @throws { Exception } Will throw an error if the ( src ) is not a ObjectLike entity.
 * @throws { Exception } Will throw an error if the ( screen ) is not a ObjectLike entity.
 * @namespace Tools
 */

/* qqq : for junior : teach to accept vector | aaa : Done. */
function mapOnlyOwnAll( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( !Object.hasOwnProperty.call( src, screen[ s ] ) )
    return false;
  }
  else if( _.countable.is( screen ) )
  {
    for( let value of screen )
    if( !Object.hasOwnProperty.call( src, value ) )
    return false;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( !Object.hasOwnProperty.call( src, k ) )
    return false;
  }

  return true;
}

//

/**
 * The mapOnlyOwnAny() returns true if map( src ) has at least one own property from map( screen ).
 * Values of properties are not checked, only names.
 *
 * Uses for..in to get each key name from map( screen ) and checks if source( src ) has at least one property with that key name.
 * Returns true if one of keys from( screen ) exists on object( src ), otherwise returns false.
 *
 * @param { Object } src - Map that will be checked for keys from( screen ).
 * @param { Object } screen - Map that hold keys.
 *
 * @example
 * _.mapOnlyOwnAny( {}, {} );
 * // returns false
 *
 * @example
 * _.mapOnlyOwnAny( { a : 1, b : 2 }, { a : 1 } );
 * // returns true
 *
 * @example
 * _.mapOnlyOwnAny( { a : 1, b : 2 }, { c : 1 } );
 * // returns false
 *
 * @returns { boolean } Returns true if object( src ) has own properties from( screen ).
 * @function mapOnlyOwnAny
 * @throws { Exception } Will throw an error if the ( src ) is not a map.
 * @throws { Exception } Will throw an error if the ( screen ) is not a map.
 * @namespace Tools
 */

/* qqq : for junior : teach to accept vector | aaa : Done. */
function mapOnlyOwnAny( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( Object.hasOwnProperty.call( src, screen[ s ] ) )
    return true;
  }
  else if( _.countable.is( screen ) )
  {
    for( let value of screen )
    if( Object.hasOwnProperty.call( src, value ) )
    return true;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( Object.hasOwnProperty.call( src, k ) )
    return true;
  }

  return false;
}

//

/**
 * The mapOnlyOwnNone() returns true if map( src ) not owns properties from map( screen ).
 * Values of properties are not checked, only names.
 *
 * Uses for..in to get each key name from object( screen ) and checks if source( src ) has own property with that key name.
 * Returns true if no one key from( screen ) exists on object( src ), otherwise returns false.
 *
 * @param { Object } src - Map that will be checked for keys from( screen ).
 * @param { Object } screen - Map that hold keys.
 *
 * @example
 * _.mapOnlyOwnNone( {}, {} );
 * // returns true
 *
 * @example
 * _.mapOnlyOwnNone( { a : 1, b : 2 }, { a : 1 } );
 * // returns false
 *
 * @example
 * _.mapOnlyOwnNone( { a : 1, b : 2 }, { c : 1 } );
 * // returns true
 *
 * @returns { boolean } Returns true if map( src ) not owns properties from( screen ).
 * @function mapOnlyOwnNone
 * @throws { Exception } Will throw an error if the ( src ) is not a map.
 * @throws { Exception } Will throw an error if the ( screen ) is not a map.
 * @namespace Tools
 */

/* qqq : for junior : teach to accept vector | aaa : Done.*/
/* xxx : move? */
function mapOnlyOwnNone( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( Object.hasOwnProperty.call( src, screen[ s ] ) )
    return false;
  }
  else if( _.countable.is( screen ) )
  {
    for( let value of screen )
    if( Object.hasOwnProperty.call( src, value ) )
    return false;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( Object.hasOwnProperty.call( src, k ) )
    return false;
  }

  return true;
}

//

function mapHasExactly( srcMap, screenMaps )
{
  let result = true;

  _.assert( arguments.length === 2 );

  result = result && _.mapHasOnly( srcMap, screenMaps );
  result = result && _.mapHasAll( srcMap, screenMaps );

  return result;
}

//

function mapOnlyOwnExactly( srcMap, screenMaps )
{
  let result = true;

  _.assert( arguments.length === 2 );

  result = result && _.mapOnlyOwnOnly( srcMap, screenMaps );
  result = result && _.mapOnlyOwnAll( srcMap, screenMaps );

  return result;
}

//

function mapHasOnly( srcMap, screenMaps )
{

  _.assert( arguments.length === 2 );

  let l = arguments.length;
  let but = Object.keys( _.mapBut_( null, srcMap, screenMaps ) );

  if( but.length > 0 )
  return false;

  return true;
}

//

/* xxx : review */
function mapOnlyOwnOnly( srcMap, screenMaps )
{

  _.assert( arguments.length === 2 );

  let l = arguments.length;
  // let but = Object.keys( _.mapOnlyOwnBut_( null, srcMap, screenMaps ) );
  let but = Object.keys( _.mapOnlyOwnButOld( srcMap, screenMaps ) );

  if( but.length > 0 )
  return false;

  return true;
}

//

function mapHasNoUndefine( srcMap )
{

  _.assert( arguments.length === 1 );

  let but = [];
  let l = arguments.length;

  for( let s in srcMap )
  if( srcMap[ s ] === undefined )
  return false;

  return true;
}

// --
// map move
// --

// /**
//  * The mapMake() routine is used to copy the values of all properties
//  * from one or more source objects to the new object.
//  *
//  * @param { ...objectLike } arguments[] - The source object(s).
//  *
//  * @example
//  * _.mapMake( { a : 7, b : 13 }, { c : 3, d : 33 }, { e : 77 } );
//  * // returns { a : 7, b : 13, c : 3, d : 33, e : 77 }
//  *
//  * @returns { objectLike } It will return the new object filled by [ key, value ]
//  * from one or more source objects.
//  * @function mapMake
//  * @namespace Tools
//  */
//
// function mapMake( src )
// {
//   _.assert( arguments.length === 0 || arguments.length === 1 );
//   if( arguments.length <= 1 )
//   if( arguments[ 0 ] === undefined || arguments[ 0 ] === null )
//   return Object.create( null );
//   return _.props.extend( null, src );
// }
//
// //
//
// function mapCloneShallow( src )
// {
//   return _.mapMake( src );
// }

//

/**
 * @callback mapCloneAssigning.onField
 * @param { objectLike } dstContainer - destination object.
 * @param { objectLike } srcContainer - source object.
 * @param { string } key - key to coping from one object to another.
 * @param { function } onField - handler of fields.
 */

/**
 * The mapCloneAssigning() routine is used to clone the values of all
 * enumerable own properties from {-srcMap-} object to an (options.dst) object.
 *
 * It creates two variables:
 * let options = options || {}, result = options.dst || {}.
 * Iterate over {-srcMap-} object, checks if {-srcMap-} object has own properties.
 * If true, it calls the provided callback function( options.onField( result, srcMap, k ) ) for each key (k),
 * and copies each [ key, value ] of the {-srcMap-} to the (result),
 * and after cycle, returns clone with prototype of srcMap.
 *
 * @param { objectLike } srcMap - The source object.
 * @param { Object } o - The options.
 * @param { objectLike } [options.dst = Object.create( null )] - The target object.
 * @param { mapCloneAssigning.onField } [options.onField()] - The callback function to copy each [ key, value ]
 * of the {-srcMap-} to the (result).
 *
 * @example
 * function Example() {
 *   this.name = 'Peter';
 *   this.age = 27;
 * }
 * _.mapCloneAssigning( new Example(), { dst : { sex : 'Male' } } );
 * // returns Example { sex : 'Male', name : 'Peter', age : 27 }
 *
 * @returns { objectLike }  The (result) object gets returned.
 * @function mapCloneAssigning
 * @throws { Error } Will throw an Error if ( o ) is not an Object,
 * if ( arguments.length > 2 ), if (key) is not a String or
 * if {-srcMap-} has not own properties.
 * @namespace Tools
 */

function mapCloneAssigning( o ) /* xxx : review */
{
  o.dstMap = o.dstMap || Object.create( null );

  _.assert( _.mapIs( o ) );
  _.assert( arguments.length === 1, 'Expects {-srcMap-} as argument' );
  _.assert( !_.primitive.is( o.srcMap ), 'Expects {-srcMap-} as argument' );
  _.routine.options( mapCloneAssigning, o );

  if( !o.onField )
  o.onField = function onField( dstContainer, srcContainer, key )
  {
    _.assert( _.strIs( key ) );
    dstContainer[ key ] = srcContainer[ key ];
  }

  for( let k in o.srcMap )
  {
    if( Object.hasOwnProperty.call( o.srcMap, k ) )
    o.onField( o.dstMap, o.srcMap, k, o.onField );
  }

  Object.setPrototypeOf( o.dstMap, Object.getPrototypeOf( o.srcMap ) );

  return o.dstMap;
}

mapCloneAssigning.defaults =
{
  srcMap : null,
  dstMap : null,
  onField : null,
}

//

function mapsExtend( dstMap, srcMaps )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( dstMap ), 'Expects non primitive as the first argument' );

  /* aaa : allow and cover vector */ /* Dmytro : allowed and covered. I think, an optimization for array like vectors has no sense. Otherwise, we need to add single branch with for cycle */
  if( _.countable.is( srcMaps ) )
  for( let srcMap of srcMaps )
  dstMapExtend( srcMap );
  else
  dstMapExtend( srcMaps );

  return dstMap;

  /* */

  function dstMapExtend( srcMap )
  {
    _.assert( !_.primitive.is( srcMap ), 'Expects non primitive' );

    if( Object.getPrototypeOf( srcMap ) === null )
    Object.assign( dstMap, srcMap );
    else for( let k in srcMap )
    dstMap[ k ] = srcMap[ k ];
  }

  // if( dstMap === null )
  // dstMap = Object.create( null );
  //
  // if( srcMaps.length === 1 && Object.getPrototypeOf( srcMaps[ 0 ] ) === null )
  // return Object.assign( dstMap, srcMaps[ 0 ] );
  //
  // if( !_.vector.is( srcMaps ) )
  // srcMaps = [ srcMaps ];
  //
  // _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  // _.assert( _.vector.is( srcMaps ) );
  // _.assert( !_.primitive.is( dstMap ), 'Expects non primitive as the first argument' );
  //
  // /* aaa : allow and cover vector */ /* Dmytro : allowed and covered. I think, an optimization for array like vectors has no sense. Otherwise, we need to add single branch with for cycle */
  // for( let a = 0 ; a < srcMaps.length ; a++ )
  // {
  //   let srcMap = srcMaps[ a ];
  //
  //   _.assert( !_.primitive.is( srcMap ), 'Expects non primitive' );
  //
  //   if( Object.getPrototypeOf( srcMap ) === null )
  //   Object.assign( dstMap, srcMap );
  //   else for( let k in srcMap )
  //   dstMap[ k ] = srcMap[ k ];
  //
  // }
  //
  // return dstMap;
}

//

/**
 * The mapExtendConditional() creates a new [ key, value ]
 * from the next objects if callback function(filter) returns true.
 *
 * It calls a provided callback function(filter) once for each key in an (argument),
 * and adds to the {-srcMap-} all the [ key, value ] for which callback
 * function(filter) returns true.
 *
 * @param { function } filter - The callback function to test each [ key, value ]
 * of the (dstMap) object.
 * @param { objectLike } dstMap - The target object.
 * @param { ...objectLike } arguments[] - The next object.
 *
 * @example
 * _.mapExtendConditional( _.props.mapper.dstNotHas(), { a : 1, b : 2 }, { a : 1 , c : 3 } );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @returns { objectLike } Returns the unique [ key, value ].
 * @function mapExtendConditional
 * @throws { Error } Will throw an Error if ( arguments.length < 3 ), (filter)
 * is not a Function, (result) and (argument) are not the objects.
 * @namespace Tools
 */

function mapExtendConditional( filter, dstMap )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( !!filter );
  // _.assert( filter.functionFamily === 'PropertyMapper' );
  _.assert( _.props.mapperIs( filter ) && !filter.identity.functor );
  _.assert( arguments.length >= 3, 'Expects more arguments' );
  _.assert( _.routine.is( filter ), 'Expects filter' );
  _.assert( !_.primitive.is( dstMap ), 'Expects non primitive as argument' );

  for( let a = 2 ; a < arguments.length ; a++ )
  {
    let srcMap = arguments[ a ];

    _.assert( !_.primitive.is( srcMap ), () => 'Expects object-like entity to extend, but got : ' + _.entity.strType( srcMap ) );

    for( let k in srcMap )
    {

      filter.call( this, dstMap, srcMap, k );

    }

  }

  return dstMap;
}

//

function mapsExtendConditional( filter, dstMap, srcMaps )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( !!filter );
  // _.assert( filter.functionFamily === 'PropertyMapper' );
  _.assert( _.props.mapperIs( filter ) && !filter.identity.functor );
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( _.routine.is( filter ), 'Expects filter' );
  _.assert( !_.primitive.is( dstMap ), 'Expects non primitive as argument' );

  if( _.arrayIs( srcMaps ) )
  for( let a = 0 ; a < srcMaps.length ; a++ )
  {
    let srcMap = srcMaps[ a ];

    _.assert( !_.primitive.is( srcMap ), () => 'Expects object-like entity to extend, but got : ' + _.entity.strType( srcMap ) );

    for( let k in srcMap )
    {
      filter.call( this, dstMap, srcMap, k );
    }
  }
  else /* countable */
  for( let srcMap of srcMaps )
  {
    _.assert( !_.primitive.is( srcMap ), () => 'Expects object-like entity to extend, but got : ' + _.entity.strType( srcMap ) );

    for( let k in srcMap )
    {
      filter.call( this, dstMap, srcMap, k );
    }
  }

  return dstMap;
}

//

function mapExtendHiding( dstMap )
{
  return _.mapExtendConditional( _.props.mapper.hiding(), ... arguments );
}

//

function mapsExtendHiding( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  return _.mapsExtendConditional( _.props.mapper.hiding(), dstMap, srcMaps );
}

//

function mapExtendAppending( dstMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  return _.mapExtendConditional( _.props.mapper.appendingAnything(), ... arguments );
}

//

function mapsExtendAppending( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  if( dstMap === null )
  return _.props.extend( null, srcMaps[ 0 ] );
  return _.mapsExtendConditional( _.props.mapper.appendingAnything(), dstMap, srcMaps );
}

//

function mapExtendPrepending( dstMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  return _.mapExtendConditional( _.props.mapper.prependingAnything(), ... arguments );
}

//

function mapsExtendPrepending( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  if( dstMap === null )
  return _.props.extend( null, srcMaps[ 0 ] );
  return _.mapsExtendConditional( _.props.mapper.prependingAnything(), dstMap, srcMaps );
}

//

function mapExtendAppendingOnlyArrays( dstMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  return _.mapExtendConditional( _.props.mapper.appendingOnlyArrays(), ... arguments );
}

//

function mapsExtendAppendingOnlyArrays( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  if( dstMap === null )
  return _.props.extend( null, srcMaps[ 0 ] );
  return _.mapsExtendConditional( _.props.mapper.appendingOnlyArrays(), dstMap, srcMaps );
}

//

function mapExtendByDefined( dstMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  return _.mapExtendConditional( _.props.mapper.srcDefined(), ... arguments );
}

//

function mapsExtendByDefined( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  return _.mapsExtendConditional( _.props.mapper.srcDefined(), dstMap, srcMaps );
}

//

function mapExtendNulls( dstMap )
{
  return _.mapExtendConditional( _.props.mapper.dstNotHasOrSrcNotNull(), ... arguments );
}

//

function mapsExtendNulls( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  return _.mapsExtendConditional( _.props.mapper.dstNotHasOrSrcNotNull(), dstMap, srcMaps );
}

//

function mapExtendDstNotOwn( dstMap, srcMap )
{
  if( dstMap === null && arguments.length === 2 )
  return _.props.extend( dstMap, srcMap );
  return _.mapExtendConditional( _.props.mapper.dstNotOwn(), ... arguments );
}

//

function mapsExtendDstNotOwn( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  if( dstMap === null )
  return _.props.extend( null, srcMaps[ 0 ] );
  return _.mapsExtendConditional( _.props.mapper.dstNotOwn(), dstMap, srcMaps );
}

//

function mapExtendNotIdentical( dstMap, srcMap )
{
  if( dstMap === null && arguments.length === 2 )
  return _.props.extend( dstMap, srcMap );
  return _.mapExtendConditional( _.props.mapper.notIdentical(), ... arguments );
}

//

function mapsExtendNotIdentical( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  if( dstMap === null )
  return _.props.extend( null, srcMaps[ 0 ] );
  return _.mapsExtendConditional( _.props.mapper.notIdentical(), dstMap, srcMaps );
}

//

function mapSupplementByMaps( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  if( dstMap === null )
  return _.props.extend( null, srcMaps[ 0 ] );
  return _.mapsExtendConditional( _.props.mapper.dstNotHas(), dstMap, srcMaps );
}

//

function mapSupplementNulls( dstMap )
{
  return _.mapExtendConditional( _.props.mapper.dstNotHasOrHasNull(), ... arguments );
}

//

function mapSupplementNils( dstMap )
{
  return _.mapExtendConditional( _.props.mapper.dstNotHasOrHasNil(), ... arguments );
}

//

function mapSupplementAssigning( dstMap )
{
  return _.mapExtendConditional( _.props.mapper.dstNotHasAssigning(), ... arguments );
}

//

function mapSupplementAppending( dstMap )
{
  if( dstMap === null && arguments.length === 2 )
  return Object.assign( Object.create( null ), srcMap );
  return _.mapExtendConditional( _.props.mapper.dstNotHasAppending(), ... arguments );
}

//

function mapsSupplementAppending( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  return _.mapsExtendConditional( _.props.mapper.dstNotHasAppending(), dstMap, srcMaps );
}

//

function mapSupplementOwnAssigning( dstMap )
{
  return _.mapExtendConditional( _.props.mapper.dstNotOwnAssigning(), ... arguments );
}

//

/**
 * The routine mapComplement() complements {-dstMap-} by one or several {-srcMap-}. Routine does not change
 * defined pairs key-value in {-dstMap-}.
 * If {-dstMap-} and {-srcMap-} has equal keys, and value of {-dstMap-} is undefined, then routine
 * mapComplement() changes it to {-srcMap-} value.
 * If pair key-value does not exists in {-dstMap-}, then routine appends this pair to {-dstMap-}.
 *
 * @param { objectLike } dstMap - ObjectLike entity to be complemented.
 * @param { ...objectLike } srcMap - The source object(s).
 *
 * @example
 * _.mapComplement( { a : 1, b : 2, c : 3 }, { a : 4, b : 5, c : 6, d : 7 } );
 * // returns { a : 1, b : 3, c : 3, d : 7 };
 *
 * @example
 * _.mapComplement( { a : 1, b : 2, c : 3 }, { a : 4, b : 5 }, { c : 6, d : 7 } );
 * // returns { a : 1, b : 3, c : 3, d : 7 };
 *
 * @example
 * _.mapComplement( { a : 1, b : 2, c : undefined }, { a : 4, b : 5, c : 6, d : 7 } );
 * // returns { a : 1, b : 3, c : 6, d : 7 };
 *
 * @example
 * _.mapComplement( { a : 1, b : 2, c : undefined }, { a : 4, b : 5 }, { c : 6, d : 7 } );
 * // returns { a : 1, b : 3, c : 6, d : 7 };
 *
 * @returns { objectLike } - Returns the destination object filled by unique values from source object(s), and if it is possible, replaced undefined
 * values in destination object.
 * @function mapComplement
 * @namespace Tools
 */

function mapComplement( dstMap, srcMap )
{
  dstNotOwnOrUndefinedAssigning.identity = { propertyMapper : true, propertyTransformer : true };
  return _.mapExtendConditional( dstNotOwnOrUndefinedAssigning, ... arguments );

  function dstNotOwnOrUndefinedAssigning( dstContainer, srcContainer, key )
  {
    if( Object.hasOwnProperty.call( dstContainer, key ) )
    {
      if( dstContainer[ key ] !== undefined )
      return;
    }
    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }

}

//

function mapsComplement( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  return _.mapsExtendConditional( _.props.mapper.dstNotOwnOrUndefinedAssigning(), dstMap, srcMaps );
}

//

function mapComplementReplacingUndefines( dstMap, srcMap )
{
  _.assert( !!_.props.mapper );
  return _.mapExtendConditional( _.props.mapper.dstNotOwnOrUndefinedAssigning(), ... arguments );
}

//

function mapsComplementReplacingUndefines( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  return _.mapsExtendConditional( _.props.mapper.dstNotOwnOrUndefinedAssigning(), dstMap, srcMaps );
}

//

function mapComplementPreservingUndefines( dstMap )
{
  return _.mapExtendConditional( _.props.mapper.dstNotOwnAssigning(), ... arguments );
}

//

function mapsComplementPreservingUndefines( dstMap, srcMaps )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  return _.mapsExtendConditional( _.props.mapper.dstNotOwnAssigning(), dstMap, srcMaps );
}

// --
// map recursive
// --

function mapExtendRecursiveConditional( filters, dstMap, srcMap )
{
  _.assert( arguments.length >= 3, 'Expects at least three arguments' );
  // _.assert( this === Self );
  let srcMaps = _.longSlice( arguments, 2 );
  return _.mapsExtendRecursiveConditional( filters, dstMap, srcMaps );
}

//

function _filterTrue(){ return true };
_filterTrue.identity = { propertyCondition : true, propertyTransformer : true };
function _filterFalse(){ return true };
_filterFalse.identity = { propertyCondition : true, propertyTransformer : true };

function mapsExtendRecursiveConditional( filters, dstMap, srcMaps )
{

  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  // _.assert( this === Self );

  if( _.routine.is( filters ) )
  filters = { onUpFilter : filters, onField : filters }

  if( filters.onUpFilter === undefined )
  filters.onUpFilter = filters.onField;
  else if( filters.onUpFilter === true )
  filters.onUpFilter = _filterTrue;
  else if( filters.onUpFilter === false )
  filters.onUpFilter = _filterFalse;

  if( filters.onField === true )
  filters.onField = _filterTrue;
  else if( filters.onField === false )
  filters.onField = _filterFalse;

  _.assert( _.routine.is( filters.onUpFilter ) );
  _.assert( _.routine.is( filters.onField ) );
  // _.assert( _.props.conditionIs( filters.onUpFilter ) );
  _.assert( _.props.conditionIs( filters.onUpFilter ) && !filters.onUpFilter.identity.functor, 'Expects PropertyFilter {-propertyCondition-}' );
  _.assert( _.props.transformerIs( filters.onField ) );
  // _.assert( filters.onUpFilter.functionFamily === 'PropertyFilter' );
  // _.assert( filters.onField.functionFamily === 'PropertyFilter' || filters.onField.functionFamily === 'PropertyMapper' );

  if( _.arrayIs( srcMaps ) )
  for( let a = 0 ; a < srcMaps.length ; a++ )
  {
    let srcMap = srcMaps[ a ];
    _mapExtendRecursiveConditional( filters, dstMap, srcMap );
  }
  else /* countable */
  {
    for( let srcMap of srcMaps )
    _mapExtendRecursiveConditional( filters, dstMap, srcMap );
  }

  return dstMap;
}

//

function _mapExtendRecursiveConditional( filters, dstMap, srcMap )
{

  _.assert( _.aux.is( srcMap ) );

  for( let s in srcMap )
  {

    if( _.aux.is( srcMap[ s ] ) )
    {

      if( filters.onUpFilter( dstMap, srcMap, s ) === true )
      {
        if( !_.object.isBasic( dstMap[ s ] ) )
        dstMap[ s ] = Object.create( null );
        _._mapExtendRecursiveConditional( filters, dstMap[ s ], srcMap[ s ] );
      }

    }
    else
    {

      if( filters.onField( dstMap, srcMap, s ) === true )
      dstMap[ s ] = srcMap[ s ];

    }

  }

  return dstMap;
}

//

function mapExtendRecursive( dstMap, srcMap )
{

  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  // _.assert( this === Self );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    srcMap = arguments[ a ];
    _._mapExtendRecursive( dstMap, srcMap );
  }

  return dstMap;
}

//

function mapsExtendRecursive( dstMap, srcMaps )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  // _.assert( this === Self );

  if( _.arrayIs( srcMaps ) )
  for( let a = 1 ; a < srcMaps.length ; a++ )
  {
    let srcMap = srcMaps[ a ];
    _._mapExtendRecursive( dstMap, srcMap );
  }
  else /* countable */
  {
    for( let srcMap of srcMaps )
    _._mapExtendRecursive( dstMap, srcMap );
  }

  return dstMap;
}

//

function _mapExtendRecursive( dstMap, srcMap )
{

  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( _.aux.is( srcMap ) );

  for( let s in srcMap )
  {

    if( _.aux.is( srcMap[ s ] ) )
    {

      if( !_.aux.is( dstMap[ s ] ) )
      dstMap[ s ] = Object.create( null );
      _._mapExtendRecursive( dstMap[ s ], srcMap[ s ] );

    }
    else
    {

      dstMap[ s ] = srcMap[ s ];

    }

  }

}

//

function mapExtendAppendingAnythingRecursive( dstMap, srcMap )
{
  // _.assert( this === Self );
  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  let filters = { onField : _.props.mapper.appendingAnything(), onUpFilter : true };
  return _.mapExtendRecursiveConditional( filters, ... arguments );
}

//

function mapsExtendAppendingAnythingRecursive( dstMap, srcMaps )
{
  // _.assert( this === Self );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  let filters = { onField : _.props.mapper.appendingAnything(), onUpFilter : true };
  return _.mapsExtendRecursiveConditional.call( _, filters, dstMap, srcMaps );
}

//

function mapExtendAppendingArraysRecursive( dstMap, srcMap )
{
  // _.assert( this === Self );
  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  let filters = { onField : _.props.mapper.appendingOnlyArrays(), onUpFilter : true };
  return _.mapExtendRecursiveConditional( filters, ... arguments );
}

//

function mapsExtendAppendingArraysRecursive( dstMap, srcMaps )
{
  // _.assert( this === Self );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  let filters = { onField : _.props.mapper.appendingOnlyArrays(), onUpFilter : true };
  return _.mapsExtendRecursiveConditional.call( _, filters, dstMap, srcMaps );
}

//

function mapExtendAppendingOnceRecursive( dstMap, srcMap )
{
  // _.assert( this === Self );
  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  let filters = { onField : _.props.mapper.appendingOnce(), onUpFilter : true };
  return _.mapExtendRecursiveConditional( filters, ... arguments );
}

//

function mapsExtendAppendingOnceRecursive( dstMap, srcMaps )
{
  // _.assert( this === Self );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  let filters = { onField : _.props.mapper.appendingOnce(), onUpFilter : true };
  return _.mapsExtendRecursiveConditional.call( _, filters, dstMap, srcMaps );
}

//

function mapSupplementRecursive( dstMap, srcMap )
{
  // _.assert( this === Self );
  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  let filters = { onField : _.props.mapper.dstNotHas(), onUpFilter : true };
  return _.mapExtendRecursiveConditional( filters, ... arguments );
}

//

function mapSupplementByMapsRecursive( dstMap, srcMaps )
{
  // _.assert( this === Self );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  let filters = { onField : _.props.mapper.dstNotHas(), onUpFilter : true };
  return _.mapsExtendRecursiveConditional.call( _, filters, dstMap, srcMaps );
}

//

function mapSupplementOwnRecursive( dstMap, srcMap )
{
  // _.assert( this === Self );
  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  let filters = { onField : _.props.mapper.dstOwn(), onUpFilter : true };
  return _.mapExtendRecursiveConditional( filters, ... arguments );
}

//

function mapsSupplementOwnRecursive( dstMap, srcMaps )
{
  // _.assert( this === Self );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  let filters = { onField : _.props.mapper.dstOwn(), onUpFilter : true };
  return _.mapsExtendRecursiveConditional.call( _, filters, dstMap, srcMaps );
}

//

function mapSupplementRemovingRecursive( dstMap, srcMap )
{
  // _.assert( this === Self );
  _.assert( arguments.length >= 2, 'Expects at least two arguments' );
  let filters = { onField : _.props.mapper.removing(), onUpFilter : true };
  return _.mapExtendRecursiveConditional( filters, ... arguments );
}

//

function mapSupplementByMapsRemovingRecursive( dstMap, srcMaps )
{
  // _.assert( this === Self );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  let filters = { onField : _.props.mapper.removing(), onUpFilter : true };
  return _.mapsExtendRecursiveConditional.call( _, filters, dstMap, srcMaps );
}

// --
// map selector
// --

/**
 * The mapOnlyPrimitives() gets all object`s {-srcMap-} enumerable atomic fields( null, undef, number, string, symbol ) and returns them as new map.
 *
 * It takes an object {-srcMap-} creates an empty map,
 * checks if {-srcMap-} is an object.
 * If true, it copies object`s {-srcMap-} enumerable atomic properties to the new map using
 * their original name/value and returns the result, otherwise it returns empty map.
 *
 * @param { objectLike } srcMap - Object to get a map of atomic properties.
 *
 * @example
 * let a = {};
 * Object.defineProperty( a, 'x', { enumerable : 0, value : 3 } )
 * _.mapOnlyPrimitives( a );
 * // returns {}
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2, c : function(){} };
 * Object.setPrototypeOf( a, b );
 * _.mapOnlyPrimitives( a );
 * // returns { a : 1, b : 2 }
 *
 * @returns { object } A new map with all atomic fields from source {-srcMap-}.
 * @function mapOnlyPrimitives
 * @throws { Error } Will throw an Error if {-srcMap-} is not an Object.
 * @namespace Tools
 */

function mapOnlyPrimitives( srcMap )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( !_.primitive.is( srcMap ) );

  let result = _.mapExtendConditional( _.props.mapper.primitive(), Object.create( null ), srcMap );
  return result;
}

// --
// map manipulator
// --

function mapSetWithKeys( dstMap, key, val )
{
  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( _.object.isBasic( dstMap ) );
  _.assert( _.strIs( key ) || _.countable.is( key ) );
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );

  /* aaa : allow and cover vector */ /* Dmytro : implemented and covered */
  if( _.countable.is( key ) )
  {
    if( _.argumentsArray.like( key ) )
    for( let s = 0 ; s < key.length ; s++ )
    set( dstMap, key[ s ], val );
    else
    for( let value of key )
    set( dstMap, value, val );
  }
  else
  {
    set( dstMap, key, val );
  }

  return dstMap;

  /* */

  function set( dstMap, key, val )
  {
    if( val === undefined )
    delete dstMap[ key ];
    else
    dstMap[ key ] = val;
  }
}

//

function mapSetWithKeyStrictly( dstMap, key, val )
{
  if( dstMap === null )
  dstMap = Object.create( null );

  _.assert( _.object.isBasic( dstMap ) );
  _.assert( _.strIs( key ) || _.countable.is( key ) );
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );

  /* aaa : allow and cover vector */ /* Dmytro : implemented and covered */
  if( _.countable.is( key ) )
  {
    if( _.argumentsArray.like( key ) )
    for( let s = 0 ; s < key.length ; s++ )
    set( dstMap, key[ s ], val );
    else
    for( let value of key )
    set( dstMap, value, val );
  }
  else
  {
    set( dstMap, key, val );
  }

  return dstMap;

  function set( dstMap, key, val )
  {
    if( val === undefined )
    {
      delete dstMap[ key ];
    }
    else
    {
      _.assert( dstMap[ key ] === undefined || dstMap[ key ] === val );
      dstMap[ key ] = val;
    }
  }
}

// --
// map getter
// --

function mapInvert( src, dst )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  return _._mapInvert({ src, dst });
}

mapInvert.defaults =
{
  src : null,
  dst : null,
  duplicate : 'error',
}

//

function _mapInvert( o )
{
  _.routine.options( _mapInvert, o );

  o.dst = o.dst || Object.create( null );

  _.assert( arguments.length === 1, 'Expects exactly one argument' );
  _.assert( !_.primitive.is( o.src ) );
  _.assert( !_.primitive.is( o.dst ) );
  /* qqq : for junior : bad : lack of important assert */

  let del;
  if( o.duplicate === 'delete' )
  del = Object.create( null );

  /* */

  for( let k in o.src )
  {
    let e = o.src[ k ];
    if( o.duplicate === 'delete' )
    if( o.dst[ e ] !== undefined )
    {
      del[ e ] = k;
      continue;
    }
    if( o.duplicate === 'array' || o.duplicate === 'array-with-value' )
    {
      if( o.dst[ e ] === undefined )
      o.dst[ e ] = o.duplicate === 'array-with-value' ? [ e ] : [];
      o.dst[ e ].push( k );
    }
    else
    {
      _.assert( o.dst[ e ] === undefined, 'Cant invert the map, it has several keys with value', o.src[ k ] );
      o.dst[ e ] = k;
    }
  }

  /* */

  if( o.duplicate === 'delete' )
  _.mapDelete( o.dst, del );

  return o.dst;
}

_mapInvert.defaults =
{
  src : null,
  dst : null,
  duplicate : 'error',
}

//

function mapInvertDroppingDuplicates( src, dst )
{
  dst = dst || Object.create( null );

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( !_.primitive.is( src ) );

  let drop;

  for( let s in src )
  {
    if( dst[ src[ s ] ] !== undefined )
    {
      drop = drop || Object.create( null );
      drop[ src[ s ] ] = true;
    }
    dst[ src[ s ] ] = s;
  }

  if( drop )
  for( let d in drop )
  {
    delete dst[ d ];
  }

  return dst;
}

//

function mapsFlatten( o )
{

  if( _.countable.is( o ) )
  o = { src : o };

  _.routine.options( mapsFlatten, o );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( o.delimeter === false || o.delimeter === 0 || _.strIs( o.delimeter ) );
  _.assert( _.countable.is( o.src ) || _.aux.is( o.src ) ); /* xxx */

  o.dst = o.dst || Object.create( null );
  extend( o.src, '' );

  return o.dst;

  /* */

  function extend( src, prefix )
  {

    /* aaa : allow and cover vector */ /* Dmytro : extended, covered */
    if( _.countable.is( src ) )
    {
      if( _.argumentsArray.like( src ) )
      for( let s = 0 ; s < src.length ; s++ )
      extend( src[ s ], prefix );
      else
      for( let value of src )
      extend( value, prefix );
    }
    else if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        let key = k;
        if( _.strIs( o.delimeter ) )
        key = ( prefix ? prefix + o.delimeter : '' ) + k;

        if( _.aux.is( src[ k ] ) )
        {
          extend( src[ k ], key );
        }
        else
        {
          _.assert( !!o.allowingCollision || o.dst[ key ] === undefined );
          o.dst[ key ] = src[ k ];
        }
      }

    }
    else
    {
      _.assert( 0, 'Expects map or array of maps, but got ' + _.entity.strType( src ) );
    }
  }

}

mapsFlatten.defaults =
{
  src : null,
  dst : null,
  allowingCollision : 0,
  delimeter : '/',
}

// //
//
// /**
//  * The mapToArray() converts an object {-srcMap-} into array [ [ key, value ] ... ].
//  *
//  * It takes an object {-srcMap-} creates an empty array,
//  * checks if ( arguments.length === 1 ) and {-srcMap-} is an object.
//  * If true, it returns a list of [ [ key, value ] ... ] pairs.
//  * Otherwise it throws an Error.
//  *
//  * @param { objectLike } src - object to get a list of [ key, value ] pairs.
//  *
//  * @example
//  * _.mapToArray( { a : 3, b : 13, c : 7 } );
//  * // returns [ [ 'a', 3 ], [ 'b', 13 ], [ 'c', 7 ] ]
//  *
//  * @returns { array } Returns a list of [ [ key, value ] ... ] pairs.
//  * @function mapToArray
//  * @throws { Error } Will throw an Error if( arguments.length !== 1 ) or {-srcMap-} is not an object.
//  * @namespace Tools
//  */
//
// function mapToArray( src, o )
// {
//   _.assert( this === _ );
//   return _.map.pairs( ... arguments );
// }

//

/**
 * The mapToStr() routine converts and returns the passed object {-srcMap-} to the string.
 *
 * It takes an object and two strings (keyValSep) and (tupleSep),
 * checks if (keyValSep and tupleSep) are strings.
 * If false, it assigns them defaults ( ' : ' ) to the (keyValSep) and
 * ( '; ' ) to the tupleSep.
 * Otherwise, it returns a string representing the passed object {-srcMap-}.
 *
 * @param { objectLike } src - The object to convert to the string.
 * @param { string } [ keyValSep = ' : ' ] keyValSep - colon.
 * @param { string } [ tupleSep = '; ' ] tupleSep - semicolon.
 *
 * @example
 * _.mapToStr( { a : 1, b : 2, c : 3, d : 4 }, ' : ', '; ' );
 * // returns 'a : 1; b : 2; c : 3; d : 4'
 *
 * @example
 * _.mapToStr( [ 1, 2, 3 ], ' : ', '; ' );
 * // returns '0 : 1; 1 : 2; 2 : 3';
 *
 * @example
 * _.mapToStr( 'abc', ' : ', '; ' );
 * // returns '0 : a; 1 : b; 2 : c';
 *
 * @returns { string } Returns a string (result) representing the passed object {-srcMap-}.
 * @function mapToStr
 * @namespace Tools
 */

function mapToStr( o )
{

  if( _.strIs( o ) )
  o = { src : o }

  _.routine.options( mapToStr, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  let result = '';
  for( let s in o.src )
  {
    result += s + o.keyValDelimeter + o.src[ s ] + o.entryDelimeter;
  }

  result = result.substr( 0, result.length-o.entryDelimeter.length );

  return result
}

mapToStr.defaults =
{
  src : null,
  keyValDelimeter : ':',
  entryDelimeter : ';',
}

//

function fromHashMap( dstMap, srcMap )
{

  if( arguments.length === 1 )
  {
    srcMap = arguments[ 0 ];
    dstMap = null;
  }

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.hashMap.is( srcMap ) );
  _.assert( !_.primitiveIs( dstMap ) || dstMap === null );

  if( dstMap === null )
  dstMap = Object.create( null );

  for( let pair of srcMap )
  {
    dstMap[ pair[ 0 ] ] = pair[ 1 ];
  }

  return dstMap
}

// --
// map logical operator
// --

/**
 * The mapButConditional() routine returns a new object (result)
 * whose (values) are not equal to the arrays or objects.
 *
 * Takes any number of objects.
 * If the first object has same key any other object has
 * then this pair [ key, value ] will not be included into (result) object.
 * Otherwise,
 * it calls a provided callback function( _.props.mapper.primitive() )
 * once for each key in the {-srcMap-}, and adds to the (result) object
 * all the [ key, value ],
 * if values are not equal to the array or object.
 *
 * @param { function } filter.primitive() - Callback function to test each [ key, value ] of the {-srcMap-} object.
 * @param { objectLike } srcMap - The target object.
 * @param { ...objectLike } arguments[] - The next objects.
 *
 * @example
 * _.mapButConditional_( null, _.props.mapper.primitive(), { a : 1, b : 'b', c : [ 1, 2, 3 ] } );
 * // returns { a : 1, b : "b" }
 *
 * @returns { object } Returns an object whose (values) are not equal to the arrays or objects.
 * @function mapButConditional
 * @throws { Error } Will throw an Error if {-srcMap-} is not an object.
 * @namespace Tools
 */

function mapButConditionalOld( propertyCondition, srcMap, butMap )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( !_.primitive.is( butMap ), 'Expects non primitive {-butMap-}' );
  _.assert( !_.primitive.is( srcMap ), 'Expects non primitive {-srcMap-}' );
  _.assert( propertyCondition && propertyCondition.length === 3, 'Expects PropertyFilter {-propertyCondition-}' );
  _.assert( _.props.conditionIs( propertyCondition ) && !propertyCondition.identity.functor, 'Expects PropertyFilter {-propertyCondition-}' );

  let result = Object.create( null );

  /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  if( _.countable.is( butMap ) )
  {
    let filterRoutines = [ filterWithVectorButMap, filterWithArrayLikeButMap ];
    let arrayLikeIs = _.argumentsArray.like( butMap ) ? 1 : 0;
    for( let s in srcMap )
    {
      let butKey = filterRoutines[ arrayLikeIs ]( s );
      if( butKey === undefined )
      result[ s ] = srcMap[ s ];
    }
  }
  else
  {
    for( let s in srcMap )
    {
      if( propertyCondition( butMap, srcMap, s ) )
      result[ s ] = srcMap[ s ];
    }
  }

  return result;

  /* */

  function filterWithVectorButMap( s )
  {
    for( let but of butMap )
    if( !propertyCondition( but, srcMap, s ) )
    return s;
  }

  /* */

  function filterWithArrayLikeButMap( s )
  {
    for( let m = 0 ; m < butMap.length ; m++ )
    if( !propertyCondition( butMap[ m ], srcMap, s ) )
    return s;
  }
}

//

function mapButConditional_( /* propertyCondition, dstMap, srcMap, butMap */ )
{
  // _.assert( arguments.length === 3 || arguments.length === 4, 'Expects three or four arguments' );

  _.assert( arguments.length === 4, 'Not clear how to construct {-dstMap-}. Please, specify exactly 4 arguments' );

  let propertyCondition = arguments[ 0 ];
  let dstMap = arguments[ 1 ];
  let srcMap = arguments[ 2 ];
  let butMap = arguments[ 3 ];

  if( dstMap === null )
  dstMap = arguments[ 1 ] = Object.create( null );

  // if( arguments.length === 3 )
  // {
  //   butMap = arguments[ 2 ];
  //   srcMap = arguments[ 1 ];
  // }

  /* */

  let o =
  {
    filter : propertyCondition,
    dstMap,
    srcMap,
    butMap,
  };

  o = _._mapBut_VerifyMapFields( o );
  _.assert( _.routineIs( o.filter ) && o.filter.length === 3, 'Expects filter {-o.filter-}' );
  _.assert( _.props.conditionIs( o.filter ), 'Expects PropertyFilter {-o.filter-}' );

  let filterRoutine = _._mapBut_FilterFunctor( o );

  for( let key in o.srcMap )
  filterRoutine( key );

  return o.dstMap;


  // return _._mapBut_
  // ({
  //   filter : propertyCondition,
  //   dstMap,
  //   srcMap,
  //   butMap,
  // });

  // _.assert( arguments.length === 3 || arguments.length === 4, 'Expects three or four arguments' );
  // _.assert( _.routineIs( propertyCondition ) && propertyCondition.length === 3, 'Expects PropertyFilter {-propertyCondition-}' );
  // _.assert( _.props.conditionIs( propertyCondition ) && !propertyCondition.identity.functor, 'Expects PropertyFilter {-propertyCondition-}' );
  // _.assert( !_.primitive.is( dstMap ), 'Expects map like {-dstMap-}' );
  // _.assert( !_.primitive.is( srcMap ) || _.longIs( srcMap ), 'Expects map {-srcMap-}' );
  // _.assert( !_.primitive.is( butMap ) || _.longIs( butMap ) || _.routineIs( butMap ), 'Expects object like {-butMap-}' );
  //
  // if( dstMap === srcMap )
  // {
  //
  //   /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  //   if( _.vector.is( butMap ) )
  //   {
  //     for( let s in srcMap )
  //     {
  //       for( let m = 0 ; m < butMap.length ; m++ )
  //       {
  //         if( !propertyCondition( butMap[ m ], srcMap, s ) )
  //         delete dstMap[ s ];
  //       }
  //     }
  //   }
  //   else
  //   {
  //     for( let s in srcMap )
  //     {
  //       if( !propertyCondition( butMap, srcMap, s ) )
  //       delete dstMap[ s ];
  //     }
  //   }
  //
  // }
  // else
  // {
  //
  //   /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  //   if( _.vector.is( butMap ) )
  //   {
  //     /* aaa : for Dmytro : bad */ /* Dmytro : for butMap types implemented two cyles. Types of elements is checked in filters */
  //     for( let s in srcMap )
  //     {
  //       let m;
  //       for( m = 0 ; m < butMap.length ; m++ )
  //       if( !propertyCondition( butMap[ m ], srcMap, s ) )
  //       break;
  //
  //       if( m === butMap.length )
  //       dstMap[ s ] = srcMap[ s ];
  //     }
  //   }
  //   else
  //   {
  //     for( let s in srcMap )
  //     {
  //       if( propertyCondition( butMap, srcMap, s ) )
  //       dstMap[ s ] = srcMap[ s ];
  //     }
  //   }
  //
  // }
  //
  // return dstMap;
}

//

/**
 * Returns new object with unique pairs key-value from {-srcMap-} screened by screen map {-butMap-}.
 *
 * from the first {-srcMap-} original object.
 * Values for result object come from original object {-srcMap-}
 * not from second or other one.
 * If the first object has same key any other object has
 * then this pair( key/value ) will not be included into result object.
 * Otherwise pair( key/value ) from the first object goes into result object.
 *
 * @param{ objectLike } srcMap - original object.
 * @param{ ...objectLike } arguments[] - one or more objects.
 * Objects to return an object without repeating keys.
 *
 * @example
 * _.mapBut_( null, { a : 7, b : 13, c : 3 }, { a : 7, b : 13 } );
 * // returns { c : 3 }
 *
 * Returns new object filled by unique keys
 * @throws { Error }
 *  In debug mode it throws an error if any argument is not object like.
 * @returns { object } Returns new object made by unique keys.
 * @function mapBut
 * @namespace Tools
 */

function mapButOld( srcMap, butMap )
{
  let result = Object.create( null );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( srcMap ), 'Expects map {-srcMap-}' );

  /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  if( _.countable.is( butMap ) )
  {
    let filterRoutines = [ filterWithVectorButMap, filterWithArrayLikeButMap ];
    let arrayLikeIs = _.argumentsArray.like( butMap ) ? 1 : 0;
    for( let s in srcMap )
    {
      let butKey = filterRoutines[ arrayLikeIs ]( s );
      if( butKey === undefined )
      result[ s ] = srcMap[ s ];
    }

    // /* aaa : for Dmytro : bad */ /* Dmytro : improved, used checks with types */
    // for( let s in srcMap )
    // {
    //   let m;
    //   for( m = 0 ; m < butMap.length ; m++ )
    //   {
    //     /* aaa : for Dmytro : write GOOD coverage */ /* Dmytro : coverage extended */
    //     if( _.primitive.is( butMap[ m ] ) )
    //     {
    //       if( s === butMap[ m ] )
    //       break;
    //     }
    //     else
    //     {
    //       if( s in butMap[ m ] )
    //       break;
    //     }
    //     //
    //     // if( s === butMap[ m ] )
    //     // break;
    //     // if( _.aux.is( butMap[ m ] ) )
    //     // if( s in butMap[ m ] )
    //     // break;
    //   }
    //
    //   if( m === butMap.length )
    //   result[ s ] = srcMap[ s ];
    // }
  }
  else if( !_.primitive.is( butMap ) )
  {
    for( let s in srcMap )
    {
      if( !( s in butMap ) )
      result[ s ] = srcMap[ s ];
    }
  }
  else
  {
    _.assert( 0, 'Expects object-like or long-like {-butMap-}' ); /* xxx */
  }

  return result;

  /* */

  function filterWithVectorButMap( s )
  {
    for( let but of butMap )
    {
      if( _.primitive.is( but ) )
      {
        if( s === but )
        return s;
      }
      else if( _.aux.is( but ) )
      {
        if( s in but )
        return s;
      }
      else
      {
        _.assert( 0, 'Unexpected type of element' );
      }
    }
  }

  /* */

  function filterWithArrayLikeButMap( s )
  {
    for( let m = 0 ; m < butMap.length ; m++ )
    {
      if( _.primitive.is( butMap[ m ] ) )
      {
        if( s === butMap[ m ] )
        return s;
      }
      else if( _.aux.is( butMap[ m ] ) )
      {
        if( s in butMap[ m ] )
        return s;
      }
      else
      {
        _.assert( 0, 'Unexpected type of element' );
      }
    }
  }
}

//

function mapBut_( dstMap, srcMap, butMap )
{
  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );

  if( dstMap === null )
  dstMap = arguments[ 0 ] = arguments[ 0 ] || Object.create( null );

  _.assert( arguments.length === 3, 'Not clear how to construct {-dstMap-}. Please, specify exactly 3 arguments' );
  // if( arguments.length === 2 )
  // {
  //   butMap = arguments[ 1 ];
  //   srcMap = arguments[ 0 ];
  // }

  /* */

  let o =
  {
    dstMap,
    srcMap,
    butMap,
  };

  o = _._mapBut_VerifyMapFields( o );

  let mapsAreIdentical = o.dstMap === o.srcMap ? 1 : 0;
  let butMapsIsCountable = _.countable.is( o.butMap ) ? 2 : 0;
  let filterRoutines =
  [
    filterNotIdenticalWithAuxScreenMap,
    filterIdenticalWithAuxScreenMap,
    filterNotIdenticalWithVectorScreenMap,
    filterIdenticalWithVectorScreenMap
  ];
  let key = mapsAreIdentical + butMapsIsCountable;
  let filterRoutine = filterRoutines[ key ];
  let searchingRoutine;
  if( butMapsIsCountable )
  searchingRoutine = _screenMapSearchingRoutineFunctor( o.butMap );

  for( let key in o.srcMap )
  filterRoutine( key );

  return o.dstMap;

  /* */

  function filterNotIdenticalWithAuxScreenMap( key )
  {
    if( !( key in o.butMap ) )
    o.dstMap[ key ] = o.srcMap[ key ];
  }

  /* */

  function filterIdenticalWithAuxScreenMap( key )
  {
    if( key in o.butMap )
    delete o.dstMap[ key ];
  }

  /* */

  function filterNotIdenticalWithVectorScreenMap( key )
  {
    let butKey = searchingRoutine( o.butMap, key );
    if( butKey !== undefined )
    return;

    o.dstMap[ key ] = o.srcMap[ key ];
  }

  /* */

  function filterIdenticalWithVectorScreenMap( key )
  {
    let butKey = searchingRoutine( o.butMap, key );
    if( butKey !== undefined )
    delete o.dstMap[ key ];
  }

  // let filter = _.props.conditionFrom( filterBut );
  //
  // return _._mapBut_
  // ({
  //   filter,
  //   dstMap,
  //   srcMap,
  //   butMap,
  // });
  //
  // /* */
  //
  // /* qqq : for Dmytro : bad : not optimal */
  // function filterBut( butMap, srcMap, key )
  // {
  //   if( _.aux.is( butMap ) )
  //   {
  //     if( !( key in butMap ) )
  //     return key;
  //   }
  //   else if( _.primitive.is( butMap ) )
  //   {
  //     if( key !== butMap )
  //     return key;
  //   }
  // }
  // filterBut.identity = { propertyCondition : true, propertyTransformer : true };
  //
  // _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );
  // _.assert( !_.primitive.is( dstMap ), 'Expects map like destination map {-dstMap-}' );
  // _.assert( !_.primitive.is( srcMap ) || _.longIs( srcMap ), 'Expects long or map {-srcMap-}' );
  // _.assert( !_.primitive.is( butMap ) || _.longIs( butMap ) || _.routineIs( butMap ), 'Expects object like {-butMap-}' );
  //
  // if( dstMap === srcMap )
  // {
  //
  //   /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  //   if( _.vector.is( butMap ) )
  //   {
  //     /* aaa : for Dmytro : bad */ /* Dmytro : for butMap types implemented two cyles. Types of elements is checked in filters */
  //     for( let s in srcMap )
  //     {
  //       for( let m = 0 ; m < butMap.length ; m++ )
  //       {
  //         /* aaa : for Dmytro : write GOOD coverage */ /* Dmytro : coverage extended */
  //         if( _.aux.is( butMap[ m ] ) )
  //         {
  //           if( s in butMap[ m ] )
  //           delete dstMap[ s ];
  //         }
  //         else
  //         {
  //           if( s === butMap[ m ] )
  //           delete dstMap[ s ];
  //         }
  //       }
  //     }
  //   }
  //   else
  //   {
  //     for( let s in srcMap )
  //     {
  //       if( s in butMap )
  //       delete dstMap[ s ];
  //     }
  //   }
  //
  // }
  // else
  // {
  //
  //   /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  //   if( _.vector.is( butMap ) )
  //   {
  //     /* aaa : for Dmytro : bad */ /* Dmytro : for butMap types implemented two cyles. Types of elements is checked in filters */
  //     for( let s in srcMap )
  //     {
  //       let m;
  //       for( m = 0 ; m < butMap.length ; m++ )
  //       {
  //         /* aaa : for Dmytro : was bad implementation. cover */ /* Dmytro : improved, implemented, covered */
  //         if( _.primitiveIs( butMap[ m ] ) )
  //         {
  //           if( s === butMap[ m ] )
  //           break;
  //         }
  //         else
  //         {
  //           if( s in butMap[ m ] )
  //           break;
  //         }
  //       }
  //
  //       if( m === butMap.length )
  //       dstMap[ s ] = srcMap[ s ];
  //     }
  //   }
  //   else
  //   {
  //     for( let s in srcMap )
  //     {
  //       if( !( s in butMap ) )
  //       dstMap[ s ] = srcMap[ s ];
  //     }
  //   }
  //
  // }
  //
  // return dstMap;
}

//

function _mapBut_VerifyMapFields( o )
{
  _.assert( arguments.length === 1, 'Expects single options map {-o-}' );
  _.assert( !_.primitive.is( o.dstMap ), 'Expects non primitive {-o.dstMap-}' );
  _.assert( !_.primitive.is( o.srcMap ), 'Expects non primitive {-o.srcMap-}' );
  _.assert( !_.primitive.is( o.butMap ), 'Expects object like {-o.butMap-}' );
  _.assert( !_.vector.is( o.dstMap ), 'Expects aux like {-o.dstMap-}' );
  return o;
}

//

function _mapBut_FilterFunctor( o )
{
  let mapsAreIdentical = o.dstMap === o.srcMap ? 1 : 0;
  let butMapIsCountable = _.countable.is( o.butMap ) ? 2 : 0;
  if( _.argumentsArray.like( o.butMap ) )
  butMapIsCountable += 2;
  let filterRoutines =
  [
    filterNotIdentical,
    filterIdentical,
    filterNotIdenticalWithVectorButMap,
    filterIdenticalWithVectorButMap,
    filterNotIdenticalWithArrayButMap,
    filterIdenticalWithArrayButMap,
  ];

  return filterRoutines[ mapsAreIdentical + butMapIsCountable ];

  /* */

  function filterNotIdentical( key )
  {
    if( o.filter( o.butMap, o.srcMap, key ) )
    o.dstMap[ key ] = o.srcMap[ key ];
  }

  /* */

  function filterIdentical( key )
  {
    if( !o.filter( o.butMap, o.srcMap, key ) )
    delete o.dstMap[ key ];
  }

  /* */

  function filterNotIdenticalWithArrayButMap( key )
  {
    for( let m = 0 ; m < o.butMap.length ; m++ )
    if( _.primitive.is( o.butMap[ m ] ) || _.aux.is( o.butMap[ m ] ) )
    {
      if( !o.filter( o.butMap[ m ], o.srcMap, key ) )
      return;
    }
    o.dstMap[ key ] = o.srcMap[ key ];
  }

  /* */

  function filterNotIdenticalWithVectorButMap( key )
  {
    for( let but of o.butMap )
    if( _.primitive.is( but ) || _.aux.is( but ) )
    {
      if( !o.filter( but, o.srcMap, key ) )
      return;
    }
    o.dstMap[ key ] = o.srcMap[ key ];
  }

  /* */

  function filterIdenticalWithArrayButMap( key )
  {
    for( let m = 0 ; m < o.butMap.length ; m++ )
    if( _.primitive.is( o.butMap[ m ] ) )
    {
      if( !o.filter( o.butMap[ m ], o.srcMap, key ) )
      delete o.dstMap[ key ];
    }
  }

  /* */

  function filterIdenticalWithVectorButMap( key )
  {
    for( let but of o.butMap )
    if( _.primitive.is( but ) )
    {
      if( !o.filter( but, o.srcMap, key ) )
      delete o.dstMap[ key ];
    }
  }
}
//
// //
//
// function _mapBut_( o )
// {
//   _.assert( arguments.length === 1, 'Expects single options map {-o-}' );
//   _.assert( _.routineIs( o.filter ) && o.filter.length === 3, 'Expects filter {-o.filter-}' );
//   _.assert( _.props.conditionIs( o.filter ), 'Expects PropertyFilter {-o.filter-}' );
//   _.assert( !_.primitive.is( o.dstMap ), 'Expects non primitive {-o.dstMap-}' );
//   _.assert( !_.primitive.is( o.srcMap ), 'Expects non primitive {-o.srcMap-}' );
//   _.assert( !_.primitive.is( o.butMap ), 'Expects object like {-o.butMap-}' );
//   _.assert( !_.vector.is( o.dstMap ), 'Expects aux like {-o.dstMap-}' );
//   // _.assert( !_.primitive.is( o.butMap ) || _.vector.is( o.butMap ) || _.routineIs( o.butMap ), 'Expects object like {-o.butMap-}' );
//
//   let mapsAreIdentical = o.dstMap === o.srcMap ? 1 : 0;
//   let butMapIsVector = _.vector.is( o.butMap ) ? 2 : 0;
//   let filterRoutines =
//   [
//     filterNotIdentical,
//     filterIdentical,
//     filterNotIdenticalWithVectorButMap,
//     filterIdenticalWithVectorButMap
//   ];
//   let key = mapsAreIdentical + butMapIsVector;
//
//   for( let s in o.srcMap )
//   filterRoutines[ key ]( s );
//
//   return o.dstMap;
//
//   /* */
//
//   function filterNotIdentical( key )
//   {
//     if( o.filter( o.butMap, o.srcMap, key ) )
//     o.dstMap[ key ] = o.srcMap[ key ];
//   }
//
//   /* */
//
//   function filterIdentical( key )
//   {
//     if( !o.filter( o.butMap, o.srcMap, key ) )
//     delete o.dstMap[ key ];
//   }
//
//   /* */
//
//   function filterNotIdenticalWithVectorButMap( key )
//   {
//     /* aaa : for Dmytro : bad */ /* Dmytro : for butMap types implemented two cyles. Types of elements is checked in filters */
//     if( _.argumentsArray.like( o.butMap ) )
//     {
//       for( let m = 0 ; m < o.butMap.length ; m++ )
//       if( _.primitive.is( o.butMap[ m ] ) || _.aux.is( o.butMap[ m ] ) )
//       {
//         if( !o.filter( o.butMap[ m ], o.srcMap, key ) )
//         return;
//       }
//       // if( _.primitive.is( o.butMap[ m ] ) )
//       // {
//       //   if( !o.filter( o.butMap[ m ], o.srcMap, key ) )
//       //   return;
//       // }
//       o.dstMap[ key ] = o.srcMap[ key ];
//     }
//     else
//     {
//       for( let but of o.butMap )
//       if( _.primitive.is( but ) || _.aux.is( but ) )
//       {
//         if( !o.filter( but, o.srcMap, key ) )
//         return;
//       }
//       // if( _.primitive.is( but ) )
//       // {
//       //   if( !o.filter( but, o.srcMap, key ) )
//       //   return;
//       // }
//       o.dstMap[ key ] = o.srcMap[ key ];
//     }
//   }
//
//   /* */
//
//   function filterIdenticalWithVectorButMap( key )
//   {
//     if( _.argumentsArray.like( o.butMap ) )
//     {
//       for( let m = 0 ; m < o.butMap.length ; m++ )
//       if( _.primitive.is( o.butMap[ m ] ) )
//       {
//         if( !o.filter( o.butMap[ m ], o.srcMap, key ) )
//         delete o.dstMap[ key ];
//       }
//     }
//     else
//     {
//       for( let but of o.butMap )
//       if( _.primitive.is( but ) )
//       {
//         if( !o.filter( but, o.srcMap, key ) )
//         delete o.dstMap[ key ];
//       }
//     }
//   }
//
//   // if( o.dstMap === o.srcMap )
//   // {
//   //
//   //   /* aaa : allow and cover vector */ /* Dmytro : allowed, covered */
//   //   if( _.vector.is( o.butMap ) )
//   //   {
//   //     for( let s in o.srcMap )
//   //     {
//   //       for( let m = 0 ; m < o.butMap.length ; m++ )
//   //       {
//   //         if( !o.filter( o.butMap[ m ], o.srcMap, s ) )
//   //         delete o.dstMap[ s ];
//   //       }
//   //     }
//   //   }
//   //   else
//   //   {
//   //     for( let s in o.srcMap )
//   //     {
//   //       if( !o.filter( o.butMap, o.srcMap, s ) )
//   //       delete o.dstMap[ s ];
//   //     }
//   //   }
//   //
//   // }
//   // else
//   // {
//   //
//   //   /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
//   //   if( _.vector.is( o.butMap ) )
//   //   {
//   //      /* aaa : for Dmytro : bad */ /* Dmytro : for butMap types implemented two cyles. Types of elements is checked in filters */
//   //     for( let s in o.srcMap )
//   //     {
//   //       let m;
//   //       for( m = 0 ; m < o.butMap.length ; m++ )
//   //       if( !o.filter( o.butMap[ m ], o.srcMap, s ) )
//   //       break;
//   //
//   //       if( m === o.butMap.length )
//   //       o.dstMap[ s ] = o.srcMap[ s ];
//   //     }
//   //   }
//   //   else
//   //   {
//   //     for( let s in o.srcMap )
//   //     {
//   //       if( o.filter( o.butMap, o.srcMap, s ) )
//   //       o.dstMap[ s ] = o.srcMap[ s ];
//   //     }
//   //   }
//   //
//   // }
//   //
//   // return o.dstMap;
// }

//

function mapDelete( dstMap, ins )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( !_.primitive.is( dstMap ) );
  if( ins === undefined )
  return _.mapEmpty( dstMap );
  return _.mapBut_( dstMap, dstMap, ins );
}

//

function mapEmpty( dstMap )
{

  _.assert( arguments.length === 1 );
  _.assert( !_.primitive.is( dstMap ) );

  for( let i in dstMap )
  {
    delete dstMap[ i ];
  }

  return dstMap;
}

//

/**
 * Returns new object with unique keys.
 *
 * Takes any number of objects.
 * Returns new object filled by unique keys
 * from the first {-srcMap-} original object.
 * Values for result object come from original object {-srcMap-}
 * not from second or other one.
 * If the first object has same key any other object has
 * then this pair( key/value ) will not be included into result object.
 * Otherwise pair( key/value ) from the first object goes into result object.
 *
 * @param{ objectLike } srcMap - original object.
 * @param{ ...objectLike } arguments[] - one or more objects.
 * Objects to return an object without repeating keys.
 *
 * @example
 * _.mapButIgnoringUndefines( { a : 7, b : 13, c : 3 }, { a : 7, b : 13 } );
 * // returns { c : 3 }
 *
 * @throws { Error }
 *  In debug mode it throws an error if any argument is not object like.
 * @returns { object } Returns new object made by unique keys.
 * @function mapButIgnoringUndefines
 * @namespace Tools
 */

// function mapButIgnoringUndefines( srcMap, butMap )
// {
//   let result = Object.create( null );
//
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//
//   return _.mapButConditional_( null, _.props.condition.dstUndefinedSrcNotUndefined(), srcMap, butMap );
// }

//

function mapButIgnoringUndefines_( dstMap, srcMap, butMap )
{

  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );

  return _.mapButConditional_( _.props.condition.dstUndefinedSrcNotUndefined(), ... arguments );

}

//

/**
 * The mapOnlyOwnBut() returns new object with unique own keys.
 *
 * Takes any number of objects.
 * Returns new object filled by unique own keys
 * from the first {-srcMap-} original object.
 * Values for (result) object come from original object {-srcMap-}
 * not from second or other one.
 * If {-srcMap-} does not have own properties it skips rest of code and checks another properties.
 * If the first object has same key any other object has
 * then this pair( key/value ) will not be included into result object.
 * Otherwise pair( key/value ) from the first object goes into result object.
 *
 * @param { objectLike } srcMap - The original object.
 * @param { ...objectLike } arguments[] - One or more objects.
 *
 * @example
 * _.mapBut_( null, { a : 7, 'toString' : 5 }, { b : 33, c : 77 } );
 * // returns { a : 7 }
 *
 * @returns { object } Returns new (result) object with unique own keys.
 * @function mapOnlyOwnBut
 * @throws { Error } Will throw an Error if {-srcMap-} is not an object.
 * @namespace Tools
 */

function mapOnlyOwnButOld( srcMap, butMap )
{
  let result = Object.create( null );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  return _.mapButConditionalOld( _.props.condition.dstNotHasSrcOwn(), srcMap, butMap );
}

//

function mapOnlyOwnBut_( dstMap, srcMap, butMap )
{

  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );

  return _.mapButConditional_( _.props.condition.dstNotHasSrcOwn(), ... arguments );
}

//

/**
 * @typedef screenMaps
 * @property { objectLike } screenMaps.screenMap - The first object.
 * @property { ...objectLike } srcMap.arguments[1, ...] -
 * The pseudo array (arguments[]) from the first [1] index to the end.
 * @property { object } dstMap - The empty object.
 * @namespace Tools
 */

/**
 * The mapOnly() returns an object filled by unique [ key, value ]
 * from others objects.
 *
 * It takes number of objects, creates a new object by three properties
 * and calls the _mapOnly( {} ) with created object.
 *
 * @see  {@link wTools._mapOnly} - See for more information.
 *
 * @param { objectLike } screenMap - The first object.
 * @param { ...objectLike } arguments[] - One or more objects.
 *
 * @example
 * _.mapOnly_( null, { a : 13, b : 77, c : 3, d : 'name' }, { d : 'name', c : 33, a : 'abc' } );
 * // returns { a : "abc", c : 33, d : "name" };
 *
 * @returns { Object } Returns the object filled by unique [ key, value ]
 * from others objects.
 * @function mapOnly
 * @throws { Error } Will throw an Error if (arguments.length < 2) or (arguments.length !== 2).
 * @namespace Tools
 */

function mapOnlyOld( srcMaps, screenMaps )
{
  if( arguments.length === 1 )
  return _.mapsExtend( null, srcMaps );

  _.assert( arguments.length === 2, 'Expects single or two arguments' );

  return _._mapOnly
  ({
    srcMaps,
    screenMaps,
    dstMap : Object.create( null ),
  });
}

//

function mapOnly_( dstMap, srcMaps, screenMaps )
{


  if( arguments.length === 1 )
  return _.mapsExtend( null, dstMap );

  _.assert( arguments.length === 3, 'Not clear how to construct {-dstMap-}. Please, specify exactly 3 arguments' );

  // else if( arguments.length === 2 )
  // {
  //
  //   // return _.mapOnlyOld( srcMaps, screenMaps );
  //
  //   // aaa : for Dmytro : bad! /* Dmytro : this condition allow modify srcMaps if passed only 2 arguments */
  //   if( dstMap === null )
  //   return Object.create( null );
  //   screenMaps = arguments[ 1 ];
  //   srcMaps = arguments[ 0 ];
  // }
  // else if( arguments.length !== 3 )
  // {
  //   _.assert( 0, 'Expects at least one argument and no more then three arguments' );
  // }

  let o = _._mapOnly_VerifyMapFields
  ({
    srcMaps,
    screenMaps,
    dstMap : dstMap || Object.create( null ),
  });

  let mapsAreIdentical = o.dstMap === o.srcMaps ? 1 : 0;
  let screenMapsIsCountable = _.countable.is( o.screenMaps ) ? 2 : 0;
  let filterRoutines =
  [
    filterNotIdenticalWithAuxScreenMap,
    filterIdenticalWithAuxScreenMap,
    filterNotIdenticalWithVectorScreenMap,
    filterIdenticalWithVectorScreenMap
  ];
  let key = mapsAreIdentical + screenMapsIsCountable;
  let filterRoutine = filterRoutines[ key ];
  let searchingRoutine;
  if( screenMapsIsCountable )
  searchingRoutine = _screenMapSearchingRoutineFunctor( o.screenMaps );

  if( _.countable.is( o.srcMaps ) )
  {
    for( let srcMap of o.srcMaps )
    {
      _.assert( !_.primitive.is( srcMap ), 'Expects no primitive in {-o.srcMaps-}' );
      filterRoutine( srcMap );
    }
  }
  else
  {
    filterRoutine( o.srcMaps );
  }

  return o.dstMap;

  /* */

  function filterNotIdenticalWithVectorScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      let screenKey = searchingRoutine( o.screenMaps, key );
      if( screenKey !== undefined )
      o.dstMap[ screenKey ] = srcMap[ screenKey ];
    }
  }

  /* */

  function filterIdenticalWithVectorScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      let screenKey = searchingRoutine( o.screenMaps, key );
      if( screenKey === undefined )
      delete srcMap[ key ];
    }
  }

  /* */

  function filterNotIdenticalWithAuxScreenMap( srcMap )
  {
    for( let key in o.screenMaps )
    {
      if( o.screenMaps[ key ] === undefined )
      continue;

      if( key in srcMap )
      o.dstMap[ key ] = srcMap[ key ];
    }
  }


  /* */

  function filterIdenticalWithAuxScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      if( !( key in o.screenMaps ) )
      delete srcMap[ key ];
    }
  }

  // return _.mapOnlyOld( srcMaps, screenMaps );
  // aaa : for Dmytro : bad! /* Dmytro : improved, optimized */

  // return _._mapOnly_
  // ({
  //   srcMaps,
  //   screenMaps,
  //   dstMap,
  // });

}

// //
//
// function mapOnlyOwn( srcMaps, screenMaps )
// {
//
//   if( arguments.length === 1 )
//   return _.mapsExtendConditional( _.props.mapper.srcOwn(), null, srcMaps );
//
//   _.assert( arguments.length === 1 || arguments.length === 2, 'Expects single or two arguments' );
//
//   return _._mapOnly
//   ({
//     filter : _.props.mapper.srcOwn(),
//     srcMaps,
//     screenMaps,
//     dstMap : Object.create( null ),
//   });
//
// }

//

function mapOnlyOwn_( dstMap, srcMaps, screenMaps )
{

  if( arguments.length === 1 )
  return _.mapsExtendConditional( _.props.mapper.srcOwn(), null, _.array.as( dstMap ) );

  _.assert( arguments.length === 3, 'Not clear how to construct {-dstMap-}. Please, specify exactly 3 arguments' );

  // else if( arguments.length === 2 )
  // {
  //   if( dstMap === null )
  //   return Object.create( null );
  //
  //   screenMaps = arguments[ 1 ];
  //   srcMaps = arguments[ 0 ];
  // }
  // else if( arguments.length !== 3 )
  // {
  //   _.assert( 0, 'Expects at least one argument and no more then three arguments' );
  // }

  let o = _._mapOnly_VerifyMapFields
  ({
    filter : _.props.mapper.srcOwn(),
    srcMaps,
    screenMaps,
    dstMap : dstMap || Object.create( null ),
  });

  _.assert( _.props.mapperIs( o.filter ), 'Expects PropertyFilter {-o.filter-}' );

  let filterRoutine = _._mapOnly_FilterFunctor( o );

  if( _.countable.is( o.srcMaps ) )
  {
    for( let srcMap of o.srcMaps )
    {
      _.assert( !_.primitive.is( srcMap ), 'Expects no primitive in {-o.srcMaps-}' );
      filterRoutine( srcMap );
    }
  }
  else
  {
    filterRoutine( o.srcMaps );
  }

  return o.dstMap;

  // return _._mapOnly_
  // ({
  //   filter : _.props.mapper.srcOwn(),
  //   srcMaps,
  //   screenMaps,
  //   dstMap,
  // });

}

//

// function mapOnlyComplementing( srcMaps, screenMaps )
// {
//
//   _.assert( arguments.length === 1 || arguments.length === 2, 'Expects single or two arguments' );
//
//   return _._mapOnly
//   ({
//     filter : _.props.mapper.dstNotOwnOrUndefinedAssigning(),
//     srcMaps,
//     screenMaps,
//     dstMap : Object.create( null ),
//   });
//
// }

//

function mapOnlyComplementing_( dstMap, srcMaps, screenMaps )
{

  _.assert( arguments.length === 3, 'Not clear how to construct {-dstMap-}. Please, specify exactly 3 arguments' );

  // if( arguments.length === 2 )
  // {
  //   if( dstMap === null )
  //   return Object.create( null );
  //
  //   screenMaps = arguments[ 1 ];
  //   srcMaps = arguments[ 0 ];
  // }
  // else if( arguments.length !== 3 )
  // {
  //   _.assert( 0, 'Expects two or three arguments' );
  // }

  let o = _._mapOnly_VerifyMapFields
  ({
    filter : _.props.mapper.dstNotOwnOrUndefinedAssigning(),
    srcMaps,
    screenMaps,
    dstMap : dstMap || Object.create( null ),
  });

  _.assert( _.props.mapperIs( o.filter ), 'Expects PropertyFilter {-o.filter-}' );

  let filterRoutine = _._mapOnly_FilterFunctor( o );

  if( _.countable.is( o.srcMaps ) )
  {
    for( let srcMap of o.srcMaps )
    {
      _.assert( !_.primitive.is( srcMap ), 'Expects no primitive in {-o.srcMaps-}' );
      filterRoutine( srcMap );
    }
  }
  else
  {
    filterRoutine( o.srcMaps );
  }

  return o.dstMap;

  // return _._mapOnly_
  // ({
  //   filter : _.props.mapper.dstNotOwnOrUndefinedAssigning(),
  //   srcMaps,
  //   screenMaps,
  //   dstMap,
  // });

}

//

/**
 * @callback  options.filter
 * @param { objectLike } dstMap - An empty object.
 * @param { objectLike } srcMaps - The target object.
 * @param { string } - The key of the (screenMap).
 */

/**
 * The _mapOnly() returns an object filled by unique [ key, value]
 * from others objects.
 *
 * The _mapOnly() checks whether there are the keys of
 * the (screenMap) in the list of (srcMaps).
 * If true, it calls a provided callback function(filter)
 * and adds to the (dstMap) all the [ key, value ]
 * for which callback function returns true.
 *
 * @param { function } [options.filter = filter.bypass()] options.filter - The callback function.
 * @param { objectLike } options.srcMaps - The target object.
 * @param { objectLike } options.screenMaps - The source object.
 * @param { Object } [options.dstMap = Object.create( null )] options.dstMap - The empty object.
 *
 * @example
 * let options = Object.create( null );
 * options.dstMap = Object.create( null );
 * options.screenMaps = { 'a' : 13, 'b' : 77, 'c' : 3, 'name' : 'Mikle' };
 * options.srcMaps = { 'a' : 33, 'd' : 'name', 'name' : 'Mikle', 'c' : 33 };
 * _mapOnly( options );
 * // returns { a : 33, c : 33, name : "Mikle" };
 *
 * @example
 * let options = Object.create( null );
 * options.dstMap = Object.create( null );
 * options.screenMaps = { a : 13, b : 77, c : 3, d : 'name' };
 * options.srcMaps = { d : 'name', c : 33, a : 'abc' };
 * _mapOnly( options );
 * // returns { a : "abc", c : 33, d : "name" };
 *
 * @returns { Object } Returns an object filled by unique [ key, value ]
 * from others objects.
 * @function _mapOnly
 * @throws { Error } Will throw an Error if (options.dstMap or screenMap) are not objects,
 * or if (srcMaps) is not an array
 * @namespace Tools
 */

/* xxx : qqq : for Dmytro : comment out */
function _mapOnly( o )
{
  let self = this;

  o.dstMap = o.dstMap || Object.create( null );
  o.filter = o.filter || _.props.mapper.bypass();

  _.assert( arguments.length === 1, 'Expects single options map {-o-}' );
  _.assert( _.props.mapperIs( o.filter ), 'Expects PropertyFilter {-o.filter-}' );
  _.assert( !_.primitive.is( o.dstMap ), 'Expects non primitive {-o.dstMap-}' );
  _.assert( !_.primitive.is( o.screenMaps ), 'Expects non primitive {-o.screenMaps-}' );
  _.assert( !_.primitive.is( o.srcMaps ), 'Expects non primitive {-srcMap-}' );
  _.map.assertHasOnly( o, _mapOnly.defaults );

  /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
  if( _.countable.is( o.srcMaps ) )
  for( let srcMap of o.srcMaps )
  {
    _.assert( !_.primitive.is( srcMap ), 'Expects non primitive {-srcMap-}' );

    if( _.countable.is( o.screenMaps ) )
    filterSrcMapWithVectorScreenMap( srcMap );
    else
    filterSrcMap( srcMap );
  }
  else
  {
    if( _.countable.is( o.screenMaps ) )
    filterSrcMapWithVectorScreenMap( o.srcMaps );
    else
    filterSrcMap( o.srcMaps );
  }

  return o.dstMap;

  /* */

  function filterSrcMapWithVectorScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      let screenKey = screenKeySearch( key );
      if( screenKey )
      o.filter.call( self, o.dstMap, srcMap, screenKey );
    }
  }

  /* */

  function screenKeySearch( key )
  {
    if( _.argumentsArray.like( o.screenMaps ) )
    {
      for( let m = 0 ; m < o.screenMaps.length ; m++ )
      if( _.primitive.is( o.screenMaps[ m ] ) )
      {
        if( o.screenMaps[ m ] === key )
        return key;
      }
    }
    else
    {
      for( let m of o.screenMaps )
      if( _.primitive.is( m ) )
      {
        if( m === key )
        return key;
      }
    }

    // let m;
    // if( _.argumentsArray.like( o.screenMaps ) )
    // {
    //   for( m = 0 ; m < o.screenMaps.length ; m++ )
    //   if( _.vector.is( o.screenMaps[ m ] ) && key in o.screenMaps[ m ] )
    //   return key;
    //   else if( _.aux.is( o.screenMaps[ m ] ) && key in o.screenMaps[ m ] )
    //   return key;
    //   else if( _.primitive.is( o.screenMaps[ m ] ) && o.screenMaps[ m ] === key )
    //   return key;
    //   else if( key === String( m ) )
    //   return key;
    // }
    // else
    // {
    //   for( m of o.screenMaps )
    //   if( _.vector.is( m ) && key in m )
    //   return key;
    //   else if( _.aux.is( m ) && key in m )
    //   return key;
    //   else if( _.primitive.is( m ) && m === key )
    //   return key;
    // }
  }

  /* */

  function filterSrcMap( srcMap )
  {
    for( let key in o.screenMaps )
    {
      if( o.screenMaps[ key ] === undefined )
      continue;

      if( key in srcMap )
      o.filter.call( this, o.dstMap, srcMap, key );
    }
  }

  // let dstMap = o.dstMap || Object.create( null );
  // let screenMap = o.screenMaps;
  // let srcMaps = o.srcMaps;
  //
  // /* aaa : for Dmytro : not optimal */ /* Dmytro : optimized */
  // if( !_.vector.is( srcMaps ) )
  // srcMaps = [ srcMaps ];
  //
  // if( !o.filter )
  // o.filter = _.props.mapper.bypass();
  //
  // if( Config.debug )
  // {
  //
  //   // _.assert( o.filter.functionFamily === 'PropertyMapper' );
  //   _.assert( _.props.mapperIs( o.filter ), 'Expects PropertyFilter {-propertyCondition-}' );
  //   _.assert( arguments.length === 1, 'Expects single argument' );
  //   _.assert( !_.primitive.is( dstMap ), 'Expects object-like {-dstMap-}' );
  //   _.assert( !_.primitive.is( screenMap ), 'Expects not primitive {-screenMap-}' );
  //   _.assert( _.vector.is( srcMaps ), 'Expects array {-srcMaps-}' );
  //   _.map.assertHasOnly( o, _mapOnly.defaults );
  //
  //   for( let s = srcMaps.length - 1 ; s >= 0 ; s-- )
  //   _.assert( !_.primitive.is( srcMaps[ s ] ), 'Expects {-srcMaps-}' );
  //
  // }
  //
  // if( _.longIs( screenMap ) )
  // {
  //   for( let k in screenMap ) /* aaa : for Dmytro : bad */ /* Dmytro : improved, used conditions for types */
  //   {
  //
  //     if( screenMap[ k ] === undefined )
  //     continue;
  //
  //     let s;
  //     for( s = srcMaps.length-1 ; s >= 0 ; s-- )
  //     {
  //       if( !_.aux.is( screenMap[ k ] ) && screenMap[ k ] in srcMaps[ s ] )
  //       // k = screenMap[ k ]; /* aaa : ? */ /* Dmytro : key definition */
  //       break;
  //       if( k in srcMaps[ s ] )
  //       break;
  //     }
  //
  //     if( s === -1 )
  //     continue;
  //
  //     o.filter.call( this, dstMap, srcMaps[ s ], k );
  //
  //   }
  // }
  // else
  // {
  //   for( let k in screenMap )
  //   {
  //     if( screenMap[ k ] === undefined )
  //     continue;
  //
  //     for( let s in srcMaps )
  //     if( k in srcMaps[ s ] )
  //     o.filter.call( this, dstMap, srcMaps[ s ], k );
  //   }
  // }
  //
  // return dstMap;
}

_mapOnly.defaults =
{
  dstMap : null,
  srcMaps : null,
  screenMaps : null,
  filter : null,
}

//

function _mapOnly_VerifyMapFields( o )
{
  _.assert( arguments.length === 1, 'Expects single options map {-o-}' );
  _.assert( !_.primitive.is( o.dstMap ), 'Expects non primitive {-o.dstMap-}' );
  _.assert( !_.primitive.is( o.screenMaps ), 'Expects non primitive {-o.screenMaps-}' );
  _.assert( !_.primitive.is( o.srcMaps ), 'Expects non primitive {-o.srcMaps-}' );
  _.map.assertHasOnly( o, _mapOnly_VerifyMapFields.defaults );
  _.assert( !_.vector.is( o.dstMap ), 'Expects not a vector {-o.dstMap-}' );

  return o;
}

_mapOnly_VerifyMapFields.defaults =
{
  dstMap : null,
  srcMaps : null,
  screenMaps : null,
  filter : null,
}

//

function _mapOnly_FilterFunctor( o )
{
  let self = this;
  let mapsAreIdentical = o.dstMap === o.srcMaps ? 1 : 0;
  let screenMapsIsVector = _.vector.is( o.screenMaps ) ? 2 : 0;
  let filterRoutines =
  [
    filterNotIdenticalWithAuxScreenMap,
    filterIdenticalWithAuxScreenMap,
    filterNotIdenticalWithVectorScreenMap,
    filterIdenticalWithVectorScreenMap
  ];
  let key = mapsAreIdentical + screenMapsIsVector;
  let searchingRoutine;
  if( screenMapsIsVector )
  searchingRoutine = _screenMapSearchingRoutineFunctor( o.screenMaps );

  return filterRoutines[ key ];

  /* */

  function filterNotIdenticalWithVectorScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      let screenKey = searchingRoutine( o.screenMaps, key );
      if( screenKey !== undefined )
      o.filter.call( self, o.dstMap, srcMap, key );
    }
  }

  /* */

  function filterIdenticalWithVectorScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      let screenKey = searchingRoutine( o.screenMaps, key );
      if( screenKey === undefined )
      delete srcMap[ key ];
      else
      o.filter.call( self, o.dstMap, srcMap, key );
    }
  }

  /* */

  function filterNotIdenticalWithAuxScreenMap( srcMap )
  {
    for( let key in o.screenMaps )
    {
      if( o.screenMaps[ key ] === undefined )
      continue;

      if( key in srcMap )
      o.filter.call( self, o.dstMap, srcMap, key );
    }
  }

  /* */

  function filterIdenticalWithAuxScreenMap( srcMap )
  {
    for( let key in srcMap )
    {
      if( !( key in o.screenMaps ) )
      delete srcMap[ key ];
      else
      o.filter.call( self, o.dstMap, srcMap, key );
    }
  }
}

/* */

function _screenMapSearchingRoutineFunctor( screenMaps )
{
  let screenMapsIsArray = _.argumentsArray.like( screenMaps ) ? 1 : 0;
  let searchingRoutines =
  [
    searchKeyInVectorScreenMapWithPrimitives,
    searchKeyInArrayScreenMapWithPrimitives,
    searchKeyInVectorScreenMapWithMaps,
    searchKeyInArrayScreenMapWithMaps,
  ];

  let element;
  if( screenMapsIsArray )
  {
    element = screenMaps[ 0 ];
  }
  else
  {
    for( let el of screenMaps )
    {
      element = el;
      break;
    }
  }

  let screenMapsElementIsAux = _.aux.is( element ) ? 2 : 0;
  return searchingRoutines[ screenMapsIsArray + screenMapsElementIsAux ];

  /* */

  function searchKeyInArrayScreenMapWithPrimitives( screenMaps, key )
  {
    for( let m = 0 ; m < screenMaps.length ; m++ )
    if( screenMaps[ m ] === key )
    return key;
  }

  function searchKeyInArrayScreenMapWithMaps( screenMaps, key )
  {
    for( let m = 0 ; m < screenMaps.length ; m++ )
    if( key in screenMaps[ m ] )
    return key;
  }

  /* */

  function searchKeyInVectorScreenMapWithPrimitives( screenMaps, key )
  {
    for( let m of screenMaps )
    if( m === key )
    return key;
  }

  function searchKeyInVectorScreenMapWithMaps( screenMaps, key )
  {
    for( let m of screenMaps )
    if( key in m )
    return key;
  }
}

/* */

// function _mapOnly_SearchKeyInVectorScreenMap( screenMaps, key )
// {
//   if( _.argumentsArray.like( screenMaps ) )
//   {
//     for( let m = 0 ; m < screenMaps.length ; m++ )
//     if( _.primitive.is( screenMaps[ m ] ) )
//     {
//       if( screenMaps[ m ] === key )
//       return key;
//     }
//     else if( _.aux.is( screenMaps[ m ] ) )
//     {
//       if( key in screenMaps[ m ] )
//       return key;
//     }
//   }
//   else
//   {
//     for( let m of screenMaps )
//     if( _.primitive.is( m ) )
//     {
//       if( m === key )
//       return key;
//     }
//     else if( _.aux.is( m ) )
//     {
//       if( key in m )
//       return key;
//     }
//   }
// }
//
// //
//
// function _mapOnly_( o )
// {
//   let self = this;
//   o.dstMap = o.dstMap || Object.create( null );
//   o.filter = o.filter || _.props.mapper.bypass();
//
//   _.assert( arguments.length === 1, 'Expects single options map {-o-}' );
//   _.assert( _.props.mapperIs( o.filter ), 'Expects PropertyFilter {-o.filter-}' );
//   _.assert( !_.primitive.is( o.dstMap ), 'Expects non primitive {-o.dstMap-}' );
//   _.assert( !_.primitive.is( o.screenMaps ), 'Expects non primitive {-o.screenMaps-}' );
//   _.assert( !_.primitive.is( o.srcMaps ), 'Expects non primitive {-o.srcMaps-}' );
//   _.map.assertHasOnly( o, _mapOnly_.defaults );
//   _.assert( !_.vector.is( o.dstMap ), 'Expects not a vector {-o.dstMap-}' );
//
//   /* aaa : allow and cover vector */ /* Dmytro : allowed, covered. I think, an optimization for array like vectors has no sense. Otherwise, we need to add single branch with for cycle */
//
//   let mapsAreIdentical = o.dstMap === o.srcMaps ? 1 : 0;
//   let screenMapsIsVector = _.vector.is( o.screenMaps ) ? 2 : 0;
//   let filterRoutines = [ filterNotIdentical, filterIdentical, filterWithVectorScreenMap, filterWithVectorScreenMap ];
//   let filterCallbacks = [ filterNotIdenticalMaps, filterIdenticalMaps ];
//   let key = mapsAreIdentical + screenMapsIsVector;
//
//   if( _.vector.is( o.srcMaps ) )
//   {
//     for( let srcMap of o.srcMaps )
//     {
//       _.assert( !_.primitive.is( srcMap ), 'Expects no primitive in {-o.srcMaps-}' );
//       filterRoutines[ key ]( srcMap, filterCallbacks[ mapsAreIdentical ] );
//     }
//   }
//   else
//   {
//     filterRoutines[ key ]( o.srcMaps, filterCallbacks[ mapsAreIdentical ] );
//   }
//
//   return o.dstMap;
//
//   /* */
//
//   function filterNotIdenticalMaps( src, key, foundKey )
//   {
//     if( foundKey !== undefined )
//     o.filter.call( self, o.dstMap, src, key );
//   }
//
//   /* */
//
//   function filterIdenticalMaps( src, key, foundKey )
//   {
//     if( foundKey === undefined )
//     delete src[ key ];
//     else
//     o.filter.call( self, o.dstMap, src, key );
//   }
//
//   /* */
//
//   function filterWithVectorScreenMap( srcMap, filterCallback )
//   {
//     for( let key in srcMap )
//     {
//       let screenKey = screenMapSearch( key );
//       filterCallback( srcMap, key, screenKey );
//     }
//   }
//
//   /* */
//
//   function screenMapSearch( key )
//   {
//     if( _.argumentsArray.like( o.screenMaps ) )
//     {
//       for( let m = 0 ; m < o.screenMaps.length ; m++ )
//       if( _.primitive.is( o.screenMaps[ m ] ) )
//       {
//         if( o.screenMaps[ m ] === key )
//         return key;
//       }
//       else if( _.aux.is( o.screenMaps[ m ] ) )
//       {
//         if( key in o.screenMaps[ m ] )
//         return key;
//       }
//       // if( _.primitive.is( o.screenMaps[ m ] ) )
//       // {
//       //   if( o.screenMaps[ m ] === key )
//       //   return key;
//       // }
//     }
//     else
//     {
//       for( let m of o.screenMaps )
//       if( _.primitive.is( m ) )
//       {
//         if( m === key )
//         return key;
//       }
//       else if( _.aux.is( m ) )
//       {
//         if( key in m )
//         return key;
//       }
//       // if( _.primitive.is( m ) )
//       // {
//       //   if( m === key )
//       //   return key;
//       // }
//     }
//     // if( _.argumentsArray.like( o.screenMaps ) )
//     // {
//     //   for( let m = 0 ; m < o.screenMaps.length ; m++ )
//     //   if( _.vector.is( o.screenMaps[ m ] ) && key in o.screenMaps[ m ] )
//     //   return key;
//     //   else if( _.aux.is( o.screenMaps[ m ] ) && key in o.screenMaps[ m ] )
//     //   return key;
//     //   else if( _.primitive.is( o.screenMaps[ m ] ) && o.screenMaps[ m ] === key )
//     //   return key;
//     //   else if( key === String( m ) )
//     //   return key;
//     // }
//     // else
//     // {
//     //   for( let e of o.screenMaps )
//     //   if( _.vector.is( e ) && key in e )
//     //   return key;
//     //   else if( _.aux.is( e ) && key in e )
//     //   return key;
//     //   else if( _.primitive.is( e ) && e === key )
//     //   return key;
//     // }
//   }
//
//   /* */
//
//   function filterNotIdentical( srcMap )
//   {
//     for( let key in o.screenMaps )
//     {
//       if( o.screenMaps[ key ] === undefined )
//       continue;
//
//       if( key in srcMap )
//       o.filter.call( self, o.dstMap, srcMap, key );
//     }
//     // for( let key in srcMap )
//     // {
//     //   if( ( key in o.screenMaps ) && o.screenMaps[ key ] !== undefined )
//     //   o.filter.call( self, o.dstMap, srcMap, key );
//     // }
//   }
//
//   /* */
//
//   function filterIdentical( srcMap )
//   {
//     for( let key in srcMap )
//     {
//       if( !( key in o.screenMaps ) )
//       delete srcMap[ key ];
//       else
//       o.filter.call( self, o.dstMap, srcMap, key );
//     }
//   }
//
//   // let dstMap = o.dstMap || Object.create( null );
//   // let screenMap = o.screenMaps;
//   // let srcMaps = o.srcMaps;
//   //
//   // /* aaa : for Dmytro : not optimal */ /* Dmytro : optimized */
//   // if( !_.vector.is( srcMaps ) )
//   // srcMaps = [ srcMaps ];
//   //
//   // if( !o.filter )
//   // o.filter = _.props.mapper.bypass();
//   //
//   // if( Config.debug )
//   // {
//   //
//   //   // _.assert( o.filter.functionFamily === 'PropertyMapper' );
//   //   _.assert( _.props.mapperIs( o.filter ), 'Expects PropertyFilter {-propertyCondition-}' );
//   //   _.assert( arguments.length === 1, 'Expects single argument' );
//   //   _.assert( !_.primitive.is( dstMap ), 'Expects object-like {-dstMap-}' );
//   //   _.assert( !_.primitive.is( screenMap ), 'Expects not primitive {-screenMap-}' );
//   //   _.assert( _.vector.is( srcMaps ), 'Expects vector {-srcMaps-}' );
//   //   _.map.assertHasOnly( o, _mapOnly_.defaults );
//   //   _.map.assertHasOnly( o, _mapOnly_.defaults );
//   //
//   //   for( let s = srcMaps.length - 1 ; s >= 0 ; s-- )
//   //   _.assert( !_.primitive.is( srcMaps[ s ] ), 'Expects {-srcMaps-}' );
//   //
//   // }
//   //
//   // /* aaa : allow and cover vector */ /* Dmytro : implemented, covered */
//   //
//   // if( o.dstMap === o.srcMaps || o.dstMap === o.srcMaps[ 0 ] )
//   // {
//   //   if( _.vector.is( screenMap ) )
//   //   _mapsFilterWithLongScreenMap.call( this, mapsIdenticalFilterWithLong );
//   //   else
//   //   _mapsIdenticalFilter.call( this );
//   // }
//   // else
//   // {
//   //   if( _.vector.is( screenMap ) )
//   //   _mapsFilterWithLongScreenMap.call( this, mapsNotIdenticalFilterWithLong );
//   //   else
//   //   _mapsNotIdenticalFilter.call( this )
//   // }
//   //
//   // return dstMap;
//   //
//   // /* */
//   //
//   // function _mapsFilterWithLongScreenMap( filterCallback )
//   // {
//   //   for( let s in srcMaps )
//   //   {
//   //     let srcMap = srcMaps[ s ];
//   //
//   //     for( let k in srcMap )
//   //     {
//   //       let m = iterateKeyOfScreenMap( k );
//   //       // for( m = 0 ; m < screenMap.length ; m++ ) /* aaa : for Dmytro : teach to work with any vector here and in similar places */ /* Dmytro : implemented */
//   //       // for( m of screenMap )
//   //       // {
//   //       //   if( _.vector.is( screenMap[ m ] ) )
//   //       //   {
//   //       //     /* aaa : for Dmytro : check */ /* Dmytro : covered */
//   //       //     if( k in screenMap[ m ] )
//   //       //     break;
//   //       //   }
//   //       //   else
//   //       //   {
//   //       //     if( k === String( m ) )
//   //       //     break;
//   //       //   }
//   //       // }
//   //
//   //       filterCallback.call( this, srcMap, m, k );
//   //     }
//   //   }
//   // }
//   //
//   // /* */
//   //
//   // function iterateKeyOfScreenMap( k )
//   // {
//   //   let m;
//   //   if( _.argumentsArray.like( screenMap ) )
//   //   {
//   //     for( m = 0 ; m < screenMap.length ; m++ )
//   //     if( _.vector.is( screenMap[ m ] ) && k in screenMap[ m ] )
//   //     return m;
//   //     else if( _.aux.is( screenMap[ m ] ) && k in screenMap[ m ] )
//   //     return m;
//   //     else if( _.primitive.is( screenMap[ m ] ) && screenMap[ m ] === k )
//   //     return m;
//   //     else if( k === String( m ) )
//   //     return m;
//   //   }
//   //   else
//   //   {
//   //     for( m of screenMap )
//   //     if( _.vector.is( m ) && k in m )
//   //     return k;
//   //     else if( _.aux.is( m ) && k in m )
//   //     return k;
//   //     else if( _.primitive.is( m ) && m === k )
//   //     return k;
//   //
//   //     return srcMaps.length;
//   //   }
//   //
//   //   return m;
//   // }
//   //
//   // /* */
//   //
//   // function mapsIdenticalFilterWithLong( src, index, key )
//   // {
//   //   if( index === screenMap.length )
//   //   delete src[ key ];
//   //   else
//   //   o.filter.call( this, dstMap, src, key );
//   // }
//   //
//   // /* */
//   //
//   // function mapsNotIdenticalFilterWithLong( src, index, key )
//   // {
//   //   if( index !== screenMap.length )
//   //   o.filter.call( this, dstMap, src, key );
//   // }
//   //
//   // /* */
//   //
//   // function _mapsIdenticalFilter()
//   // {
//   //   for( let s in srcMaps )
//   //   {
//   //     let srcMap = srcMaps[ s ];
//   //
//   //     for( let k in srcMap )
//   //     {
//   //       if( !( k in screenMap ) )
//   //       delete srcMap[ k ];
//   //       else
//   //       o.filter.call( this, dstMap, srcMap, k );
//   //     }
//   //   }
//   // }
//   //
//   // /* */
//   //
//   // function _mapsNotIdenticalFilter()
//   // {
//   //   for( let k in screenMap )
//   //   {
//   //     if( screenMap[ k ] === undefined )
//   //     continue;
//   //
//   //     for( let s in srcMaps )
//   //     if( k in srcMaps[ s ] )
//   //     o.filter.call( this, dstMap, srcMaps[ s ], k );
//   //   }
//   // }
// }
//
// _mapOnly_.defaults =
// {
//   dstMap : null,
//   srcMaps : null,
//   screenMaps : null,
//   filter : null,
// }

//

/* qqq : cover */
function mapDiff( dst, src1, src2 )
{
  if( arguments.length === 2 )
  {
    dst = null;
    src1 = arguments[ 0 ];
    src2 = arguments[ 1 ];
  }

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( dst === null || _.aux.is( dst ) );

  dst = dst || Object.create( null );

  dst.src1 = _.mapBut_( dst.src1 || null, src1, src2 );
  dst.src2 = _.mapBut_( dst.src2 || null, src2, src1 );
  dst.src2 = _.props.extend( null, dst.src1, dst.src2 );
  dst.identical = Object.keys( dst.src1 ).length === 0 && Object.keys( dst.src2 ).length === 0;

  return dst;
}

// --
// map sure
// --

function sureHasExactly( srcMap, screenMaps, msg )
{
  let result = true;

  result = result && _.map.sureHasOnly.apply( this, arguments );
  result = result && _.map.sureHasAll.apply( this, arguments );

  return true;
}

//

function sureOwnExactly( srcMap, screenMaps, msg )
{
  let result = true;

  result = result && _.map.sureOwnOnly.apply( this, arguments );
  result = result && _.map.sureOwnAll.apply( this, arguments );

  return true;
}

//

/**
 * Checks if map passed by argument {-srcMap-} has only properties represented in object(s) passed after first argument. Checks all enumerable properties.
 * Works only in debug mode. Uses StackTrace level 2. {@link wTools.err See err}
 * If routine found some unique properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after last object. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } screenMaps - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let a = { a : 1, b : 3 };
 * let b = { a : 2, b : 3 };
 * _.map.sureHasOnly( a, b );
 * // no exception
 *
 * @example
 * let a = { a : 1, c : 3 };
 * let b = { a : 2, b : 3 };
 * _.map.sureHasOnly( a, b );
 *
 * // log
 * // caught <anonymous>:3:8
 * // Object should have no fields : c
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasOnly (file:///.../wTools/staging/Base.s:4188)
 * // at <anonymous>:3
 *
 * @example
 * let x = { d : 1 };
 * let a = Object.create( x );
 * let b = { a : 1 };
 * _.map.sureHasOnly( a, b, 'message' )
 *
 * // log
 * // caught <anonymous>:4:8
 * // message Object should have no fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasOnly (file:///.../wTools/staging/Base.s:4188)
 * // at <anonymous>:4
 *
 * @example
 * let x = { d : 1 };
 * let a = Object.create( x );
 * let b = { a : 1 };
 * _.map.sureHasOnly( a, b, () => 'message, ' + 'map`, ' should have no fields :'  )
 *
 * // log
 * // caught <anonymous>:4:8
 * // message Object should have no fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasOnly (file:///.../wTools/staging/Base.s:4188)
 * // at <anonymous>:4
 *
 * @function sureHasOnly
 * @throws {Exception} If no arguments are provided or more than four arguments are provided.
 * @throws {Exception} If map {-srcMap-} contains unique property.
 * @namespace Tools
 *
 */

function sureHasOnly( srcMap, screenMaps, msg )
{
  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  /* qqq : for Dmytro : bad ! */
  // let but = Object.keys( _.mapBut_( null, srcMap, screenMaps ) );
  let but = Object.keys( _.mapButOld( srcMap, screenMaps ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    err = _._err
    ({
      args : [ `${ _.entity.strType( srcMap ) } should have no fields :`, _.strQuote( but ).join( ', ' ) ],
      level : 2,
    });
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//

/**
 * Checks if map passed by argument {-srcMap-} has only properties represented in object(s) passed after first argument. Checks only own properties of the objects.
 * Works only in debug mode. Uses StackTrace level 2.{@link wTools.err See err}
 * If routine found some unique properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after last object. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } screenMaps - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let x = { d : 1 };
 * let a = Object.create( x );
 * a.a = 5;
 * let b = { a : 2 };
 * _.map.sureOwnOnly( a, b );
 * //no exception
 *
 * @example
 * let a = { d : 1 };
 * let b = { a : 2 };
 * _.map.sureOwnOnly( a, b );
 *
 * // log
 * // caught <anonymous>:3:10
 * // Object should have no own fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureOwnOnly (file:///.../wTools/staging/Base.s:4215)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0, y : 2 };
 * let b = { c : 0, d : 3};
 * let c = { a : 1 };
 * _.map.sureOwnOnly( a, b, 'error msg' );
 *
 * // log
 * // caught <anonymous>:4:8
 * // error msg Object should have no own fields : x, y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureOwnOnly (file:///.../wTools/staging/Base.s:4215)
 * // at <anonymous>:4
 *
 * @example
 * let a = { x : 0, y : 2 };
 * let b = { c : 0, d : 3};
 * let c = { a : 1 };
 * _.map.sureOwnOnly( a, b, () => 'error, ' + 'map should', ' no own fields :' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // error, map should have no own fields : x, y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureOwnOnly (file:///.../wTools/staging/Base.s:4215)
 * // at <anonymous>:3
 *
 * @function sureOwnOnly
 * @throws {Exception} If no arguments are provided or more than four arguments are provided.
 * @throws {Exception} If map {-srcMap-} contains unique property.
 * @namespace Tools
 *
 */

function sureOwnOnly( srcMap, screenMaps, msg )
{
  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  /* qqq : for Dmytro : bad! */
  let but = Object.keys( _.mapOnlyOwnButOld( srcMap, screenMaps ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should own no fields :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 3,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//

/**
 * Checks if map passed by argument {-srcMap-} has all properties represented in object passed by argument( all ). Checks all enumerable properties.
 * Works only in debug mode. Uses StackTrace level 2.{@link wTools.err See err}
 * If routine did not find some properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after last object. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } all - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let x = { a : 1 };
 * let a = Object.create( x );
 * let b = { a : 2 };
 * _.map.sureHasAll( a, b );
 * // no exception
 *
 * @example
 * let a = { d : 1 };
 * let b = { a : 2 };
 * _.map.sureHasAll( a, b );
 *
 * // log
 * // caught <anonymous>:3:10
 * // Object should have fields : a
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasAll (file:///.../wTools/staging/Base.s:4242)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0, y : 2 };
 * let b = { x : 0, d : 3};
 * _.map.sureHasAll( a, b, 'error msg' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // error msg Object should have fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasAll (file:///.../wTools/staging/Base.s:4242)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0 };
 * let b = { x : 1, y : 0};
 * _.map.sureHasAll( a, b, () => 'error, ' + 'map should', ' have fields :' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // error, map should have fields : y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasAll (file:///.../wTools/staging/Base.s:4242)
 * // at <anonymous>:3
 *
 * @function sureHasAll
 * @throws {Exception} If no arguments are provided or more than four arguments are provided.
 * @throws {Exception} If map {-srcMap-} not contains some properties from argument( all ).
 * @namespace Tools
 *
 */

function sureHasAll( srcMap, all, msg )
{

  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  let but = Object.keys( _.mapBut_( null, all, srcMap ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should have fields :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//

/**
 * Checks if map passed by argument {-srcMap-} has all properties represented in object passed by argument( all ). Checks only own properties of the objects.
 * Works only in Config.debug mode. Uses StackTrace level 2. {@link wTools.err See err}
 * If routine did not find some properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after last object. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } all - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let a = { a : 1 };
 * let b = { a : 2 };
 * wTools.sureMapOwnAll( a, b );
 * // no exception
 *
 * @example
 * let a = { a : 1 };
 * let b = { a : 2, b : 2 }
 * _.map.sureOwnAll( a, b );
 *
 * // log
 * // caught <anonymous>:3:8
 * // Object should have own fields : b
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureOwnAll (file:///.../wTools/staging/Base.s:4269)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0 };
 * let b = { x : 1, y : 0};
 * _.map.sureOwnAll( a, b, 'error, should own fields' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // error, should own fields : y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureOwnAll (file:///.../wTools/staging/Base.s:4269)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0 };
 * let b = { x : 1, y : 0};
 * _.map.sureOwnAll( a, b, () => 'error, ' + 'map should', ' own fields :' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // error, map should own fields : y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureOwnAll (file:///.../wTools/staging/Base.s:4269)
 * // at <anonymous>:3
 *
 * @function sureOwnAll
 * @throws {Exception} If no arguments are provided or more than four arguments are provided.
 * @throws {Exception} If map {-srcMap-} not contains some properties from argument( all ).
 * @namespace Tools
 *
 */

function sureOwnAll( srcMap, all, msg )
{

  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  let but = Object.keys( _.mapOnlyOwnBut_( null, all, srcMap ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should own fields :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//

/**
 * Checks if map passed by argument {-srcMap-} has no properties represented in object(s) passed after first argument. Checks all enumerable properties.
 * Works only in debug mode. Uses StackTrace level 2. {@link wTools.err See err}
 * If routine found some properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after last object. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param {...Object} screenMaps - object(s) to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * _.map.sureHasNone( a, b );
 * // no exception
 *
 * @example
 * let x = { a : 1 };
 * let a = Object.create( x );
 * let b = { a : 2, b : 2 }
 * _.map.sureHasNone( a, b );
 *
 * // log
 * // caught <anonymous>:4:8
 * // Object should have no fields : a
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasNone (file:///.../wTools/staging/Base.s:4518)
 * // at <anonymous>:4
 *
 * @example
 * let a = { x : 0, y : 1 };
 * let b = { x : 1, y : 0 };
 * _.map.sureHasNone( a, b, 'error, map should have no fields' );
 *
 * // log
 * // caught <anonymous>:3:9
 * // error, map should have no fields : x, y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasNone (file:///.../wTools/staging/Base.s:4518)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0, y : 1 };
 * let b = { x : 1, y : 0 };
 * _.map.sureHasNone( a, b, () => 'error, ' + 'map should have', 'no fields :' );
 *
 * // log
 * // caught <anonymous>:3:9
 * // error, map should have no fields : x, y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasNone (file:///.../wTools/staging/Base.s:4518)
 * // at <anonymous>:3
 *
 * @function sureHasNone
 * @throws {Exception} If no arguments are provided or more than four arguments are provided.
 * @throws {Exception} If map {-srcMap-} contains some properties from other map(s).
 * @namespace Tools
 *
 */

function sureHasNone( srcMap, screenMaps, msg )
{

  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  let but = Object.keys( _.mapOnly_( null, srcMap, screenMaps ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should have no fields :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//

function sureOwnNone( srcMap, screenMaps, msg )
{

  _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4, 'Expects two, three or four arguments' );

  let but = Object.keys( _.mapOnlyOwn_( null, srcMap, screenMaps ) );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 2 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should own no fields :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 2; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

//

/**
 * Checks if map passed by argument {-srcMap-} not contains undefined properties. Works only in debug mode. Uses StackTrace level 2. {@link wTools.err See err}
 * If routine found undefined property it generates and throws exception, otherwise returns without exception.
 * Also generates error using messages passed after first argument. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let map = { a : '1', b : 'name' };
 * _.map.sureHasNoUndefine( map );
 * // no exception
 *
 * @example
 * let map = { a : '1', b : undefined };
 * _.map.sureHasNoUndefine( map );
 *
 * // log
 * // caught <anonymous>:2:8
 * // Object  should have no undefines, but has : b
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasNoUndefine (file:///.../wTools/staging/Base.s:4087)
 * // at <anonymous>:2
 *
 * @example
 * let map = { a : undefined, b : '1' };
 * _.map.sureHasNoUndefine( map, '"map" has undefines :');
 *
 * // log
 * // caught <anonymous>:2:8
 * // "map" has undefines : a
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasNoUndefine (file:///.../wTools/staging/Base.s:4087)
 * // at <anonymous>:2
 *
 * @example
 * let map = { a : undefined, b : '1' };
 * _.map.sureHasNoUndefine( map, '"map"', () => 'should have ' + 'no undefines, but has :' );
 *
 * // log
 * // caught <anonymous>:2:8
 * // "map" should have no undefines, but has : a
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at sureHasNoUndefine (file:///.../wTools/staging/Base.s:4087)
 * // at <anonymous>:2
 *
 * @function sureHasNoUndefine
 * @throws {Exception} If no arguments passed or than three arguments passed.
 * @throws {Exception} If map {-srcMap-} contains undefined property.
 * @namespace Tools
 *
 */

function sureHasNoUndefine( srcMap, msg )
{

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3, 'Expects one, two or three arguments' )

  let but = [];

  for( let s in srcMap )
  if( srcMap[ s ] === undefined )
  but.push( s );

  if( but.length > 0 )
  {
    let err;
    if( arguments.length === 1 )
    {
      err = _._err
      ({
        args : [ `${ _.entity.strType( srcMap ) } should have no undefines, but has :`, _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    else
    {
      let arr = [];
      for( let i = 1; i < arguments.length; i++ )
      {
        if( _.routine.is( arguments[ i ] ) )
        arguments[ i ] = ( arguments[ i ] )();
        arr.push( arguments[ i ] );
      }
      err = _._err
      ({
        args : [ arr.join( ' ' ), _.strQuote( but ).join( ', ' ) ],
        level : 2,
      });
    }
    debugger; /* eslint-disable-line no-debugger */
    throw err;
    return false;
  }

  return true;
}

// --
// map assert
// --

function assertHasExactly( srcMap, screenMaps, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureHasExactly.apply( this, arguments );
}

//

function assertOwnExactly( srcMap, screenMaps, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureOwnExactly.apply( this, arguments );
}

//

/**
 * Checks if map passed by argument {-srcMap-} has only properties represented in object(s) passed after first argument. Checks all enumerable properties.
 * Works only in debug mode. Uses StackTrace level 2. {@link wTools.err See err}
 * If routine found some unique properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after second argument. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } screenMaps - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let a = { a : 1, b : 3 };
 * let b = { a : 2, b : 3 };
 * _.map.assertHasOnly( a, b );
 * //no exception
 *
 * @example
 * let a = { a : 1, c : 3 };
 * let b = { a : 2, b : 3 };
 * _.map.assertHasOnly( a, b );
 *
 * // log
 * // caught <anonymous>:3:8
 * // Object should have no fields : c
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasOnly (file:///.../wTools/staging/Base.s:4188)
 * // at <anonymous>:3
 *
 * @example
 * let x = { d : 1 };
 * let a = Object.create( x );
 * let b = { a : 1 };
 * _.map.assertHasOnly( a, b, 'map should have no fields :' )
 *
 * // log
 * // caught <anonymous>:4:8
 * // map should have no fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasOnly (file:///.../wTools/staging/Base.s:4188)
 * // at <anonymous>:4
 *
 * @example
 * let x = { d : 1 };
 * let a = Object.create( x );
 * let b = { a : 1 };
 * _.map.assertHasOnly( a, b, 'map', () => ' should' + ' have no fields :' )
 *
 * // log
 * // caught <anonymous>:4:8
 * // map should have no fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasOnly (file:///.../wTools/staging/Base.s:4188)
 * // at <anonymous>:4
 *
 * @function assertHasOnly
 * @throws {Exception} If no arguments provided or more than four arguments passed.
 * @throws {Exception} If map {-srcMap-} contains unique property.
 * @namespace Tools
 *
 */

function assertHasOnly( srcMap, screenMaps, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureHasOnly.apply( this, arguments );

  /* */

  // _.assert( 2 <= arguments.length && arguments.length <= 4, 'Expects two, three or four arguments' );
  //
  // let but = mapButKeys( srcMap, screenMaps );
  //
  // if( but.length > 0 )
  // {
  //   let err;
  //   let msgKeys = _.strQuote( but ).join( ', ' );
  //   if( arguments.length === 2 )
  //   err = errFromArgs([ `${ _.entity.strType( srcMap ) } should have no fields : ${ msgKeys }` ]);
  //   else
  //   err = errFromArgs([ msgMake( arguments ), msgKeys ]);
  //   throw err;
  // }
  //
  // return true;
  //
  // /* */
  //
  // function mapButKeys( srcMap, butMap )
  // {
  //   let result = [];
  //   _.assert( !_.primitive.is( srcMap ), 'Expects map {-srcMap-}' );
  //
  //   /* aaa : allow and cover vector */ /* Dmytro : this inlining is not needed, that was mistake */
  //   if( _.vector.is( butMap ) )
  //   {
  //     /* aaa : for Dmytro : bad */ /* Dmytro : this inlining is not needed, that was mistake */
  //     for( let s in srcMap )
  //     {
  //       let m;
  //       for( m = 0 ; m < butMap.length ; m++ )
  //       {
  //         /* aaa : for Dmytro : was bad implementation. cover */ /* Dmytro : this inlining is not needed, that was mistake */
  //         if( _.primitive.is( butMap[ m ] ) )
  //         {
  //           if( s === butMap[ m ] )
  //           break;
  //         }
  //         else
  //         {
  //           if( s in butMap[ m ] )
  //           break;
  //         }
  //       }
  //
  //       if( m === butMap.length )
  //       result.push( s );
  //     }
  //   }
  //   else if( !_.primitive.is( butMap ) )
  //   {
  //     for( let s in srcMap )
  //     {
  //       if( !( s in butMap ) )
  //       result.push( s );
  //     }
  //   }
  //   else
  //   {
  //     _.assert( 0, 'Expects object-like or long-like {-butMap-}' );
  //   }
  //
  //   return result;
  // }
  //
  // /* */
  //
  // function errFromArgs( args )
  // {
  //   return _._err
  //   ({
  //     args,
  //     level : 2,
  //   });
  // }
  //
  // /* */
  //
  // function msgMake( args )
  // {
  //   let arr = [];
  //   for( let i = 2; i < args.length; i++ )
  //   {
  //     if( _.routineIs( args[ i ] ) )
  //     args[ i ] = args[ i ]();
  //     arr.push( args[ i ] );
  //   }
  //   return arr.join( ' ' );
  // }
}

//

/**
 * Checks if map passed by argument {-srcMap-} has only properties represented in object(s) passed after first argument. Checks only own properties of the objects.
 * Works only in debug mode. Uses StackTrace level 2.{@link wTools.err See err}
 * If routine found some unique properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after second argument. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } screenMaps - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let x = { d : 1 };
 * let a = Object.create( x );
 * a.a = 5;
 * let b = { a : 2 };
 * _.map.assertOwnOnly( a, b );
 * // no exception
 *
 * @example
 * let a = { d : 1 };
 * let b = { a : 2 };
 * _.map.assertOwnOnly( a, b );
 *
 * // log
 * // caught <anonymous>:3:10
 * // Object should have no own fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertOwnOnly (file:///.../wTools/staging/Base.s:4215)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0, y : 2 };
 * let b = { c : 0, d : 3};
 * let c = { a : 1 };
 * _.map.assertOwnOnly( a, b, 'error, map should have no own fields :' );
 *
 * // log
 * // caught <anonymous>:4:8
 * // error, map should have no own fields : x, y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertOwnOnly (file:///.../wTools/staging/Base.s:4215)
 * // at <anonymous>:4
 *
 * @example
 * let a = { x : 0, y : 2 };
 * let b = { c : 0, d : 3};
 * let c = { a : 1 };
 * _.map.assertOwnOnly( a, b, () => 'error, ' + 'map', ' should have no own fields :' );
 *
 * // log
 * // caught <anonymous>:4:8
 * // error, map should have no own fields : x, y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertOwnOnly (file:///.../wTools/staging/Base.s:4215)
 * // at <anonymous>:4
 *
 * @function assertOwnOnly
 * @throws {Exception} If no arguments provided or more than four arguments passed.
 * @throws {Exception} If map {-srcMap-} contains unique property.
 * @namespace Tools
 *
 */

function assertOwnOnly( srcMap, screenMaps, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureOwnOnly.apply( this, arguments );
}

//

/**
 * Checks if map passed by argument {-srcMap-} has no properties represented in object(s) passed after first argument. Checks all enumerable properties.
 * Works only in debug mode. Uses StackTrace level 2. {@link wTools.err See err}
 * If routine found some properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after second argument. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } screenMaps - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let a = { a : 1 };
 * let b = { b : 2 };
 * _.map.assertHasNone( a, b );
 * // no exception
 *
 * @example
 * let x = { a : 1 };
 * let a = Object.create( x );
 * let b = { a : 2, b : 2 }
 * _.map.assertHasNone( a, b );
 *
 * // log
 * // caught <anonymous>:4:8
 * // Object should have no fields : a
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasAll (file:///.../wTools/staging/Base.s:4518)
 * // at <anonymous>:4
 *
 * @example
 * let a = { x : 0, y : 1 };
 * let b = { x : 1, y : 0 };
 * _.map.assertHasNone( a, b, 'map should have no fields :' );
 *
 * // log
 * // caught <anonymous>:3:9
 * // map should have no fields : x, y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasNone (file:///.../wTools/staging/Base.s:4518)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0, y : 1 };
 * let b = { x : 1, y : 0 };
 * _.map.assertHasNone( a, b, () => 'map ' + 'should ', 'have no fields :' );
 *
 * // log
 * // caught <anonymous>:3:9
 * // map should have no fields : x, y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasNone (file:///.../wTools/staging/Base.s:4518)
 * // at <anonymous>:3
 *
 * @function assertHasNone
 * @throws {Exception} If no arguments provided or more than four arguments passed.
 * @throws {Exception} If map {-srcMap-} contains some properties from other map(s).
 * @namespace Tools
 *
 */

function assertHasNone( srcMap, screenMaps, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureHasNone.apply( this, arguments );
}

//

function assertOwnNone( srcMap, screenMaps, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureOwnNone.apply( this, arguments );
}

//

/**
 * Checks if map passed by argument {-srcMap-} has all properties represented in object passed by argument( all ). Checks all enumerable properties.
 * Works only in debug mode. Uses StackTrace level 2.{@link wTools.err See err}
 * If routine did not find some properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after second argument. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } all - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let x = { a : 1 };
 * let a = Object.create( x );
 * let b = { a : 2 };
 * _.map.assertHasAll( a, b );
 * // no exception
 *
 * @example
 * let a = { d : 1 };
 * let b = { a : 2 };
 * _.map.assertHasAll( a, b );
 *
 * // log
 * // caught <anonymous>:3:10
 * // Object should have fields : a
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasAll (file:///.../wTools/staging/Base.s:4242)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0, y : 2 };
 * let b = { x : 0, d : 3};
 * _.map.assertHasAll( a, b, 'map should have fields :' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // map should have fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasAll (file:///.../wTools/staging/Base.s:4242)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0, y : 2 };
 * let b = { x : 0, d : 3};
 * _.map.assertHasAll( a, b, () => 'map' + ' should', ' have fields :' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // map should have fields : d
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasAll (file:///.../wTools/staging/Base.s:4242)
 * // at <anonymous>:3
 *
 * @function assertHasAll
 * @throws {Exception} If no arguments provided or more than four arguments passed.
 * @throws {Exception} If map {-srcMap-} not contains some properties from argument( all ).
 * @namespace Tools
 *
 */

function assertHasAll( srcMap, all, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureHasAll.apply( this, arguments );
}

//

/**
 * Checks if map passed by argument {-srcMap-} has all properties represented in object passed by argument( all ). Checks only own properties of the objects.
 * Works only in Config.debug mode. Uses StackTrace level 2. {@link wTools.err See err}
 * If routine did not find some properties in source it generates and throws exception, otherwise returns without exception.
 * Also generates error using message passed after second argument. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { Object } all - object to compare with.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in third argument.
 *
 * @example
 * let a = { a : 1 };
 * let b = { a : 2 };
 * _.map.assertOwnAll( a, b );
 * // no exception
 *
 * @example
 * let a = { a : 1 };
 * let b = { a : 2, b : 2 }
 * _.map.assertOwnAll( a, b );
 *
 * // log
 * // caught <anonymous>:3:8
 * // Object should own fields : b
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasAll (file:///.../wTools/staging/Base.s:4269)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0 };
 * let b = { x : 1, y : 0};
 * _.map.assertOwnAll( a, b, 'error msg, map should own fields :' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // error msg, map should own fields : y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertOwnAll (file:///.../wTools/staging/Base.s:4269)
 * // at <anonymous>:3
 *
 * @example
 * let a = { x : 0 };
 * let b = { x : 1, y : 0};
 * _.map.assertOwnAll( a, b, 'error msg, ', () => 'map' + ' should own fields :' );
 *
 * // log
 * // caught <anonymous>:4:9
 * // error msg, map should own fields : y
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertOwnAll (file:///.../wTools/staging/Base.s:4269)
 * // at <anonymous>:3
 *
 * @function assertOwnAll
 * @throws {Exception} If no arguments passed or more than four arguments passed.
 * @throws {Exception} If map {-srcMap-} not contains some properties from argument( all ).
 * @namespace Tools
 *
 */

function assertOwnAll( srcMap, all, msg )
{
  if( Config.debug === false )
  return true;
  return _.map.sureOwnAll.apply( this, arguments );
}

//

/**
 * Checks if map passed by argument {-srcMap-} not contains undefined properties. Works only in debug mode. Uses StackTrace level 2. {@link wTools.err See err}
 * If routine found undefined property it generates and throws exception, otherwise returns without exception.
 * Also generates error using messages passed after first argument. Message may be a string, an array, or a function.
 *
 * @param { Object } srcMap - source map.
 * @param { * } [ msg ] - error message for generated exception.
 * @param { * } [ msg ] - error message that adds to the message in second argument.
 *
 * @example
 * let map = { a : '1', b : 'name' };
 * _.map.assertHasNoUndefine( map );
 * // no exception
 *
 * @example
 * let map = { a : '1', b : undefined };
 * _.map.assertHasNoUndefine( map );
 *
 * // log
 * // caught <anonymous>:2:8
 * // Object should have no undefines, but has : b
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasNoUndefine (file:///.../wTools/staging/Base.s:4087)
 * // at <anonymous>:2
 *
 * @example
 * let map = { a : undefined, b : '1' };
 * _.map.assertHasNoUndefine( map, '"map" has undefines :');
 *
 * // log
 * // caught <anonymous>:2:8
 * // "map" has undefines : a
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasNoUndefine (file:///.../wTools/staging/Base.s:4087)
 * // at <anonymous>:2
 *
 * @example
 * let map = { a : undefined, b : '1' };
 * _.map.assertHasNoUndefine( map, 'map', () => ' has ' + 'undefines :');
 *
 * // log
 * // caught <anonymous>:2:8
 * // map has undefines : a
 * //
 * // at _err (file:///.../wTools/staging/Base.s:3707)
 * // at assertHasNoUndefine (file:///.../wTools/staging/Base.s:4087)
 * // at <anonymous>:2
 *
 * @function assertHasNoUndefine
 * @throws {Exception} If no arguments provided or more than three arguments passed.
 * @throws {Exception} If map {-srcMap-} contains undefined property.
 * @namespace Tools
 *
 */

function assertHasNoUndefine( srcMap, msg )
{
  if( Config.debug === false )
  return true;

  /* */

  _.assert( 1 <= arguments.length && arguments.length <= 3, 'Expects one, two or three arguments' )
  _.assert( !_.primitive.is( srcMap ) );

  let but = [];

  for( let s in srcMap )
  if( srcMap[ s ] === undefined )
  but.push( s );

  if( but.length > 0 )
  {
    let msgKeys = _.strQuote( but ).join( ', ' );
    if( arguments.length === 1 )
    throw errFromArgs([ `${ _.entity.strType( srcMap ) } should have no undefines, but has : ${ msgKeys }` ]);
    else
    throw errFromArgs([ msgMake( arguments ), msgKeys ])
  }

  return true;

  /* */

  function errFromArgs( args )
  {
    return _._err
    ({
      args,
      level : 2,
    });
  }

  /* */

  function msgMake( args )
  {
    let arr = [];
    for( let i = 1 ; i < args.length ; i++ )
    {
      if( _.routine.is( args[ i ] ) )
      args[ i ] = args[ i ]();
      arr.push( args[ i ] );
    }
    return arr.join( ' ' );
  }
}

// --
// extension
// --

let Extension =
{

  // map selector

  /* xxx : review */
  mapFirstPair,
  mapAllValsSet,
  mapValsWithKeys,
  mapValWithIndex,
  mapKeyWithIndex,
  mapKeyWithValue,
  // mapIndexWithKey,
  // mapIndexWithValue,

  mapOnlyNulls,
  mapButNulls,

  // map checker

  // mapsAreIdentical, /* xxx : remove */
  // mapContain,

  objectSatisfy,

  /* xxx : move routines to another namespace? */

  /* introduce routine::mapHasKey */
  mapOwn : mapOwnKey, /* qqq : good coverage required! */
  mapOwnKey,

  mapHas : mapHasKey, /* qqq : good coverage required! */
  mapHasKey,

  mapOnlyOwnKey,
  mapHasVal,
  mapOnlyOwnVal,

  mapHasAll,
  mapHasAny,
  mapHasNone,

  mapOnlyOwnAll,
  mapOnlyOwnAny,
  mapOnlyOwnNone,

  mapHasExactly,
  mapOnlyOwnExactly,

  mapHasOnly,
  mapOnlyOwnOnly,

  mapHasNoUndefine,

  // map extend

  // mapMake,
  // mapCloneShallow,
  mapCloneAssigning, /* dubious */

  // mapExtend,
  mapsExtend,
  mapExtendConditional,
  mapsExtendConditional,

  mapExtendHiding,
  mapsExtendHiding,
  mapExtendAppending,
  mapsExtendAppending,
  mapExtendPrepending,
  mapsExtendPrepending,
  mapExtendAppendingOnlyArrays,
  mapsExtendAppendingOnlyArrays,
  mapExtendByDefined,
  mapsExtendByDefined,
  mapExtendNulls, /* qqq : cover */ /* qqq : check routine mapExtendNulls. seems does not extend undefined fields */
  mapsExtendNulls, /* qqq : cover */
  mapExtendDstNotOwn, /* qqq : cover */
  mapsExtendDstNotOwn, /* qqq : cover */
  mapExtendNotIdentical, /* qqq : cover */
  mapsExtendNotIdentical, /* qqq : cover */

  // mapSupplement,
  mapSupplementNulls,
  mapSupplementNils,
  mapSupplementAssigning,
  mapSupplementAppending,
  mapsSupplementAppending,

  mapSupplementOwnAssigning,

  mapComplement,
  mapsComplement,
  mapComplementReplacingUndefines,
  mapsComplementReplacingUndefines,
  mapComplementPreservingUndefines,
  mapsComplementPreservingUndefines,

  // map extend recursive

  mapExtendRecursiveConditional,
  mapsExtendRecursiveConditional,
  _mapExtendRecursiveConditional,

  mapExtendRecursive,
  mapsExtendRecursive,
  _mapExtendRecursive,

  mapExtendAppendingAnythingRecursive,
  mapsExtendAppendingAnythingRecursive,
  mapExtendAppendingArraysRecursive,
  mapsExtendAppendingArraysRecursive,
  mapExtendAppendingOnceRecursive,
  mapsExtendAppendingOnceRecursive,

  mapSupplementRecursive,
  mapSupplementByMapsRecursive,
  mapSupplementOwnRecursive,
  mapsSupplementOwnRecursive,
  mapSupplementRemovingRecursive,
  mapSupplementByMapsRemovingRecursive,

  // map selector

  mapOnlyPrimitives,

  // map manipulator

  /* xxx */
  mapSetWithKeys,
  mapSet : mapSetWithKeys,
  mapSetWithKeyStrictly,

  // map transformer

  mapInvert, /* qqq : write _mapInvert accepting o-map | aaa : Done. Yevhen S. */
  _mapInvert,
  mapInvertDroppingDuplicates,
  mapsFlatten,

  // mapToArray,
  mapToStr, /* experimental */
  mapFromHashMap : fromHashMap,

  // map logical operator

  mapButConditionalOld, /* !!! : use instead of mapButConditional */ /* qqq : make it accept null in the first argument */ /* Dmytro : covered, coverage is more complex */
  mapButConditional_,
  // mapBut, /* !!! : use instead of mapBut */ /* Dmytro : covered, coverage is more complex */
  mapBut_, /* qqq : make it accept null in the first argument */
  mapButOld,
  _mapBut_VerifyMapFields,
  _mapBut_FilterFunctor,
  // _mapBut_,
  mapDelete,
  mapEmpty, /* xxx : remove */
  // mapButIgnoringUndefines, /* !!! : use instead of mapButIgnoringUndefines */ /* Dmytro : covered, coverage is more complex */
  mapButIgnoringUndefines_, /* qqq : make it accept null in the first argument */
  /* qqq : for Dmytro : cover */
  /* qqq : for Dmytro : mess with problems! */
  /* xxx : use as default mapBut? */

  mapOnlyOwnButOld, /* !!! : use instead of mapOnlyOwnBut */ /* Dmytro : covered, coverage is more complex */
  mapOnlyOwnBut_, /* qqq : make it accept null in the first argument */

  mapOnlyOld, /* !!! : use instead of mapOnly */ /* Dmytro : covered, coverage is more complex */
  mapOnly_,  /* qqq : make it accept null in the first argument */
  // mapOnlyOwn, /* !!! : use instead of mapOnlyOwn */ /* Dmytro : covered, coverage is more complex */
  mapOnlyOwn_, /* qqq : make it accept null in the first argument */
  /* qqq : cover */
  // mapOnlyComplementing, /* !!! : use instead of mapOnlyComplementing */ /* Dmytro : covered, coverage is more complex */
  mapOnlyComplementing_, /* qqq : make it accept null in the first argument */
  _mapOnly, /* xxx : qqq : comment out */
  _mapOnly_VerifyMapFields,
  _mapOnly_FilterFunctor,
  _screenMapSearchingRoutineFunctor,
  // _mapOnly_SearchKeyInVectorScreenMap,
  // _mapOnly_,

  mapDiff,

  /* qqq xxx : implement mapDiff(), ask how to */

}

// --
//
// --

/* qqq : for junior : duplicate all routines */

let ExtensionMap =
{

  // transformer

  fromHashMap,

  // sure

  sureHasExactly,
  sureOwnExactly,

  sureHasOnly,
  sureOwnOnly,

  sureHasAll,
  sureOwnAll,

  sureHasNone,
  sureOwnNone,

  sureHasNoUndefine,

  // assert

  assertHasExactly,
  assertOwnExactly,

  assertHasOnly,
  assertOwnOnly,

  assertHasNone,
  assertOwnNone,

  assertHasAll,
  assertOwnAll,

  assertHasNoUndefine,

}

//

_.props.supplement( _, Extension );
_.props.supplement( _.map, ExtensionMap );
_.assert( _.aux.is( _.map ) );

})();


/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Map.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Map_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Map_s */ })();

/* */  /* begin of file Number_s */ ( function Number_s() { function Number_s_naked() { ( function _l5_Numbers_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// number
// --

function clamp( src, low, high )
{
  _.assert( arguments.length === 2 || arguments.length === 3, 'Expects two or three arguments' );
  _.assert( _.number.is( src ) );

  if( arguments.length === 2 )
  {
    _.assert( arguments[ 1 ].length === 2 );
    low = arguments[ 1 ][ 0 ];
    high = arguments[ 1 ][ 1 ];
  }

  if( src > high )
  return high;

  if( src < low )
  return low;

  return src;
}

//

function mix( ins1, ins2, progress )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  return ins1*( 1-progress ) + ins2*( progress );
}

// --
// extension
// --

/*
zzz : review and merge with similar routines _.range.*
*/

let ToolsExtension =
{

  numberClamp : clamp, /* teach it to accept cintervals */
  numberMix : mix,

}

Object.assign( _, ToolsExtension );

//

let NumberExtension =
{

  clamp,
  mix,

}

Object.assign( _.number, NumberExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Number.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Number_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Number_s */ })();

/* */  /* begin of file Object_s */ ( function Object_s() { function Object_s_naked() { ( function _l5_Object_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.object = _.object || Object.create( null );

// --
// dichotomy
// --

// --
// extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

let ObjectExtension =
{

}

Object.assign( _.object, ObjectExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Object.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Object_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Object_s */ })();

/* */  /* begin of file Pair_s */ ( function Pair_s() { function Pair_s_naked() { ( function _l5_Pair_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.pair = _.pair || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{
};

//

_.props.supplement( _.pair, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Pair.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Pair_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Pair_s */ })();

/* */  /* begin of file Path_s */ ( function Path_s() { function Path_s_naked() { ( function _l5_Path_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.path;

// --
//
// --

function escape( filePath )
{
  let self = this;
  let splits = self.split( filePath );

  splits = splits.map( ( split ) =>
  {

    {
      let i = 0;
      while( split[ i ] === '"' )
      i += 1;
      if( i > 0 )
      split = split.substring( 0, i ) + split;
    }

    {
      let i = split.length-1;
      while( split[ i ] === '"' )
      i -= 1;
      if( i < split.length-1 )
      split = split + split.substring( i+1, split.length );
    }

    let left = _.strLeft_( split, self.escapeTokens )
    if( left.entry )
    return `"${split}"`;
    return split;

  });

  return splits.join( self.upToken );
}

// --
// extension
// --

let Extension =
{
  escape,
}

_.props.supplement( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Path.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Path_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Path_s */ })();

/* */  /* begin of file Permutation_s */ ( function Permutation_s() { function Permutation_s_naked() { ( function _l5_Permutation_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.permutation = _.permutation || Object.create( null );

// --
//
// --

/**
 * Routine eachSample() accepts the container {-sets-} with scalar or vector elements.
 * Routine returns an array of vectors. Each vector is a unique combination of elements of vectors
 * that is passed in option {-sets-}.
 *
 * Routine eachSample() accepts the options map {-o-} or two arguments. If options map
 * is used, all parameters can be set. If passed two arguments, first of them is ( sets )
 * and second is ( onEach ).
 *
 * Routine eachSample() accepts the callback {-onEach-}. Callback accepts two arguments. The first is
 * template {-sample-} and second is index of vector in returned array. Callback can change template {-sample-}
 * and corrupt the building of vectors.
 *
 * @param {Array|Map} sets - Container with vector and scalar elements to combine new vectors.
 * @param {Routine|Null} onEach - Callback that accepts template {-sample-} and index of new vector.
 * @param {Array|Map} sample - Template for new vectors. If not passed, routine create empty container.
 * If sample.length > vector.length, then vector elements replace template elements with the same indexes.
 * @param {boolean} leftToRight - Sets the direction of reading {-sets-}. 1 - left to rigth, 0 - rigth to left. By default is 1.
 * @param {boolean} result - Sets retuned value. 1 - routine returns array with verctors, 0 - routine returns index of last element. By default is 1.
 *
 * @example
 * var got = _.permutation.eachSample( { sets : [ [ 0, 1 ], 2 ] });
 * console.log( got );
 * // log [ [ 0, 2 ], [ 1, 2 ] ]
 *
 * @example
 * var got = _.permutation.eachSample( { sets : [ [ 0, 1 ], [ 2, 3 ] ], result : 0 });
 * console.log( got );
 * // log 3
 *
 * @example
 * var got = _.permutation.eachSample( { sets : [ [ 0, 1 ], [ 2, 3 ] ] });
 * console.log( got );
 * // log [ [ 0, 2 ], [ 1, 2 ],
 *          [ 0, 3 ], [ 1, 3 ] ]
 *
 * @example
 * var got = _.permutation.eachSample( { sets : { a : [ 0, 1 ], b : [ 2, 3 ] } });
 * console.log( got );
 * // log [ { a : 0, b : 2}, { a : 1, b : 2},
 *          { a : 0, b : 3}, { a : 1, b : 3} ]
 *
 * @example
 * var got = _.permutation.eachSample( { sets : [ [ 0, 1 ], [ 2, 3 ] ], leftToRight : 0 } );
 * console.log( got );
 * // log [ [ 3, 0 ], [ 2, 0 ],
 *          [ 3, 1 ], [ 2, 1 ] ]
 *
 * @example
 * var got = _.permutation.eachSample
 * ({
 *   sets : [ [ 0, 1 ], [ 2, 3 ] ],
 *   sample : [ 2, 3, 4, 5 ]
 * });
 * console.log( got );
 * // log [ [ 3, 0, 4, 5 ], [ 2, 0, 4, 5 ],
 *          [ 3, 1, 4, 5 ], [ 2, 1, 4, 5 ] ]
 *
 * @example
 * function onEach( sample, i )
 * {
 *   _.arrayAppend( got, sample[ i ] );
 * }
 * var got = [];
 * _.permutation.eachSample
 * ({
 *   sets : [ [ 0, 1 ], [ 2, 3 ] ],
 *   onEach : onEach,
 *   sample : [ 'a', 'b', 'c', 'd' ]
 * });
 * console.log( got );
 * // log [ 0, 2, 'c', 'd' ]
 *
 * @function eachSample
 * @returns {Array} Returns array contained  check function.
 * @throws {exception} If ( arguments.length ) is less then one or more then two.
 * @throws {exception} If( onEach ) is not a Routine or null.
 * @throws {exception} If( o.sets ) is not array or objectLike.
 * @throws {exception} If ( sets ) is aixiliary and ( onEach ) not passed.
 * @throws {exception} If( o.base ) or ( o.add) is undefined.
 * @namespace Tools
 */

function eachSample( o )
{

  if( arguments.length === 2 )
  o =
  {
    sets : arguments[ 0 ],
    onEach : arguments[ 1 ],
  }
  else if( _.argumentsArray.like( arguments[ 0 ] ) )
  o =
  {
    sets : arguments[ 0 ],
  }

  _.routine.options( eachSample, o );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.routine.is( o.onEach ) || o.onEach === null );
  _.assert( _.longLike( o.sets ) || _.aux.is( o.sets ) );
  _.assert( o.base === undefined && o.add === undefined );

  if( o.result === null )
  o.result = o.onEach === null;

  /* sample */

  if( !o.sample )
  o.sample = _.entity.makeUndefined( o.sets );

  /* */

  let keys = _.longLike( o.sets ) ? _.longFromRange([ 0, o.sets.length ]) : _.props.keys( o.sets );
  if( _.bool.likeTrue( o.result ) && !_.arrayIs( o.result ) )
  o.result = [];
  if( keys.length === 0 )
  return o.result ? o.result : 0;
  let len = [];
  let indexnd = [];
  let index = 0;
  let l = _.entity.lengthOf( o.sets );

  /* sets */

  let sindex = 0;
  let breaking = 0;

  o.sets = _.filter_( null, o.sets, function( set, k )
  {
    _.assert( _.longIs( set ) || _.primitive.is( set ) );

    if( breaking === 0 )
    {
      if( _.primitive.is( set ) )
      set = [ set ];

      if( set.length === 0 )
      breaking = 1;

      len[ sindex ] = _.entity.lengthOf( o.sets[ k ] );
      indexnd[ sindex ] = 0;
      sindex += 1;
    }
    return set;

  });

  if( breaking === 1 )
  return o.result ? o.result : 0;

  /* */

  if( !firstSample() )
  return o.result;

  let iterate = o.leftToRight ? iterateLeftToRight : iterateRightToLeft;
  do
  {
    if( o.onEach )
    o.onEach.call( o.sample, o.sample, index );
  }
  while( iterate() );

  if( o.result )
  return o.result;
  else
  return index;

  /* */

  function firstSample()
  {
    let sindex = 0;

    _.each( o.sets, function( e, k )
    {
      o.sample[ k ] = o.sets[ k ][ indexnd[ sindex ] ];
      sindex += 1;
      if( !len[ k ] )
      return 0;
    });

    if( o.result )
    if( _.aux.is( o.sample ) )
    o.result.push( _.props.extend( null, o.sample ) );
    else
    // o.result.push( _.longSlice( o.sample ) ); /* Dmytro : routine _.longSlice is the common interface for slicing of longs */
    o.result.push( _.longSlice( o.sample ) );

    return 1;
  }

  /* */

  function nextSample( i )
  {

    let k = keys[ i ];
    indexnd[ i ]++;

    if( indexnd[ i ] >= len[ i ] )
    {
      indexnd[ i ] = 0;
      o.sample[ k ] = o.sets[ k ][ indexnd[ i ] ];
    }
    else
    {
      o.sample[ k ] = o.sets[ k ][ indexnd[ i ] ];
      index += 1;

      if( o.result )
      if( _.aux.is( o.sample ) )
      o.result.push( _.props.extend( null, o.sample ) );
      else
      // o.result.push( o.sample.slice() );
      o.result.push( _.longSlice( o.sample ) );

      return 1;
    }

    return 0;
  }

  /* */

  function iterateLeftToRight()
  {
    for( let i = 0 ; i < l ; i++ )
    if( nextSample( i ) )
    return 1;

    return 0;
  }

  /* */

  function iterateRightToLeft()
  {
    for( let i = l - 1 ; i >= 0 ; i-- )
    if( nextSample( i ) )
    return 1;

    return 0;
  }

}

eachSample.defaults =
{
  leftToRight : 1,
  onEach : null,

  sets : null,
  sample : null,

  result : null, /* was 1 */
};

//

function eachPermutation( o )
{

  _.routine.options( eachPermutation, arguments );

  if( o.result === null )
  o.result = o.onEach === null;

  if( _.number.is( o.sets ) )
  {
    if( o.sets < 0 )
    o.sets = 0;
    let sets = Array( o.sets );
    for( let i = o.sets-1 ; i >= 0 ; i-- )
    sets[ i ] = i;
    o.sets = sets;
  }

  if( _.bool.likeTrue( o.result ) && !_.arrayIs( o.result ) )
  o.result = [];

  const add = ( _.argumentsArray.like( o.result ) || _.routineIs( o.result.push ) ) ? append1 : append0;
  const dst = o.result ? o.result : undefined;
  const sets = o.sets;
  const length = o.sets.length;
  const last = length - 1;
  const plast = length - 2;
  const slast = length - 3;
  const iterateAll = o.onEach === null ? iterateWithoutCallback : iterateWithCallback;
  let left = last;
  let swaps = 0;
  let iteration = 0;

  if( length <= 1 )
  {
    if( length === 1 )
    {
      if( o.onEach )
      o.onEach( sets, iteration, left, last, swaps );
      add();
    }
    return;
  }

  let iterations = 1;
  for( let i = plast-1 ; i >= 0 ; i-- )
  {
    iterations *= ( last - i );
  }
  iterations *= length;

  let counter = [];
  for( let i = plast ; i >= 0 ; i-- )
  counter[ i ] = last-i;

  _.assert( _.longIs( sets ) );
  _.assert( length >= 0 );
  _.assert( length <= 30 );

  iterateAll();

  return dst;

  /* */

  function append0()
  {
  }

  function append1()
  {
    dst.push( sets.slice() );
  }

  function swap( left, right )
  {
    _.assert( sets[ right ] !== undefined );
    _.assert( sets[ left ] !== undefined );
    let ex = sets[ right ];
    sets[ right ] = sets[ left ];
    sets[ left ] = ex;
  }

  function reverse()
  {
    if( left >= slast )
    {
      swaps = 1;
      swap( left, last );
      counter[ left ] -= 1;
    }
    else
    {
      swaps = last - left;
      if( swaps % 2 === 1 )
      swaps -= 1;
      swaps /= 2;
      for( let i = swaps ; i >= 0 ; i-- )
      swap( left + i, last - i );
      counter[ left ] -= 1;
      swaps += 1;
    }
  }

  function nextCounter()
  {
    while( counter[ left ] === 0 && left !== 0 )
    left -= 1;
    for( let i = left + 1 ; i < counter.length ; i++ )
    counter[ i ] = last - i;
  }

  function onEachDefault()
  {
  }

  function iterateWithoutCallback()
  {

    while( iteration < iterations )
    {
      add();
      left = plast;
      nextCounter();
      reverse();
      iteration += 1;
    }
  }

  function iterateWithCallback()
  {
    _.assert( _.routineIs( o.onEach ), 'Expects routine {-o.onEach-}' );

    while( iteration < iterations )
    {
      o.onEach( sets, iteration, left, last, swaps );
      add();
      left = plast;
      nextCounter();
      reverse();
      iteration += 1;
    }
  }

}

eachPermutation.defaults =
{
  onEach : null,
  sets : null, /* was container */
  result : null, /* was dst */
}

/*

== number:3

= log

0 . 2..2 . 0 1 2
1 . 1..2 . 0 2 1
2 . 0..2 . 1 2 0
3 . 1..2 . 1 0 2
4 . 0..2 . 2 0 1
5 . 1..2 . 2 1 0

== number:4

= log

0 . 3..3 . 0 1 2 3
1 . 2..3 . 0 1 3 2
2 . 1..3 . 0 2 3 1
3 . 2..3 . 0 2 1 3
4 . 1..3 . 0 3 1 2
5 . 2..3 . 0 3 2 1

6 . 0..3 . 1 2 3 0
7 . 2..3 . 1 2 0 3
8 . 1..3 . 1 3 0 2
9 . 2..3 . 1 3 2 0
10 . 1..3 . 1 0 2 3
11 . 2..3 . 1 0 3 2

12 . 0..3 . 2 3 0 1
13 . 2..3 . 2 3 1 0
14 . 1..3 . 2 0 1 3
15 . 2..3 . 2 0 3 1
16 . 1..3 . 2 1 3 0
17 . 2..3 . 2 1 0 3

18 . 0..3 . 3 0 1 2
19 . 2..3 . 3 0 2 1
20 . 1..3 . 3 1 2 0
21 . 2..3 . 3 1 0 2
22 . 1..3 . 3 2 0 1
23 . 2..3 . 3 2 1 0

== number:5

= count

120
24
6
2
1

4
3
2

= log

0 . 4..4 . 0 1 2 3 4
1 . 3..4 . 0 1 2 4 3
2 . 2..4 . 0 1 3 4 2
3 . 3..4 . 0 1 3 2 4
4 . 2..4 . 0 1 4 2 3
5 . 3..4 . 0 1 4 3 2
6 . 1..4 . 0 2 3 4 1
7 . 3..4 . 0 2 3 1 4
8 . 2..4 . 0 2 4 1 3
9 . 3..4 . 0 2 4 3 1
10 . 2..4 . 0 2 1 3 4
11 . 3..4 . 0 2 1 4 3
12 . 1..4 . 0 3 4 1 2
13 . 3..4 . 0 3 4 2 1
14 . 2..4 . 0 3 1 2 4
15 . 3..4 . 0 3 1 4 2
16 . 2..4 . 0 3 2 4 1
17 . 3..4 . 0 3 2 1 4
18 . 1..4 . 0 4 1 2 3
19 . 3..4 . 0 4 1 3 2
20 . 2..4 . 0 4 2 3 1
21 . 3..4 . 0 4 2 1 3
22 . 2..4 . 0 4 3 1 2
23 . 3..4 . 0 4 3 2 1

24 . 0..4 . 1 2 3 4 0
25 . 3..4 . 1 2 3 0 4
26 . 2..4 . 1 2 4 0 3
27 . 3..4 . 1 2 4 3 0
28 . 2..4 . 1 2 0 3 4
29 . 3..4 . 1 2 0 4 3
30 . 1..4 . 1 3 4 0 2
31 . 3..4 . 1 3 4 2 0
32 . 2..4 . 1 3 0 2 4
33 . 3..4 . 1 3 0 4 2
34 . 2..4 . 1 3 2 4 0
35 . 3..4 . 1 3 2 0 4
36 . 1..4 . 1 4 0 2 3
37 . 3..4 . 1 4 0 3 2
38 . 2..4 . 1 4 2 3 0
39 . 3..4 . 1 4 2 0 3
40 . 2..4 . 1 4 3 0 2
41 . 3..4 . 1 4 3 2 0
42 . 1..4 . 1 0 2 3 4
43 . 3..4 . 1 0 2 4 3
44 . 2..4 . 1 0 3 4 2
45 . 3..4 . 1 0 3 2 4
46 . 2..4 . 1 0 4 2 3
47 . 3..4 . 1 0 4 3 2

48 . 0..4 . 2 3 4 0 1
49 . 3..4 . 2 3 4 1 0
50 . 2..4 . 2 3 0 1 4
51 . 3..4 . 2 3 0 4 1
52 . 2..4 . 2 3 1 4 0
53 . 3..4 . 2 3 1 0 4
54 . 1..4 . 2 4 0 1 3
55 . 3..4 . 2 4 0 3 1
56 . 2..4 . 2 4 1 3 0
57 . 3..4 . 2 4 1 0 3
58 . 2..4 . 2 4 3 0 1
59 . 3..4 . 2 4 3 1 0
60 . 1..4 . 2 0 1 3 4
61 . 3..4 . 2 0 1 4 3
62 . 2..4 . 2 0 3 4 1
63 . 3..4 . 2 0 3 1 4
64 . 2..4 . 2 0 4 1 3
65 . 3..4 . 2 0 4 3 1
66 . 1..4 . 2 1 3 4 0
67 . 3..4 . 2 1 3 0 4
68 . 2..4 . 2 1 4 0 3
69 . 3..4 . 2 1 4 3 0
70 . 2..4 . 2 1 0 3 4
71 . 3..4 . 2 1 0 4 3
72 . 0..4 . 3 4 0 1 2
73 . 3..4 . 3 4 0 2 1
74 . 2..4 . 3 4 1 2 0
75 . 3..4 . 3 4 1 0 2
76 . 2..4 . 3 4 2 0 1
77 . 3..4 . 3 4 2 1 0
78 . 1..4 . 3 0 1 2 4
79 . 3..4 . 3 0 1 4 2
80 . 2..4 . 3 0 2 4 1
81 . 3..4 . 3 0 2 1 4
82 . 2..4 . 3 0 4 1 2
83 . 3..4 . 3 0 4 2 1
84 . 1..4 . 3 1 2 4 0
85 . 3..4 . 3 1 2 0 4
86 . 2..4 . 3 1 4 0 2
87 . 3..4 . 3 1 4 2 0
88 . 2..4 . 3 1 0 2 4
89 . 3..4 . 3 1 0 4 2
90 . 1..4 . 3 2 4 0 1
91 . 3..4 . 3 2 4 1 0
92 . 2..4 . 3 2 0 1 4
93 . 3..4 . 3 2 0 4 1
94 . 2..4 . 3 2 1 4 0
95 . 3..4 . 3 2 1 0 4
96 . 0..4 . 4 0 1 2 3
97 . 3..4 . 4 0 1 3 2
98 . 2..4 . 4 0 2 3 1
99 . 3..4 . 4 0 2 1 3
100 . 2..4 . 4 0 3 1 2
101 . 3..4 . 4 0 3 2 1
102 . 1..4 . 4 1 2 3 0
103 . 3..4 . 4 1 2 0 3
104 . 2..4 . 4 1 3 0 2
105 . 3..4 . 4 1 3 2 0
106 . 2..4 . 4 1 0 2 3
107 . 3..4 . 4 1 0 3 2
108 . 1..4 . 4 2 3 0 1
109 . 3..4 . 4 2 3 1 0
110 . 2..4 . 4 2 0 1 3
111 . 3..4 . 4 2 0 3 1
112 . 2..4 . 4 2 1 3 0
113 . 3..4 . 4 2 1 0 3
114 . 1..4 . 4 3 0 1 2
115 . 3..4 . 4 3 0 2 1
116 . 2..4 . 4 3 1 2 0
117 . 3..4 . 4 3 1 0 2
118 . 2..4 . 4 3 2 0 1
119 . 3..4 . 4 3 2 1 0

*/

//

function swapsCount( permutation )
{
  let counter = 0;
  let forward = permutation.slice();
  let backward = [];
  for( let i = forward.length-1 ; i >= 0 ; i-- )
  {
    backward[ forward[ i ] ] = i;
  }
  for( let i = backward.length-1 ; i >= 0 ; i-- )
  {
    if( backward[ i ] !== i )
    {
      let forward1 = forward[ i ];
      let backward1 = backward[ i ];
      forward[ backward1 ] = forward1;
      backward[ forward1 ] = backward1;
      counter += 1;
    }
  }
  return counter;
}

//

/* Calculates the factorial of an integer number ( >= 0 ) */

function _factorial( src )
{
  let result = 1;
  while( src > 1 )
  {
    result = result * src;
    src -= 1;
  }
  return result;
}

//

/**
 * @summary Returns factorial for number `src`.
 * @description Number `src`
 * @param {Number} src Source number. Should be less than 10000.
 * @function factorial
 * @namespace Tools
 * @module wTools
 */

function factorial( src )
{
  _.assert( src < 10000 );
  _.assert( _.intIs( src ) );
  _.assert( src >= 0 );
  _.assert( arguments.length === 1, 'Expects single argument' );
  if( src === 0 )
  return 1;
  return _.permutation._factorial( src )
}

// --
// extend permutation
// --

let PermutationExtension =
{

  eachSample, /* xxx : review */
  eachPermutation,
  swapsCount,
  _factorial,
  factorial,

}

//

Object.assign( _.permutation, PermutationExtension );

// --
// extend tools
// --

let ToolsExtension =
{

  // eachSample, /* xxx : review */
  // eachPermutation,
  // swapsCount,
  // _factorial,
  factorial,

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Permutation.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Permutation_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Permutation_s */ })();

/* */  /* begin of file Primitive_s */ ( function Primitive_s() { function Primitive_s_naked() { ( function _l5_Primitive_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

//

let PrimitiveExtension =
{
}

Object.assign( _.primitive, PrimitiveExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Primitive.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Primitive_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Primitive_s */ })();

/* */  /* begin of file Printer_s */ ( function Printer_s() { function Printer_s_naked() { ( function _l5_Printer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.printer = _.printer || Object.create( null );

// --
// printer
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( Self, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Printer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Printer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Printer_s */ })();

/* */  /* begin of file Process_s */ ( function Process_s() { function Process_s_naked() { ( function _l5_Process_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.process = _.process || Object.create( null );

// --
// implementation
// --

// --
// declaration
// --

let Extension =
{

}

_.props.supplement( _.process, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Process.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Process_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Process_s */ })();

/* */  /* begin of file PropertyTransformer_s */ ( function PropertyTransformer_s() { function PropertyTransformer_s_naked() { ( function _l5_PropertyTransformer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function mapperFromCondition( routine )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.routine.is( routine ), 'Expects routine but got', _.entity.strType( routine ) );
  _.assert( !!routine.identity );

  if( routine.identity.propertyCondition )
  {
    if( routine.identity.functor )
    {
      functor.identity = { propertyMapper : true, propertyTransformer : true, functor : true };
      return functor;
    }
    else
    {
      mapper.identity = { propertyMapper : true, propertyTransformer : true };
      return mapper;
    }
  }
  else if( routine.identity.propertyMapper )
  {
    return routine;
  }
  else _.assert( 0, 'Expects PropertyTransformer' );

  function mapper( dstContainer, srcContainer, key )
  {
    let result = routine( dstContainer, srcContainer, key );
    _.assert( _.bool.is( result ) );
    if( result === false )
    return;
    dstContainer[ key ] = srcContainer[ key ];
  }

  function functor()
  {
    let routine2 = routine( ... arguments );
    _.assert( _.props.conditionIs( routine2 ) && !routine2.identity.functor );
    mapper.identity = { propertyMapper : true, propertyTransformer : true };
    return mapper;
    function mapper( dstContainer, srcContainer, key )
    {
      let result = routine2( dstContainer, srcContainer, key );
      _.assert( _.bool.is( result ) );
      if( result === false )
      return;
      dstContainer[ key ] = srcContainer[ key ];
    }
  }

}

//

function mapperFrom( routine )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.routine.is( routine ), 'Expects routine but got', _.entity.strType( routine ) );

  if( routine.identity )
  {
    if( routine.identity.propertyMapper )
    {
      routine.identity.propertyTransformer = true;
      return routine;
    }
    else
    {
      return _.props.mapperFromCondition( routine );
    }
  }

  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;
}

//

function conditionFrom( routine )
{

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.routine.is( routine ), 'Expects routine but got', _.entity.strType( routine ) );

  if( routine.identity )
  {
    if( !routine.identity.propertyCondition )
    {
      _.assert( !routine.identity.propertyMapper, 'It is not possible to convert FieldMapper to FieldFilter' );
      _.assert( routine.identity.propertyCondition === undefined );
      routine.identity.propertyCondition = true;
    }
    routine.identity.propertyTransformer = true;
    return routine;
  }

  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;
}

//

function transformerRegister( fi, name )
{

  if( !name )
  name = fi.name;

  _.assert( _.strDefined( name ) );
  _.assert( _.object.isBasic( fi.identity ), 'Not property transformer' );
  _.assert( !!fi.identity );

  if( fi.identity.propertyMapper )
  {
    _.assert( _.props.mapper[ name ] === undefined );
    _.props.mapper[ name ] = mapperFrom( fi );
    return;
  }
  else if( fi.identity.propertyCondition )
  {
    _.assert( _.props.condition[ name ] === undefined );
    _.assert( _.props.mapper[ name ] === undefined );
    _.props.mapper[ name ] = _.props.mapperFromCondition( fi );
    _.props.condition[ name ] = fi;
    return;
  }
  else _.assert( 0, 'unexpected' );

}

//

function transformersRegister( transformers )
{

  _.assert( _.mapIs( transformers ) );

  for( let f in transformers )
  {
    let fi = transformers[ f ];

    // if( fi.length )
    // debugger;
    // if( fi.length ) /* xxx*/
    // continue;
    // fi = fi();

    _.assert( !!fi.identity && !!fi.identity.functor, `Routine::${f} is not functor` );
    _.props.transformerRegister( fi, f );
  }

}

//

function transformerUnregister( transformerName, transformerType )
{
  transformerType = transformerType || 'mapper';

  _.assert( _.strIs( transformerName ) );
  _.assert( _.strIs( transformerType ) );
  _.assert( _.props[ transformerType ][ transformerName ] !== undefined, 'Transformer must be registered' );

  delete _.props[ transformerType ][ transformerName ];
  return;
}

//

function transformersUnregister( transformerNames, transformerType )
{
  _.assert( _.arrayIs( transformerNames ) );
  _.assert( _.strIs( transformerType ) );

  transformerNames.forEach( ( transformerName ) => _.props.transformerUnregister( transformerName, transformerType ) )
  return;
}

//

function transformerIs( transformer )
{
  if( !_.routine.is( transformer ) )
  return false;
  if( !_.object.isBasic( transformer.identity ) )
  return false;

  let result =
  (
    !!( transformer.identity.propertyTransformer
    || transformer.identity.propertyCondition
    || transformer.identity.propertyMapper )
  );

  return result;
}

//

function mapperIs( transformer )
{
  if( !_.routine.is( transformer ) )
  return false;
  if( !_.object.isBasic( transformer.identity ) )
  return false;
  return !!transformer.identity.propertyMapper;
}

//

function conditionIs( transformer )
{
  if( !_.routine.is( transformer ) )
  return false;
  if( !_.object.isBasic( transformer.identity ) )
  return false;
  return !!transformer.identity.propertyCondition;
}

// --
// extend
// --

let PropsExtension =
{

  mapperFromCondition,
  mapperFrom,
  conditionFrom,
  transformerRegister,
  transformersRegister,
  transformerUnregister,
  transformersUnregister,
  transformerIs,
  mapperIs,
  conditionIs,

}

Object.assign( _.props, PropsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/PropertyTransformer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, PropertyTransformer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file PropertyTransformer_s */ })();

/* */  /* begin of file Props_s */ ( function Props_s() { function Props_s_naked() { ( function _l5_Property_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.props = _.props || Object.create( null );

// --
// implementation
// --

// function identical( src1, src2 )
// {
//
//   _.assert( arguments.length === 2, 'Expects exactly two arguments' );
//   _.assert( !_.primitive.is( src1 ) );
//   _.assert( !_.primitive.is( src2 ) );
//
//   if( Object.keys( src1 ).length !== Object.keys( src2 ).length )
//   return false;
//
//   for( let s in src1 )
//   {
//     if( src1[ s ] !== src2[ s ] )
//     return false;
//   }
//
//   return true;
// }

//

function hasAll( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( !( screen[ s ] in src ) )
    return false;
  }
  else if( _.vector.is( screen ) )
  {
    for( let value of screen )
    if( !( value in src ) )
    return false;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( !( k in src ) )
    return false;
  }

  return true;

}

//

function hasAny( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( screen[ s ] in src )
    return true;
  }
  else if( _.vector.is( screen ) )
  {
    for( let value of screen )
    if( value in src )
    return true;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( k in src )
    return true;
  }

  return false;
}

//

function hasNone( src, screen )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( !_.primitive.is( src ) );
  _.assert( !_.primitive.is( screen ) );

  if( _.argumentsArray.like( screen ) )
  {
    for( let s = 0 ; s < screen.length ; s++ )
    if( screen[ s ] in src )
    return false;
  }
  else if( _.vector.is( screen ) )
  {
    for( let value of screen )
    if( value in src )
    return false;
  }
  else if( _.aux.is( screen ) )
  {
    for( let k in screen )
    if( k in src )
    return false;
  }

  return true;
}

// // --
// // property implicit
// // --
//
// const prototypeSymbol = Symbol.for( 'prototype' );
// const constructorSymbol = Symbol.for( 'constructor' );
//
// _.assert( _.props.implicit === undefined );
// _.assert( _.props.Implicit === undefined );
// _.props.implicit = _.wrap.declare({ name : 'Implicit' }).namespace;
// _.props.Implicit = _.props.implicit.class;
// _.assert( _.mapIs( _.props.implicit ) );
// _.assert( _.routineIs( _.props.Implicit ) );
//
// _.props.implicit.prototype = new _.props.Implicit( prototypeSymbol );
// _.props.implicit.constructor = new _.props.Implicit( constructorSymbol );

// --
// extension
// --

let Extension =
{

  // identical,
  hasAll,
  hasAny,
  hasNone,

}

//

Object.assign( _.props, Extension );
// _.assert( _.routine.is( _.props.filterWithEscape ) ); debugger;

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Props.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Props_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Props_s */ })();

/* */  /* begin of file Prototype_s */ ( function Prototype_s() { function Prototype_s_naked() { ( function _l5_Prototype_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.prototype = _.prototype || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{
}

//

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Prototype.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Prototype_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Prototype_s */ })();

/* */  /* begin of file Regexp_s */ ( function Regexp_s() { function Regexp_s_naked() { ( function _l5_Regexp_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
// const Self = _global_.wTools;
_.regexp = _.regexp || Object.create( null );
_.regexp.s = _.regexp.s || Object.create( null );

// --
// regexp
// --

function regexpsEquivalent( src1, src2 )
{

  _.assert( _.strIs( src1 ) || _.regexpIs( src1 ) || _.longIs( src1 ), 'Expects string/regexp or array of strings/regexps {-src1-}' );
  _.assert( _.strIs( src2 ) || _.regexpIs( src2 ) || _.longIs( src2 ), 'Expects string/regexp or array of strings/regexps {-src2-}' );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  let isLong1 = _.longIs( src1 );
  let isLong2 = _.longIs( src2 );

  if( isLong1 && isLong2 )
  {
    let result = [];
    _.assert( src1.length === src2.length );
    for( let i = 0, len = src1.length ; i < len; i++ )
    {
      result[ i ] = _.regexp.equivalent( src1[ i ], src2[ i ] );
    }
    return result;
  }
  else if( !isLong1 && isLong2 )
  {
    let result = [];
    for( let i = 0, len = src2.length ; i < len; i++ )
    {
      result[ i ] = _.regexp.equivalent( src1, src2[ i ] );
    }
    return result;
  }
  else if( isLong1 && !isLong2 )
  {
    let result = [];
    for( let i = 0, len = src1.length ; i < len; i++ )
    {
      result[ i ] = _.regexp.equivalent( src1[ i ], src2 );
    }
    return result;
  }
  else
  {
    return _.regexp.equivalent( src1, src2 );
  }

}

//

function _test( regexp, str )
{
  _.assert( arguments.length === 2 );
  _.assert( _.regexpLike( regexp ) );
  _.assert( _.strIs( str ) );

  if( _.strIs( regexp ) )
  return regexp === str;
  else
  return regexp.test( str );

}

//

function test( regexp, strs )
{
  _.assert( arguments.length === 2 );
  _.assert( _.regexpLike( regexp ) );

  if( _.strIs( strs ) )
  return _.regexp._test( regexp, strs );
  else if( _.argumentsArray.like( strs ) )
  return strs.map( ( str ) => _.regexp._test( regexp, str ) )
  else _.assert( 0 );

}

//

function testAll( regexp, strs )
{
  _.assert( arguments.length === 2 );
  _.assert( _.regexpLike( regexp ) );

  if( _.strIs( strs ) )
  return _.regexp._test( regexp, strs );
  else if( _.argumentsArray.like( strs ) )
  return strs.every( ( str ) => _.regexp._test( regexp, str ) )
  else _.assert( 0 );

}

//

function testAny( regexp, strs )
{
  _.assert( arguments.length === 2 );
  _.assert( _.regexpLike( regexp ) );

  if( _.strIs( strs ) )
  return _.regexp._test( regexp, strs );
  else if( _.argumentsArray.like( strs ) )
  return strs.some( ( str ) => _.regexp._test( regexp, str ) )
  else _.assert( 0 );

}

//

function testNone( regexp, strs )
{
  _.assert( arguments.length === 2 );
  _.assert( _.regexpLike( regexp ) );

  if( _.strIs( strs ) )
  return !_.regexp._test( regexp, strs );
  else if( _.argumentsArray.like( strs ) )
  return !strs.some( ( str ) => _.regexp._test( regexp, str ) )
  else _.assert( 0 );

}

//

function regexpsTestAll( regexps, strs )
{
  _.assert( arguments.length === 2 );

  if( !_.arrayIs( regexps ) )
  return _.regexpTestAll( regexps, strs );

  _.assert( _.regexpsLikeAll( regexps ) );

  return regexps.every( ( regexp ) => _.regexpTestAll( regexp, strs ) );
}

//

function regexpsTestAny( regexps, strs )
{
  _.assert( arguments.length === 2 );

  if( !_.arrayIs( regexps ) )
  return _.regexpTestAny( regexps, strs );

  _.assert( _.regexpsLikeAll( regexps ) );

  return regexps.some( ( regexp ) => _.regexpTestAny( regexp, strs ) );
}

//

function regexpsTestNone( regexps, strs )
{
  _.assert( arguments.length === 2 );

  if( !_.arrayIs( regexps ) )
  return _.regexpTestNone( regexps, strs );

  _.assert( _.regexpsLikeAll( regexps ) );

  return regexps.every( ( regexp ) => _.regexpTestNone( regexp, strs ) );
}

// --
// extension
// --

let ToolsExtension =
{

  regexpsEquivalent : regexpsEquivalent,
  regexpsEquivalentAll : _.vectorizeAll( _.regexp.equivalentShallow.bind( _.regexp ), 2 ),
  regexpsEquivalentAny : _.vectorizeAny( _.regexp.equivalentShallow.bind( _.regexp ), 2 ),
  regexpsEquivalentNone : _.vectorizeNone( _.regexp.equivalentShallow.bind( _.regexp ), 2 ),

  regexpsEscape : _.vectorize( _.regexpEscape ),

  _regexpTest : _test,
  regexpTest : test,

  regexpTestAll : testAll,
  regexpTestAny : testAny,
  regexpTestNone : testNone,

  regexpsTestAll,
  regexpsTestAny,
  regexpsTestNone,


}

_.props.supplement( _, ToolsExtension ); /* qqq for junior : create namespace _.regexp. stand-alone PR | aaa : Done. */

//

let RegexpExtension =
{

  // regexp

  _test,
  test,

  testAll,
  testAny,
  testNone,

}

_.props.supplement( _.regexp, RegexpExtension );

//

let RegexpsExtension =
{

  // regexps

  regexpsEquivalent,

  escape : _.vectorize( _.regexpEscape ),

  testAll : regexpsTestAll,
  testAny : regexpsTestAny,
  testNone : regexpsTestNone,

}

//

_.props.supplement( _.regexp.s, RegexpsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Regexp.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Regexp_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Regexp_s */ })();

/* */  /* begin of file Routine_s */ ( function Routine_s() { function Routine_s_naked() { ( function _l5_Routine_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

let RoutineExtension =
{

}

//

Object.assign( _.routine, RoutineExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Routine.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Routine_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Routine_s */ })();

/* */  /* begin of file Set_s */ ( function Set_s() { function Set_s_naked() { ( function _l5_Set_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function butElement( dst, src1, element )
{

  if( dst === null )
  dst = new Set();
  else if( dst === _.self )
  dst = src1;

  _.assert( arguments.length === 3 );
  _.assert( _.set.is( dst ) || dst === null );
  _.assert( _.countable.is( src1 ) );

  if( dst === src1 )
  {
    dst.delete( element );
  }
  else
  {
    for( let e of src1 )
    if( e !== element )
    dst.add( e );
  }

  return dst;
}

//

/* qqq : cover */
/* qqq : add test cases src1/src2 is set/countable/array/unrolls */
function but( dst, src1, src2 )
{

  if( dst === null )
  dst = new Set();
  else if( dst === _.self )
  dst = src1;

  _.assert( arguments.length === 3 );
  _.assert( _.set.is( dst ) || dst === null );
  _.assert( _.countable.is( src1 ) );
  _.assert( _.countable.is( src2 ) );

  if( dst === src1 )
  {
    for( let e of src2 )
    if( dst.has( e ) )
    dst.delete( e );
  }
  else
  {
    if( !_.set.is( src2 ) )
    src2 = [ ... src2 ];
    for( let e of src1 )
    if( !src2.has( e ) )
    dst.add( e );
  }

  return dst;
}

//

/* qqq : cover */
/* qqq : src1 could be countable or unroll */
/* qqq : src2 could be countable or unroll */
function only( dst, src1, src2 )
{
  // if( arguments.length === 2 )
  // {
  //   dst = null;
  //   src1 = arguments[ 0 ];
  //   src2 = arguments[ 1 ];
  // }

  _.assert( arguments.length === 3 );
  _.assert( dst === null || _.set.is( dst ) );
  _.assert( _.countable.is( src1 ) );
  _.assert( _.countable.is( src2 ) );

  if( dst === null )
  dst = new Set();

  for( let e of src1 )
  if( src2.has( e ) )
  dst.add( e );

  return dst;
}

//

/* qqq : cover */
/* qqq : src1 could be countable or unroll */
/* qqq : src2 could be countable or unroll */
function union( dst, src1, src2 )
{

  // if( arguments.length === 2 )
  // {
  //   dst = null;
  //   src1 = arguments[ 0 ];
  //   src2 = arguments[ 1 ];
  // }

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( dst === null || _.set.is( dst ) );
  _.assert( _.countable.is( src1 ) );
  _.assert( _.countable.is( src2 ) );

  if( dst === null )
  dst = new Set();

  if( _.unrollIs( src1 ) )
  {
    _.assert( 0, 'not implemented' );
    for( let set of src1 )
    {
      _.assert( _.set.is( set ) );
      for( let e of set )
      dst.add( e );
    }
  }
  else
  {
    for( let e of src1 )
    dst.add( e );
  }

  if( src2 !== undefined )
  if( _.unrollIs( src2 ) )
  {
    xxx
    for( let set of src2 )
    {
      _.assert( _.set.is( set ) );
      for( let e of set )
      dst.add( e );
    }
  }
  else
  {
    for( let e of src2 )
    dst.add( e );
  }

  return dst;
}

//

/* qqq : cover */
function diff( dst, src1, src2 )
{

  if( arguments.length === 2 )
  {
    dst = null;
    src1 = arguments[ 0 ];
    src2 = arguments[ 1 ];
  }

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( dst === null || _.aux.is( dst ) );
  _.assert( _.set.is( src1 ) );
  _.assert( _.set.is( src2 ) );

  dst = dst || Object.create( null );
  dst.src1 = _.set.but( dst.src1 || null, src1, src2 );
  dst.src2 = _.set.but( dst.src2 || null, src2, src1 );
  dst.diff = new Set([ ... dst.src1, ... dst.src2 ]);
  dst.identical = dst.src1.size === 0 && dst.src2.size === 0;

  return dst;
}

//

function appendContainer( dst, src )
{
  if( dst === null )
  dst = new Set;

  _.assert( arguments.length === 2 );

  if( _.countable.is( src ) )
  {
    dst.add( ... src );
  }
  else
  {
    dst.add( src );
  }

  return dst;
}

// --
// extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

//

let SetExtension =
{

  /* xxx2 : review */
  butElement,
  but,
  only,
  union,
  diff,

  appendContainer,

}

Object.assign( _.set, SetExtension );

//

let SetsExtension =
{

}

//

Object.assign( _.set.s, SetsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Set.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Set_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Set_s */ })();

/* */  /* begin of file Sorted_s */ ( function Sorted_s() { function Sorted_s_naked() { ( function _l5_Sorted_s_()
{

'use strict';

//

const _global = _global_;
const _ = _global_.wTools;
_.sorted = _.sorted || Object.create( null );

// --
// implementation
// --

function searchFirstIndex( srcArr, ins )
{
  let l = 0;
  let r = srcArr.length;
  let m;
  if( srcArr.length )

  do
  {
    m = Math.floor( ( l + r ) / 2 );
    if( srcArr[ m ] < ins )
    l = m+1;
    else if( srcArr[ m ] > ins )
    r = m;
    else
    return m;
  }
  while( l < r );
  if( srcArr[ m ] < ins )
  return m+1;

  return m;
}

// --
// extension
// --

let Extension =
{

  searchFirstIndex,
  // searchFirst,

}

_.props.supplement( _.sorted, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Sorted.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Sorted_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Sorted_s */ })();

/* */  /* begin of file Str_s */ ( function Str_s() { function Str_s_naked() { ( function _l5_Str_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// exporter
// --

function _exportStringDiagnosticShallow( src, o )
{
  return src;
}

//

function exportStringDiagnosticShallow( src, o )
{
  let result;
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects 1 or 2 arguments' );
  _.assert( this.like( src ) );
  return this._exportStringDiagnosticShallow( ... arguments );
}

//

function _exportStringCodeShallow( src, o )
{
  return `'${src}'`;
}

//

function exportStringCodeShallow( src, o )
{
  let result;
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects 1 or 2 arguments' );
  _.assert( this.like( src ) );
  return this._exportStringCodeShallow( ... arguments );
}

// --
// decorator
// --

function quote( o )
{

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ], quote : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  if( o.quote === undefined || o.quote === null )
  o.quote = quote.defaults.quote;
  _.map.assertHasOnly( o, quote.defaults );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( _.arrayIs( o.src ) )
  {
    let result = [];
    for( let s = 0 ; s < o.src.length ; s++ )
    result.push( _.strQuote({ src : o.src[ s ], quote : o.quote }) );
    return result;
  }

  let src = o.src;

  if( !_.primitive.is( src ) )
  src = _.entity.exportString( src );

  _.assert( _.primitive.is( src ) );

  let result = o.quote + String( src ) + o.quote;

  return result;
}

quote.defaults =
{
  src : null,
  quote : '"',
}

//

function unquote( o )
{

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ], quote : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  if( o.quote === undefined || o.quote === null )
  o.quote = unquote.defaults.quote;
  _.map.assertHasOnly( o, unquote.defaults );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( _.arrayIs( o.src ) )
  {
    let result = [];
    for( let s = 0 ; s < o.src.length ; s++ )
    result.push( _.strUnquote({ src : o.src[ s ], quote : o.quote }) );
    return result;
  }

  let result = o.src;
  let isolated = _.strIsolateInside( result, o.quote );
  if( isolated[ 0 ] === '' && isolated[ 4 ] === '' )
  result = isolated[ 2 ];

  return result;
}

unquote.defaults =
{
  src : null,
  quote : [ '"', '`', '\'' ],
}

//

/**
 * The routine `strQuotePairsNormalize` analyzes source String or Array and creates an Array of arrays of pairs of quotes.
 * Returns an array with arrays of pairs of quotes.
 *
 * @param { String|Array|_.bool.likeTrue } quote -
 * String : String to add matching pairs to.
 * _.bool.likeTrue : Returnes an array of arrays of 2 elements ( 3 types of quotes: ', ", ` ).
 * Array of strings : Creates matching quotes for strings.
 * Array of arrays of strings : Checks to be exactly 2 elements in array & adds them to the result array.
 *
 * @example
 * _.strQuotePairsNormalize( true );
 * // returns
 * [
 *   [ '"', '"' ],
 *   [ '`', '`' ],
 *   [ '\'', '\'' ]
 * ]
 *
 * @example
 * _.strQuotePairsNormalize( '' );
 * // returns [ [ '', '' ] ]
 *
 * @example
 * _.strQuotePairsNormalize( 'str' );
 * // returns [ [ 'str', 'str' ] ]
 *
 * @example
 * _.strQuotePairsNormalize( [ '', ' ', '\n', 'str' ] );
 * // returns
 * [
 *   [ '', '' ],
 *   [ ' ', ' ' ],
 *   [ '\n', '\n' ],
 *   [ 'str', 'str' ]
 * ]
 *
 * @example
 * _.strQuotePairsNormalize( [ [ '', '' ], [ ' ',  ' ' ], [ '\n', '\n' ], [ 'str', 'str' ] ] )
 * // returns
 * [
 *   [ '', '' ],
 *   [ ' ', ' ' ],
 *   [ '\n', '\n' ],
 *   [ 'str', 'str' ]
 * ]
 *
 * @example
 * _.strQuotePairsNormalize( [ [ '', '' ], '', [ ' ',  ' ' ], '""', [ '\n', '\n' ], '\t', [ 'str', 'str' ], 'src' ] )
 * // returns
 * [
 *   [ '', '' ], [ '', '' ],
 *   [ ' ', ' ' ], [ '""', '""' ],
 *   [ '\n', '\n' ], [ '\t', '\t' ],
 *   [ 'str', 'str' ], [ 'src', 'src' ]
 * ]
 *
 * @returns { Array } Returns an array of arrays with pair of quotes.
 * @throws { Exception } If { -quote- } is not of String or Array type.
 * @throws { Exception } If { -quote- } is of Array type and includes an array with not exactly 2 elements.
 * @throws { Exception } If ( arguments.length ) is not exactly equals 1.
 * @function quotePairsNormalize
 * @namespace Tools
 */

function quotePairsNormalize( quote )
{

  if( ( _.bool.like( quote ) && quote ) )
  quote = quoteAnalyze.defaults.quote;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( quote ) || _.arrayIs( quote ) );

  quote = _.array.as( quote );
  for( let q = 0 ; q < quote.length ; q++ )
  {
    let quotingPair = quote[ q ];
    _.assert( _.pair.is( quotingPair ) || _.strIs( quotingPair ) );
    if( _.strIs( quotingPair ) )
    quotingPair = quote[ q ] = [ quotingPair, quotingPair ];
    _.assert( _.strIs( quotingPair[ 0 ] ) && _.strIs( quotingPair[ 1 ] ) );
  }

  return quote;
}

//

/**
 * The routine `strQuoteAnalyze` analyzes source string and quotes within it.
 * Returns a map with 2 arrays:
 * ranges - indexes of quotes in a source string,
 * quotes - types of quotes used in a source string.
 *
 * @param { Object } o - Options map.
 * @param { String } src - Source string to analyze.
 * @param { String } quote - Quotes to be found in a source string.
 *
 * @example
 * _.strQuoteAnalyze( 'a b c' );
 * // returns { ranges : [], quotes : [] }
 *
 * @example
 * _.strQuoteAnalyze( '"a b" c' );
 * // returns { ranges : [ 0, 4 ], quotes : [ '"' ] }
 *
 * @example
 * _.strQuoteAnalyze( '`a `"b c"`' );
 * // returns { ranges : [ 0, 3, 4, 8 ], quotes : [ '`', '"' ] }
 *
 * @example
 * _.strQuoteAnalyze('""`a `"""b c"``""' );
 * // returns { ranges : [ 0, 1, 2, 5, 6, 7, 8, 12, 13, 14, 15, 16 ], quotes : [ '"', '`', '"', '"', '`', '"' ] }
 *
 * @example
 * _.strQuoteAnalyze( "a', b'`,c` \"", [ [ '\'', '\'' ], '`' ] )
 * // returns { ranges : [ 1, 5, 6, 9 ], quotes : [ "'", "`" ] }
 *
 * @example
 * _.strQuoteAnalyze( "--aa-- --bb--``''\"\",,cc,,", '--' )
 * // returns { ranges : [ 0, 4, 7, 11 ], quotes : [ '--', '--' ] }
 *
 * @returns { Object } Returns a map with 2 arrays: ranges, quotes.
 * @throws { Exception } If redundant arguments are provided.
 * @throws { Exception } If ( arguments.length ) is not equal 1 or 2.
 * @function quoteAnalyze
 * @namespace Tools
 */

function quoteAnalyze( o )
{
  let i = -1;
  let result = Object.create( null );
  result.ranges = [];
  result.quotes = [];

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ], quote : ( arguments.length > 1 ? arguments[ 1 ] : null ) };
  if( o.quote === undefined || o.quote === null )
  o.quote = quoteAnalyze.defaults.quote;
  _.map.assertHasOnly( o, quoteAnalyze.defaults );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  o.quote = _.strQuotePairsNormalize( o.quote );
  let maxQuoteLength = 0;
  for( let q = 0 ; q < o.quote.length ; q++ )
  {
    let quotingPair = o.quote[ q ];
    maxQuoteLength = Math.max( maxQuoteLength, quotingPair[ 0 ].length, quotingPair[ 1 ].length );
  }

  let isEqual = maxQuoteLength === 1 ? isEqualChar : isEqualString;
  let inRange = false
  do
  {
    while( i < o.src.length )
    {
      i += 1;

      if( inRange )
      {
        if( isEqual( inRange ) )
        {
          result.ranges.push( i );
          inRange = false;
        }
        continue;
      }

      for( let q = 0 ; q < o.quote.length ; q++ )
      {
        let quotingPair = o.quote[ q ];
        if( isEqual( quotingPair[ 0 ] ) )
        {
          result.quotes.push( quotingPair[ 0 ] );
          result.ranges.push( i );
          inRange = quotingPair[ 1 ];
          break;
        }
      }
    }

    if( inRange )
    {
      result.quotes.pop();
      i = result.ranges.pop()+1;
      inRange = false;
    }

  }
  while( i < o.src.length );

  return result;

  function isEqualChar( quote )
  {
    _.assert( o.src.length >= i );
    if( o.src[ i ] === quote )
    return true;
    return false;
  }

  function isEqualString( quote )
  {
    if( i+quote.length > o.src.length )
    return false;
    let subStr = o.src.substring( i, i+quote.length );
    if( subStr === quote )
    return true;
    return false;
  }

}

quoteAnalyze.defaults =
{
  src : null,
  quote : [ '"', '`', '\'' ],
}

// --
// splitter
// --

function _leftSingle_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.strIs( src ) );

  if( _.number.is( cinterval ) )
  cinterval = [ cinterval, src.length - 1 ];
  else if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];

  cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  cinterval[ 1 ] = cinterval[ 1 ] === undefined ? src.length - 1 : cinterval[ 1 ];

  if( cinterval[ 0 ] < 0 )
  cinterval[ 0 ] = src.length + cinterval[ 0 ];
  if( cinterval[ 1 ] < -1 )
  cinterval[ 1 ] = src.length + cinterval[ 1 ];

  _.assert( _.intervalIs( cinterval ) );
  _.assert( 0 <= cinterval[ 0 ] && cinterval[ 0 ] <= src.length );
  _.assert( -1 <= cinterval[ 1 ] && cinterval[ 1 ] <= src.length - 1 );

  let result = Object.create( null );
  result.index = src.length;
  result.instanceIndex = -1;
  result.entry = undefined;

  let src1 = src.substring( cinterval[ 0 ], cinterval[ 1 ] + 1 );

  ins = _.array.as( ins );

  for( let k = 0 ; k < ins.length ; k++ )
  {
    let entry = ins[ k ];
    if( _.strIs( entry ) )
    {
      let found = src1.indexOf( entry );
      if( found >= 0 && ( found < result.index || result.entry === undefined ) )
      {
        result.instanceIndex = k;
        result.index = found;
        result.entry = entry;
      }
    }
    else if( _.regexpIs( entry ) )
    {
      let found = src1.match( entry );
      if( found && ( found.index < result.index || result.entry === undefined ) )
      {
        result.instanceIndex = k;
        result.index = found.index;
        result.entry = found[ 0 ];
      }
    }
    else _.assert( 0, 'Expects string-like ( string or regexp )' );
  }

  if( cinterval[ 0 ] !== 0 && result.index !== src.length )
  result.index += cinterval[ 0 ];

  return result;
}

//

function left_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( _.argumentsArray.like( src ) )
  {
    let result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _._strLeftSingle_( src[ s ], ins, cinterval );
    return result;
  }
  else
  {
    return _._strLeftSingle_( src, ins, cinterval );
  }

}

//

function _rightSingle_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.strIs( src ) );

  if( _.number.is( cinterval ) )
  cinterval = [ cinterval, src.length - 1 ];
  else if( cinterval === undefined )
  cinterval = [ 0, src.length - 1 ];

  cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  cinterval[ 1 ] = cinterval[ 1 ] === undefined ? src.length - 1 : cinterval[ 1 ];

  if( cinterval[ 0 ] < 0 )
  cinterval[ 0 ] = src.length + cinterval[ 0 ];
  if( cinterval[ 1 ] < -1 )
  cinterval[ 1 ] = src.length + cinterval[ 1 ];

  _.assert( _.intervalIs( cinterval ) );
  _.assert( 0 <= cinterval[ 0 ] && cinterval[ 0 ] <= src.length );
  _.assert( -1 <= cinterval[ 1 ] && cinterval[ 1 ] <= src.length - 1 );

  let olength = src.length;

  let result = Object.create( null );
  result.index = -1;
  result.instanceIndex = -1;
  result.entry = undefined;

  let src1 = src.substring( cinterval[ 0 ], cinterval[ 1 ] + 1 );

  ins = _.array.as( ins );

  for( let k = 0, len = ins.length ; k < len ; k++ )
  {
    let entry = ins[ k ];
    if( _.strIs( entry ) )
    {
      let found = src1.lastIndexOf( entry );
      if( found >= 0 && found > result.index )
      {
        result.instanceIndex = k;
        result.index = found;
        result.entry = entry;
      }
    }
    else if( _.regexpIs( entry ) )
    {

      let regexp1 = _.regexpsJoin([ '.*', '(', entry, ')' ]);
      let match1 = src1.match( regexp1 );
      if( !match1 )
      continue;

      let regexp2 = _.regexpsJoin([ entry, '(?!(?=.).*', entry, ')' ]);
      let match2 = src1.match( regexp2 );
      _.assert( !!match2 );

      let found;
      let found1 = match1[ 1 ];
      let found2 = match2[ 0 ];
      let index;
      let index1 = match1.index + match1[ 0 ].length;
      let index2 = match2.index + match2[ 0 ].length;

      if( index1 === index2 )
      {
        if( found1.length < found2.length )
        {
          found = found2;
          index = index2 - found.length;
        }
        else
        {
          found = found1;
          index = index1 - found.length;
        }
      }
      else if( index1 < index2 )
      {
        found = found2;
        index = index2 - found.length;
      }
      else
      {
        found = found1;
        index = index1 - found.length;
      }

      if( index > result.index )
      {
        result.instanceIndex = k;
        result.index = index;
        result.entry = found;
      }

    }
    else _.assert( 0, 'Expects string-like ( string or regexp )' );
  }

  if( cinterval[ 0 ] !== 0 && result.index !== -1 )
  result.index += cinterval[ 0 ];

  return result;
}

//

function right_( src, ins, cinterval )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( _.argumentsArray.like( src ) )
  {
    let result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _._strRightSingle_( src[ s ], ins, cinterval );
    return result;
  }
  else
  {
    return _._strRightSingle_( src, ins, cinterval );
  }

}

//

/**
 * Routine strInsideOf() returns part of a source string {-src-} between first occurrence of {-begin-} and last occurrence of {-end-}.
 * Returns result if {-begin-} and {-end-} exists in the {-src-} and index of {-end-} is bigger the index of {-begin-}.
 * Otherwise returns undefined.
 *
 * @example
 * _.strInsideOf({ src : 'abcd', begin : 'a', end : 'd', pairing : 0 });
 * // returns : 'bc'
 *
 * @example
 * _.strInsideOf({ src : 'abcd', begin : 'a', end : 'd', pairing : 1 });
 * // returns : undefined
 *
 * @example
 * // index of begin is bigger then index of end
 * _.strInsideOf( 'abcd', 'c', 'a' )
 * // returns : undefined
 *
 * @example
 * _.strInsideOf( 'abc', 'a', 'a' );
 * // returns : undefined
 *
 * @example
 * _.strInsideOf( 'abcd', 'x', 'y' )
 * // returns : undefined
 *
 * @example
 * _.strInsideOf( 'a', 'a', 'a' );
 * // returns : 'a'
 *
 * Basic parameter set :
 * @param { String } src - The source string.
 * @param { String|Array } begin - String or array of strings to find from begin of source.
 * @param { String|Array } end - String or array of strings to find from end source.
 * Alternative parameter set :
 * @param { String } o - Options map.
 * @param { String } o.src - The source string.
 * @param { String|Array } o.begin - String or array of strings to find from begin of source.
 * @param { String|Array } o.end - String or array of strings to find from end source.
 * @param { BoolLike } o.pairing - If option is enabled and {-begin-} ( or {-end-} ) is an Array of strings, then
 * both containerized {-begin-} and {-end-} should have equivalent lengths.
 * @returns { String|Undefined } - Returns part of source string between {-begin-} and {-end-} or undefined.
 * @throws { Exception } If arguments.length is 1 and argument is not an options map {-o-}.
 * @throws { Exception } If arguments.length is 3 and any of arguments is not a String.
 * @throws { Exception } If arguments.length neither is 1 nor 3.
 * @throws { Exception } If {-o.pairing-} is true like and containerized version of {-o.begin-} and {-o.end-}
 * have different length.
 * @throws { Exception } If options map {-o-} has unknown properties.
 * @function strInsideOf
 * @namespace Tools
 */

function strInsideOf_head( routine, args )
{

  let o = args[ 0 ]
  if( _.mapIs( o ) )
  {
    _.assert( args.length === 1, 'Expects exactly one argument' );
  }
  else
  {
    o = Object.create( null );
    o.src = args[ 0 ];
    o.begin = args[ 1 ];
    o.end = args[ 2 ];
    _.assert( args.length === 3, 'Expects exactly three arguments' );
  }

  _.routine.options( routine, o );
  _.assert( _.strIs( o.src ), 'Expects string {-o.src-}' );

  // if( _.longIs( o.begin ) && o.begin.length === 1 )
  // o.begin = o.begin[ 0 ];
  // if( _.longIs( o.end ) && o.end.length === 1 )
  // o.end = o.end[ 0 ];
  if( _.longIs( o.begin || _.longIs( o.end )) )
  {
    o.begin = _.array.as( o.begin );
    o.end = _.array.as( o.end );
  }

  _.assert
  (
    !o.pairing || !_.longIs( o.begin ) || o.begin.length === o.end.length,
    `If option::o.paring is true then length of o.begin should be equal to length of o.end`
  );

  return o;
}

function strInsideOf_body( o )
{
  let beginOf, endOf;

  beginOf = _.strBeginOf( o.src, o.begin );
  if( beginOf === undefined )
  return undefined;

  endOf = _.strEndOf( o.src, o.end );
  if( endOf === undefined )
  return undefined;

  if( o.pairing && _.longIs( o.begin ) )
  {
    let beginIndex = _.longLeftIndex( o.begin, beginOf );
    let endIndex = _.longLeftIndex( o.end, endOf );

    if( beginIndex !== endIndex )
    return undefined;
  }
  let result = o.src.substring( beginOf.length, o.src.length - endOf.length );

  return result;
}

strInsideOf_body.defaults =
{
  src : null,
  begin : null,
  end : null,
  pairing : 0, /* xxx : set to 1 */
}

//

let insideOf = _.routine.unite( strInsideOf_head, strInsideOf_body );

//

/**
 * Routine strInsideOf_() founds parts of a source string {-src-} between first occurrence of {-begin-} at the begin of {-src-}
 * and first occurrence of {-end-} at the end of {-src-}.
 * Returns result if {-begin-} and {-end-} exists in the {-src-} and index of {-end-} is bigger the index of {-begin-}.
 * The format of returned value : [ begin, mid, end ].
 * If {-src-} has not {-begin-} or {-end-} routine returns : [ undefined, undefined, undefined ].
 * If option {-o.pairing-} is true and founded {-begin-} is not equivalent to founded {-end-},
 * then routine returns : [ undefined, undefined, undefined ].
 *
 * @example
 * _.strInsideOf_( 'abc', 'a', 'a' );
 * // returns :[ undefined, undefined, undefined ]
 *
 * @example
 * _.strInsideOf_( 'abcd', 'x', 'y' )
 * // returns : [ undefined, undefined, undefined ]
 *
 * @example
 * _.strInsideOf_( 'abc', 'abc', 'abc' );
 * // returns : 'abc'
 *
 * @example
 * _.strInsideOf_({ src : 'abcd', begin : 'a', end : 'd', pairing : 0 });
 * // returns : [ 'a', 'bc', 'd' ]
 *
 * @example
 * _.strInsideOf_({ src : 'abcd', begin : 'a', end : 'd', pairing : 1 });
 * // returns : [ undefined, undefined, undefined ]
 *
 * Basic parameter set :
 * @param { String } src - The source string.
 * @param { String|Array } begin - String or array of strings to find from begin of source.
 * @param { String|Array } end - String or array of strings to find from end source.
 * Alternative parameter set :
 * @param { String } o - Options map.
 * @param { String } o.src - The source string.
 * @param { String|Array } o.begin - String or array of strings to find from begin of source.
 * @param { String|Array } o.end - String or array of strings to find from end source.
 * @param { BoolLike } o.pairing - If option is enabled, then founded begin of {-src-} and
 * founded end of {-src-} should be identical.
 * @returns { Array } - Returns array with parts of source string {-src-} in format : [ begin, mid, end ].
 * If any of part has no entry, routine returns array : [ undefined, undefined, undefined ].
 * If pairing is enabled, and founded begin and end is not equivalent, then routine returns : [ undefined, undefined, undefined ].
 * @throws { Exception } If arguments.length is 1 and argument is not an options map {-o-}.
 * @throws { Exception } If arguments.length is 3 and any of arguments is not a String.
 * @throws { Exception } If arguments.length neither is 1 nor 3.
 * @throws { Exception } If {-src-} ( {-o.src-} ) is not a String.
 * @throws { Exception } If any of {-begin-} ( {-o.begin-} ) or {-end-} ( {-o.end-} ) is not a String or array of Strings.
 * @throws { Exception } If options map {-o-} has unknown properties.
 * @function strInsideOf_
 * @namespace Tools
 */

function strInsideOf__head( routine, args )
{

  let o = args[ 0 ];
  if( _.mapIs( o ) )
  {
    _.assert( args.length === 1, 'Expects exactly one argument' );
  }
  else
  {
    o = Object.create( null );
    o.src = args[ 0 ];
    o.begin = args[ 1 ];
    o.end = args[ 2 ];
    _.assert( args.length === 3, 'Expects exactly three arguments' );
  }

  _.assert( _.strIs( o.src ), 'Expects string {-o.src-}' );
  _.routine.options( routine, o );

  o.begin = _.array.as( o.begin );
  o.end = _.array.as( o.end );

  _.assert
  (
    !o.pairing || o.begin.length === o.end.length,
    `If {-o.paring-} is true then length of o.begin should be equal to length of o.end.`
  );

  return o;
}

function strInsideOf__body( o )
{

  let begin = _.strBeginOf( o.src, o.begin );
  if( begin === undefined )
  return [ undefined, undefined, undefined ];

  let end = _.strEndOf( o.src, o.end );
  if( end === undefined )
  return [ undefined, undefined, undefined ];

  if( o.pairing )
  {
    let beginIndex = _.longLeftIndex( o.begin, begin );
    let endIndex = _.longLeftIndex( o.end, end );

    if( beginIndex !== endIndex )
    return [ undefined, undefined, undefined ];
  }

  let mid = o.src.substring( begin.length, o.src.length - end.length );

  return [ begin, mid, end ];
}

strInsideOf__body.defaults =
{
  src : null,
  begin : null,
  end : null,
  pairing : 1, /* xxx : set to 1 */
}

let insideOf_ = _.routine.unite( strInsideOf__head, strInsideOf__body );

//

function outsideOf( src, begin, end )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );

  let beginOf, endOf;

  beginOf = _.strBeginOf( src, begin );
  if( beginOf === undefined )
  return undefined;

  endOf = _.strEndOf( src, end );
  if( endOf === undefined )
  return undefined;

  let result = beginOf + endOf;

  return result;
}

//--
// replacers
//--

function _removedBegin( src, begin )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );

  let result = src;
  let beginOf = _._strBeginOf( result, begin );
  if( beginOf !== undefined )
  result = result.substr( beginOf.length, result.length );

  return result;
}

//

/**
 * Finds substring prefix ( begin ) occurrence from the very begining of source ( src ) and removes it.
 * Returns original string if source( src ) does not have occurrence of ( prefix ).
 *
 * @param { String } src - Source string to parse.
 * @param { String } prefix - String that is to be dropped.
 * @returns { String } Returns string with result of prefix removement.
 *
 * @example
 * _.strRemoveBegin( 'example', 'exa' );
 * // returns mple
 *
 * @example
 * _.strRemoveBegin( 'example', 'abc' );
 * // returns example
 *
 * @function removeBegin
 * @throws { Exception } Throws a exception if( src ) is not a String.
 * @throws { Exception } Throws a exception if( prefix ) is not a String.
 * @throws { Exception } Throws a exception if( arguments.length ) is not equal 2.
 * @namespace Tools
 *
 */

function removeBegin( src, begin )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( src ) || _.strIs( src ), 'Expects string or array of strings {-src-}' );
  _.assert( _.longIs( begin ) || _.strIs( begin ) || _.regexpIs( begin ), 'Expects string/regexp or array of strings/regexps {-begin-}' );

  let result = [];
  let srcIsArray = _.longIs( src );

  if( _.strIs( src ) && !_.longIs( begin ) )
  return _._strRemovedBegin( src, begin );

  src = _.array.as( src );
  begin = _.array.as( begin );
  for( let s = 0, slen = src.length ; s < slen ; s++ )
  {
    let beginOf = undefined;
    let src1 = src[ s ]
    for( let b = 0, blen = begin.length ; b < blen ; b++ )
    {
      beginOf = _._strBeginOf( src1, begin[ b ] );
      if( beginOf !== undefined )
      break;
    }
    if( beginOf !== undefined )
    src1 = src1.substr( beginOf.length, src1.length );
    result[ s ] = src1;
  }

  if( !srcIsArray )
  return result[ 0 ];

  return result;
}

//

function _removedEnd( src, end )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ), 'Expects string {-src-}' );

  let result = src;
  let endOf = _._strEndOf( result, end );
  if( endOf !== undefined )
  result = result.substr( 0, result.length - endOf.length );

  return result;
}

//

/**
 * Removes occurrence of postfix ( end ) from the very end of string( src ).
 * Returns original string if no occurrence finded.
 * @param { String } src - Source string to parse.
 * @param { String } postfix - String that is to be dropped.
 * @returns { String } Returns string with result of postfix removement.
 *
 * @example
 * _.strRemoveEnd( 'example', 'le' );
 * // returns examp
 *
 * @example
 * _.strRemoveEnd( 'example', 'abc' );
 * // returns example
 *
 * @function removeEnd
 * @throws { Exception } Throws a exception if( src ) is not a String.
 * @throws { Exception } Throws a exception if( postfix ) is not a String.
 * @throws { Exception } Throws a exception if( arguments.length ) is not equal 2.
 * @namespace Tools
 *
 */

function removeEnd( src, end )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( src ) || _.strIs( src ), 'Expects string or array of strings {-src-}' );
  _.assert( _.longIs( end ) || _.strIs( end ) || _.regexpIs( end ), 'Expects string/regexp or array of strings/regexps {-end-}' );

  let result = [];
  let srcIsArray = _.longIs( src );

  if( _.strIs( src ) && !_.longIs( end ) )
  return _._strRemovedEnd( src, end );

  src = _.array.as( src );
  end = _.array.as( end );

  for( let s = 0, slen = src.length ; s < slen ; s++ )
  {
    let endOf = undefined;
    let src1 = src[ s ]
    for( let b = 0, blen = end.length ; b < blen ; b++ )
    {
      endOf = _._strEndOf( src1, end[ b ] );
      if( endOf !== undefined )
      break;
    }
    if( endOf !== undefined )
    src1 = src1.substr( 0, src1.length - endOf.length );
    result[ s ] = src1;
  }

  if( !srcIsArray )
  return result[ 0 ];

  return result;
}

//

function replaceBegin( src, begin, ins )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( _.strIs( ins ) || _.longIs( ins ), 'Expects {-ins-} as string/array of strings' );
  if( _.longIs( begin ) && _.longIs( ins ) )
  _.assert( begin.length === ins.length );

  begin = _.array.as( begin );
  let result = _.array.as( src ).slice();

  for( let k = 0, srcLength = result.length; k < srcLength; k++ )
  for( let j = 0, beginLength = begin.length; j < beginLength; j++ )
  if( _.strBegins( result[ k ], begin[ j ] ) )
  {
    let prefix = _.longIs( ins ) ? ins[ j ] : ins;
    _.assert( _.strIs( prefix ) );
    result[ k ] = prefix + _.strRemoveBegin( result[ k ], begin[ j ] );
    break;
  }

  if( result.length === 1 && _.strIs( src ) )
  return result[ 0 ];

  return result;
}

//

function replaceEnd( src, end, ins )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( _.strIs( ins ) || _.longIs( ins ), 'Expects {-ins-} as string/array of strings' );
  if( _.longIs( end ) && _.longIs( ins ) )
  _.assert( end.length === ins.length );

  end = _.array.as( end );
  let result = _.array.as( src ).slice();

  for( let k = 0, srcLength = result.length; k < srcLength; k++ )
  for( let j = 0, endLength = end.length; j < endLength; j++ )
  if( _.strEnds( result[ k ], end[ j ] ) )
  {
    let postfix = _.longIs( ins ) ? ins[ j ] : ins;
    _.assert( _.strIs( postfix ) );
    result[ k ] = _.strRemoveEnd( result[ k ], end[ j ] ) + postfix;
    break;
  }

  if( result.length === 1 && _.strIs( src ) )
  return result[ 0 ];

  return result;
}

//

/**
* Finds substring or regexp ( insStr ) occurrence from the source string ( srcStr ) and replaces them
* with the subStr values.
* Returns original string if source( src ) does not have occurrence of ( insStr ).
*
* @param { String } srcStr - Source string to parse.
* @param { String } insStr - String/RegExp that is to be replaced.
* @param { String } subStr - Replacement String/RegExp.
* @returns { String } Returns string with result of substring replacement.
*
* @example
* _.strReplace( 'source string', 's', 'S' );
* // returns Source string
*
* @example
* _.strReplace( 'example', 's' );
* // returns example
*
* @function replace
* @throws { Exception } Throws a exception if( srcStr ) is not a String.
* @throws { Exception } Throws a exception if( insStr ) is not a String or a RegExp.
* @throws { Exception } Throws a exception if( subStr ) is not a String.
* @throws { Exception } Throws a exception if( arguments.length ) is not equal 3.
* @namespace Tools
*
*/

function replace( src, ins, sub )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( _.strsAreAll( sub ), 'Expects {-sub-} as string/array of strings' );

  if( _.longIs( ins ) && _.longIs( sub ) )
  _.assert( ins.length === sub.length );

  ins = _.array.as( ins );
  for( let i = 0 ; i < ins.length ; i++ )
  _.assert( ins[ i ] !== '', '{-ins-} should be a string with length' );

  /* */

  let result = _.array.as( src ).slice();

  for( let i = 0 ; i < result.length ; i++ )
  {
    result[ i ] = _.strSplit
    ({
      src : result[ i ],
      delimeter : ins,
      quoting : 0,
      stripping : 0,
      preservingEmpty : 1,
      preservingDelimeters : 1,
      onDelimeter : ( e, k ) => _.strIs( sub ) ? sub : sub[ k ],
    });
    result[ i ] = result[ i ].join( '' );
  }

  if( result.length === 1 && _.strIs( src ) )
  return result[ 0 ];

  return result;
}

// --
// stripper
// --

/**
 * Routine strip() removes entries of leading and trailing characters in source string {-o.src-},
 * which is found by mask {-o.stripper-}.
 * If {-o.stripper-} is not defined function removes leading and trailing whitespaces and escaped
 * characters from begin and end of source string {-o.src-}.
 *
 * @example
 * _.strStrip( '  abc  ' );
 * // returns 'abc'
 *
 * @example
 * _.strStrip({ src : 'ababa', stripper : 'a' });
 * // returns 'bb'
 *
 * @example
 * _.strStrip({ src : '  abc  ', stripper : /^\s+/ });
 * // returns 'abc  '
 *
 * @example
 * _.strStrip({ src : 'axc bb cxa', stripper : [ 'a', 'x' ] });
 * // returns 'c bb c'
 *
 * @example
 * _.strStrip({ src : '  abc  ', stripper : true });
 * // returns 'abc'
 *
 * First parameter set :
 * @param { String|Array } src - Source string(s) to strip.
 * Second parameter set :
 * @param { Aux } o - Options map.
 * @param { String|Array } o.src - Source string(s) to strip.
 * @param { String|RegExp|Array|BoolLike } o.stripper - Defines characters to remove.
 * @returns { String|Array } - Returns stripped string. If source string was an Array of strings, then routine
 * returns array with stripped strings.
 * @function strip
 * @throws { Exception } Throw an error if arguments.length is not equal 1.
 * @throws { Exception } Throw an error if options map {-o-} has not valid type.
 * @throws { Exception } Throw an error if options map {-o-} has unknown property.
 * @throws { Exception } Throw an error if {-o.src-} is not a String or not an Array of strings.
 * @throws { Exception } Throw an error if {-o.stripper-} has not valid type, or it has value `false`.
 * @namespace Tools
 */

function strip( o )
{

  if( _.strIs( o ) || _.arrayIs( o ) )
  o = { src : o };

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.routine.options( strip, o );

  o.stripper = stripperNormalize();
  let stripRoutine = _.regexpIs( o.stripper ) ? singleStripByRegexp : singleStripByArrayOfStrings;

  if( _.arrayIs( o.src ) )
  {
    _.assert( _.strsAreAll( o.src ), 'Expects strings {-o.srs-}' );

    let result = [];
    for( let i = 0 ; i < o.src.length ; i++ )
    result[ i ] = stripRoutine( o.src[ i ] );
    return result;
  }

  _.assert( _.strIs( o.src ) );
  return stripRoutine( o.src );

  /* */

  function stripperNormalize()
  {
    let stripper = o.stripper;
    if( _.bool.likeTrue( o.stripper ) )
    {
      stripper = strip.defaults.stripper;
    }
    else if( _.arrayIs( o.stripper ) )
    {
      _.assert( _.strsAreAll( o.stripper ), 'Expects characters in container {-o.stripper-}' );
    }
    else if( _.strIs( o.stripper ) )
    {
      stripper = _.regexpEscape( o.stripper );
      stripper = new RegExp( stripper, 'g' );
    }
    else if( !_.regexpIs( o.stripper ) )
    {
      _.assert( 0, 'Unexpected type of {-o.stripper-}. Expects either a String, an Array or a Regexp {-o.stripper-}' );
    }
    return stripper;
  }

  /* */

  function singleStripByRegexp( src )
  {
    return src.replace( o.stripper, '' );
  }

  /* */

  function singleStripByArrayOfStrings( src )
  {
    let begin = 0;
    for( ; begin < src.length ; begin++ )
    if( o.stripper.indexOf( src[ begin ] ) === -1 )
    break;

    let end = src.length-1;
    for( ; end >= 0 ; end-- )
    if( o.stripper.indexOf( src[ end ] ) === -1 )
    break;

    if( begin >= end )
    return '';

    return src.substring( begin, end + 1 );
  }

}

strip.defaults =
{
  src : null,
  stripper : /^(\s|\n|\0)+|(\s|\n|\0)+$/g,
  // stripper : /^(\s|\n|\0)+|(\s|\n|\0)+$/gm, /* Dmytro : multiline replacing should be an option, not for single string */
}

// function strStrip( o )
// {
//
//   if( _.strIs( o ) || _.arrayIs( o ) )
//   o = { src : o };
//
//   _.routine.options( strStrip, o );
//   _.assert( arguments.length === 1, 'Expects single argument' );
//
//   if( _.arrayIs( o.src ) )
//   {
//     let result = [];
//     for( let s = 0 ; s < o.src.length ; s++ )
//     {
//       let optionsForStrip = _.props.extend( null, o );
//       optionsForStrip.src = optionsForStrip.src[ s ];
//       result[ s ] = strStrip( optionsForStrip );
//     }
//     return result;
//   }
//
//   if( _.bool.likeTrue( o.stripper ) )
//   {
//     o.stripper = strip.defaults.stripper;
//   }
//
//   _.assert( _.strIs( o.src ), 'Expects string or array o.src, got', _.entity.strType( o.src ) );
//   _.assert( _.strIs( o.stripper ) || _.arrayIs( o.stripper ) || _.regexpIs( o.stripper ), 'Expects string or array or regexp ( o.stripper )' );
//
//   if( _.strIs( o.stripper ) || _.regexpIs( o.stripper ) )
//   {
//     let exp = o.stripper;
//     if( _.strIs( exp ) )
//     {
//       exp = _.regexpEscape( exp );
//       exp = new RegExp( exp, 'g' );
//     }
//     return o.src.replace( exp, '' );
//   }
//   else
//   {
//
//     _.assert( _.arrayIs( o.stripper ) );
//
//     if( Config.debug )
//     for( let s of o.stripper )
//     {
//       _.assert( _.strIs( s, 'Expects string {-stripper[ * ]-}' ) );
//     }
//
//     let b = 0;
//     for( ; b < o.src.length ; b++ )
//     if( o.stripper.indexOf( o.src[ b ] ) === -1 )
//     break;
//
//     let e = o.src.length-1;
//     for( ; e >= 0 ; e-- )
//     if( o.stripper.indexOf( o.src[ e ] ) === -1 )
//     break;
//
//     if( b >= e )
//     return '';
//
//     return o.src.substring( b, e+1 );
//   }
//
// }
//
// strStrip.defaults =
// {
//   src : null,
//   stripper : /^(\s|\n|\0)+|(\s|\n|\0)+$/gm,
// }

//

/**
 * Same as _.strStrip with one difference:
 * If( o.stripper ) is not defined, function removes only leading whitespaces and escaped characters from( o.src ).
 *
 * @example
 * _.strStripLeft( ' a ' )
 * // returns 'a '
 *
 * @method stripLeft
 * @namespace Tools
 *
 */

function stripLeft( o )
{

  if( _.strIs( o ) || _.arrayIs( o ) )
  o = { src : o };

  _.routine.options( stripLeft, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  return _.strStrip( o );
}

stripLeft.defaults =
{
  ... strip.defaults,
  stripper : /^(\s|\n|\0)+/gm,
}

//

/**
 * Same as _.strStrip with one difference:
 * If( o.stripper ) is not defined, function removes only trailing whitespaces and escaped characters from( o.src ).
 *
 * @example
 * _.strStripRight( ' a ' )
 * // returns ' a'
 *
 * @method stripRight
 * @namespace Tools
 *
 */

function stripRight( o )
{

  if( _.strIs( o ) || _.arrayIs( o ) )
  o = { src : o };

  _.routine.options( stripRight, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  return _.strStrip( o );
}

stripRight.defaults =
{
  ... strip.defaults,
  stripper : /(\s|\n|\0)+$/gm,
}

//

/**
 * Removes whitespaces from source( src ).
 * If argument( sub ) is defined, function replaces whitespaces with it.
 *
 * @param {string} src - Source string to parse.
 * @param {string} sub - Substring that replaces whitespaces.
 * @returns {string} Returns a string with removed whitespaces.
 *
 * @example
 * _.strRemoveAllSpaces( 'a b c d e' );
 * // returns abcde
 *
 * @example
 * _.strRemoveAllSpaces( 'a b c d e', '*' );
 * // returns a*b*c*d*e
 *
 * @method _removeAllSpaces
 * @namespace Tools
 *
*/

function _removeAllSpaces( src, sub )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.strIs( src ) );

  if( sub === undefined )
  sub = '';

  return src.replace( /\s/g, sub );
}

//

/**
 * Removes empty lines from the string passed by argument( srcStr ).
 *
 * @param {string} srcStr - Source string to parse.
 * @returns {string} Returns a string with empty lines removed.
 *
 * @example
 * _.strStripEmptyLines( 'first\n\nsecond' );
 * // returns
 * // first
 * // second
 *
 * @example
 * _.strStripEmptyLines( 'zero\n\nfirst\n\nsecond' );
 * // returns
 * // zero
 * // first
 * // second
 *
 * @method strStripEmptyLines
 * @throws { Exception } Throw an exception if( srcStr ) is not a String.
 * @throws { Exception } Throw an exception if( arguments.length ) is not equal 1.
 * @namespace Tools
 *
 */

function _stripEmptyLines( srcStr )
{
  let result = '';
  let lines = srcStr.split( '\n' );

  _.assert( _.strIs( srcStr ) );
  _.assert( arguments.length === 1, 'Expects single argument' );

  for( let l = 0; l < lines.length; l += 1 )
  {
    let line = lines[ l ];

    if( !_.strStrip( line ) )
    continue;

    result += line + '\n';
  }

  result = result.substring( 0, result.length - 1 );
  return result;
}

// --
// split
// --

function splitsCoupledGroup( o )
{

  if( _.arrayIs( o ) )
  o = { splits : o }

  o = _.routine.options( splitsCoupledGroup, o );

  o.prefix = _.array.as( o.prefix );
  o.postfix = _.array.as( o.postfix );

  _.assert( arguments.length === 1 );
  _.assert( _.regexpsLikeAll( o.prefix ) );
  _.assert( _.regexpsLikeAll( o.postfix ) );

  let level = 0;
  let begins = [];
  for( let i = 0 ; i < o.splits.length ; i++ )
  {
    let element = o.splits[ i ];

    if( _.regexpsTestAny( o.prefix, element ) )
    {
      begins.push( i );
    }
    else if( _.regexpsTestAny( o.postfix, element ) )
    {
      if( begins.length === 0 && !o.allowingUncoupledPostfix )
      throw _.err( `"${ element }" does not have complementing openning\n` );

      if( begins.length === 0 )
      continue;

      let begin = begins.pop();
      let end = i;
      let l = end-begin;

      _.assert( l >= 0 )
      let newElement = o.splits.splice( begin, l+1, null );
      o.splits[ begin ] = newElement;

      i -= l;
    }

  }

  if( begins.length && !o.allowingUncoupledPrefix )
  {
    debugger;
    throw _.err( `"${ begins[ begins.length-1 ] }" does not have complementing closing\n` );
  }

  return o.splits;
}

splitsCoupledGroup.defaults =
{
  splits : null,
  prefix : '"',
  postfix : '"',
  allowingUncoupledPrefix : 0,
  allowingUncoupledPostfix : 0,
}

//

function splitsUngroupedJoin( o )
{

  if( _.arrayIs( o ) )
  o = { splits : o }
  o = _.routine.options( splitsUngroupedJoin, o );

  let s = o.splits.length-1;
  let l = null;

  while( s >= 0 )
  {
    let split = o.splits[ s ];

    if( _.strIs( split ) )
    {
      if( l === null )
      l = s;
    }
    else if( l !== null )
    {
      join();
    }

    s -= 1;
  }

  if( l !== null )
  join();

  return o.splits;

  /* */

  function join()
  {
    if( s+1 < l )
    {
      let element = o.splits.slice( s+1, l+1 ).join( '' );
      o.splits.splice( s+1, l+1, element );
    }
    l = null;
  }

}

splitsUngroupedJoin.defaults =
{
  splits : null,
}

//

function strSplitsQuotedRejoin_head( routine, args )
{
  let o = args[ 0 ];

  _.routine.options( routine, o );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( args.length === 1, 'Expects one or two arguments' );
  _.assert( _.object.isBasic( o ) );

  if( o.quoting )
  {

    if( _.bool.like( o.quoting ) )
    {
      if( !o.quotingPrefixes )
      o.quotingPrefixes = [ '"' ];
      if( !o.quotingPostfixes )
      o.quotingPostfixes = [ '"' ];
    }
    else if( _.strIs( o.quoting ) || _.regexpIs( o.quoting ) || _.arrayIs( o.quoting ) )
    {
      _.assert( !o.quotingPrefixes );
      _.assert( !o.quotingPostfixes );
      o.quoting = _.array.as( o.quoting );
      o.quotingPrefixes = o.quoting.map( ( q ) => _.arrayIs( q ) ? q[ 0 ] : q );
      o.quotingPostfixes = o.quoting.map( ( q ) => _.arrayIs( q ) ? q[ 0 ] : q );
      o.quoting = true;
    }
    else _.assert( 0, 'unexpected type of {-o.quoting-}' );

    _.assert
    (
      !o.pairing || o.quotingPrefixes.length === o.quotingPostfixes.length,
      `If option::o.paring is true then the length of o.quotingPrefixes should be equal to the length of o.quotingPostfixes`
    );

    if( Config.debug )
    {
      _.assert( o.quotingPrefixes.length === o.quotingPostfixes.length );
      _.assert( _.bool.like( o.quoting ) );
      o.quotingPrefixes.forEach( ( q ) => _.assert( _.strIs( q ) ) );
      o.quotingPostfixes.forEach( ( q ) => _.assert( _.strIs( q ) ) );
    }

  }

  return o;
}

//

function strSplitsQuotedRejoin_body( o )
{

  _.assert( arguments.length === 1 );
  _.assert( _.arrayIs( o.splits ) );

  /* quoting */

  // let s = 1; // why was it 1??
  let s = 0;
  if( o.quoting )
  {
    for( s ; s < o.splits.length ; s += 1 )
    splitsQuote( o.splits[ s ], s );
  }

  return o.splits;

  function splitsQuote( split, i )
  {
    let s2;
    let q = o.quotingPrefixes.indexOf( split );

    if( q >= 0 )
    {
      let postfix = o.quotingPostfixes[ q ];
      for( s2 = i+2 ; s2 < o.splits.length ; s2 += 1 )
      {
        let split2 = o.splits[ s2 ];
        if( split2 === postfix )
        {
          if( o.pairing )
          if( o.quotingPrefixes.indexOf( o.splits[ s ] ) !== o.quotingPostfixes.indexOf( o.splits[ s2 ] ) )
          break;
          let bextra = 0;
          let eextra = 0;
          if( o.inliningQuoting )
          {
            s -= 1;
            bextra += 1;
            s2 += 1;
            eextra += 1;
          }
          let splitNew = o.splits.splice( s, s2-s+1, null );
          if( !o.preservingQuoting )
          {
            splitNew.splice( bextra, 1 );
            splitNew.splice( splitNew.length-1-eextra, 1 );
          }
          splitNew = splitNew.join( '' );
          if( o.onQuoting )
          o.splits[ s ] = o.onQuoting( splitNew, o );
          else
          o.splits[ s ] = splitNew;
          s2 = s;
          break;
        }
      }
    }

    /* if complementing postfix not found */

    if( s2 >= o.splits.length )
    {
      if( !_.longHas( o.delimeter, split ) )
      {
        let splitNew = o.splits.splice( s, 2 ).join( '' );
        o.splits[ s-1 ] = o.splits[ s-1 ] + splitNew;
      }
      else
      {
      }
    }
  }
}

strSplitsQuotedRejoin_body.defaults =
{
  quoting : 1,
  quotingPrefixes : null,
  quotingPostfixes : null,
  preservingQuoting : 1,
  inliningQuoting : 1,
  splits : null,
  delimeter : null,
  onQuoting : null,
  pairing : 0
}

//

let splitsQuotedRejoin = _.routine.unite( strSplitsQuotedRejoin_head, strSplitsQuotedRejoin_body );

// --
//
// --

function strSplitsDropDelimeters_head( routine, args )
{
  let o = args[ 0 ];

  _.routine.options( routine, o );

  if( _.strIs( o.delimeter ) )
  o.delimeter = [ o.delimeter ];

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( args.length === 1 );
  _.assert( _.object.isBasic( o ) );

  return o;
}

//

function strSplitsDropDelimeters_body( o )
{

  _.assert( arguments.length === 1 );
  _.assert( _.arrayIs( o.splits ) );

  /* stripping */

  // if( o.delimeter.some( ( d ) => _.regexpIs( d ) ) )
  // debugger;

  for( let s = o.splits.length-1 ; s >= 0 ; s-- )
  {
    let split = o.splits[ s ];

    if( _.regexpsTestAny( o.delimeter, split ) ) /* xxx qqq : ? */
    o.splits.splice( s, 1 );

    // if( _.longHas( o.delimeter, split ) )
    // o.splits.splice( s, 1 );
    //
    // if( s % 2 === 1 )
    // o.splits.splice( s, 1 );

  }

  return o.splits;
}

strSplitsDropDelimeters_body.defaults =
{
  splits : null,
  delimeter : null,
}

//

let splitsDropDelimeters = _.routine.unite( strSplitsDropDelimeters_head, strSplitsDropDelimeters_body );

// --
//
// --

function strSplitsStrip_head( routine, args )
{
  let o = args[ 0 ];

  _.routine.options( routine, o );

  if( o.stripping && _.bool.like( o.stripping ) )
  o.stripping = _.strStrip.defaults.stripper;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( args.length === 1 );
  _.assert( _.object.isBasic( o ) );
  _.assert( !o.stripping || _.strIs( o.stripping ) || _.regexpIs( o.stripping ) );

  return o;
}

//

function strSplitsStrip_body( o )
{

  _.assert( arguments.length === 1 );
  _.assert( _.arrayIs( o.splits ) );

  if( !o.stripping )
  return o.splits;

  /* stripping */

  for( let s = 0 ; s < o.splits.length ; s++ )
  {
    let split = o.splits[ s ];

    if( _.strIs( split ) )
    split = _.strStrip({ src : split, stripper : o.stripping });

    o.splits[ s ] = split;
  }

  return o.splits;
}

strSplitsStrip_body.defaults =
{
  stripping : 1,
  splits : null,
}

//

let splitsStrip = _.routine.unite( strSplitsStrip_head, strSplitsStrip_body );

// --
//
// --

function strSplitsDropEmpty_head( routine, args )
{
  let o = args[ 0 ];

  _.routine.options( routine, o );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( args.length === 1 );
  _.assert( _.object.isBasic( o ) );

  return o;
}

//

function strSplitsDropEmpty_body( o )
{

  _.assert( arguments.length === 1 );
  _.assert( _.arrayIs( o.splits ) );

  /* stripping */

  for( let s = 0 ; s < o.splits.length ; s++ )
  {
    let split = o.splits[ s ];

    if( !split )
    {
      o.splits.splice( s, 1 );
      s -= 1;
    }

  }

  return o.splits;
}

strSplitsDropEmpty_body.defaults =
{
  splits : null,
}

//

let splitsDropEmpty = _.routine.unite( strSplitsDropEmpty_head, strSplitsDropEmpty_body );

// --
//
// --

function strSplitFast_head( routine, args )
{
  let o = args[ 0 ];

  if( args.length === 2 )
  o = { src : args[ 0 ], delimeter : args[ 1 ] }
  else if( _.strIs( args[ 0 ] ) )
  o = { src : args[ 0 ] }

  _.routine.options( routine, o );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( args.length === 1 || args.length === 2, 'Expects one or two arguments' );
  _.assert( _.strIs( o.src ) );
  _.assert( o.delimeter === null || _.regexp.like( o.delimeter ) || _.arrayIs( o.delimeter ) );
  _.assert( _.object.isBasic( o ) );

  return o;
}

//

/* qqq2 : write performance test and optimize */
function strSplitFast_body( o )
{
  let result, closests, position, closestPosition, closestIndex, hasEmptyDelimeter, delimeter

  o.delimeter = _.array.as( o.delimeter );

  let foundDelimeters = o.delimeter.slice();

  _.assert( arguments.length === 1 );
  _.assert( _.arrayIs( o.delimeter ) );
  _.assert( _.bool.like( o.preservingDelimeters ) );

  /* */

  if( !o.preservingDelimeters && o.delimeter.length === 1 )
  {

    result = o.src.split( o.delimeter[ 0 ] );

    if( !o.preservingEmpty )
    result = result.filter( ( e ) => e ? e : false );

  }
  else
  {

    if( !o.delimeter.length )
    {
      result = [ o.src ];
      return result;
    }

    result = [];
    closests = [];
    position = 0;
    closestPosition = 0;
    closestIndex = -1;
    hasEmptyDelimeter = false;

    for( let d = 0 ; d < o.delimeter.length ; d++ )
    {
      let delimeter = o.delimeter[ d ];
      if( _.regexpIs( delimeter ) )
      {
        _.assert( !delimeter.sticky );
        if( delimeter.source === '' || delimeter.source === '()' || delimeter.source === '(?:)' )
        hasEmptyDelimeter = true;
      }
      else
      {
        if( delimeter.length === 0 )
        hasEmptyDelimeter = true;
      }
      closests[ d ] = delimeterNext( d, position );
    }

    do
    {
      closestWhich();

      if( closestPosition === o.src.length )
      break;

      if( !delimeter.length )
      position += 1;

      ordinaryAdd( o.src.substring( position, closestPosition ) );

      if( delimeter.length > 0 || position < o.src.length )
      delimeterAdd( delimeter );

      position = closests[ closestIndex ] + ( delimeter.length ? delimeter.length : 1 );

      for( let d = 0 ; d < o.delimeter.length ; d++ )
      if( closests[ d ] < position )
      closests[ d ] = delimeterNext( d, position );

    }
    while( position < o.src.length );

    if( delimeter || !hasEmptyDelimeter )
    ordinaryAdd( o.src.substring( position, o.src.length ) );

  }

  return result;

  /* */

  function delimeterAdd( delimeter )
  {

    if( o.preservingDelimeters )
    if( o.preservingEmpty || delimeter )
    {
      result.push( delimeter );
      // if( _.regexpIs( delimeter ) )
      // result.push( delimeter );
      // o.src.substring( position, closestPosition )
      // else
      // result.push( delimeter );
    }

  }

  /*  */

  function ordinaryAdd( ordinary )
  {
    if( o.preservingEmpty || ordinary )
    result.push( ordinary );
  }

  /* */

  function closestWhich()
  {

    closestPosition = o.src.length;
    closestIndex = -1;
    for( let d = 0 ; d < o.delimeter.length ; d++ )
    {
      if( closests[ d ] < o.src.length && closests[ d ] < closestPosition )
      {
        closestPosition = closests[ d ];
        closestIndex = d;
      }
    }

    delimeter = foundDelimeters[ closestIndex ];

  }

  /* */

  function delimeterNext( d, position )
  {
    _.assert( position <= o.src.length );
    let delimeter = o.delimeter[ d ];
    let result;

    if( _.strIs( delimeter ) )
    {
      result = o.src.indexOf( delimeter, position );
    }
    else
    {
      let execed = delimeter.exec( o.src.substring( position ) );
      if( execed )
      {
        result = execed.index + position;
        foundDelimeters[ d ] = execed[ 0 ];
      }
    }

    if( result === -1 )
    return o.src.length;
    return result;
  }

}

strSplitFast_body.defaults =
{
  src : null,
  delimeter : ' ',
  preservingEmpty : 1,
  preservingDelimeters : 1,
}

//

/**
 * Divides source string( o.src ) into parts using delimeter provided by argument( o.delimeter ).
 * If( o.stripping ) is true - removes leading and trailing whitespace characters.
 * If( o.preservingEmpty ) is true - empty lines are saved in the result array.
 * If( o.preservingDelimeters ) is true - leaves word delimeters in result array, otherwise removes them.
 * Function can be called in two ways:
 * - First to pass only source string and use default options;
 * - Second to pass map like ( { src : 'a, b, c', delimeter : ', ', stripping : 1 } ).
 * Returns result as array of strings.
 *
 * @param {string|object} o - Source string to split or map with source( o.src ) and options.
 * @param {string} [ o.src=null ] - Source string.
 * @param {string|array} [ o.delimeter=' ' ] - Word divider in source string.
 * @param {boolean} [ o.preservingEmpty=false ] - Leaves empty strings in the result array.
 * @param {boolean} [ o.preservingDelimeters=false ] - Puts delimeters into result array in same order how they was in the source string.
 * @param {boolean} [ o.stripping=true ] - Removes leading and trailing whitespace characters occurrences from source string.
 * @returns {object} Returns an array of strings separated by( o.delimeter ).
 *
 * @example
 * _.strSplitFast( ' first second third ' );
 * // returns [ 'first', 'second', 'third' ]
 *
 * @example
 * _.strSplitFast( { src : 'a, b, c, d', delimeter : ', '  } );
 * // returns [ 'a', 'b', 'c', 'd' ]
 *
 * @example
 * _.strSplitFast( { src : 'a.b, c.d', delimeter : [ '.', ', ' ]  } );
 * // returns [ 'a', 'b', 'c', 'd' ]
 *
 * @example
   * _.strSplitFast( { src : '    a, b, c, d   ', delimeter : [ ', ' ], stripping : 0  } );
   * // returns [ '    a', 'b', 'c', 'd   ' ]
 *
 * @example
 * _.strSplitFast( { src : 'a, b, c, d', delimeter : [ ', ' ], preservingDelimeters : 1  } );
 * // returns [ 'a', ', ', 'b', ', ', 'c', ', ', 'd' ]
 *
 * @example
 * _.strSplitFast( { src : 'a ., b ., c ., d', delimeter : [ ', ', '.' ], preservingEmpty : 1  } );
 * // returns [ 'a', '', 'b', '', 'c', '', 'd' ]
 *
 * @method splitFast
 * @throws { Exception } Throw an exception if( arguments.length ) is not equal 1 or 2.
 * @throws { Exception } Throw an exception if( o.src ) is not a String.
 * @throws { Exception } Throw an exception if( o.delimeter ) is not a String or an Array.
 * @throws { Exception } Throw an exception if object( o ) has been extended by invalid property.
 * @namespace Tools
 *
 */

let splitFast = _.routine.unite( strSplitFast_head, strSplitFast_body );

_.assert( splitFast.head === strSplitFast_head );
_.assert( splitFast.body === strSplitFast_body );
_.assert( _.object.isBasic( splitFast.defaults ) );

//

function strSplit_body( o )
{

  o.delimeter = _.array.as( o.delimeter );

  if( !o.stripping && !o.quoting && !o.onDelimeter )
  {
    return _.strSplitFast.body( _.mapOnly_( null, o, _.strSplitFast.defaults ) );
  }

  /* */

  _.assert( arguments.length === 1 );

  /* */

  let result = [];
  let fastOptions = _.mapOnly_( null, o, _.strSplitFast.defaults );
  fastOptions.preservingEmpty = 1;
  fastOptions.preservingDelimeters = 1;

  if( o.quoting )
  fastOptions.delimeter = _.arrayAppendArraysOnce( [], [ o.quotingPrefixes, o.quotingPostfixes, fastOptions.delimeter ] );

  o.splits = _.strSplitFast.body( fastOptions );

  if( o.quoting && o.onQuote )
  {
    let quotes = _.arrayAppendArraysOnce( null, [ o.quotingPrefixes, o.quotingPostfixes ] );
    for( let i = 0 ; i < o.splits.length ; i++ )
    {
      let index = _.longLeftIndex( quotes, o.splits[ i ], equalizeStrings );
      if( index !== -1 )
      o.splits[ i ] = o.onQuote( o.splits[ i ], index, quotes );
    }
  }
  if( o.onDelimeter )
  {
    let delimeter = _.filter_( null, o.delimeter, function( pattern )
    {
      if( _.regexpIs( pattern ) )
      return pattern.test( o.src ) ? pattern : null;
      return pattern;
    });
    for( let i = 0 ; i < o.splits.length ; i++ )
    {
      let index = _.longLeftIndex( delimeter, o.splits[ i ], equalizeStrings );
      if( index !== -1 )
      o.splits[ i ] = o.onDelimeter( o.splits[ i ], index, o.delimeter );
    }
  }

  if( o.quoting )
  _.strSplitsQuotedRejoin.body( o );

  if( !o.preservingDelimeters )
  _.strSplitsDropDelimeters.body( o );

  if( o.stripping )
  _.strSplitsStrip.body( o );

  if( !o.preservingEmpty )
  _.strSplitsDropEmpty.body( o );

  /* */

  return o.splits;

  /* */

  function equalizeStrings( pattern, el )
  {
    if( _.strIs( pattern ) )
    return pattern === el;
    if( pattern !== null )
    return pattern.test( el );
    return false;
  }

}

var defaults = strSplit_body.defaults = Object.create( strSplitFast_body.defaults );

defaults.preservingEmpty = 1;
defaults.preservingDelimeters = 1;
defaults.preservingQuoting = 1;
defaults.inliningQuoting = 1;

defaults.stripping = 1;
defaults.quoting = 1;
defaults.quotingPrefixes = null;
defaults.quotingPostfixes = null;

defaults.onDelimeter = null;
defaults.onQuote = null;

//

/**
 * Divides source string( o.src ) into parts using delimeter provided by argument( o.delimeter ).
 * If( o.stripping ) is true - removes leading and trailing whitespace characters.
 * If( o.preservingEmpty ) is true - empty lines are saved in the result array.
 * If( o.preservingDelimeters ) is true - leaves word delimeters in result array, otherwise removes them.
 * Function can be called in two ways:
 * - First to pass only source string and use default options;
 * - Second to pass map like ( { src : 'a, b, c', delimeter : ', ', stripping : 1 } ).
 * Returns result as array of strings.
 *
 * @param {string|object} o - Source string to split or map with source( o.src ) and options.
 * @param {string} [ o.src=null ] - Source string.
 * @param {string|array} [ o.delimeter=' ' ] - Word divider in source string.
 * @param {boolean} [ o.preservingEmpty=false ] - Leaves empty strings in the result array.
 * @param {boolean} [ o.preservingDelimeters=false ] - Puts delimeters into result array in same order how they was in the source string.
 * @param {boolean} [ o.stripping=true ] - Removes leading and trailing whitespace characters occurrences from source string.
 * @returns {object} Returns an array of strings separated by( o.delimeter ).
 *
 * @example
 * _.strSplit( ' first second third ' );
 * // returns [ 'first', 'second', 'third' ]
 *
 * @example
 * _.strSplit( { src : 'a, b, c, d', delimeter : ', '  } );
 * // returns [ 'a', 'b', 'c', 'd' ]
 *
 * @example
 * _.strSplit( { src : 'a.b, c.d', delimeter : [ '.', ', ' ]  } );
 * // returns [ 'a', 'b', 'c', 'd' ]
 *
 * @example
 * _.strSplit( { src : '    a, b, c, d   ', delimeter : [ ', ' ], stripping : 0  } );
 * // returns [ '    a', 'b', 'c', 'd   ' ]
 *
 * @example
 * _.strSplit( { src : 'a, b, c, d', delimeter : [ ', ' ], preservingDelimeters : 1  } );
 * // returns [ 'a', ', ', 'b', ', ', 'c', ', ', 'd' ]
 *
 * @example
 * _.strSplit( { src : 'a ., b ., c ., d', delimeter : [ ', ', '.' ], preservingEmpty : 1  } );
 * // returns [ 'a', '', 'b', '', 'c', '', 'd' ]
 *
 * @method split
 * @throws { Exception } Throw an exception if( arguments.length ) is not equal 1 or 2.
 * @throws { Exception } Throw an exception if( o.src ) is not a String.
 * @throws { Exception } Throw an exception if( o.delimeter ) is not a String or an Array.
 * @throws { Exception } Throw an exception if object( o ) has been extended by invalid property.
 * @namespace Tools
 *
 */

let head =
[
  splitFast.head,
  splitsQuotedRejoin.head,
  splitsDropDelimeters.head,
  splitsStrip.head,
  splitsDropEmpty.head
];
let split = _.routine.unite( head, strSplit_body );

_.assert( split.head !== splitFast.head );
_.assert( _.routine.is( split.head ) );
_.assert( split.body === strSplit_body );
_.assert( _.object.isBasic( split.defaults ) );
_.assert( !!split.defaults.preservingEmpty );

//

let splitNonPreserving = _.routine.uniteCloning( split.head, split.body );

var defaults = splitNonPreserving.defaults;

defaults.preservingEmpty = 0
defaults.preservingDelimeters = 0;

//

function _strSplitInlined_body( o )
{

  _.assert( arguments.length === 1, 'Expects single options map' );

  if( o.delimeter === null )
  o.delimeter = '#';

  let splitArray = _.strSplit
  ({
    src : o.src,
    delimeter : o.delimeter,
    stripping : o.stripping,
    quoting : o.quoting,
    preservingEmpty : 1,
    preservingDelimeters : 1,
  });

  if( splitArray.length <= 1 )
  {
    if( !o.preservingEmpty )
    if( splitArray[ 0 ] === '' )
    splitArray.splice( 0, 1 );
    return splitArray;
  }

  /*
  first - for tracking index to insert ordinary text
  onInlined should be called first and
  if undefined returned escaped text shoud be treated as ordinary
  so tracking index to insert ordinary text ( in case non undefined returned ) required
  */

  let first = 0;
  let result = [];
  let i = 0;
  for( ; i < splitArray.length; i += 4 )
  {

    if( splitArray.length-i >= 4 )
    {
      if( handleTriplet() )
      handleOrdinary();
    }
    else
    {
      if( splitArray.length > i+1 )
      {
        splitArray[ i ] = splitArray.slice( i, splitArray.length ).join( '' );
        splitArray.splice( i+1, splitArray.length-i-1 );
      }
      handleOrdinary();
      _.assert( i+1 === splitArray.length, 'Openning delimeter', o.delimeter, 'does not have closing' );
    }

  }

  return result;

  /* */

  function handleTriplet()
  {

    let delimeter1 = splitArray[ i+1 ];
    let escaped = splitArray[ i+2 ];
    let delimeter2 = splitArray[ i+3 ];

    if( o.onInlined )
    escaped = o.onInlined( escaped, o, [ delimeter1, delimeter2 ] );

    if( escaped === undefined )
    {
      _.assert( _.strIs( splitArray[ i+4 ] ) );
      splitArray[ i+2 ] = splitArray[ i+0 ] + splitArray[ i+1 ] + splitArray[ i+2 ];
      splitArray.splice( i, 2 );
      i -= 4;
      return false;
    }

    first = result.length;

    if( o.preservingDelimeters && delimeter1 !== undefined )
    if( o.preservingEmpty || delimeter1 )
    result.push( delimeter1 );

    if( o.preservingInlined && escaped !== undefined )
    if( o.preservingEmpty || escaped )
    result.push( escaped );

    if( o.preservingDelimeters && delimeter2 !== undefined )
    if( o.preservingEmpty || delimeter2 )
    result.push( delimeter2 );

    return true;
  }

  /* */

  function handleOrdinary()
  {
    let ordinary = splitArray[ i+0 ];

    if( o.onOrdinary )
    ordinary = o.onOrdinary( ordinary, o );

    if( o.preservingOrdinary && ordinary !== undefined )
    if( o.preservingEmpty || ordinary )
    result.splice( first, 0, ordinary );

    first = result.length;
  }

}

_strSplitInlined_body.defaults =
{

  src : null,
  delimeter : null,
  stripping : 0,
  quoting : 0,

  onOrdinary : null,
  onInlined : ( e ) => [ e ],

  preservingEmpty : 1,
  preservingDelimeters : 0,
  preservingOrdinary : 1,
  preservingInlined : 1,

}

//

let splitInlined = _.routine.unite( strSplitFast_head, _strSplitInlined_body );

//

/**
 * Extracts words enclosed by prefix( o.prefix ) and postfix( o.postfix ) delimeters
 * Function can be called in two ways:
 * - First to pass only source string and use default options;
 * - Second to pass source string and options map like ( { prefix : '#', postfix : '#' } ) as function context.
 *
 * Returns result as array of strings.
 *
 * Function extracts words in two attempts:
 * First by splitting source string by ( o.prefix ).
 * Second by splitting each element of the result of first attempt by( o.postfix ).
 * If splitting by ( o.prefix ) gives only single element then second attempt is skipped, otherwise function
 * splits all elements except first by ( o.postfix ) into two halfs and calls provided ( o.onInlined ) function on first half.
 * If result of second splitting( by o.postfix ) is undefined function appends value of element from first splitting attempt
 * with ( o.prefix ) prepended to the last element of result array.
 *
 * @param {string} src - Source string.
 * @param {object} o - Options map.
 * @param {string} [ o.prefix = '' ] - A delimeter that marks begining of enclosed string.
 * @param {string} [ o.postfix = '' ] - A ddelimeter that marks ending of enclosed string.
 * @param {string} [ o.onInlined = ( el ) => [ el ] ] - Function called on each splitted part of a source string.
 * @param {string} [ o.onOrdinary = null ] - Function called on each ordinary part of a source string.
 * @param {string} [ o.stripping = 0 ] - If true removes leading and trailing whitespace characters.
 * @param {string} [ o.quoting = 0 ] - If true prefixes and postfixes surounded by quotes are treated as ordinary text.
 * @param {string} [ o.preservingEmpty = 1 ] - If true empty lines are saved in the result array.
 * @param {string} [ o.preservingDelimeters = 0 ] - If true leaves word delimeters in result array, otherwise removes them.
 * @param {string} [ o.preservingOrdinary = 1 ] - If true ordinary text is saved in the result array.
 * @param {string} [ o.preservingInlined = 1 ] - If true splitted text are saved in the result array.
 * @returns {object} Returns an array of strings separated by {- o.prefix -} and {- o.postfix -}.
 *
 * @example
 * _.strSplitInlinedStereo_( 'abc' );
 * // returns [ '', [ 'abc' ], '' ]
 *
 * @example
 * _.strSplitInlinedStereo_({ src : '#abc$', prefix : '#', postfix : '$' });
 * // returns [ '', [ 'abc' ], '' ]
 *
 * @example
 * function onInlined( strip )
 * {
 *   if( strip.length )
 *   return strip.toUpperCase();
 * }
 * _.strSplitInlinedStereo_({ src : '<abc>', prefix : '<', postfix : '>', onInlined });
 * // returns [ '', [ 'ABC' ], '' ]
 *
 * @method splitInlinedStereo_
 * @throws { Exception } Throw an exception if( arguments.length ) is not equal 1.
 * @throws { Exception } Throw an exception if( o.src ) is not a String.
 * @throws { Exception } Throw an exception if object( o ) has been extended by invalid property.
 * @namespace Tools
 *
 */

function splitInlinedStereo_( o )
{
  /*
    New delimeter.
    was : 'this #background:red#is#background:default# text and is not'.
    is  : 'this background:redisbackground:default text and is not'.
    */

  if( _.strIs( o ) )
  o = { src : o };
  o.quotingPrefixes = o.quotingPrefixes || [ '"' ];
  o.quotingPostfixes = o.quotingPostfixes || [ '"' ];

  _.assert( this === _ );
  _.assert( _.strIs( o.src ) );
  _.assert( _.object.isBasic( o ) );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.routine.options( splitInlinedStereo_, o );

  let isDefaultOnInlined = true;

  if( o.onInlined === null )
  {
    o.onInlined = ( e ) => [ e ];
  }
  else
  {
    _.assert( _.routine.is( o.onInlined ), 'Expects a routine as option::onInlined' );
    isDefaultOnInlined = false;
  }

  /* Trivial cases */
  let end = handleTrivial();
  if( end !== false )
  return end;

  let replacementForPrefix = '\u{20330}';
  let isReplacedPrefix = false;
  let splitOptions = _.mapOnly_( null, o, split.defaults );
  splitOptions.preservingDelimeters = 1; /* for distinguishing between inlined and ordinary */
  splitOptions.delimeter = o.prefix === o.postfix ? o.prefix : [ o.prefix, o.postfix ];
  splitOptions.stripping = 0;
  splitOptions.preservingEmpty = 1;

  let result = _.strSplit( splitOptions ); /* array with separated ordinary, inlined and delimeters */
  result = preprocessBeforeJoin( result );

  result = _.strSplitsQuotedRejoin
  ({
    splits : result,
    delimeter : [ o.prefix, o.postfix ],
    quoting : 1,
    quotingPrefixes : [ o.prefix ],
    quotingPostfixes : [ o.postfix ],
    preservingQuoting : o.preservingDelimeters,
    inliningQuoting : 0,
    onQuoting : o.preservingEmpty ? escapeInlined( o.onInlined ) : o.onInlined
  });

  if( o.preservingEmpty )
  handlePreservingEmpty();

  unescape();

  if( o.preservingDelimeters && !o.inliningDelimeters && isDefaultOnInlined ) /* for default onInlined */
  splitInlined();

  if( isReplacedPrefix )
  result = result.map( ( el ) =>
  {
    if( _.strIs( el ) )
    return el.replace( replacementForPrefix, o.prefix )
    else
    return el;
  });

  return result;

  /* - */

  function handleTrivial()
  {
    let delimLeftPosition = o.src.indexOf( o.prefix );
    let delimRightPosition = o.src.indexOf( o.postfix );

    if( delimLeftPosition === -1 || delimRightPosition === -1 )
    {
      if( o.preservingOrdinary )
      return [ o.src ];
      else
      return [];
    }

    if( !o.preservingOrdinary && !o.preservingInlined )
    return [];

    let splitted = o.src.split( o.prefix );

    if( splitted.length === 1 )
    {
      if( o.preservingOrdinary )
      return [ o.src ];
      else
      return [];
    }

    return false;
  }

  /* */

  function splitInlined()
  {
    result = result.map( ( el ) =>
    {
      if( _.arrayIs( el ) )
      el = [ o.prefix, el[ 0 ].slice( 1, -1 ), o.postfix ];

      return el;
    });
  }

  /* */

  function escapeInlined( func )
  {
    return function ( el )
    {
      return _.escape.wrap( func( el ) );
    }
  }

  /* */

  function preprocessBeforeJoin( array )
  {
    let ordinary = '';
    let result = []
    for( let i = 0; i < array.length; i++ )
    {
      /*
        [ '', '', ' ', '', ' ', '', 'inline1', '', ' ', '', ' inline2' ]
        into
        [ '  ', '', 'inline1', '', '  inline2' ]
      */
      if( array[ i ] === o.prefix )
      {
        if( array[ i + 2 ] === o.postfix )
        {
          /* push concatenated ordinary string */
          pushOrdinary( result, ordinary );
          /* push inlined : '', 'inline1', '' */
          if( o.preservingInlined )
          {
            result.push( array[ i ] );
            result.push( o.stripping ? array[ i+1 ].trim() : array[ i+1 ] );
            result.push( array[ i+2 ] );
          }
          i += 2;
          ordinary = '';
        }
        else
        {
          ordinary += array[ i ];
        }
      }
      else
      {
        ordinary += array[ i ];
      }
    }

    pushOrdinary( result, ordinary );

    return result;
  }

  /* */

  function pushOrdinary( result, ordinary )
  {
    if( o.preservingOrdinary && ordinary )
    {
      if( ordinary === o.prefix )
      {
        result.push( replacementForPrefix );
        isReplacedPrefix = true;
      }
      else
      {
        ordinary = o.stripping ? ordinary.trim() : ordinary;
        if( o.onOrdinary )
        {
          let ordinary1 = o.onOrdinary( ordinary );
          ordinary = ordinary1 ? ordinary1 : ordinary;
        }

        result.push( ordinary );
      }
    }
  }

  /* */

  function handlePreservingEmpty()
  {
    if( _.escape.is( result[ 0 ] ) )
    {
      result.unshift( '' );
    }
    if( _.escape.is( result[ result.length-1 ] ) )
    {
      result.push( '' );
    }
    let len = result.length;
    for( let i = 0; i < len; i++ )
    {
      if( _.escape.is( result[ i ] ) )
      if( _.escape.is( result[ i + 1 ] ) )
      {
        result.splice( i + 1, 0, '' );
        len++;
      }
    }
  }

  /* */

  function unescape()
  {
    for( let i = 0; i < result.length; i++ )
    {
      if( _.escape.is( result[ i ] ) )
      result[ i ] = _.escape.unwrap( result[ i ] );
    }
  }

}

splitInlinedStereo_.defaults =
{
  src : null,
  prefix : '',
  postfix : '',
  onInlined : null,
  onOrdinary : null,

  stripping : 0,
  quoting : 0,
  quotingPrefixes : null,
  quotingPostfixes : null,

  preservingQuoting : 1,
  preservingEmpty : 0, /* changed */
  preservingDelimeters : 0,
  inliningDelimeters : 0, /* new */
  preservingOrdinary : 1,
  preservingInlined : 1,
}

//

// function strSplitInlinedStereo_( o )
// {
//   /*
//     New delimeter.
//     was : 'this #background:red#is#background:default# text and is not'.
//     is  : 'this background:redisbackground:default text and is not'.
//     */

//   if( _.strIs( o ) )
//   o = { src : o };
//   o.quotingPrefixes = o.quotingPrefixes || [ '"' ];
//   o.quotingPostfixes = o.quotingPostfixes || [ '"' ];

//   _.assert( this === _ );
//   _.assert( _.strIs( o.src ) );
//   _.assert( _.object.isBasic( o ) );
//   _.assert( arguments.length === 1, 'Expects single argument' );
//   _.routine.options( strSplitInlinedStereo_, o );

//   /* Trivial cases */
//   let end = handleTrivial();
//   if( end !== false )
//   return end;

//   let replacementForPrefix = '\u{20330}';
//   let isReplacedPrefix = false;
//   let splitOptions = _.mapOnly_( null, o, strSplit.defaults );
//   splitOptions.preservingDelimeters = 1; /* for distinguishing between inlined and ordinary */
//   splitOptions.delimeter = o.prefix === o.postfix ? o.prefix : [ o.prefix, o.postfix ];
//   splitOptions.stripping = 0;
//   splitOptions.preservingEmpty = 1;

//   let result = _.strSplit( splitOptions ); /* array with separated ordinary, inlined and delimeters */
//   result = preprocessBeforeJoin( result );

//   if( o.inliningDelimeters ) /* new */
//   result = _.strSplitsQuotedRejoin
//   ({
//     splits : result,
//     delimeter : [ o.prefix, o.postfix ],
//     quoting : 1,
//     quotingPrefixes : [ o.prefix ],
//     quotingPostfixes : [ o.postfix ],
//     preservingQuoting : o.preservingDelimeters,
//     inliningQuoting : 0,
//     onQuoting : o.preservingEmpty ? escapeInlined( o.onInlined ) : o.onInlined
//   });

//   if( o.preservingEmpty )
//   handlePreservingEmpty();

//   unescape();

//   if( isReplacedPrefix )
//   result = result.map( ( el ) =>
//   {
//     if( _.strIs( el ) )
//     return el.replace( replacementForPrefix, o.prefix )
//     else
//     return el;
//   });

//   return result;

//   /* - */

//   function handleTrivial()
//   {
//     let delimLeftPosition = o.src.indexOf( o.prefix );
//     let delimRightPosition = o.src.indexOf( o.postfix );

//     if( delimLeftPosition === -1 || delimRightPosition === -1 )
//     {
//       if( o.preservingOrdinary )
//       return [ o.src ];
//       else
//       return [];
//     }

//     if( !o.preservingOrdinary && !o.preservingInlined )
//     return [];

//     let splitted = o.src.split( o.prefix );

//     if( splitted.length === 1 )
//     {
//       if( o.preservingOrdinary )
//       return [ o.src ];
//       else
//       return [];
//     }

//     return false;
//   }

//   /* */

//   function escapeInlined( func )
//   {
//     return function ( el )
//     {
//       return _.escape.wrap( func( el ) );
//     }
//   }

//   /* */

//   function preprocessBeforeJoin( array )
//   {
//     let ordinary = '';
//     let result = []
//     for( let i = 0; i < array.length; i++ )
//     {
//       /*
//         [ '', '', ' ', '', ' ', '', 'inline1', '', ' ', '', ' inline2' ]
//         into
//         [ '  ', '', 'inline1', '', '  inline2' ]
//       */
//       if( array[ i ] === o.prefix )
//       {
//         if( array[ i + 2 ] === o.postfix )
//         {
//           /* push concatenated ordinary string */
//           pushOrdinary( result, ordinary );
//           /* push inlined : '', 'inline1', '' */
//           if( o.preservingInlined )
//           {
//             result.push( array[ i ] );
//             result.push( o.stripping ? array[ i+1 ].trim() : array[ i+1 ] );
//             result.push( array[ i+2 ] );
//           }
//           i += 2;
//           ordinary = '';
//         }
//         else
//         {
//           ordinary += array[ i ];
//         }
//       }
//       else
//       {
//         ordinary += array[ i ];
//       }
//     }

//     pushOrdinary( result, ordinary );

//     return result;
//   }

//   /* */

//   function pushOrdinary( result, ordinary )
//   {
//     if( o.preservingOrdinary && ordinary )
//     {
//       if( ordinary === o.prefix )
//       {
//         result.push( replacementForPrefix );
//         isReplacedPrefix = true;
//       }
//       else
//       {
//         ordinary = o.stripping ? ordinary.trim() : ordinary;
//         if( o.onOrdinary )
//         {
//           let ordinary1 = o.onOrdinary( ordinary );
//           ordinary = ordinary1 ? ordinary1 : ordinary;
//         }

//         result.push( ordinary );
//       }
//     }
//   }

//   /* */

//   function handlePreservingEmpty()
//   {
//     if( _.escape.is( result[ 0 ] ) )
//     {
//       result.unshift( '' );
//     }
//     if( _.escape.is( result[ result.length-1 ] ) )
//     {
//       result.push( '' );
//     }
//     let len = result.length;
//     for( let i = 0; i < len; i++ )
//     {
//       if( _.escape.is( result[ i ] ) )
//       if( _.escape.is( result[ i + 1 ] ) )
//       {
//         result.splice( i + 1, 0, '' );
//         len++;
//       }
//     }
//   }

//   /* */

//   function unescape()
//   {
//     for( let i = 0; i < result.length; i++ )
//     {
//       if( _.escape.is( result[ i ] ) )
//       result[ i ] = _.escape.unwrap( result[ i ] );
//     }
//   }

// }

// strSplitInlinedStereo_.defaults =
// {
//   src : null,
//   prefix : '',
//   postfix : '',
//   onInlined : ( e ) => [ e ],
//   onOrdinary : null,

//   stripping : 0,
//   quoting : 0,
//   quotingPrefixes : null,
//   quotingPostfixes : null,

//   preservingQuoting : 1,
//   preservingEmpty : 0, /* changed */
//   preservingDelimeters : 0,
//   inliningDelimeters : 1, /* new */
//   preservingOrdinary : 1,
//   preservingInlined : 1,
// }


// --
// converter
// --

function from( src )
{

  if( src === null )
  return src;
  if( src === undefined )
  return src;

  if( _.primitive.is( src ) )
  return String( src );

  if( _.bufferAnyIs( src ) )
  return _.bufferToStr( src );

  _.assert( _.strIs( src ) );
  return src;
}

// --
// parser
// --

function parseType( src )
{
  /*
    - 'string'
    - '5'
    - '5n'
    - 'null'
    - 'undefined'
    - 'Escape( 1 )'
    - '{- Symbol undefined -}'
    - '{- routine name -}'
    - '{- routine.anonymous -}'
    - '{- Map -}'
    - '{- Map name -}'
    - '{- Map with 9 elements -}'
    - '{- Map.polluted with 9 elements -}'
    - '{- Map name with 9 elements -}'
  */

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ), 'Expects string' );

  if( !( /^{- .+ -}$/g.test( src ) ) )
  return Object.create( null );

  src = src.slice( 3, -3 );

  return _.str._parseType( src );

}

//

function _parseType( src )
{
  /*

  {- with with 2 elements -} 4
  {- with name with 2 elements -} 5
  {- with.with with with 2 elements -} 5

  */
  _.assert( _.strIs( src ), 'Expects string' );

  let o =
  {
    type : '',
    traits : [],
  }

  let splitted = src.split( ' ' );
  let type = splitted[ 0 ];
  let length;

  if( splitted.length === 2 ) /* with name & no length */
  {
    o.name = splitted[ 1 ];
  }
  else if( splitted.length === 4 ) /* without name & with length */
  {
    length = +splitted[ 2 ];
  }
  else if( splitted.length === 5 ) /* with name & with length */
  {
    o.name = splitted[ 1 ];
    length = +splitted[ 3 ];
  }

  length = isNaN( length ) ? null : length;

  if( type.indexOf( '.' ) === -1 )
  {
    o.type = type;
  }
  else
  {
    let [ t, ... traits ] = type.split( '.' );
    o.type = t;
    o.traits = traits;
  }

  if( length !== null )
  o.length = length;

  return o;

}

// --
// xxx : implement
// --

let StrExtension =
{

  // exporter

  _exportStringDiagnosticShallow,
  exportStringDiagnosticShallow,
  _exportStringCodeShallow,
  exportStringCodeShallow,
  exportString : exportStringDiagnosticShallow,

  // parser

  parseType, /* xxx : move */
  _parseType,

  quote,
  unquote,
  quotePairsNormalize,
  quoteAnalyze,
  _leftSingle_,
  left_,
  right_,

  insideOf,
  insideOf_,
  outsideOf,

  _removedBegin,
  removeBegin,
  _removedEnd,
  removeEnd,

  replaceBegin,
  replaceEnd,
  replace,

  strip,
  stripLeft,
  stripRight,

  _removeAllSpaces,
  _stripEmptyLines,

  splitsCoupledGroup,
  splitsUngroupedJoin,
  splitsQuotedRejoin,
  splitsDropDelimeters,
  splitsStrip,
  splitsDropEmpty,

  splitFast,
  split,
  splitNonPreserving,

  splitInlined,
  splitInlinedStereo_,

  from,

}

/* xxx : duplicate exportString in namespace::diagnostic? */

/* _.props.extend */Object.assign( _.str, StrExtension );

// --
//
// --

let EntityExtension =
{

  // exportStringSimple, /* xxx : deprecate? */
  // exportStringDiagnosticShallow,
  //
  // _exportStringShallow,
  // exportString : exportStringDiagnosticShallow,
  // exportStringCodeShallow,
  // exportStringDiagnosticShallow,
  //
  // // exportStringShallowFine : exportStringDiagnosticShallow, /* xxx : remove */
  // // exportStringSolo,

}

/* xxx : duplicate exportString in namespace::diagnostic? */

//

/* _.props.extend */Object.assign( _.entity, EntityExtension );

// --
// extension
// --

let ToolsExtension =
{

  // decorator

  strQuote : quote,
  strUnquote : unquote,
  strQuotePairsNormalize : quotePairsNormalize,
  strQuoteAnalyze : quoteAnalyze,

  // splitter

  _strLeftSingle_ : _leftSingle_,
  strLeft_ : left_,
  _strRightSingle_ : _rightSingle_,
  strRight_ : right_,

  strsEquivalentAll : _.vectorizeAll( _.str.equivalent.bind( _.str ), 2 ),
  strsEquivalentAny : _.vectorizeAny( _.str.equivalent.bind( _.str ), 2 ),
  strsEquivalentNone : _.vectorizeNone( _.str.equivalent.bind( _.str ), 2 ),

  strInsideOf : insideOf,
  strInsideOf_ : insideOf_,
  strOutsideOf : outsideOf, /* !!! deprecate */

  // replacers

  _strRemovedBegin : _removedBegin,
  strRemoveBegin : removeBegin,
  _strRemovedEnd : _removedEnd,
  strRemoveEnd : removeEnd,

  strReplaceBegin : replaceBegin,
  strReplaceEnd : replaceEnd,
  strReplace : replace,

  // stripper

  strStrip : strip,
  strStripLeft : stripLeft,
  strStripRight : stripRight,
  _strRemoveAllSpaces : _removeAllSpaces,
  strRemoveAllSpaces : _.vectorize( _removeAllSpaces ),
  _strStripEmptyLines : _stripEmptyLines,
  strStripEmptyLines : _.vectorize( _stripEmptyLines ),

  // split

  strSplitsCoupledGroup : splitsCoupledGroup,
  strSplitsUngroupedJoin : splitsUngroupedJoin,
  strSplitsQuotedRejoin : splitsQuotedRejoin, /* qqq : light coverage required */
  strSplitsDropDelimeters : splitsDropDelimeters, /* qqq : light coverage required */
  strSplitsStrip : splitsStrip,
  strSplitsDropEmpty : splitsDropEmpty,

  strSplitFast : splitFast,
  strSplit : split,
  strSplitNonPreserving : splitNonPreserving,

  strSplitInlined : splitInlined,
  strSplitInlinedStereo_ : splitInlinedStereo_,

  // converter

  strFrom : from,

}

_.props.extend( _, ToolsExtension );

_.assert( !!_.strSplit.defaults.preservingEmpty );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Str.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Str_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Str_s */ })();

/* */  /* begin of file Stringer_s */ ( function Stringer_s() { function Stringer_s_naked() { ( function _l5_Stringer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Parent = _.seeker.Seeker;

// --
// implementation
// --

/* xxx : add to the list of types */

function head( o, o2 )
{

  if( o === null )
  o = Object.create( null );

  if( o2 )
  _.props.supplement( o, o2 );

  if( _.prototype.has( o, _.stringer.Stringer ) )
  return o;

  if( !o.Seeker )
  o.Seeker = Stringer;

  let it = o.Seeker.optionsToIteration( null, o );

  _.assert( _.number.is( it.verbosity ) );
  _.assert( _.routine.is( it.tabLevelDown ) );

  return it;
}

//

function iteratorInitBegin( iterator )
{
  Parent.iteratorInitBegin.call( this, iterator );

  iterator.dstNode = [];

  return iterator;
}

//

function resultExportString()
{
  let it = this;
  return it.iterator.result;
}

//

function verbosityUp()
{
  let it = this;
  let it2 = it.iterationMake();
  it2.tabLevelUp();
  it2.verbosity -= 1;
  return it2;
}

//

function verbosityDown()
{
  let it = this;
  return it;
}

//

function tabLevelUp()
{
  let it = this;
  it.tab += it.dtab;
  it.tabLevel += 1;
  it.dstNode = [];
  it.iterator.dstNode.push( it.dstNode );
  return it;
}

//

function tabLevelDown()
{
  let it = this;
  it.tab = it.tab.slice( 0, it.tab.length - it.dtab.length );
  it.tabLevel -= 1;
  return it;
}

//

function levelUp()
{
  let it = this;
  it.level += 1;
  return it;
}

//

function levelDown()
{
  let it = this;
  it.level -= 1;
  return it;
}

//

function lineWrite( src )
{
  let it = this;
  _.assert( arguments.length === 1 );
  if( it.iterator.result.length )
  it.iterator.result += `${it.eol}${it.tab}${src}`;
  else
  it.iterator.result += `${it.tab}${src}`;
  it.dstNode.push( `${it.tab}${src}` );
  return it;
}

//

function titleWrite( src )
{
  let it = this;
  _.assert( arguments.length === 1 );

  let it2 = it.verbosityUp();
  it2.lineWrite( src );
  return it2;
}

//

function elementsWrite( src )
{
  let it = this;
  _.assert( arguments.length === 1 );

  let it2 = it.verbosityUp();
  for( let e of src )
  {
    it2.lineWrite( e );
  }
  return it2;
}

//

function write( src )
{
  let it = this;
  _.assert( arguments.length === 1 );
  _.assert( _.str.is( src ) );
  it.iterator.result += src;
  if( it.dstNode.length )
  it.dstNode[ it.iterator.dstNode.length-1 ] += src;
  else
  it.dstNode.push( src );
  return it;
}

//

function eolWrite()
{
  let it = this;
  _.assert( arguments.length === 0 );
  it.write( it.eol );
  return it;
}

//

function tabWrite()
{
  let it = this;
  _.assert( arguments.length === 0 );
  it.write( it.tab );
  return it;
}

//

function nodesExportString( src, o )
{
  let result = '';

  o = _.routine.options( nodesExportString, o );

  act( src, o.tab );

  return result;

  function act( src, tab )
  {

    if( _.str.is( src ) )
    {
      if( result.length )
      result += '\n';
      result += tab + src;
      return;
    }

    if( _.array.is( src ) )
    {
      src.forEach( ( e ) => act( e, tab + o.dtab ) );
      return;
    }

    _.assert( 0 );
  }

}

nodesExportString.defaults =
{
  tab : '',
  dtab : '  ',
}

// --
//
// --

const StringerClassExtension = Object.create( null );
StringerClassExtension.constructor = function Stringer(){};
StringerClassExtension.head = head;
StringerClassExtension.iteratorInitBegin = iteratorInitBegin;
StringerClassExtension.resultExportString = resultExportString;
StringerClassExtension.verbosityUp = verbosityUp;
StringerClassExtension.verbosityDown = verbosityDown;
StringerClassExtension.tabLevelUp = tabLevelUp;
StringerClassExtension.tabLevelDown = tabLevelDown;
StringerClassExtension.levelUp = levelUp;
StringerClassExtension.levelDown = levelDown;
StringerClassExtension.write = write;
StringerClassExtension.eolWrite = eolWrite;
StringerClassExtension.tabWrite = tabWrite;
StringerClassExtension.lineWrite = lineWrite;
StringerClassExtension.titleWrite = titleWrite;
StringerClassExtension.elementsWrite = elementsWrite;

const Iterator = StringerClassExtension.Iterator = Object.create( null );
Iterator.result = '';
Iterator.dstNode = null;
Iterator.dtab = '  ';
Iterator.eol = _.str.lines.Eol.default;
Iterator.recursive = Infinity;
_.assert( !!Iterator.eol );

const Iteration = StringerClassExtension.Iteration = Object.create( null );

const IterationPreserve = StringerClassExtension.IterationPreserve = Object.create( null );
IterationPreserve.tab = '';
IterationPreserve.verbosity = 2;
IterationPreserve.tabLevel = 0;
IterationPreserve.level = 0;
IterationPreserve.dstNode = null;

const Prime = {};
const Stringer = _.seeker.classDefine
({
  name : 'Stringer',
  parent : Parent,
  prime : Prime,
  seeker : StringerClassExtension,
  iterator : Iterator,
  iteration : Iteration,
  iterationPreserve : IterationPreserve,
});

_.assert( Stringer.constructor.name === 'Stringer' );
_.assert( Stringer.IterationPreserve.tab === '' );
_.assert( Stringer.Iteration.tab === '' );
_.assert( Stringer.Iterator.tab === undefined );
_.assert( Stringer.tab === undefined );

// --
// stringer extension
// --

let StringerExtension =
{

  Stringer,
  it : head,
  nodesExportString,

}

Object.assign( _.stringer, StringerExtension );

// --
// tools extension
// --

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Stringer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Stringer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Stringer_s */ })();

/* */  /* begin of file Symbol_s */ ( function Symbol_s() { function Symbol_s_naked() { ( function _l5_Symbol_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.symbol = _.symbol || Object.create( null );

// --
// symbol
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( _, ToolsExtension );
Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Symbol.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Symbol_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Symbol_s */ })();

/* */  /* begin of file Time_s */ ( function Time_s() { function Time_s_naked() { ( function _l5_Time_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

/**
 * The routine spent() calculate spent time from time {-time-} and converts
 * the value to formatted string with seconds. If the description {-description-}
 * is provided, then routine prepend description to resulted string.
 *
 * @example
 * let now = _time.now();
 * _.time.sleep( 500 );
 * let spent = _.time.spent( 'Spent : ', now );
 * console.log( spent );
 * // log : 'Spent : 0.5s'
 *
 * @param { String } description - The description for spent time. Optional parameter.
 * @param { Number } time - The start time.
 * @returns { Number } - Returns string with spent seconds.
 * @function spent
 * @throws { Error } If arguments.length is less than 1 or greater than 2.
 * @throws { Error } If {-description-} is not a String.
 * @throws { Error } If {-time-} is not a Number.
 * @namespace wTools.time
 * @extends Tools
 */

/* qqq : introduce namespace _.units */
/* xxx : expose units formatter interface in wTools */
/* qqq xxx : use units formatters */
function spent( description, time )
{
  let now = _.time.now();

  if( arguments.length === 1 )
  {
    time = arguments[ 0 ];
    description = '';
  }

  _.assert( 1 <= arguments.length && arguments.length <= 2 );
  _.assert( _.number.is( time ) );
  _.assert( _.strIs( description ) );

  let result = description + _.time.spentFormat( now-time );

  return result;
}

//

/**
 * The routine spentFormat() converts spent time in milliseconds to seconds.
 * Routine returns string with seconds.
 *
 * @example
 * let now = _time.now();
 * _.time.sleep( 500 );
 * let spent = _.time.now() - now;
 * console.log( _.time.spentFormat( spent ) );
 * // log : '0.5s'
 *
 * @param { Number } spent - The time to convert, in ms.
 * @returns { Number } - Returns string with spent seconds.
 * @function spentFormat
 * @throws { Error } If arguments.length is not equal to 1.
 * @throws { Error } If {-spent-} is not a Number.
 * @namespace wTools.time
 * @extends Tools
 */

function spentFormat( spent )
{

  _.assert( 1 === arguments.length );
  _.assert( _.number.is( spent ) );

  let result = ( 0.001*( spent ) ).toFixed( 3 ) + 's';

  return result;
}

// --
// extension
// --

let TimeExtension =
{

  spent,
  spentFormat,

}

//

_.props.supplement( _.time, TimeExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Time.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Time_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Time_s */ })();

/* */  /* begin of file Type_s */ ( function Type_s() { function Type_s_naked() { ( function _l5_Type_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

// --
//
// --

let Extension =
{
};

//

_.props.supplement( _, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Type.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Type_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Type_s */ })();

/* */  /* begin of file Units_s */ ( function Units_s() { function Units_s_naked() { ( function _l5_Units_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.units = _.units || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{

}

//

var ToolsExtension =
{

}

//

Object.assign( _.units, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Units.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Units_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Units_s */ })();

/* */  /* begin of file Unroll_s */ ( function Unroll_s() { function Unroll_s_naked() { ( function _l5_Unroll_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// /**
//  * The routine unrollMake() returns a new unroll-array maiden from {-src-}.
//  *
//  * Unroll constructed by attaching symbol _.unroll Symbol to ordinary array. Making an unroll normalizes its content.
//  *
//  * @param { Number|Long|Set|Null|Undefined } src - The number or other instance to make unroll-array. If null is provided,
//  * then routine returns an empty Unroll.
//  *
//  * @example
//  * let src = _.unroll.make();
//  * // returns []
//  * _.unrollIs( src );
//  * // returns true
//  *
//  * @example
//  * let src = _.unroll.make( null );
//  * // returns []
//  * _.unrollIs( src );
//  * // returns true
//  *
//  * @example
//  * let src = _.unroll.make( null, null );
//  * // returns []
//  * _.unrollIs( src );
//  * // returns true
//  *
//  * @example
//  * let src = _.unroll.make( 3 );
//  * // returns [ undefined, undefined, undefined ]
//  * _.unrollIs( src );
//  * // returns true
//  *
//  * @example
//  * let src = _.unroll.make( [ 1, 2, 'str' ] );
//  * // returns [ 1, 2, 'str' ]
//  * _.unrollIs( src );
//  * // returns true
//  *
//  * @returns { Unroll } - Returns a new Unroll maiden from {-src-}.
//  * Otherwise, it returns the empty Unroll.
//  * @function unrollMake
//  * @throws { Error } If arguments.length is more then one.
//  * @throws { Error } If {-src-} is not a number, not a Long, not Set, not null, not undefined.
//  * @namespace Tools
//  */
//
// function unrollMake( src )
// {
//   let result = _.array.make( src );
//   _.assert( arguments.length === 0 || arguments.length === 1 );
//   _.assert( _.arrayIs( result ) );
//   result[ unrollSymbol ] = true;
//   if( !_.unrollIs( src ) )
//   result = _.unroll.normalize( result );
//   return result;
// }
//
// //
//
// /**
//  * The routine unrollMakeUndefined() returns a new Unroll with length equal to {-length-}.
//  * If the argument {-length-} is not provided, routine returns new Unroll with the length defined from {-src-}.
//  *
//  * @param { Long|Number|Null } src - Any Long, Number or null. If {-length-} is not provided, then routine defines length from {-src-}.
//  * @param { Number|Long|Null } length - Defines length of new Unroll. If null is provided, then length defines by {-src-}.
//  *
//  * @example
//  * _.unroll.makeUndefined();
//  * // returns []
//  *
//  * @example
//  * _.unroll.makeUndefined( null );
//  * // returns []
//  *
//  * @example
//  * _.unroll.makeUndefined( null, null );
//  * // returns []
//  *
//  * @example
//  * _.unroll.makeUndefined( 3 );
//  * // returns [ undefined, undefined, undefined]
//  *
//  * @example
//  * _.unroll.makeUndefined( 3, null );
//  * // returns [ undefined, undefined, undefined]
//  *
//  * @example
//  * _.unroll.makeUndefined( [ 1, 2, 3 ] );
//  * // returns [ undefined, undefined, undefined ]
//  *
//  * @example
//  * _.unroll.makeUndefined( [ 1, 2, 3 ], null );
//  * // returns [ undefined, undefined, undefined ]
//  *
//  * @example
//  * _.unroll.makeUndefined( [ 1, 2, 3 ], 4 );
//  * // returns [ undefined, undefined, undefined, undefined ]
//  *
//  * @example
//  * _.unroll.makeUndefined( [ 1, 2, 3, 4 ], [ 1, 2 ] );
//  * // returns [ undefined, undefined ]
//  *
//  * @example
//  * let src = new F32x( [ 1, 2, 3, 4, 5 ] );
//  * let got = _.unroll.makeUndefined( src, 3 );
//  * console.log( got );
//  * // log [ undefined, undefined, undefined ]
//  *
//  * @returns { Unroll } Returns a new Unroll with length equal to {-length-} or defined from {-src-}.
//  * If null passed, routine returns the empty Unroll.
//  * @function unrollMakeUndefined
//  * @throws { Error } If arguments.length is less then one or more then two.
//  * @throws { Error } If argument {-src-} is not a Long, not null.
//  * @throws { Error } If argument {-length-} is not a number, not a Long.
//  * @namespace Tools
//  */
//
// function unrollMakeUndefined( src, length )
// {
//   if( arguments.length === 0 )
//   return _.unroll.make();
//
//   if( _.longIs( length ) )
//   {
//     length = length.length;
//   }
//   if( length === undefined || length === null )
//   {
//     if( src === null )
//     {
//       length = 0;
//     }
//     else if( _.longLike( src ) )
//     {
//       length = src.length;
//     }
//     else if( _.number.is( src ) )
//     {
//       length = src;
//       src = null;
//     }
//     else _.assert( 0 );
//   }
//
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   _.assert( _.number.isFinite( length ) );
//   _.assert( _.longIs( src ) || src === null );
//
//   return _.unroll.make( length );
// }
//
// //
//
// /**
//  * The routine unrollFrom() performs conversion of {-src-} to unroll-array.
//  *
//  * If {-src-} is not unroll-array, routine unrollFrom() returns new unroll-array.
//  * If {-src-} is unroll-array, then routine returns {-src-}.
//  *
//  * @param { Long|Set|Number|Null|Undefined } src - The number, array-like object or Unroll. If null is provided,
//  * then routine returns an empty Unroll.
//  *
//  * @example
//  * let got = _.unroll.from( null );
//  * // returns []
//  * _.unrollIs( got );
//  * // returns true
//  *
//  * @example
//  * let got = _.unroll.from( 3 );
//  * // returns [ undefined, undefined, undefined ]
//  * _.unrollIs( got );
//  * // returns true
//  *
//  * @example
//  * let got = _.unroll.from( [ 1, 2, 'str' ] );
//  * // returns [ 1, 2, 'str' ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  *
//  * @example
//  * let got = _.unroll.from( new F32x( [ 1, 2, 0 ] ) );
//  * // returns [ 1, 2, 0 ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  *
//  * @example
//  * let got = _.unroll.from( new Set( [ 1, 2, 'str' ] ) );
//  * // returns [ 1, 2, 'str' ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  *
//  * @example
//  * let src = _.unroll.make( [ 1, 2, 'str' ] );
//  * let got = _.unroll.from( src );
//  * // returns [ 1, 2, 'str' ]
//  * console.log ( src === got );
//  * // log true
//  *
//  * @returns { Unroll } Returns Unroll converted from {-src-}. If {-src-} is Unroll, then routine returns {-src-}.
//  * @function unrollFrom
//  * @throws { Error } If arguments.length is less or more then one.
//  * @throws { Error } If argument {-src-} is not Long, not number, not Set, not null, not undefined.
//  * @namespace Tools
//  */
//
// function unrollFrom( src )
// {
//   _.assert( arguments.length === 1 );
//   if( _.unrollIs( src ) )
//   return src;
//   return _.unroll.make( src );
// }

// //
//
// /**
//  * The routine unrollsFrom() performs conversion of each argument to unroll-array.
//  * The routine returns unroll-array contained unroll-arrays converted from arguments.
//  *
//  * @param { Long|Set|Number|Null|Undefined } srcs - The objects to be converted into Unrolls.
//  *
//  * @example
//  * let got = _.unrollsFrom( null );
//  * // returns [ [] ]
//  * _.unrollIs( got );
//  * // true true
//  *
//  * @example
//  * let got = _.unrollsFrom( [ 1, 2, 'str' ] );
//  * // returns [ [ 1, 2, 'str' ] ]
//  * _.unrollIs( got );
//  * // returns true
//  * _.unrollIs( got[ 0 ] );
//  * // returns true
//  *
//  * @example
//  * let got = _.unrollsFrom( [], 1, null, [ 1, 'str' ] );
//  * // returns [ [], [ undefined ], [], [ 1, 'str' ] ]
//  * _.unrollIs( got );
//  * // returns true
//  * _.unrollIs( got[ 0 ] );
//  * // returns true
//  * _.unrollIs( got[ 1 ] );
//  * // returns true
//  * _.unrollIs( got[ 2 ] );
//  * // returns true
//  * _.unrollIs( got[ 3 ] );
//  * // returns true
//  *
//  * @returns { Unroll } - Returns Unroll contained Unrolls converted from arguments.
//  * @function unrollsFrom
//  * @throws { Error } If arguments.length is less then one.
//  * @throws { Error } If any of the arguments is not a Long, not a Set, not a Number, not null, not undefined.
//  * @namespace Tools
//  */
//
// function unrollsFrom( srcs )
// {
//   _.assert( arguments.length >= 1 );
//
//   let result = _.unroll.make( null );
//
//   for( let i = 0; i < arguments.length; i++ )
//   {
//     if( _.unrollIs( arguments[ i ] ) )
//     result.push( arguments[ i ] );
//     else
//     result.push( _.unroll.make( arguments[ i ] ) );
//   }
//
//   return result;
// }

//

// /**
//  * The routine unrollFromMaybe() performs conversion of {-src-} to unroll-array.
//  *
//  * @param { * } src - The object to make Unroll.
//  * If {-src-} has incompatible type, then routine returns original {-src-}.
//  * If {-src-} is unroll-array, then routine returns original {-src-}.
//  * If {-src-} is not unroll-array, and it converts into unroll-array, then routine
//  * unrollFromMaybe() returns new unroll-array.
//  *
//  * @example
//  * let got = _.unroll.fromMaybe( 'str' );
//  * // returns 'str'
//  *
//  * @example
//  * let got = _.unroll.fromMaybe( { a : 1 } );
//  * // returns { a : 1 }
//  *
//  * @example
//  * let got = _.unroll.fromMaybe( null );
//  * // returns []
//  * console.log( _.unrollIs( unroll ) );
//  * // log true
//  *
//  * @example
//  * let src = _.unroll.make( [ 1, 2, 'str' ] );
//  * let got = _.unroll.fromMaybe( src );
//  * console.log ( src === got );
//  * // log true
//  *
//  * @returns { Unroll|* } - If it possible, routine returns Unroll converted from {-src-}.
//  * If {-src-} is Unroll or incompatible type, it returns original {-src-}.
//  * @function unrollFromMaybe
//  * @throws { Error } If arguments.length is less or more then one.
//  * @namespace Tools
//  */
//
// function unrollFromMaybe( src )
// {
//   _.assert( arguments.length === 1 );
//   // if( _.unrollIs( src ) || _.strIs( src ) || _.bool.is( src ) || _.mapIs( src ) || src === undefined )
//   // return src;
//   // return _.unroll.make( src );
//   if( _.unrollIs( src ) ) /* previous implementation is wrong */ /* Condition of routine can be combined by another order */
//   return src;
//   else if( _.longIs( src ) || _.number.is( src ) || src === null )
//   return _.unroll.make( src );
//   else
//   return src;
// }

//

// /**
//  * The routine unrollNormalize() performs normalization of {-dstArray-}.
//  * Normalization is unrolling of Unrolls, which is elements of {-dstArray-}.
//  *
//  * If {-dstArray-} is unroll-array, routine unrollNormalize() returns unroll-array
//  * with normalized elements.
//  * If {-dstArray-} is array, routine unrollNormalize() returns array with unrolled elements.
//  *
//  * @param { Array|Unroll } dstArray - The Unroll to be unrolled (normalized).
//  *
//  * @example
//  * let unroll = _.unroll.from( [ 1, 2, _.unroll.make( [ 3, 'str' ] ) ] );
//  * let result = _.unroll.normalize( unroll )
//  * console.log( result );
//  * // log [ 1, 2, 3, 'str' ]
//  * console.log( _.unrollIs( result ) );
//  * // log true
//  *
//  * @example
//  * let unroll = _.unroll.from( [ 1,'str' ] );
//  * let result = _.unroll.normalize( [ 1, unroll, [ unroll ] ] );
//  * console.log( result );
//  * // log [ 1, 1, 'str', [ 1, 'str' ] ]
//  * console.log( _.unrollIs( result ) );
//  * // log false
//  *
//  * @returns { Array } If {-dstArray-} is array, routine returns an array with normalized elements.
//  * @returns { Unroll } If {-dstArray-} is Unroll, routine returns an Unroll with normalized elements.
//  * @function unrollNormalize
//  * @throws { Error } If ( arguments.length ) is not equal to one.
//  * @throws { Error } If argument ( dstArray ) is not arrayLike.
//  * @namespace Tools
//  */
//
// function unrollNormalize( dstArray )
// {
//
//   _.assert( arguments.length === 1 );
//   _.assert( _.arrayIs( dstArray ), () => `Expects array as the first argument {-dstArray-} but got "${ dstArray }"` );
//
//   for( let a = 0 ; a < dstArray.length ; a++ )
//   {
//     if( _.unrollIs( dstArray[ a ] ) )
//     {
//       let args = [ a, 1 ];
//       args.push.apply( args, dstArray[ a ] );
//       dstArray.splice.apply( dstArray, args );
//       a += args.length - 3;
//       /* no normalization of ready unrolls, them should be normal */
//     }
//     else if( _.arrayIs( dstArray[ a ] ) )
//     {
//       _.unroll.normalize( dstArray[ a ] );
//     }
//   }
//
//   return dstArray;
// }

// //
//
// /**
//  * The routine unrollSelect() returns a copy of a portion of {-src-} into a new Unroll. The portion of {-src-} selected
//  * by {-range-}. If end index of new Unroll is more then src.length, then routine appends elements with {-val-} value.
//  * The original {-src-} will not be modified.
//  *
//  * @param { Long } src - The Long from which makes a shallow copy.
//  * @param { Range|Number } range - The two-element src that defines the start index and the end index for copying elements.
//  * If {-range-} is number, then it defines the start index, and the end index sets to src.length.
//  * If {-range-} is undefined, routine returns Unroll with copy of {-src-}.
//  * If range[ 0 ] < 0, then start index sets to 0, the end index increments by absolute value of range[ 0 ].
//  * If range[ 1 ] <= range[ 0 ], then routine returns empty Unroll.
//  * @param { * } val - The object of any type for insertion.
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.unrollSelect( src );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5 ]
//  * console.log( _.unrollIs( got ) );
//  * // log true
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.unrollSelect( src, 2, [ 'str' ] );
//  * console.log( got );
//  * // log [ 3, 4, 5 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.unrollSelect( src, [ 1, 4 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 2, 3, 4 ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.unrollSelect( src, [ -2, 6 ], [ 'str' ] );
//  * console.log( got );
//  * // log [ 1, 2, 3, 4, 5, 'str', 'str', 'str' ]
//  * console.log( got === src );
//  * // log false
//  *
//  * @example
//  * var src = [ 1, 2, 3, 4, 5 ];
//  * var got = _.unrollSelect( src, [ 4, 1 ], [ 'str' ] );
//  * console.log( got );
//  * // log []
//  * console.log( got === src );
//  * // log false
//  *
//  * @returns { Unroll } Returns a copy of portion of source Long with appended elements that is defined by range.
//  * @function unrollSelect
//  * @throws { Error } If arguments.length is less then one or more then three.
//  * @throws { Error } If argument {-src-} is not an Array or Unroll.
//  * @throws { Error } If range.length is less or more then two.
//  * @throws { Error } If range elements is not a number / undefined.
//  * @namespace Tools
//  */
//
// function unrollSelect( src, range, val )
// {
//   let result;
//
//   if( range === undefined )
//   return _.unroll.make( src );
//
//   if( _.number.is( range ) )
//   range = [ range, src.length ];
//
//   let f = range[ 0 ] !== undefined ? range[ 0 ] : 0;
//   let l = range[ 1 ] !== undefined ? range[ 1 ] : src.length;
//
//   _.assert( _.longIs( src ) );
//   _.assert( _.intervalIs( range ) )
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   if( l < f )
//   l = f;
//
//   if( f < 0 )
//   {
//     l -= f;
//     f -= f;
//   }
//
//   if( f === 0 && l === src.length )
//   return _.unroll.make( src );
//
//   result = _.unroll.makeUndefined( src, l-f );
//
//   /* */
//
//   let f2 = Math.max( f, 0 );
//   let l2 = Math.min( src.length, l );
//   for( let r = f2 ; r < l2 ; r++ )
//   result[ r-f ] = src[ r ];
//
//   /* */
//
//   if( val !== undefined )
//   {
//     for( let r = 0 ; r < -f ; r++ )
//     result[ r ] = val;
//     for( let r = l2 - f; r < result.length ; r++ )
//     result[ r ] = val;
//   }
//
//   /* */
//
//   return result;
// }

// --
// implementation
// --

let unrollSymbol = Symbol.for( 'unroll' );

let ToolsExtension =
{

  /* qqq : for junior : duplicate namespace unroll */
  /* qqq : for junior : make the list of unduplicated namespaces */

  // unrollMake,
  // unrollMakeUndefined,
  // unrollFrom,
  // unrollsFrom,
  // unrollFromMaybe,
  // unrollNormalize,

  // unrollSelect,

  // unrollPrepend,
  // unrollAppend,
  // unrollRemove,

}

//

_.props.supplement( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Unroll.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Unroll_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Unroll_s */ })();

/* */  /* begin of file Vector_s */ ( function Vector_s() { function Vector_s_naked() { ( function _l5_Vector_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.vector = _.vector || Object.create( null );

// --
// implementation
// --

/**
 * The hasLength() routine determines whether the passed value has the property (length).
 *
 * If {-srcMap-} is equal to the (undefined) or (null) false is returned.
 * If {-srcMap-} has the property (length) true is returned.
 * Otherwise false is.
 *
 * @param { * } src - The object to be checked.
 *
 * @example
 * _.hasLength( [ 1, 2 ] );
 * // returns true
 *
 * @example
 * _.hasLength( 'Hello there!' );
 * // returns true
 *
 * @example
 * let isLength = ( function() {
 *   return _.hasLength( arguments );
 * } )( 'Hello there!' );
 * // returns true
 *
 * @example
 * _.hasLength( 10 );
 * // returns false
 *
 * @example
 * _.hasLength( {} );
 * // returns false
 *
 * @returns { boolean } Returns true if {-srcMap-} has the property (length).
 * @function hasLength
 * @namespace Tools
 */

function hasLength( src )
{
  if( src === undefined || src === null )
  return false;
  if( _.number.is( src.length ) )
  return true;
  return false;
}

// --
// extension
// --

var Extension =
{

  hasLength,

}

//

Object.assign( _.vector, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/Vector.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Vector_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Vector_s */ })();

/* */  /* begin of file zModule_s */ ( function zModule_s() { function zModule_s_naked() { ( function _l5_Module_s_()
{

'use strict';

//

const _global = _global_;
const _ = _global_.wTools;
const __ = _realGlobal_.wTools;
let ModuleFileNative = null;

let __fileNativeInclude;
if( typeof require !== 'undefined' )
__fileNativeInclude = require;
else if( typeof importScripts !== 'undefined' )
__fileNativeInclude = importScripts;
else if( _global._remoteRequire )
__fileNativeInclude = _global._remoteRequire;

const hasModuleFileDescriptor = !( typeof module === 'undefined' );

/* = concepts

Module
ModuleFile
EntryFile
ModulesEnvironment

*/

// --
// Module methods
// --

function moduleExportString()
{
  return `{- ${this.constructor.name} ${this.name} -}`;
}

// --
// Module File methods
// --

function moduleFileExportString()
{
  return `{- ${this.constructor.name} ${this.sourcePath} -}`;
}

//

function moduleFileReturnedGet()
{
  if( !this.native )
  return;
  return this.native.exports;
}

// xxx : use later
// //
//
// function ModuleFileReturnedSet( val )
// {
//   if( !this.native )
//   return;
//   return this.native.exports = val;
// }

// --
// module
// --

function is( src )
{
  if( !src )
  return false;
  if( Reflect.hasOwnProperty( src, 'constructor' ) )
  return false;
  return src[ ModuleSymbol ] === true;
}

//

/* xxx : cover */
function _with( name )
{
  let module = _.module.withName( name );
  if( module )
  return module;
  module = _.module.withPath( name );
  return module;
}

//

/* xxx : cover */
function withName( name )
{
  let module = _.module.modulesMap.get( name );
  if( !module )
  return null;
  return module;
}

//

/* xxx : cover */
function withPath( filePath )
{
  let normalizedPath = _.path.canonize( filePath );
  let file = _.module.filesMap.get( normalizedPath );
  if( !file )
  return null;
  return file.module;
}

//

function predeclare_head( routine, args )
{

  let o = args[ 0 ]
  if( _.strIs( args[ 0 ] ) )
  o = { name : args[ 0 ], entryPath : ( args.length > 1 ? args[ 1 ] : null ) }

  _.routine.options( routine, o );

  if( _.strIs( o.alias ) )
  o.alias = [ o.alias ];
  else if( o.alias === null )
  o.alias = [];

  if( !o.name )
  o.name = o.alias[ 0 ];

  o.entryPath = _.array.as( o.entryPath );
  // o.entryPath = o.entryPath.map( ( path ) => _.path.canonize( path ) );

  _.assert( _.arrayIs( o.alias ) );
  _.assert( _.strDefined( o.name ) );
  _.assert( _.mapIs( o ) );
  _.assert( o.files === undefined );

  return o;
}

//

function predeclare_body( o )
{

  _.arrayPrependOnce( o.alias, o.name );
  _.assert( _.arrayIs( o.entryPath ) );

  // if( o.name === 'wTesting' )
  // {
  //   console.log( `wTesting : ${o.entryPath}` );
  //   debugger;
  // }

  o.entryPath.forEach( ( entryPath, i ) =>
  {
    if( _.path.isDotted( entryPath ) )
    {
      if( o.basePath === null )
      o.basePath = _.path.dir( _.introspector.location({ level : 4 }).filePath );
      /* xxx : use _.introspector.dirPath */
      /* xxx : qqq : make sure _.introspector.location works properly for built-in routines ( without files ) */
      _.assert( _.strDefined( o.basePath ), '{-o.basePath-} is required if path is relative' );
      entryPath = o.entryPath[ i ] = _.path.canonize( o.basePath + '/' + entryPath );
    }
    else
    {
      let normalized = _.path.canonize( entryPath );
      if( _.path.isAbsolute( normalized ) )
      entryPath = o.entryPath[ i ] = normalized;
    }

    if( _.path.isAbsolute( entryPath ) )
    {
      let module2 = _.module.predeclaredWithEntryPathMap.get( entryPath );
      _.assert
      (
        !module2 || module2.name === o.name,
        () => `Module ${o.name} is trying to register entry path ${entryPath} which is registered for ${module2}`
      );
      _.module.predeclaredWithEntryPathMap.set( entryPath, o );
    }
    else
    {
      _.assert( !_.path.isDotted( entryPath ) );
      let module2 = _.module.predeclaredWithEntryPathMap.get( entryPath );
      _.assert
      (
        !module2 || module2.name === o.name,
        () => `Module ${o.name} is trying to register entry path ${entryPath} which is registered for ${module2}`
      );
      _.module.predeclaredWithEntryPathMap.set( entryPath, o );
    }
  });

  let module2 = _.module.predeclaredWithNameMap.get( o.name );
  if( module2 )
  {
    _.assert( o.name === module2.name );
    _.arrayAppendArrayOnce( module2.entryPath, o.entryPath );
    _.arrayAppendArrayOnce( module2.alias, o.alias ); /* xxx : rename to names */
    _.arrayAppendArrayOnce( module2.filePath, o.entryPath );
    _.arrayAppendArrayOnce( module2.lookPath, o.entryPath );
    _.arrayAppendArrayOnce( module2.lookPath, o.alias );

    register( module2, o.entryPath, o.alias );

    let files = _.module._filesWithResolvedPath( o.entryPath )
    _.module._filesUniversalAssociateModule( files, module2, true );

    return module2;
  }

  register( o, o.entryPath, o.alias );

  _.assert( o.files === undefined );
  o.files = null;
  _.assert( o.filePath === undefined );
  o.filePath = o.filePath || [];
  _.arrayAppendArray( o.filePath, o.entryPath );
  _.assert( o.lookPath === undefined );
  o.lookPath = [ ... o.entryPath, ... o.alias ];
  o.ups = new Set();
  o.downs = new Set();

  delete o.basePath;
  o.status = 0;
  Object.setPrototypeOf( o, _.module.Module.prototype );
  Object.preventExtensions( o );

  let files = _.module._filesWithResolvedPath( o.entryPath )
  _.module._filesUniversalAssociateModule( files, o, true );

  return o;

  function register( module, entryPath, alias )
  {
    entryPath.forEach( ( entryPath ) => _.module.predeclaredWithEntryPathMap.set( entryPath, module ) );
    alias.forEach( ( name ) =>
    {
      let module3 = _.module.predeclaredWithNameMap.get( name );
      _.assert( module3 === undefined || module3 === module );
      _.module.predeclaredWithNameMap.set( name, module );
    });
  }
}

predeclare_body.defaults =
{
  name : null,
  alias : null,
  entryPath : null,
  basePath : null,
}

const predeclare = _.routine.unite( predeclare_head, predeclare_body );

//

function predeclareAll( o )
{

  _.assert( arguments.length === 1 );
  _.assert( _.mapIs( o.modules ) );
  _.routine.options( predeclareAll, arguments );

  for( let k in o.modules )
  {
    let module = o.modules[ k ];
    _.assert( module.name === k || module.name === undefined );
    _.assert( _.mapIs( module ) );
    module.name = k;
    if( !module.basePath )
    module.basePath = o.basePath;
    _.module.predeclare( module );
    delete o.modules[ k ];
  }

}

predeclareAll.defaults =
{
  modules : null,
  basePath : null,
}

//

function _predeclaredWithEntryPath( entryPath )
{
  let predeclaredModule = _.module.predeclaredWithEntryPathMap.get( entryPath );
  if( predeclaredModule )
  return predeclaredModule;
}

// --
// file
// --

/* qqq xxx : cover */
function fileIs( src )
{
  if( !src )
  return false;
  if( !src.constructor )
  return false;
  if( src.constructor.name === 'ModuleFile' )
  return true;
  if( src instanceof ModuleFileNative );
  return true;
  return false;
}

//

function fileUniversalFrom( src )
{

  if( _.module.fileUniversalIs( src ) )
  return src;
  if( _.module.fileNativeIs( src ) )
  return src.universal || null;

  _.assert( 0, `Not clear how to deduce module file from ${_.entity.strType( src )}` );
}

//

function _fileUniversalFinit( file )
{
  _.assert( _.module.fileUniversalIs( file ) );

  file.status = -1;

  file.native.children.forEach( ( nativeFile, index ) =>
  {
    if( nativeFile.universal )
    _.module._fileUniversalDisassociateFile( nativeFile.universal, file );
  });

  file.downFiles.forEach( ( file2 ) =>
  {
    _.module._fileUniversalDisassociateFile( file, file2 );
  });

  _.module._fileUniversalDisassociateModules( file, false );

  if( Config.debug )
  {
    let file2 = _.module.filesMap.get( file.sourcePath );
    _.assert( file2 === undefined || file2 === file );
    _.assert( file.downFiles.size === 0 );
    _.assert( file.upFiles.size === 0 );
    _.assert( file.modules.size === 0 );
  }

  _.module.filesMap.delete( file.sourcePath );
  Object.freeze( file );
}

//

function _fileUniversalInit( o )
{
  try
  {

    o.sourcePath = _.path.canonize( o.sourcePath ); /* zzz : qqq : optimize */

    let moduleFile2 = _.module.filesMap.get( o.sourcePath );
    if( moduleFile2 )
    {
      if( moduleFile2.native !== o.native )
      {
        moduleFile2.native = o.native;
      }
      return moduleFile2;
    }

    if( Config.debug )
    verify();

    o.native.universal = o;
    Object.setPrototypeOf( o, _.module.File.prototype );
    _.module.filesMap.set( o.sourcePath, o );

    o.moduleNativeFilesMap = o.moduleNativeFilesMap || _.module.nativeFilesMap;
    o.global = o.global || _global;
    o.error = o.error || null;

    pathsAmend();
    modulesAssociate();
    filesAssociate();

    if( Config.debug )
    validate();

    Object.preventExtensions( o );
    return o;
  }
  catch( err )
  {
    err = _.err( err, `\nError in _.module._fileUniversalInit of ${o.sourcePath}` );
    throw err;
  }

  /* -

  verify,
  pathsAmend,
  filesAssociate,
  modulesAssociate,
  validate,

  */

  function verify()
  {
    _.assert( o.module === undefined );
    _.assert( o.modules === undefined );
    _.assert( o.downFile === undefined );
    _.assert( o.upFiles === undefined );
    _.assert( _.module.fileNativeIs( o.native ) );
    _.assert( o.native.universal === undefined );
    _.assert( !o.native.universal );
    _.assert( !o.native.moduleNativeFilesMap );
    _.assert
    (
      _.module.nativeFilesMap[ _.path.nativizeMinimal( o.sourcePath ) ] === o.native,
      `Module file ${o.sourcePath} is not in the current module files list`
    );
  }

  /* - */

  function pathsAmend()
  {
    /* qqq : cover */
    if( _.module._prependPath )
    _.arrayPrependArrayOnce( o.native.paths, _.module._prependPath );
    if( _.module._appendPath )
    _.arrayAppendArrayOnce( o.native.paths, _.module._appendPath );
  }

  /* - */

  function filesAssociate()
  {

/*

o.native.id - "/pro/builder/proto/wtools/atop/testing/include/Base.s"
o.native.parent.id - "/pro/builder/proto/wtools/atop/testing/include/Top.s"
xxx : test to check the parent has the child and the child has the parent

o.native.id -- "/pro/builder/proto/wtools/atop/testing/include/Top.s"
xxx : test to check the module file has universal file for each children

*/

    o.downFiles = new Set;

    let parent = _.module.fileNativeParent( o.native );
    if( parent && parent.universal )
    {
      _.module._fileUniversalAssociateFile( o, parent.universal );
    }
    else
    {
      o.downFile = null;
    }

    o.upFiles = new Set;

    o.native.children.forEach( ( file, index ) =>
    {
      if( file.universal )
      {
        _.module._fileUniversalAssociateFile( file.universal, o );
      }
    });

  }

  /* - */

  function modulesAssociate()
  {

    _.assert( o.module === undefined );
    _.assert( o.modules === undefined );

    o.module = null;
    o.modules = new Set();

    let predeclaredModule = _.module._predeclaredWithEntryPath( o.sourcePath );
    if( predeclaredModule )
    {
      _.module._fileUniversalAssociateModule( o, predeclaredModule );
    }

    if( !predeclaredModule )
    if( o.requestedSourcePath === null || _.path.isRelative( o.requestedSourcePath ) )
    {

      let parentNative = _.module.fileNativeParent( o.native );
      let parentModules;
      if
      (
        parentNative
        && parentNative.universal
        && o.moduleNativeFilesMap === parentNative.universal.moduleNativeFilesMap
        && parentNative.universal.module
      )
      {
        _.assert( !!_.module.is( parentNative.universal.module ) );
        _.assert( parentNative.universal.module instanceof _.module.Module );
        _.assert( _.set.is( parentNative.universal.modules ) );
        parentModules = parentNative.universal.modules;
        _.assert( parentModules.size > 0 );
        _.module._fileUniversalAssociateModule( o, parentModules );
      }

    }

  }

  /* - */

  function validate()
  {
    _.assert( o instanceof _.module.File );
    _.assert( _.module.fileIs( o ) );
    _.assert( _.module.fileUniversalIs( o ) );
    _.assert( o.module !== undefined );
  }

  /* - */

}

_fileUniversalInit.defaults =
{
  sourcePath : null,
  nativeSourcePath : null,
  requestedSourcePath : null,
  native : null,
  moduleNativeFilesMap : null,
  error : null,
  global : null,
  status : null,
}

//

function _filesUniversalInit( o )
{
  let visited = new Set;
  let stack = [];

  _.routine.options( _filesUniversalInit, o );
  o.files = _.array.as( o.files );
  stack.push( ... o.files );

  if( _.__GLOBAL_NAME__ === 'test1' )
  debugger;

  for( let i = 0 ; i < stack.length ; i++ )
  up( stack[ i ] );

  while( stack.length )
  down( stack.pop() );

  return visited;

  function up( file )
  {
    if( visited.has( file ) )
    return;
    visited.add( file );

    stack.push( ... file.children );

    _.assert( _.module.fileNativeIs( file ) );

    let fileName = file.filename || file.id ;
    if( !file.universal && _.module.nativeFilesMap[ fileName ] === file ) /* yyy */
    _.module._fileUniversalInit
    ({
      sourcePath : fileName,
      nativeSourcePath : fileName,
      requestedSourcePath : null,
      native : file,
      status : 2,
    });

  }

  function down( file )
  {

    if( file.universal )
    file.children.forEach( ( file2, index ) =>
    {
      if( file2.universal )
      {
        _.module._fileUniversalAssociateFile( file2.universal, file.universal );
        if( file.universal.moduleNativeFilesMap === _.module.nativeFilesMap && file.universal.module )
        _.module._filesUniversalAssociateModule( file2.universal, file.universal.module, false );
      }
    });

  }

}

_filesUniversalInit.defaults =
{
  files : null,
}

//

function _fileUniversalAssociateFile( upFile, downFile )
{

  /*
  files could belong to different environments!
  */

  if( !_.module.fileUniversalIs( upFile ) )
  debugger;
  _.assert( _.module.fileUniversalIs( upFile ) );
  _.assert( _.module.fileUniversalIs( downFile) );

  upFile.downFile = upFile.downFile || downFile;
  upFile.downFiles.add( downFile );
  for( let module of upFile.modules )
  module.downs.add( ... _.set.butElement( null, downFile.modules, module ) ); /* qqq : cover and implement deleting */

  downFile.upFiles.add( upFile );
  for( let module of downFile.modules )
  module.ups.add( ... _.set.butElement( null, upFile.modules, module ) );

}

//

function _fileUniversalDisassociateFile( upFile, downFile )
{

  /*
  files could belong to different environments
  */

  _.assert( _.module.fileUniversalIs( upFile ) );
  _.assert( _.module.fileUniversalIs( downFile) );

  upFile.downFiles.delete( downFile );
  if( upFile.downFile === downFile )
  upFile.downFile = [ ... upFile.downFiles ][ 0 ] || null; /* qqq : cover */

  downFile.upFiles.delete( upFile );

}

//

function _fileUniversalAssociateModule( file, module )
{
  let result = 0;

  if( Config.debug )
  {
    _.assert( arguments.length === 2 );
    let module2 = _.module._predeclaredWithEntryPath( file.sourcePath );
    _.assert
    (
      module2 === undefined || module2 === module,
      () => `Attempt to associate ${file} with ${module}, but it is entry of ${module2}`
    );
  }

  if( _.set.is( module ) )
  {
    module.forEach( ( module ) => result += _.module._fileUniversalAssociateModule( file, module ) );
    return result;
  }

  _.assert( _.module.fileUniversalIs( file ) );
  _.assert( _.module.is( module ) );

  file.modules.add( module );
  file.module = file.module || module;

  result += 1;

  module.files = module.files || new HashMap();
  module.files.set( file.sourcePath, file );
  module.alias.forEach( ( name ) =>
  {
    if( Config.debug )
    {
      let module2 = _.module.modulesMap.get( name );
      _.assert( module2 === undefined || module2 === module );
    }
    _.module.modulesMap.set( name, module );
  });

  return result;
}

//

function _fileUniversalDisassociateModules( file, reassociating )
{
  let result = 0;

  if( Config.debug )
  {
    _.assert( arguments.length === 1 || arguments.length === 2 );
    _.assert( _.module.fileUniversalIs( file ) );
  }

  result += file.modules.size;

  if( !file.modules.size )
  return result;

  if( reassociating )
  reassociate();
  else
  deassociate();

  return result;

  function moduleDisassociate( module )
  {
    module.files.delete( file.sourcePath );
  }

  function deassociate()
  {
    file.modules.forEach( ( module ) => moduleDisassociate( module ) );
    file.modules.clear();
    file.module = null;
  }

  function reassociate()
  {
    let downModules = new Set();

    file.downFiles.forEach( ( file2 ) => downModules.add( ... file2.modules ) );

    file.modules.forEach( ( module ) =>
    {
      if( !downModules.has( module ) )
      {
        moduleDisassociate( module, downModules );
        file.modules.delete( module );
        if( module === file.module )
        file.module = null;
      }
    });

    if( file.module = null && file.modules.size > 0 )
    {
      debugger; /* xxx : qqq : cover */
      file.module = [ ... file.modules ][ 0 ];
    }

  }

}

//

function _filesUniversalAssociateModule( files, modules, disassociating )
{
  let visited = new Set;
  let stack = [];

  files = _.countable.is( files ) ? files : [ files ];
  stack.push( ... files );

  if( disassociating )
  files.forEach( ( file ) => _.module._fileUniversalDisassociateModules( file, false ) );

  if( Config.debug )
  {
    _.assert( _.module.is( modules ) || _.set.is( modules ) );
    if( _.set.is( modules ) )
    modules.forEach( ( module ) => _.assert( _.module.is( module ) ) );
  }

  if( _.set.is( modules ) )
  {
    while( stack.length )
    modulesAssociate( stack.pop() );
  }
  else
  {
    while( stack.length )
    moduleAssociate( stack.pop() );
  }

  return visited;

  /* - */

  function modulesAssociate( file )
  {
    if( visited.has( file ) )
    return;
    visited.add( file );

    _.assert( _.module.fileUniversalIs( file ) );
    _.assert( _.setIs( file.upFiles ) );

    if( file.moduleNativeFilesMap !== _.module.nativeFilesMap )
    {
      return;
    }

    let module2 = _.module._predeclaredWithEntryPath( file.sourcePath );
    if( module2 && !modules.has( module2 ) )
    return;
    // if( module2 && modules.size > 1 ) /* xxx2*/
    // _.assert( 0, 'not tested' ); /* xxx qqq : cover and fix */

    if( _.set.identicalShallow( file.modules, modules ) )
    return;

    if( disassociating )
    _.module._fileUniversalDisassociateModules( file, true );

    modules.forEach( ( module ) => singleAssociate( file, module ) );
  }

  /* - */

  function moduleAssociate( file )
  {
    if( visited.has( file ) )
    return;
    visited.add( file );

    let module = modules;

    _.assert( _.module.fileUniversalIs( file ) );
    _.assert( _.setIs( file.upFiles ) );

    if( file.moduleNativeFilesMap !== _.module.nativeFilesMap )
    return;

    let module2 = _.module._predeclaredWithEntryPath( file.sourcePath );
    if( module2 && module2 !== module )
    return;

    if( file.modules.has( module ) )
    {
      if( file.modules.size === 1 || !disassociating )
      return;
    }

    if( disassociating )
    _.module._fileUniversalDisassociateModules( file, true );

    singleAssociate( file, module );
  }

  /* - */

  function singleAssociate( file, module )
  {

    file.upFiles.forEach( ( file2 ) =>
    {
      if( file2 === undefined )
      debugger; /* xxx : qqq : cover */
      if( file2 === undefined )
      return;
      stack.push( file2 );
    });

    _.module._fileUniversalAssociateModule( file, module );
  }

  /* - */

}

//

function _fileWithResolvedPath( caninicalSourcePath )
{
  _.assert( _.strIs( caninicalSourcePath ) );
  let result = _.module.filesMap.get( caninicalSourcePath );
  return result;
}

//

/*
this solution has limitations
is not going to work for special cases of multiple global namespace n > 2
better solution might not exist
*/

function _fileWithResolvedPathAnyNamespace( caninicalSourcePath )
{
  _.assert( _.strIs( caninicalSourcePath ) );
  let result = _.module.filesMap.get( caninicalSourcePath );
  if( !result ) /* yyy */
  for( let globalName in _globals_ )
  {
    if( !_globals_[ globalName ].wTools || !_globals_[ globalName ].wTools.module || !_globals_[ globalName ].wTools.module.filesMap )
    continue;
    result = _globals_[ globalName ].wTools.module.filesMap.get( caninicalSourcePath );
    if( result )
    return result;
  }
  return result;
}

//

function _filesWithResolvedPath( caninicalSourcePathCountable )
{
  let result = new Set();
  if( _.strIs( caninicalSourcePathCountable ) )
  caninicalSourcePathCountable = [ caninicalSourcePathCountable ];
  caninicalSourcePathCountable.forEach( ( sourcePath ) =>
  {
    let file = _.module.filesMap.get( sourcePath );
    if( file )
    result.add( file );
  });
  return result;
}

//

function fileWithResolvedPath( sourcePath )
{
  var result = _.module.filesMap.get( _.path.canonize( sourcePath ) );
  return result;
}

//

function fileWith( relativeSourcePath )
{
  let absoluteSourcePath = relativeSourcePath;

  if( _.numberIs( relativeSourcePath ) )
  {
    _.assert( relativeSourcePath >= 0 );
    absoluteSourcePath = _.introspector.location({ level : relativeSourcePath + 1 }).filePath;
    return _.module._fileWithResolvedPath( absoluteSourcePath );
  }

  if( _.path.isDotted( relativeSourcePath ) )
  {
    /* zzz : qqq : optimize _.introspector.location({ level : 1 }).filePath */
    /* zzz : qqq : optimize _.path.dir( _.introspector.location({ level : 1 }).filePath ) */
    let basePath = _.path.dir( _.introspector.location({ level : 1 }).filePath );
    absoluteSourcePath = _.path.canonize( basePath + '/' + absoluteSourcePath );
  }
  else
  {
    absoluteSourcePath = _.path.canonize( absoluteSourcePath );
  }

  let moduleFile = _.module._fileWithResolvedPath( absoluteSourcePath );
  return moduleFile;
}

//

function _fileNativeWithResolvedNativePath( caninicalSourcePath, nativeFilesMap )
{
  nativeFilesMap = nativeFilesMap || _.module.nativeFilesMap;
  let result = nativeFilesMap[ caninicalSourcePath ];
  return result;
}

//

function fileNativeWith( relativeSourcePath, nativeFilesMap )
{
  let absoluteSourcePath = relativeSourcePath;

  if( _.numberIs( relativeSourcePath ) )
  {
    _.assert( relativeSourcePath >= 0 );
    absoluteSourcePath = _.introspector.location({ level : relativeSourcePath + 1 }).filePath;
    return _.module._fileNativeWithResolvedNativePath( _.path.nativizeMinimal( absoluteSourcePath ), nativeFilesMap );
  }

  if( _.path.isDotted( relativeSourcePath ) )
  {
    let basePath = _.path.dir( _.introspector.location({ level : 1 }).filePath );
    absoluteSourcePath = _.path.nativizeMinimal( _.path.canonize( basePath + '/' + absoluteSourcePath ) );
  }
  else
  {
    absoluteSourcePath = _.path.nativizeMinimal( absoluteSourcePath );
  }

  let moduleFile = _.module._fileNativeWithResolvedNativePath( absoluteSourcePath, nativeFilesMap );
  return moduleFile;
}

// --
// export string
// --

function _exportString( module, it )
{

  if( !it.verbosity )
  return it;

  it.lineWrite( String( module ) );

  if( it.verbosity === 1 )
  return it;

  if( module.downs.size > 0 )
  it.titleWrite( 'downs' ).elementsWrite( module.downs );
  if( module.ups.size > 0 )
  it.titleWrite( 'ups' ).elementsWrite( module.ups );

  return it;
}

_exportString.defaults =
{
  it : null,
}

//

function exportString( module, o )
{

  o = _.routine.options( exportString, o || null );
  let it = o.it = _.stringer.it( o.it, { verbosity : 1, recursive : 1 } );
  it.opts = o;
  it.src = module;
  _export( module, it );
  return it;

  function _export( module, it )
  {
    _.module._exportString( module, it );

    // if( it.verbosity > 0 )
    // if( it.recursive - it.level > 1 )
    // if( module.upFiles.size > 0 )
    // {
    //   let it2 = it.iterationMake().tabLevelUp();
    //   if( it.verbosity > 1 )
    //   {
    //     it2.lineWrite( 'ups' ).tabLevelUp();
    //   }
    //   for( let file2 of module.upFiles )
    //   {
    //     _export( file2, it2.iterationMake().levelUp() );
    //   }
    // }

  }

}

exportString.defaults =
{
  format : 'diagnostic',
  verbosity : 1,
  it : null,
}

//

function _fileExportString( file, it )
{

  if( !it.verbosity )
  return it;

  it.lineWrite( String( file ) );

  if( it.verbosity === 1 )
  return it;

  if( file.native._virtualEnvironment )
  it.titleWrite( `virtualEnvironment : ${file.native._virtualEnvironment.global.__GLOBAL_NAME__}` );
  if( file.global )
  it.titleWrite( `global : ${file.global.__GLOBAL_NAME__}` );
  if( file.error )
  it.titleWrite( `error : ${!!file.error}` );
  if( file.modules.size > 0 )
  it.titleWrite( 'modules' ).elementsWrite( file.modules );
  if( file.downFiles.size > 0 )
  it.titleWrite( 'downFiles' ).elementsWrite( file.downFiles );
  if( file.upFiles.size > 0 )
  it.titleWrite( 'upFiles' ).elementsWrite( file.upFiles );

  return it;
}

_fileExportString.defaults =
{
  it : null,
}

//

function fileExportString( file, o )
{

  _.assert( _.module.fileUniversalIs( file ), () => `Expects module file, but got ${_.strType( file )}` );
  o = _.routine.options( fileExportString, o || null );
  let it = o.it = _.stringer.it( o.it, { verbosity : 1, recursive : 1 } );
  _export( file, it );
  return it;

  function _export( file, it )
  {
    _.module._fileExportString( file, it );

    if( it.verbosity > 0 )
    if( it.recursive - it.level > 1 )
    if( file.upFiles.size > 0 )
    {
      let it2 = it.iterationMake().tabLevelUp();
      if( it.verbosity > 1 )
      {
        it2.lineWrite( 'ups' ).tabLevelUp();
      }
      for( let file2 of file.upFiles )
      {
        _export( file2, it2.iterationMake().levelUp() );
      }
    }

  }

}

fileExportString.defaults =
{
  it : null,
}

//

function recursiveExportString( src, o )
{
  let Format = new Set([ 'diagnostic' ]);

  o = _.routine.options( recursiveExportString, o || null );
  _.assert( Format.has( o.format ) );

  let it = o.it = _.stringer.it( o.it );
  it.opts = o;
  _.assert( _.number.is( it.depth ) );

  if( _.module.fileIs( src ) )
  _.module.fileExport( src, { it } );
  else if( _.module.is( src ) )
  _.module.fileExport( src, { it } );

  it.lineWrite( operation.clname );

}

recursiveExportString.defaults =
{
  format : 'diagnostic',
  it : null,
}

// --
// file path
// --

/* xxx : cover _.module.fileNativeIs() */
/* xxx : cover and move on l3 */
/* qqq : for junior : cover */
function filePath_head( routine, args )
{

  let o = args[ 0 ];
  if( !_.mapIs( o ) )
  o = { paths : o }
  if( _.strIs( o.paths ) )
  o.paths = [ o.paths ];

  _.assert( args.length === 1 );
  _.assert( arguments.length === 2 );
  _.assert( _.arrayIs( o.paths ) );
  _.routine.options( filePathAmend, o );

  if( _.path.nativizeMinimal && _.path.canonize )
  {
    for( var p = 0 ; p < o.paths.length ; p++ )
    {
      o.paths[ p ] = _.path.nativizeMinimal( _.path.canonize( o.paths[ p ] ) );
    }
  }

  return o;
}

//

function filePathAmend_body( o )
{
  const ModuleFileNative = require( 'module' );

  if( o.moduleFile )
  if( typeof _ !== 'undefined' )
  o.moduleFile = fileNativeFrom( o.moduleFile );

  let filePathAmend = o.amending === 'prepend' ? arrayPrependedArrayOnce : arrayAppendedArrayOnce;

  if( o.globally )
  filePathAmend( ModuleFileNative.globalPaths, o.paths );

  if( o.locally && o.moduleFile )
  filePathAmend( o.moduleFile.paths, o.paths );

  if( o.locally && o.permanent )
  {
    if( o.amending === 'prepend' ) /* qqq : cover please */
    {
      _.module._prependPath = _.module._prependPath || [];
      filePathAmend( _.module._prependPath, o.paths );
    }
    else if( o.amending === 'append' ) /* qqq : cover please */
    {
      _.module._appendPath = _.module._appendPath || [];
      filePathAmend( _.module._appendPath, o.paths );
    }
  }

  if( o.locally && o.recursive && o.moduleFile )
  return _root( o.moduleFile, o.paths, new Set );

  /* - */

  function _root( _module, paths, visited )
  {

    if( visited.has( _module ) )
    return;

    if( o.recursive >= 2 )
    while( fileNativeParent( _module ) )
    _module = fileNativeParent( _module );

    _children1( _module, paths, visited );
  }

  /* - */

  function fileNativeParent( file )
  {
    if( file.parent && file.parent.id !== undefined )
    return file.parent;
  }

  /* - */

  function _children1( _module, paths, visited )
  {

    if( visited.has( _module ) )
    return;

    visited.add( _module );

    filePathAmend( _module.paths, paths );

    if( o.recursive >= 2 )
    if( _module.children )
    {
      for( var c = 0 ; c < _module.children.length ; c++ )
      _children2( _module.children[ c ], paths, visited );
    }

  }

  /* - */

  function _children2( _module, paths, visited )
  {

    if( visited.has( _module ) )
    return;

    visited.add( _module );

    filePathAmend( _module.paths, paths );

    if( _module.children )
    {
      for( var c = 0 ; c < _module.children.length ; c++ )
      _children2( _module.children[ c ], paths, visited );
    }

  }

  /* - */

  function fileNativeFrom( src )
  {
    if( _.module && _.module.fileNativeFrom )
    return _.module.fileNativeFrom( src );
    return src;
  }

  /* - */

  function arrayAppendedArrayOnce( dstArray, insArray )
  {
    let result = 0;

    for( let i = 0, len = insArray.length ; i < len ; i++ )
    {
      if( dstArray.indexOf( insArray[ i ] ) === -1 )
      {
        dstArray.push( insArray[ i ] );
        result += 1;
      }
    }

    return result;
  }

  /* - */

  function arrayPrependedArrayOnce( dstArray, insArray )
  {
    let result = 0;

    for( let i = insArray.length - 1 ; i >= 0 ; i-- )
    {
      let index = i;
      if( dstArray === insArray )
      index = i + result;
      if( dstArray.indexOf( insArray[ index ] ) === -1 )
      {
        dstArray.unshift( insArray[ index ] );
        result += 1;
      }
    }

    return result;
  }

  /* - */

}

filePathAmend_body.defaults =
{
  moduleFile : null,
  paths : null,
  permanent : 0,
  globally : 1,
  locally : 0,
  recursive : 2,
  amending : 'append',
}

let filePathAmend = _.routine.unite( filePath_head, filePathAmend_body );

//

function pathRemove_body( o )
{
  const ModuleFileNative = require( 'module' );

  if( o.moduleFile )
  o.moduleFile = _.module.fileNativeFrom( o.moduleFile );

  if( o.globally )
  remove( ModuleFileNative.globalPaths, o.paths );

  if( o.locally && o.moduleFile )
  remove( o.moduleFile.paths, o.paths );

  if( o.locally && o.permanent )
  {
    if( _.module._prependPath )
    remove( _.module._prependPath, o.paths );
    if( _.module._appendPath )
    remove( _.module._appendPath, o.paths );
  }

  if( o.locally && o.recursive && o.moduleFile )
  return _root( o.moduleFile, o.paths, new Set );

  /* - */

  function _root( _module, paths, visited )
  {

    if( visited.has( _module ) )
    return;

    if( o.recursive >= 2 )
    while( _.module.fileNativeParent( _module ) )
    _module = _.module.fileNativeParent( _module );

    _children1( _module, paths, visited );
  }

  /* - */

  function _children1( _module, paths, visited )
  {

    if( visited.has( _module ) )
    return;

    visited.add( _module );

    remove( _module.paths, paths );

    if( o.recursive >= 2 )
    if( _module.children )
    {
      for( var c = 0 ; c < _module.children.length ; c++ )
      _children2( _module.children[ c ], paths, visited );
    }

  }

  /* - */

  function _children2( _module, paths, visited )
  {

    if( visited.has( _module ) )
    return;

    visited.add( _module );

    remove( _module.paths, paths );

    if( _module.children )
    {
      for( var c = 0 ; c < _module.children.length ; c++ )
      _children2( _module.children[ c ], paths, visited );
    }

  }

  /* - */

  function remove( dst, src )
  {
    for( let p = 0 ; p < src.length ; p++ )
    {
      if( dst.indexOf( src[ p ] ) !== -1 )
      dst.splice( p, 1 );
    }
  }

  /* - */

}

pathRemove_body.defaults =
{
  moduleFile : null,
  paths : null,
  permanent : 0,
  globally : 1,
  locally : 0,
  recursive : 2,
  amending : 'append',
}

let filePathRemove = _.routine.unite( filePath_head, pathRemove_body );

//

function filePathGet( o )
{
  const ModuleFileNative = require( 'module' );

  if( !_.mapIs( o ) )
  o = { moduleFile : o }

  _.assert( arguments.length === 0 || arguments.length === 1 );
  o = _.routine.options( filePathGet, o );

  if( o.all === null )
  o.all = o.locally && o.globally;

  let result = Object.create( null );
  if( o.locally )
  result.local = [];
  if( o.globally )
  result.global = [];
  if( o.all )
  result.all = [];

  if( o.moduleFile )
  o.moduleFile = _.module.fileNativeFrom( o.moduleFile );
  o.moduleFile = o.moduleFile || module;

  if( o.globally )
  {
    _.assert( _.arrayIs( ModuleFileNative.globalPaths ) );
    result.global.push( ... ModuleFileNative.globalPaths );
    if( result.all )
    result.all.push( ... ModuleFileNative.globalPaths );
  }

  if( o.locally )
  {
    _.assert( _.arrayIs( o.moduleFile.paths ) );
    result.local.push( ... o.moduleFile.paths );
    if( result.all )
    result.all.push( ... o.moduleFile.paths );
  }

  return result;
}

filePathGet.defaults =
{
  moduleFile : null,
  globally : 1,
  locally : 1,
  all : null,
}

// --
//
// --

function _resolve( o )
{

  // _.map.assertHasAll( o, _resolve.defaults );

  if( _.argumentsArray.like( o.moduleName ) )
  {
    let result = [];
    for( let a = 0 ; a < o.moduleName.length ; a++ )
    {
      let r = _.module._resolve
      ({
        basePath : o.basePath,
        downPath : o.downPath,
        moduleName : o.moduleName[ a ],
        throwing : o.throwing,
        withAlternatives : o.withAlternatives,
      });
      if( r !== undefined )
      result[ a ] = r;
    }
    return result;
  }

  if( o.moduleName === _.optional )
  return;

  let r = _.module._resolveFirst
  ({
    moduleNames : [ o.moduleName ],
    downPath : o.downPath,
    basePath : o.basePath,
    throwing : o.throwing,
    withAlternatives : o.withAlternatives,
  });

  return r;
}

_resolve.defaults =
{
  basePath : null,
  downPath : null,
  moduleName : null,
  throwing : 0,
  withAlternatives : 1,
}

//

function resolve( moduleName )
{
  let downPath = _.path.normalize( _.introspector.location({ level : 1 }).filePath );
  let basePath = _.path.dir( downPath );
  /* qqq zzz : optimize for release build for utility::starter */
  let result = _.module._resolve
  ({
    basePath,
    downPath,
    moduleName : arguments,
    throwing : 0,
    withAlternatives : 1,
  });
  _.assert( _.arrayIs( result ) );
  if( result.length <= 1 )
  return result[ 0 ];
  return result;
}

//

function _resolveFirst( o )
{

  if( !_.mapIs( o ) )
  o = { moduleNames : arguments }

  _.assert( _.strDefined( o.downPath ) );
  _.assert( _.strDefined( o.basePath ) );

  let sourcePaths = this._moduleNamesToPaths( o.moduleNames );
  let resolved = this._fileResolve
  ({
    sourcePaths,
    basePath : o.basePath,
    downPath : o.downPath,
    withAlternatives : o.withAlternatives,
    all : 0,
  });

  if( o.throwing )
  if( resolved === undefined && !o.moduleNames.includes( _.optional ) )
  {
    /* xxx : take care of section module files stack */
    throw _.err
    (
      `Cant resolve module::${Array.prototype.slice.call( o.moduleNames ).join( ' module::' )}.`
      + `\nLooked at:\n - ${sourcePaths.join( '\n - ' )}`
    );
  }

  return resolved;
}

_resolveFirst.defaults =
{
  moduleNames : null,
  downPath : null,
  basePath : null,
  throwing : 0,
  withAlternatives : 1,
}

//

function resolveFirst()
{
  let downPath = _.path.normalize( _.introspector.location({ level : 1 }).filePath );
  let basePath = _.path.dir( downPath );
  return _.module._resolveFirst
  ({
    moduleNames : arguments,
    basePath,
    downPath,
    throwing : 0,
  });
}

//

function _fileResolve( o )
{
  let result = [];

  if( !_.mapIs( arguments[ 0 ] ) )
  o = { sourcePaths : arguments[ 0 ] }

  let native = _.module.nativeFilesMap[ _.path.nativizeMinimal( o.downPath ) ];
  native = native || module; /* xxx : comment out and look among namesapces? */

  _.assert( arguments.length === 1 );
  _.assert( _.longIs( o.sourcePaths ) );
  _.strDefined( o.downPath );
  _.strDefined( o.basePath );
  _.assert( !!native );

  for( let a = 0 ; a < o.sourcePaths.length ; a++ )
  {
    let sourcePath = o.sourcePaths[ a ];
    let resolved;

    // if( _.strHas( sourcePath, '/Main.s' ) )
    // debugger;

    resolved = nativeResolve( sourcePath );
    if( resolved === undefined && o.withAlternatives )
    {
      let sourcePath2 = sourcePath.toLowerCase();
      if( sourcePath !== sourcePath2 )
      resolved = nativeResolve( sourcePath2 );
    }

    result.push( resolved );
    if( !o.all )
    return result[ 0 ];
  }

  // /* zzz : remove later */
  // if( o.basePath )
  // {
  //   o.basePath = _.path.canonize( o.basePath );
  //   let index = o.basePath.indexOf( '/wtools/' );
  //   if( index >= 0 )
  //   o.basePath = o.basePath.substring( 0, index+8 );
  // }

  // if( o.basePath )
  // for( let a = 0 ; a < o.sourcePaths.length ; a++ )
  // {
  //   let sourcePath = o.sourcePaths[ a ];
  //   let resolved;
  //
  //   if( _.path.isAbsolute( sourcePath ) )
  //   continue;
  //
  //   try
  //   {
  //     let filePath = _.path.nativizeMinimal( _.path.canonize( o.basePath + '/' + sourcePath ) );
  //     resolved = ModuleFileNative._resolveFilename( filePath, native, false, undefined );
  //   }
  //   catch( err )
  //   {
  //     continue;
  //   }
  //
  //   result.push( resolved );
  //   if( !o.all )
  //   return result[ 0 ];
  // }

  if( o.all )
  return result;
  else
  return undefined;

  function nativeResolve( sourcePath )
  {
    /* xxx : not optimal */
    try
    {
      let r;
      if( _.path.isAbsolute( sourcePath ) )
      r = ModuleFileNative._resolveFilename( _.path.nativizeMinimal( sourcePath ), native, false, undefined );
      else
      r = ModuleFileNative._resolveFilename( sourcePath, native, false, undefined );
      if( r )
      r = _.path.normalize( r );
      return r;
    }
    catch( err )
    {
      return;
    }
  }
}

_fileResolve.defaults =
{
  sourcePaths : null,
  downPath : null,
  basePath : null,
  withAlternatives : 1,
  all : 0,
}

//

function _moduleNamesToPaths( names )
{
  let result = [];

  _.assert( arguments.length === 1 );
  _.assert( _.longIs( names ) );

  for( let a = 0 ; a < names.length ; a++ )
  {
    let src = names[ a ];
    if( src === _.optional )
    continue;
    _.assert( _.strDefined( src ) );
    var descriptor = _.module.predeclaredWithNameMap.get( src );
    if( descriptor )
    {
      _.assert( _.longIs( descriptor.lookPath ) );
      _.arrayAppendArray( result, descriptor.lookPath );
    }
    else
    {
      result.push( src );
    }
  }

  return result;
}

// --
// include
// --

function _fileIncludeSingle( downPath, filePath )
{
  _.assert( arguments.length === 2 );
  _.assert( _.strIs( filePath ), 'Expects string' );

  if( !hasModuleFileDescriptor )
  throw _.err( 'Cant include, routine "require" does not exist.' );

  // if( downPath.endsWith( 'secondary1' ) && filePath.endsWith( 'secondary3' ) )
  // debugger;

  let normalizedPath = _.path.nativizeMinimal( filePath );
  let moduleFile = _.module._fileWithResolvedPathAnyNamespace( downPath );
  if( moduleFile )
  return moduleFile.native.require( normalizedPath );
  return _.module.__fileNativeInclude( normalizedPath );

}

//

/* xxx : implement _.path._dir */
/* xxx : qqq3 : optimize _.path.dir */

function include()
{
  _.assert( arguments.length === 1 );
  _.assert( _.strIs( arguments[ 0 ] ) );

  let downPath = _.path.normalize( _.introspector.location({ level : 1 }).filePath );
  let basePath = _.path.dir( downPath );
  let resolved = _.module._resolve
  ({
    basePath,
    downPath,
    moduleName : arguments,
    throwing : 1,
    withAlternatives : 1,
  });

  if( resolved.length === 1 )
  {
    return _.module._fileIncludeSingle( downPath, resolved[ 0 ] );
  }
  else
  {
    let result = [];
    for( let i = 0 ; i < resolved.length ; i++ )
    result[ i ] = _.module._fileIncludeSingle( downPath, resolved[ i ] );
    return result;
  }

}

//

function includeFirst()
{
  let downPath = _.path.normalize( _.introspector.location({ level : 1 }).filePath );
  let basePath = _.path.dir( downPath );
  let resolved = _.module._resolveFirst
  ({
    basePath,
    downPath,
    moduleNames : arguments,
    throwing : 1,
    withAlternatives : 1,
  });
  if( resolved )
  {
    return _.module._fileIncludeSingle( downPath, resolved );
  }
}

//

function isIncluded( src )
{
  if( _.module.modulesMap.has( src ) )
  return true;
  return false;
}

// --
// setup
// --

function _trackingEnable()
{

  const ModuleFileNative = require( 'module' );
  const NjsResolveFilename = ModuleFileNative._resolveFilename;
  const NjsLoad1 = ModuleFileNative._load;
  const NjsLoad2 = ModuleFileNative.prototype.load;

  const resolving = Object.create( null );
  resolving.request = null;
  resolving.parent = null;
  resolving.resolvedPath = null;

  const loading = Object.create( null );
  loading.request = null;
  loading.parent = null;
  loading.childrenLength = null;
  loading.counter = 0;

  _.assert( _.routineIs( NjsResolveFilename ) );
  _.assert( _.routineIs( NjsLoad1 ) );
  _.assert( _.routineIs( NjsLoad2 ) );

  ModuleFileNative._resolveFilename = _resolveFilename;

  const dlopen = process.dlopen;
  if( !_realGlobal_._modulingGlobal_ )
  {
    ModuleFileNative._load = _loadEnvironment;
    _realGlobal_._modulingGlobal_ = _global;
    process.dlopen = dlopen2;
  }

  ModuleFileNative.prototype.load = moduleFileLoad;

  // return process.dlopen(module, path.toNamespacedPath(filename));

  /* */

  function dlopen2()
  {
    let r;
    try
    {
      r = dlopen.apply( this, arguments );
    }
    catch( err )
    {
      debugger;
      // if( err.message === 'Module did not self-register.' )
      // {
      //   debugger;
      //   return undefined;
      // }
      throw err;
    }
    return r;
  }

  /* */

  function _resolveFilename( /* request, parent, isMain, options */ )
  {
    let request = arguments[ 0 ];
    let parent = arguments[ 1 ];
    let isMain = arguments[ 2 ];
    let options = arguments[ 3 ];

    if( resolving.parent === parent && resolving.request === request )
    return resolving.resolvedPath;
    resolving.resolvedPath = NjsResolveFilename.apply( this, arguments );
    resolving.request = request;
    resolving.parent = parent;
    return resolving.resolvedPath;
  }

  /* - */

  function _loadModuling( request, parent, isMain )
  {
    let result, err;
    const counter = loading.counter;

    loading.request = request;
    loading.parent = parent;
    loading.childrenLength = parent ? parent.children.length : 0;

    try
    {
      result = NjsLoad1.apply( this, arguments );
    }
    catch( _err )
    {
      err = _err;
    }

    if( !err )
    {
      try
      {
        if( loading.counter === counter )
        second( request, parent );
      }
      catch( err2 )
      {
        console.error( err2 );
      }
    }

    loading.request = null;
    loading.parent = null;

    if( err )
    throw err;
    return result;
  }

  /* - */

  function second( request, parent )
  {

    // if( request.endsWith( 'testing/entry/Main.s' ) )
    // debugger;
    // if( request.endsWith( 'secondary3' ) )
    // debugger;

    if( !parent.universal )
    return;
    // yyy
    // if( parent.universal.moduleNativeFilesMap !== _.module.nativeFilesMap )
    // {
    //   // debugger;
    //   return;
    // }
    // if( parent.universal.moduleNativeFilesMap !== ModuleFileNative._cache )
    // {
    //   debugger;
    //   return;
    // }
    // if( !_.path.isDotted( request ) )
    // {
    //   _.debugger;
    //   // debugger; /* xxx : check */
    //   return;
    // }

    let native;
    if( loading.request === request && loading.parent === parent )
    {
      _.assert( loading.childrenLength === parent.children.length || loading.childrenLength + 1 === parent.children.length );
      if( loading.childrenLength === parent.children.length )
      return;
      else
      native = parent.children[ parent.children.length - 1 ];
    }
    else
    {
      let resolvedPath = _resolveFilename( request, parent, false );
      native = ModuleFileNative._cache[ resolvedPath ];
      _.assert( !!_.module.fileNativeParent( native ) );
      _.assert( 0, 'not tested' ); /* xxx : qqq : cover? */
    }

    if( native.universal ) /* xxx2 : yyy : investigate test routine requireElectronProblem */
    if( _.module.fileNativeParent( native ) !== parent )
    {
      // if( native.universal.sourcePath.endsWith( 'wFiles' ) )
      // debugger;
      // _.debugger;
      _.module._fileUniversalAssociateFile( native.universal, parent.universal );
      if( !_.module._predeclaredWithEntryPath( native.universal.sourcePath ) ) /* yyy */
      _.module._filesUniversalAssociateModule( native.universal, parent.universal.modules, false );
    }
  }

  /* - */

  function _loadEnvironment( request, parent, isMain )
  {
    let result;
    const originalModuleNativeFiles = ModuleFileNative._cache;
    const originalGlobal = _realGlobal_._global_;

    // if( request.endsWith( 'wTesting' ) )
    // debugger;
    // if( request.endsWith( 'testing/entry/Main.s' ) )
    // debugger;

    if( parent )
    if( parent._virtualEnvironment )
    {
      if( parent._virtualEnvironment.moduleNativeFilesMap )
      ModuleFileNative._cache = parent._virtualEnvironment.moduleNativeFilesMap;
      if( parent._virtualEnvironment.global )
      _realGlobal_._global_ = parent._virtualEnvironment.global;
    }
    else if( parent.universal )
    {
      if( parent.universal.moduleNativeFilesMap )
      ModuleFileNative._cache = parent.universal.moduleNativeFilesMap;
      if( parent.universal.global )
      _realGlobal_._global_ = parent.universal.global;
    }

    try
    {
      result = _loadModuling.apply( this, arguments );
    }
    catch( err )
    {
      let error;
      if( parent && parent.filename )
      error = _.err( err, `\nModule file "${parent.filename}" failed to include "${request}"` );
      else
      error = _.err( err, `\nFailed to include "${request}"` );
      throw error;
    }
    finally
    {
      ModuleFileNative._cache = originalModuleNativeFiles;
      _realGlobal_._global_ = originalGlobal;
    }

    return result;
  }

  /* - */

  function fileShare( moduleFile )
  {
    const nativeSourcePath = moduleFile.fileName || moduleFile.id;

    if( !_.module.filePathIsBin( nativeSourcePath ) )
    return;
    for( let name in _globals_ )
    {
      let global = _globals_[ name ];
      if( global.wTools && global.wTools.module && global.wTools.module.nativeFilesMap )
      if( !global.wTools.module.nativeFilesMap[ nativeSourcePath ] )
      {
        debugger;
        global.wTools.module.nativeFilesMap[ nativeSourcePath ] = moduleFile;
      }
    }
  }

  /* - */

  function moduleFileLoad( nativeSourcePath )
  {
    let result;
    let native = this;

    loading.counter += 1;

    // yyy
    if( _modulingGlobal_ === _global )
    fileShare( native );

    /*
    ignore includes of other global namespaces
    */
    if( _.module.nativeFilesMap !== ModuleFileNative._cache )
    {
      return NjsLoad2.apply( this, arguments );
    }

    let moduleFile = _.module._fileUniversalInit
    ({
      sourcePath : nativeSourcePath,
      nativeSourcePath,
      requestedSourcePath : resolving.request,
      native,
      status : 1,
    });

    _.assert( native === ModuleFileNative._cache[ moduleFile.nativeSourcePath ] );
    _.assert( native === moduleFile.native );
    _.assert( resolving.resolvedPath === nativeSourcePath );

    try
    {
      result = NjsLoad2.apply( this, arguments );
    }
    catch( err )
    {
      err = _.err( err );
      try
      {
        moduleFile.error = moduleFile.error || err;
        _.module._fileUniversalFinit( moduleFile );
      }
      catch( err2 )
      {
        console.error( _.err( err2 ) );
      }
      throw err;
    }

    if( moduleFile.status !== -1 )
    {
      moduleFile.status = 2;
    }

    return result;
  }

  /* - */

}

//

function _Setup()
{

  if( _.module._modulesToPredeclare )
  _.module.predeclareAll({ modules : _.module._modulesToPredeclare, basePath : __dirname });

  if( typeof require === 'undefined' )
  return;

  if( !ModuleFileNative )
  ModuleFileNative = require( 'module' );

  if( !_.module.rootFileNative )
  {
    let rootFileNative = _.module.rootFileNative = module;
    while( _.module.fileNativeParent( rootFileNative ) )
    rootFileNative = _.module.fileNativeParent( rootFileNative );
    _.module.rootFileNative = rootFileNative;
  }

  if( !_.module.nativeFilesMap )
  _.module.nativeFilesMap = ModuleFileNative._cache;

  if( _.module._setupRequireDone )
  return;
  _.module._setupRequireDone = 1;

  // /* qqq xxx : remove that if-return branch */
  // if( _global_.Config.interpreter === 'browser' )
  // return;

  _.module._trackingEnable();
  _.module._filesUniversalInit({ files : [ _.module.rootFileNative ] });

  if( _.module.rootFileNative.universal )
  _.module.rootFile = _.module.rootFileNative.universal;

}

// --
// Module
// --

const ModuleSymbol = Symbol.for( 'Module' );

function Module()
{
  _.assert( 0, 'not implemented' );
  if( arguments.length !== 0 )
  throw new Error( 'Expects no arguments' );
  _.assert( this instanceof Module );
  return this;
}

_.class.declareBasic
({
  constructor : Module,
  exportString : moduleExportString,
});

Object.defineProperty( Module.prototype, ModuleSymbol,
{
  enumerable : false,
  configurable : false,
  writable : false,
  value : true,
});

// --
// Module File
// --

const ModuleFileSymbol = Symbol.for( 'ModuleFile' );

function ModuleFile()
{
  _.assert( 0, 'not implemented' );
  if( arguments.length !== 0 )
  throw new Error( 'Expects no arguments' );
  _.assert( this instanceof ModuleFile );
  return this;
}

_.class.declareBasic
({
  constructor : ModuleFile,
  exportString : moduleFileExportString,
});

Object.defineProperty( ModuleFile.prototype, ModuleFileSymbol,
{
  enumerable : false,
  configurable : false,
  writable : false,
  value : true,
});

/* xxx : qqq : for junior : cover */
Object.defineProperty( ModuleFile.prototype, 'returned',
{
  enumerable : true,
  configurable : true,
  get : moduleFileReturnedGet,
  // set : _returnedSet, /* qqq : uncomment later and write test */
});

// --
// module extension
// --

var ModuleExtension =
{

  // module

  is,
  with : _with,
  withName,
  withPath,

  predeclare,
  predeclareAll,
  _predeclaredWithEntryPath,

  // file

  fileIs,
  fileUniversalIs : __.module.fileUniversalIs,
  fileUniversalFrom,
  _fileUniversalFinit,
  _fileUniversalInit,
  _filesUniversalInit,
  _fileUniversalAssociateFile,
  _fileUniversalDisassociateFile,
  _fileUniversalAssociateModule,
  _fileUniversalDisassociateModules,
  _filesUniversalAssociateModule,

  _filesWithResolvedPath,
  _fileWithResolvedPath,
  _fileWithResolvedPathAnyNamespace,
  fileWithResolvedPath,
  fileWith,

  fileNativeIs : __.module.fileNativeIs,
  fileNativeFrom : __.module.fileNativeFrom,
  fileNativeParent : __.module.fileNativeParent,
  _fileNativeWithResolvedNativePath,
  fileNativeWith,

  // export string

  _exportString,
  exportString,
  _fileExportString,
  fileExportString,
  recursiveExportString,

  // file path

  filePathAmend,
  filePathRemove,
  filePathGet,
  filePathIsBin : __.module.filePathIsBin,

  // resolve

  _resolve,
  resolve,
  _resolveFirst,
  resolveFirst,
  _fileResolve,

  _moduleNamesToPaths,

  // include

  _fileIncludeSingle,

  include,
  includeFirst,

  isIncluded,

  // setup

  _trackingEnable,
  /* qqq : implement and cover routine _trackingDisable */
  _Setup,

  // fields

  Module,
  File : ModuleFile,
  __fileNativeInclude,
  _prependPath : null,
  _appendPath : null,
  rootFile : null,
  rootFileNative : null,
  predeclaredWithNameMap : new HashMap,
  predeclaredWithEntryPathMap : new HashMap,
  modulesMap : new HashMap,
  nativeFilesMap : null,
  filesMap : new HashMap,
  _setupRequireDone : null,

}

/* xxx : move to l3/l5 */
/* xxx : test of include file which deos not exist and reinclude file wich was trying include file which does not exist */

Object.assign( _.module, ModuleExtension );

// --
// tools extension
// --

var ToolsExtension =
{
  include,
  includeFirst,
}

Object.assign( _, ToolsExtension );

_.module._Setup();

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5/zModule.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l5' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, zModule_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file zModule_s */ })();

/* */  /* begin of file Compose_s */ ( function Compose_s() { function Compose_s_naked() { ( function _Compose_s_()
{

'use strict'; /* xxx : deprecate? */

const _global = _global_;
const _ = _global_.wTools;
// _.compose = _.compose || Object.create( null );
_.routine.chainer = _.routine.chainer || Object.create( null );
_.routine.tail = _.routine.tail || Object.create( null );

// --
// chainer
// --

function originalChainer( /* args, result, fo, k */ )
{
  let args = arguments[ 0 ];
  let result = arguments[ 1 ];
  let fo = arguments[ 2 ];
  let k = arguments[ 3 ];
  _.assert( result !== false );
  return args;
}

//

function originalWithDontChainer( /* args, result, fo, k */ )
{
  let args = arguments[ 0 ];
  let result = arguments[ 1 ];
  let fo = arguments[ 2 ];
  let k = arguments[ 3 ];

  _.assert( result !== false );
  if( result === _.dont )
  return _.dont;
  return args;
}

//

function composeAllChainer( /* args, result, fo, k */ )
{
  let args = arguments[ 0 ];
  let result = arguments[ 1 ];
  let fo = arguments[ 2 ];
  let k = arguments[ 3 ];

  _.assert( result !== false );
  if( result === _.dont )
  return _.dont;
  return args;
}

//

function chainingChainer( /* args, result, fo, k */ )
{
  let args = arguments[ 0 ];
  let result = arguments[ 1 ];
  let fo = arguments[ 2 ];
  let k = arguments[ 3 ];

  _.assert( result !== false );
  if( result === undefined )
  return args;
  if( result === _.dont )
  return _.dont;
  return _.unroll.from( result );
}

// --
// tail
// --

function returningLastTail( args, fo )
{
  // let self = arguments[ 0 ];
  // let args = arguments[ 1 ];
  // let act = arguments[ 2 ];
  // let fo = arguments[ 3 ];
  let self = this;
  let act = fo.act;

  let result = act.apply( self, args );
  return result[ result.length-1 ];
}

//

function composeAllTail( args, fo )
{
  // let self = arguments[ 0 ];
  // let args = arguments[ 1 ];
  // let act = arguments[ 2 ];
  // let fo = arguments[ 3 ];
  let self = this;
  let act = fo.act;

  let result = act.apply( self, args );
  _.assert( !!result );
  if( !result.length )
  return result;
  if( result[ result.length-1 ] === _.dont )
  return false;
  if( !_.all( result ) )
  return false;
  return result;
}

//

function chainingTail( args, fo )
{
  // let self = arguments[ 0 ];
  // let args = arguments[ 1 ];
  // let act = arguments[ 2 ];
  // let fo = arguments[ 3 ];
  let self = this;
  let act = fo.act;

  let result = act.apply( self, args );
  if( result[ result.length-1 ] === _.dont )
  result.pop();
  return result;
}

// --
// declare
// --

let chainer =
{
  original : originalChainer,
  originalWithDont : originalWithDontChainer,
  composeAll : composeAllChainer,
  chaining : chainingChainer,
}

Object.assign( _.routine.chainer, chainer );

let tail =
{
  returningLast : returningLastTail,
  composeAll : composeAllTail,
  chaining : chainingTail,
}

Object.assign( _.routine.tail, tail );

// --
// extend
// --

// let Extension =
// {
//
//   chainer,
//   supervisor
//
// }
//
// Object.assign( Self, Extension );
// /* xxx : qqq : remove */

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l6/Compose.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l6' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Compose_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Compose_s */ })();

/* */  /* begin of file PropertyTransformers_s */ ( function PropertyTransformers_s() { function PropertyTransformers_s_naked() { ( function _PropertyTransformer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

function bypass()
{
  let routine = bypass;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function bypass( dstContainer, srcContainer, key )
  {
    /*dstContainer[ key ] = srcContainer[ key ];*/
    return true;
  }
}

bypass.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function assigning()
{
  let routine = assigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;
  function assigning( dstContainer, srcContainer, key )
  {
    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }
}

assigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function primitive()
{
  let routine = primitive;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function primitive( dstContainer, srcContainer, key )
  {
    if( !_.primitive.is( srcContainer[ key ] ) )
    return false;

    return true;
  }
}

primitive.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function hiding()
{
  let routine = hiding;

  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function hiding( dstContainer, srcContainer, key )
  {
    let properties =
    {
      value : srcContainer[ key ],
      enumerable : false,
      configurable : true,
    };
    Object.defineProperty( dstContainer, key, properties );
  }

}

hiding.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function appendingAnything()
{
  let routine = appendingAnything;

  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function appendingAnything( dstContainer, srcContainer, key )
  {
    if( dstContainer[ key ] === undefined )
    dstContainer[ key ] = srcContainer[ key ];
    else if( _.arrayIs( dstContainer[ key ] ) )
    dstContainer[ key ] = _.arrayAppendArrays( dstContainer[ key ], [ srcContainer[ key ] ] );
    else
    dstContainer[ key ] = _.arrayAppendArrays( [], [ dstContainer[ key ], srcContainer[ key ] ] );
  }

}

appendingAnything.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function prependingAnything()
{
  let routine = prependingAnything;

  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function prependingAnything( dstContainer, srcContainer, key )
  {
    if( dstContainer[ key ] === undefined )
    dstContainer[ key ] = srcContainer[ key ];
    else if( _.arrayIs( dstContainer[ key ] ) )
    dstContainer[ key ] = _.arrayPrependArrays( dstContainer[ key ], [ srcContainer[ key ] ] );
    else
    dstContainer[ key ] = _.arrayPrependArrays( [], [ dstContainer[ key ], srcContainer[ key ] ] );
  }

}

prependingAnything.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function appendingOnlyArrays()
{
  let routine = appendingOnlyArrays;

  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function appendingOnlyArrays( dstContainer, srcContainer, key )
  {
    if( _.arrayIs( dstContainer[ key ] ) && _.arrayIs( srcContainer[ key ] ) )
    _.arrayAppendArray( dstContainer[ key ], srcContainer[ key ] );
    else
    dstContainer[ key ] = srcContainer[ key ];
  }

}

appendingOnlyArrays.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function appendingOnce()
{
  let routine = appendingOnce;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function appendingOnce( dstContainer, srcContainer, key )
  {
    if( _.arrayIs( dstContainer[ key ] ) && _.arrayIs( srcContainer[ key ] ) )
    _.arrayAppendArrayOnce( dstContainer[ key ], srcContainer[ key ] );
    else
    dstContainer[ key ] = srcContainer[ key ];
  }

}

appendingOnce.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function removing()
{
  let routine = removing;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function removing( dstContainer, srcContainer, key )
  {
    let dstElement = dstContainer[ key ];
    let srcElement = srcContainer[ key ];
    if( _.arrayIs( dstElement ) && _.arrayIs( srcElement ) )
    {
      if( dstElement === srcElement )
      dstContainer[ key ] = [];
      else
      _.arrayRemoveArrayOnce( dstElement, srcElement );
    }
    else if( dstElement === srcElement )
    {
      delete dstContainer[ key ];
    }
  }

}

removing.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function notPrimitiveAssigning()
{
  let routine = notPrimitiveAssigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function notPrimitiveAssigning( dstContainer, srcContainer, key )
  {
    if( _.primitive.is( srcContainer[ key ] ) )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }

}

notPrimitiveAssigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function assigningRecursive()
{
  let routine = assigningRecursive;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function assigningRecursive( dstContainer, srcContainer, key )
  {
    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key, _.entity.assign2FieldFromContainer );
  }

}

assigningRecursive.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function drop( dropContainer )
{

  debugger;

  _.assert( _.object.isBasic( dropContainer ) );

  let routine = drop;

  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function drop( dstContainer, srcContainer, key )
  {
    if( dropContainer[ key ] !== undefined )
    return false

    /*dstContainer[ key ] = srcContainer[ key ];*/
    return true;
  }

}

drop.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function notIdentical()
{
  let routine = notIdentical;
  routine.identity = { propertyCondition : true, propertyTransformer : true }; ;
  return routine;
  function notIdentical( dstContainer, srcContainer, key )
  {
    if( dstContainer[ key ] === srcContainer[ key ] )
    return false;
    return true;
  }
}

notIdentical.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

// --
// src
// --

function srcDefined()
{
  let routine = srcDefined;
  routine.identity = { propertyCondition : true, propertyTransformer : true }; ;
  return routine;

  function srcDefined( dstContainer, srcContainer, key )
  {
    if( srcContainer[ key ] === undefined )
    return false;
    return true;
  }
}

srcDefined.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotHasOrSrcNotNull()
{
  let routine = dstNotHasOrSrcNotNull;
  routine.identity = { propertyCondition : true, propertyTransformer : true }; ;
  return routine;
  function dstNotHasOrSrcNotNull( dstContainer, srcContainer, key )
  {
    if( key in dstContainer && dstContainer[ key ] !== undefined )
    return false;
    if( srcContainer[ key ] === null )
    return false;
    return true;
  }
}

dstNotHasOrSrcNotNull.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

// --
// dst
// --

function dstNotConstant()
{
  let routine = dstNotConstant;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotConstant( dstContainer, srcContainer, key )
  {
    let d = Object.getOwnPropertyDescriptor( dstContainer, key );
    if( !d )
    return true;
    if( !d.writable )
    return false;
    return true;
  }

}

dstNotConstant.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstAndSrcOwn()
{
  let routine = dstAndSrcOwn;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstAndSrcOwn( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return false;
    if( !Object.hasOwnProperty.call( dstContainer, key ) )
    return false;

    return true;
  }

}

dstAndSrcOwn.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstUndefinedSrcNotUndefined()
{
  let routine = dstUndefinedSrcNotUndefined;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstUndefinedSrcNotUndefined( dstContainer, srcContainer, key )
  {
    if( dstContainer[ key ] !== undefined )
    return false;
    if( srcContainer[ key ] === undefined )
    return false;
    return true;
  }

}

dstUndefinedSrcNotUndefined.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

// --
// dstNotHas
// --

function dstNotHas()
{
  let routine = dstNotHas;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotHas( dstContainer, srcContainer, key )
  {

    if( key in dstContainer )
    return false;

    return true;
  }

}

dstNotHas.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotHasOrHasNull()
{
  let routine = dstNotHasOrHasNull;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotHasOrHasNull( dstContainer, srcContainer, key )
  {
    if( key in dstContainer && dstContainer[ key ] !== null )
    return false;
    return true;
  }

}

dstNotHasOrHasNull.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotHasOrHasNil()
{
  let routine = dstNotHasOrHasNil;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotHasOrHasNil( dstContainer, srcContainer, key )
  {

    if( key in dstContainer && dstContainer[ key ] !== _.nothing )
    return false;

    return true;
  }

}

dstNotHasOrHasNil.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotHasAssigning()
{
  let routine = dstNotHasAssigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function dstNotHasAssigning( dstContainer, srcContainer, key )
  {
    if( dstContainer[ key ] !== undefined )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }

}

dstNotHasAssigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function dstNotHasAppending()
{
  let routine = dstNotHasAppending;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function dstNotHasAppending( dstContainer, srcContainer, key )
  {
    if( key in dstContainer )
    {
      debugger;
      if( _.arrayIs( dstContainer[ key ] ) && _.arrayIs( srcContainer[ key ] ) )
      _.arrayAppendArray( dstContainer, srcContainer, key );
      return;
    }
    dstContainer[ key ] = srcContainer[ key ];
  }

}

dstNotHasAppending.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function dstNotHasSrcPrimitive()
{
  let routine = dstNotHasSrcPrimitive;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotHasSrcPrimitive( dstContainer, srcContainer, key )
  {
    debugger;
    if( key in dstContainer )
    return false;

    if( !_.primitive.is( srcContainer[ key ] ) )
    return false;

    return true;
  }

}

dstNotHasSrcPrimitive.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotHasSrcOwn()
{
  let routine = dstNotHasSrcOwn;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotHasSrcOwn( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return false;
    if( key in dstContainer )
    return false;

    /*dstContainer[ key ] = srcContainer[ key ];*/
    return true;
  }

}

dstNotHasSrcOwn.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotHasSrcOwnAssigning()
{
  let routine = dstNotHasSrcOwnAssigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function dstNotHasSrcOwnAssigning( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return;
    if( key in dstContainer )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }

}

dstNotHasSrcOwnAssigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function dstNotHasSrcOwnRoutines()
{
  let routine = dstNotHasSrcOwnRoutines;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotHasSrcOwnRoutines( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return false;
    if( !_.routine.is( srcContainer[ key ] ) )
    return false;
    if( key in dstContainer )
    return false;

    /*dstContainer[ key ] = srcContainer[ key ];*/

    return true;
  }

}

dstNotHasSrcOwnRoutines.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotHasAssigningRecursive()
{
  let routine = dstNotHasAssigningRecursive;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function dstNotHasAssigningRecursive( dstContainer, srcContainer, key )
  {
    if( key in dstContainer )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key, _.entity.assign2FieldFromContainer );
  }

}

dstNotHasAssigningRecursive.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

// --
// dstOwn
// --

function dstOwn()
{
  let routine = dstOwn;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstOwn( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( dstContainer, key ) )
    return false;
    return true;
  }

}

dstOwn.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotOwn()
{
  let routine = dstNotOwn;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotOwn( dstContainer, srcContainer, key )
  {
    if( Object.hasOwnProperty.call( dstContainer, key ) )
    return false;
    return true;
  }

}

dstNotOwn.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotOwnNotSame()
{
  let routine = dstNotOwnNotSame;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotOwnNotSame( dstContainer, srcContainer, key )
  {
    if( key === 'groupTextualReport' )
    debugger;
    if( Object.hasOwnProperty.call( dstContainer, key ) )
    return false;
    if( dstContainer[ key ] === srcContainer[ key ] )
    return false;
    return true;
  }

}

dstNotOwnNotSame.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotOwnSrcOwn()
{
  let routine = dstNotOwnSrcOwn;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstNotOwnSrcOwn( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return false;

    if( Object.hasOwnProperty.call( dstContainer, key ) )
    return false;

    return true;
  }

}

dstNotOwnSrcOwn.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstNotOwnSrcOwnAssigning()
{
  let routine = dstNotOwnSrcOwnAssigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function dstNotOwnSrcOwnAssigning( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return;

    if( Object.hasOwnProperty.call( dstContainer, key ) )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }

}

dstNotOwnSrcOwnAssigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function dstNotOwnOrUndefinedAssigning()
{
  let routine = dstNotOwnOrUndefinedAssigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function dstNotOwnOrUndefinedAssigning( dstContainer, srcContainer, key )
  {

    if( Object.hasOwnProperty.call( dstContainer, key ) )
    {

      if( dstContainer[ key ] !== undefined )
      return;

    }

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }

}

dstNotOwnOrUndefinedAssigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function dstNotOwnAssigning()
{
  let routine = dstNotOwnAssigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function dstNotOwnAssigning( dstContainer, srcContainer, key )
  {

    if( Object.hasOwnProperty.call( dstContainer, key ) )
    return;

    let srcElement = srcContainer[ key ];
    if( _.mapIs( srcElement ) || _.arrayIs( srcElement ) )
    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
    else
    dstContainer[ key ] = srcContainer[ key ];

  }

}

dstNotOwnAssigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function dstNotOwnAppending()
{
  let routine = dstNotOwnAppending;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function dstNotOwnAppending( dstContainer, srcContainer, key )
  {
    debugger;
    if( dstContainer[ key ] !== undefined )
    {
      debugger;
      if( _.arrayIs( dstContainer[ key ] ) && _.arrayIs( srcContainer[ key ] ) )
      _.arrayAppendArray( dstContainer, srcContainer, key );
    }
    if( Object.hasOwnProperty.call( dstContainer, key ) )
    return;
    dstContainer[ key ] = srcContainer[ key ];
  }

}

dstNotOwnAppending.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

// --
// dstHas
// --

function dstHasMaybeUndefined()
{
  let routine = dstHasMaybeUndefined;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstHasMaybeUndefined( dstContainer, srcContainer, key )
  {
    if( key in dstContainer )
    return true;
    return false;
  }

}

dstHasMaybeUndefined.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstHasButUndefined()
{
  let routine = dstHasButUndefined;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstHasButUndefined( dstContainer, srcContainer, key )
  {
    if( dstContainer[ key ] === undefined )
    return false;
    return true;
  }

}

dstHasButUndefined.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstHasSrcOwn()
{
  let routine = dstHasSrcOwn;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstHasSrcOwn( dstContainer, srcContainer, key )
  {
    if( !( key in dstContainer ) )
    return false;
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return false;
    return true;
  }

}

dstHasSrcOwn.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function dstHasSrcNotOwn()
{
  let routine = dstHasSrcNotOwn;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function dstHasSrcNotOwn( dstContainer, srcContainer, key )
  {
    if( !( key in dstContainer ) )
    return false;
    if( Object.hasOwnProperty.call( srcContainer, key ) )
    return false;
    return true;
  }

}

dstHasSrcNotOwn.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

// --
// srcOwn
// --

function srcOwn()
{
  let routine = srcOwn;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function srcOwn( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return false;

    /*dstContainer[ key ] = srcContainer[ key ];*/
    return true;
  }

}

srcOwn.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function srcOwnRoutines()
{
  let routine = srcOwnRoutines;
  routine.identity = { propertyCondition : true, propertyTransformer : true }; ;
  return routine;

  function srcOwnRoutines( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return false;
    if( !_.routine.is( srcContainer[ key ] ) )
    return false;

    /*dstContainer[ key ] = srcContainer[ key ];*/
    return true;
  }

}

srcOwnRoutines.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function srcOwnAssigning()
{
  let routine = assigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function assigning( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }

}

srcOwnAssigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function srcOwnPrimitive()
{
  let routine = srcOwnPrimitive;
  routine.identity = { propertyCondition : true, propertyTransformer : true };
  return routine;

  function srcOwnPrimitive( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return false;
    if( !_.primitive.is( srcContainer[ key ] ) )
    return false;

    /*dstContainer[ key ] = srcContainer[ key ];*/
    return true;
  }

}

srcOwnPrimitive.identity = { propertyCondition : true, propertyTransformer : true, functor : true };

//

function srcOwnNotPrimitiveAssigning()
{
  let routine = srcOwnNotPrimitiveAssigning;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function srcOwnNotPrimitiveAssigning( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return;
    if( _.primitive.is( srcContainer[ key ] ) )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key );
  }

}

srcOwnNotPrimitiveAssigning.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function srcOwnNotPrimitiveAssigningRecursive()
{
  let routine = srcOwnNotPrimitiveAssigningRecursive;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function srcOwnNotPrimitiveAssigningRecursive( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return;
    if( _.primitive.is( srcContainer[ key ] ) )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key, _.entity.assign2FieldFromContainer );
  }

}

srcOwnNotPrimitiveAssigningRecursive.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

//

function srcOwnAssigningRecursive()
{
  let routine = srcOwnAssigningRecursive;
  routine.identity = { propertyMapper : true, propertyTransformer : true };
  return routine;

  function srcOwnAssigningRecursive( dstContainer, srcContainer, key )
  {
    if( !Object.hasOwnProperty.call( srcContainer, key ) )
    return;

    _.entity.assign2FieldFromContainer( dstContainer, srcContainer, key, _.entity.assign2FieldFromContainer );
  }

}

srcOwnAssigningRecursive.identity = { propertyMapper : true, propertyTransformer : true, functor : true };

// --
// make
// --

let _Transformers =
{

  //

  bypass,
  assigning,
  primitive,
  hiding,
  appendingAnything,
  prependingAnything,
  appendingOnlyArrays,
  appendingOnce,
  removing,
  notPrimitiveAssigning,
  assigningRecursive,
  drop,
  notIdentical,

  // src

  srcDefined,
  dstNotHasOrSrcNotNull,

  // dst

  dstNotConstant,
  dstAndSrcOwn,
  dstUndefinedSrcNotUndefined,

  // dstNotHas

  dstNotHas,
  dstNotHasOrHasNull,
  dstNotHasOrHasNil,

  dstNotHasAssigning,
  dstNotHasAppending,
  dstNotHasSrcPrimitive,

  dstNotHasSrcOwn,
  dstNotHasSrcOwnAssigning,
  dstNotHasSrcOwnRoutines,
  dstNotHasAssigningRecursive,

  // dstOwn

  dstOwn,
  dstNotOwn,
  dstNotOwnNotSame,
  dstNotOwnSrcOwn,
  dstNotOwnSrcOwnAssigning,
  dstNotOwnOrUndefinedAssigning,
  dstNotOwnAssigning,
  dstNotOwnAppending,

  // dstHas

  dstHasMaybeUndefined,
  dstHasButUndefined,
  dstHasSrcOwn,
  dstHasSrcNotOwn,

  // srcOwn

  srcOwn,
  srcOwnRoutines,
  srcOwnAssigning,
  srcOwnPrimitive,
  srcOwnNotPrimitiveAssigning,
  srcOwnNotPrimitiveAssigningRecursive,
  srcOwnAssigningRecursive,

}

// --
// extend
// --

_.props.transformersRegister( _Transformers );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l6/PropertyTransformers.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l6' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, PropertyTransformers_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file PropertyTransformers_s */ })();

/* */  /* begin of file ArgumentsArray_s */ ( function ArgumentsArray_s() { function ArgumentsArray_s_naked() { ( function _l7_ArgumentsArray_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.argumentsArray = _.argumentsArray || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{

}

//

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/ArgumentsArray.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ArgumentsArray_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ArgumentsArray_s */ })();

/* */  /* begin of file Array_s */ ( function Array_s() { function Array_s_naked() { ( function _l7_Array_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _global_.wTools;

// --
// implementation
// --

// --
// declaration
// --

let ToolsExtension =
{

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Array.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Array_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Array_s */ })();

/* */  /* begin of file ArraySet_s */ ( function ArraySet_s() { function ArraySet_s_naked() { ( function _l7_ArraySet_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.arraySet = _.arraySet || Object.create( null );

// --
// array set
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( Self, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/ArraySet.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ArraySet_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ArraySet_s */ })();

/* */  /* begin of file Auxiliary_s */ ( function Auxiliary_s() { function Auxiliary_s_naked() { ( function _l7_Auxiliary_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// dichotomy
// --

// --
// extension
// --

var AuxiliaryExtension =
{

}

Object.assign( _.aux, AuxiliaryExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Auxiliary.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Auxiliary_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Auxiliary_s */ })();

/* */  /* begin of file BigInt_s */ ( function BigInt_s() { function BigInt_s_naked() { ( function _l7_BigInt_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.bigInt = _.bigInt || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( Self, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/BigInt.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, BigInt_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file BigInt_s */ })();

/* */  /* begin of file Bool_s */ ( function Bool_s() { function Bool_s_naked() { ( function _l7_Bool_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.bool = _.bool || Object.create( null );

// --
// bool
// --

/**
 * @summary Converts argument( src ) to boolean.
 * @function boolFrom
 * @param {*} src - entity to convert
 * @namespace Tools
 * @throws Exception if cannot convert.
 */

function from( src )
{
  let result = _.bool.fromMaybe( src );
  _.assert( _.boolIs( result ), `Cant convert ${_.entity.strType( src )} to boolean` );
  return result;
}

//

/**
 * @summary Converts argument( src ) to boolean or return src.
 * @function boolFrom
 * @param {*} src - entity to convert
 * @namespace Tools
 */

function fromMaybe( src )
{
  if( _.bool.is( src ) )
  {
    return src;
  }
  else if( _.number.is( src ) )
  {
    return !!src;
  }
  else if( _.strIs( src ) )
  {
    src = src.toLowerCase();
    if( src === '0' )
    return false;
    if( src === 'false' )
    return false;
    if( src === '1' )
    return true;
    if( src === 'true' )
    return true;
    return src;
  }
  else
  {
    return src;
  }
}

//

/**
 * @summary Converts argument( src ) to boolean.
 * @function boolFrom
 * @param {*} src - entity to convert
 * @namespace Tools
 */

function coerceFrom( src )
{
  if( _.strIs( src ) )
  {
    src = src.toLowerCase();
    if( src === '0' )
    return false;
    if( src === 'false' )
    return false;
    if( src === 'null' )
    return false;
    if( src === 'undefined' )
    return false;
    if( src === '' )
    return false;
    return true;
  }
  return Boolean( src );
}

// --
// implementation
// --

let ToolsExtension =
{

  boolFrom : from,
  boolFromMaybe : fromMaybe,
  boolCoerceFrom : coerceFrom,

}

Object.assign( _, ToolsExtension );

//

let BoolExtension =
{

  from,
  fromMaybe,
  coerceFrom,

}

Object.assign( _.bool, BoolExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Bool.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Bool_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Bool_s */ })();

/* */  /* begin of file Buffer_s */ ( function Buffer_s() { function Buffer_s_naked() { ( function _l7_Buffer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// buffer
// --

function _argumentsOnlyBuffer( /* dst, src, range, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( dst === null )
  dst = true;
  else if( dst === src )
  dst = false;
  else if( arguments.length === 4 )
  _.assert( _.longIs( dst ) || _.bufferAnyIs( dst ), '{-dst-} should be Long or buffer' );
  else
  {
    if( arguments.length > 1 && !_.intervalIs( src ) && !_.number.is( src ) )
    _.assert( _.longIs( dst ) || _.bufferAnyIs( dst ) );
    else
    {
      ins = range;
      range = src;
      src = dst;
      dst = false;
    }
  }

  _.assert( _.longIs( src ) || _.bufferAnyIs( src ) );

  return [ dst, src, range, ins ];
}

function _returnDst( dst, src )
{
  let dstLength;
  if( !_.bool.is( dst ) )
  dstLength = dst.length === undefined ? dst.byteLength : dst.length;

  if( dstLength !== undefined )
  {
    let srcLength = src.length === undefined ? src.byteLength : src.length;

    if( _.arrayLikeResizable( dst ) )
    dst.length = srcLength;
    else if( _.argumentsArray.is( dst ) )
    dst = new Array( srcLength );
    else if( dstLength !== srcLength )
    dst = _.bufferViewIs( dst ) ? new BufferView( new BufferRaw( srcLength ) ) : new dst.constructor( srcLength );

    let dstTyped = dst;
    if( _.bufferRawIs( dstTyped ) )
    dstTyped = new U8x( dstTyped );
    else if( _.bufferViewIs( dstTyped ) )
    dstTyped = new U8x( dstTyped.buffer );

    if( _.bufferRawIs( src ) )
    src = new U8x( src );
    else if( _.bufferViewIs( src ) )
    src = new U8x( src.buffer );

    for( let i = 0; i < srcLength; i++ )
    dstTyped[ i ] = src[ i ];

    return dst;
  }
  return dst === true ? _.bufferMake( src ) : src;
}

//

/**
 * The bufferRelen() routine returns a new or the same typed array {-srcMap-} with a new or the same length (len).
 *
 * It creates the variable (result) checks, if (len) is more than (src.length),
 * if true, it creates and assigns to (result) a new typed array with the new length (len) by call the function(longMakeUndefined(src, len))
 * and copies each element from the {-srcMap-} into the (result) array while ensuring only valid data types, if data types are invalid they are replaced with zero.
 * Otherwise, if (len) is less than (src.length) it returns a new typed array from 0 to the (len) indexes, but not including (len).
 * Otherwise, it returns an initial typed array.
 *
 * @see {@link wTools.longMakeUndefined} - See for more information.
 *
 * @param { typedArray } src - The source typed array.
 * @param { Number } len - The length of a typed array.
 *
 * @example
 * let ints = new I8x( [ 3, 7, 13 ] );
 * _.bufferRelen( ints, 4 );
 * // returns [ 3, 7, 13, 0 ]
 *
 * @example
 * let ints2 = new I16x( [ 3, 7, 13, 33, 77 ] );
 * _.bufferRelen( ints2, 3 );
 * // returns [ 3, 7, 13 ]
 *
 * @example
 * let ints3 = new I32x( [ 3, 7, 13, 33, 77 ] );
 * _.bufferRelen( ints3, 6 );
 * // returns [ 3, 0, 13, 0, 77, 0 ]
 *
 * @returns { typedArray } - Returns a new or the same typed array {-srcMap-} with a new or the same length (len).
 * @function bufferRelen
 * @namespace Tools
 */

function bufferRelen( src, len )
{
  let result = src;

  _.assert( _.bufferTypedIs( src ) );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.number.is( len ) );

  if( len > src.length )
  {
    result = _.long.makeUndefined( src, len );
    result.set( src );
  }
  else if( len < src.length )
  {
    result = src.subarray( 0, len );
  }

  return result;
}

//

/**
 * Routine bufferBut_() copies elements from source buffer {-src-} to destination buffer {-dst-}.
 * Routine copies all elements excluding elements in range {-cinterval-}, its elements replaces by elements
 * from insertion buffer {-ins-}.
 *
 * If first and second provided arguments is containers, then fisrs argument is destination
 * container {-dst-} and second argument is source container {-src-}. All data in {-dst-} cleares. If {-dst-} container
 * is not resizable and resulted length of destination container is not equal to original {-dst-} length, then routine
 * makes new container of {-dst-} type.
 *
 * If first argument and second argument are the same container, routine tries to change container inplace.
 *
 * If {-dst-} is not provided then routine tries to change container inplace.
 *
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } src - The container from which makes a shallow copy.
 * @param { Range|Number } cinterval - The two-element array that defines the start index and the end index for removing elements.
 * If {-cinterval-} is a Number, then it defines the index of removed element.
 * If {-cinterval-} is undefined and {-dst-} is null, then routine returns copy of {-src-}, otherwise, routine returns original {-src-}.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] > src.length, end index sets to ( src.length - 1 ).
 * If range[ 1 ] < range[ 0 ], then routine removes not elements, the insertion of elements begins at start index.
 * @param { BufferAny|Long } ins - The container with elements for insertion. Inserting begins at start index.
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferBut_( buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferBut_( null, buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferBut_( buffer, buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let dst = [ 0, 0 ]
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferBut_( dst, buffer );
 * console.log( got );
 * // log [ 1, 2, 3, 4 ]
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let ins = new I32x( [ 0, 0 ] );
 * let got = _.bufferBut_( buffer, [ 1, 2 ], ins );
 * console.log( got );
 * // log Uint8Array[ 1, 0, 0, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferBut_( null, buffer, 1, [ 0, 0 ] );
 * console.log( got );
 * // log Uint8Array[ 0, 0, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferBut_( buffer, buffer, [ 1, 2 ], [ 0, 0 ] );
 * console.log( got );
 * // log Uint8Array[ 1, 0, 0, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let dst = [ 0, 0 ]
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferBut_( dst, buffer, [ 1, 2 ], [ 0, 0 ] );
 * console.log( got );
 * // log [ 1, 0, 0, 4 ]
 * console.log( got === dst );
 * // log true
 *
 * @returns { BufferAny|Long } - If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-src-} type.
 * If {-dst-} and {-src-} are the same container, routine tries to return original container.
 * @function bufferBut_
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} is not a buffer, not a Long, not null.
 * @throws { Error } If {-src-} is not an any buffer, not a Long.
 * @throws { Error } If {-cinterval-} is not a Range or not a Number.
 * @namespace Tools
 */

function bufferBut_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  let dstLength = 0;
  if( dst !== null )
  dstLength = dst.length === undefined ? dst.byteLength : dst.length;
  let srcLength = src.length === undefined ? src.byteLength : src.length;

  if( cinterval === undefined )
  {
    cinterval = [ 0, -1 ];
    ins = undefined;
  }
  else if( _.number.is( cinterval ) )
  {
    cinterval = [ cinterval, cinterval ];
  }

  _.assert( _.bufferAnyIs( dst ) || _.longIs( dst ) || dst === null, 'Expects {-dst-} of any buffer type, long or null' );
  _.assert( _.bufferAnyIs( src ) || _.longIs( src ), 'Expects {-src-} of any buffer type or long' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );
  _.assert( _.longIs( ins ) || _.bufferNodeIs( ins ) || ins === undefined || ins === null, 'Expects iterable buffer {-ins-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  let last = cinterval[ 1 ] = cinterval[ 1 ] === undefined ? srcLength - 1 : cinterval[ 1 ];

  if( first < 0 )
  first = 0;
  if( first > srcLength )
  first = srcLength;
  if( last > srcLength - 1 )
  last = srcLength - 1;

  if( last + 1 < first )
  last = first - 1;

  let delta = last - first + 1;
  let insLength = 0
  if( ins )
  insLength = ins.length === undefined ? ins.byteLength : ins.length;
  let delta2 = delta - insLength;
  let resultLength = srcLength - delta2;

  let result = dst;
  if( dst === null )
  {
    result = _.bufferMakeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( ( dstLength === resultLength ) && delta === 0 )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      ins ? dst.splice( first, delta, ... ins ) : dst.splice( first, delta );
      return dst;
    }
    else if( dstLength !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.bufferMakeUndefined( dst, resultLength );
    }
  }
  else if( dstLength !== resultLength )
  {
    dst = _.bufferMakeUndefined( dst, resultLength );
  }

  let resultTyped = result;
  if( _.bufferRawIs( result ) )
  resultTyped = new U8x( result );
  else if( _.bufferViewIs( result ) )
  resultTyped = new U8x( result.buffer );
  let srcTyped = src;
  if( _.bufferRawIs( src ) )
  srcTyped = new U8x( src );
  else if( _.bufferViewIs( src ) )
  srcTyped = new U8x( src.buffer );

  for( let i = 0 ; i < first ; i++ )
  resultTyped[ i ] = srcTyped[ i ];

  for( let i = last + 1 ; i < srcLength ; i++ )
  resultTyped[ i - delta2 ] = srcTyped[ i ];

  if( ins )
  {
    for( let i = 0 ; i < insLength ; i++ )
    resultTyped[ first + i ] = ins[ i ];
  }

  return result;
}

//

/**
 * Routine bufferOnly_() returns a shallow copy of a portion of provided container {-dstArray-}
 * into a new container selected by range {-range-}.
 *
 * If first and second provided arguments is containers, then fisrs argument is destination
 * container {-dst-} and second argument is source container {-dstArray-}. All data in {-dst-}
 * will be cleared. If {-dst-} container is not resizable and resulted container length
 * is not equal to original {-dst-} length, then routine makes new container of {-dst-} type.
 *
 * If first argument and second argument is the same container, routine will try change container inplace.
 *
 * If {-dst-} is not provided routine makes new container of {-dstArray-} type.
 *
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } dstArray - The container from which makes a shallow copy.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for selecting elements.
 * If {-range-} is number, then it defines the start index, and the end index sets to dstArray.length.
 * If {-range-} is undefined, routine returns copy of {-dstArray-}.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] > dstArray.length, end index sets to dstArray.length.
 * If range[ 1 ] <= range[ 0 ], then routine returns empty container.
 * @param { * } srcArray - The object of any type for insertion.
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferOnly_( buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferOnly_( null, buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferOnly_( buffer, buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let dst = [ 0, 0 ]
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferOnly_( dst, buffer );
 * console.log( got );
 * // log [ 1, 2, 3, 4 ]
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let src = new I32x( [ 0, 0, 0 ] );
 * let got = _.bufferOnly_( buffer, [ 1, 3 ], src );
 * console.log( got );
 * // log Uint8Array[ 2, 3 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferOnly_( null, buffer, 1, [ 0, 0, 0 ] );
 * console.log( got );
 * // log Uint8Array[ 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferOnly_( buffer, buffer, [ 1, 3 ], [ 0, 0, 0 ] );
 * console.log( got );
 * // log Uint8Array[ 2, 3 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let dst = [ 0, 0 ];
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferOnly_( dst, buffer, [ 1, 3 ], [ 0, 0, 0 ] );
 * console.log( got );
 * // log [ 2, 3 ]
 * console.log( got === dst );
 * // log true
 *
 * @returns { BufferAny|Long } If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-dstArray-} type.
 * If {-dst-} and {-dstArray-} is the same container, routine tries to return original container.
 * @function bufferOnly_
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} is not an any buffer, not a Long, not null.
 * @throws { Error } If {-dstArray-} is not an any buffer, not a Long.
 * @throws { Error } If ( range ) is not a Range or not a Number.
 * @namespace Tools
 */

function bufferOnly_( dst, src, cinterval )
{
  _.assert( 1 <= arguments.length && arguments.length <= 3, 'Expects not {-ins-} argument' );

  if( arguments.length < 3 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
  }

  let dstLength = 0;
  if( dst !== null )
  dstLength = dst.length === undefined ? dst.byteLength : dst.length;
  let srcLength = src.length === undefined ? src.byteLength : src.length;

  if( cinterval === undefined )
  cinterval = [ 0, srcLength - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval ];

  _.assert( _.bufferAnyIs( dst ) || _.longIs( dst ) || dst === null, 'Expects {-dst-} of any buffer type, long or null' );
  _.assert( _.bufferAnyIs( src ) || _.longIs( src ), 'Expects {-src-} of any buffer type or long' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  let last = cinterval[ 1 ] = cinterval[ 1 ] === undefined ? srcLength - 1 : cinterval[ 1 ];

  if( first < 0 )
  first = 0;
  if( last > srcLength - 1 )
  last = srcLength - 1;

  if( last + 1 < first )
  last = first - 1;

  let first2 = Math.max( first, 0 );
  let last2 = Math.min( srcLength - 1, last );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.bufferMakeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( dstLength === resultLength )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      _.assert( Object.isExtensible( dst ), 'Array is not extensible, cannot change array' );
      if( resultLength === 0 )
      return _.longEmpty( dst );

      dst.splice( last2 + 1, dst.length - last + 1 );
      dst.splice( 0, first2 );
      return dst;
    }
    else if( dstLength !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.bufferMakeUndefined( dst, resultLength );
    }
  }
  else if( dstLength !== resultLength )
  {
    if( _.arrayLikeResizable( result ) )
    result.splice( resultLength );
    else
    result = _.bufferMakeUndefined( dst, resultLength );
  }

  let resultTyped = result;
  if( _.bufferRawIs( result ) )
  resultTyped = new U8x( result );
  else if( _.bufferViewIs( result ) )
  resultTyped = new U8x( result.buffer );
  let srcTyped = src;
  if( _.bufferRawIs( src ) )
  srcTyped = new U8x( src );
  else if( _.bufferViewIs( src ) )
  srcTyped = new U8x( src.buffer );

  for( let r = first2 ; r < last2 + 1 ; r++ )
  resultTyped[ r - first2 ] = srcTyped[ r ];

  return result;
}

//

/**
 * Routine bufferGrow_() grows provided container {-dst-} by copying elements of source buffer to it.
 * Routine uses cinterval {-cinterval-} positions of the source container and value {-ins-} to fill destination buffer.
 * Routine can only grows size of source container.
 *
 * If first and second provided arguments is containers, then fisrs argument is destination
 * container {-dst-} and second argument is source container {-dstArray-}. All data in {-dst-}
 * will be cleared. If {-dst-} container is not resizable and resulted container length
 * is not equal to original {-src-} length, then routine makes new container with {-dst-} type.
 *
 * If first argument and second argument is the same container, routine will try change container inplace.
 *
 * If {-dst-} is not provided routine makes new container with {-src-} type.
 *
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } src - The container from which makes a shallow copy.
 * @param { Range|Number } cinterval - The two-element array that defines the start index and the end index for copying elements from {-src-} and adding {-ins-}.
 * If {-range-} is number, then it defines the end index, and the start index is 0.
 * If range[ 0 ] < 0, then start index sets to 0, end index incrementes by absolute value of range[ 0 ].
 * If range[ 0 ] > 0, then start index sets to 0.
 * If range[ 1 ] < range[ 0 ], then routine returns a copy of original container.
 * @param { * } ins - The object of any type for insertion.
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferGrow_( buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferGrow_( null, buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferGrow_( buffer, buffer, [ 0, 3 ] );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let dst = [ 0, 0 ]
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferGrow_( dst, buffer, [ 0, 3 ] );
 * console.log( got );
 * // log [ 1, 2, 3, 4 ]
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferGrow_( buffer, [ 1, 5 ], 0 );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4, 0, 0 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferGrow_( null, buffer, 2, 1 );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferGrow_( buffer, buffer, [ 0, 3 ], 2 );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let dst = [ 0, 0 ];
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferGrow_( dst, buffer, [ 1, 5 ], 1 );
 * console.log( got );
 * // log [ 1, 2, 3, 4, 1, 1 ]
 * console.log( got === dst );
 * // log true
 *
 * @returns { BufferAny|Long } - If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-src-} type.
 * If {-dst-} and {-src-} is the same container, routine tries to return original container.
 * @function bufferGrow_
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} is not an any buffer, not a Long, not null.
 * @throws { Error } If {-src-} is not an any buffer, not a Long.
 * @throws { Error } If ( range ) is not a Range or not a Number.
 * @namespace Tools
 */

function bufferGrow_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  let dstLength = 0;
  if( dst !== null )
  dstLength = dst.length === undefined ? dst.byteLength : dst.length;
  let srcLength = src.length === undefined ? src.byteLength : src.length;

  if( cinterval === undefined )
  cinterval = [ 0, srcLength - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval - 1 ];

  _.assert( _.bufferAnyIs( dst ) || _.longIs( dst ) || dst === null, 'Expects {-dst-} of any buffer type, long or null' );
  _.assert( _.bufferAnyIs( src ) || _.longIs( src ), 'Expects {-src-} of any buffer type or long' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  let last = cinterval[ 1 ] = cinterval[ 1 ] === undefined ? srcLength - 1 : cinterval[ 1 ];

  if( first > 0 )
  first = 0;
  if( last < srcLength - 1 )
  last = srcLength - 1;

  if( first < 0 )
  {
    last -= first;
    first -= first;
  }

  if( last + 1 < first )
  last = first - 1;

  let first2 = Math.max( -cinterval[ 0 ], 0 );
  let last2 = Math.min( srcLength - 1 + first2, last + first2 );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.bufferMakeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( dstLength === resultLength )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      _.assert( Object.isExtensible( dst ), 'Array is not extensible, cannot change array' );
      dst.splice( first, 0, ... _.dup( ins, first2 ) );
      dst.splice( last2 + 1, 0, ... _.dup( ins, resultLength <= last2 ? 0 : resultLength - last2 - 1 ) );
      return dst;
    }
    else if( dstLength !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.bufferMakeUndefined( dst, resultLength );
    }
  }
  else if( dstLength !== resultLength )
  {
    if( _.arrayLikeResizable( result ) )
    result.splice( resultLength );
    else
    result = _.bufferMakeUndefined( dst, resultLength );
  }

  let resultTyped = result;
  if( _.bufferRawIs( result ) )
  resultTyped = new U8x( result );
  else if( _.bufferViewIs( result ) )
  resultTyped = new U8x( result.buffer );
  let srcTyped = src;
  if( _.bufferRawIs( src ) )
  srcTyped = new U8x( src );
  else if( _.bufferViewIs( src ) )
  srcTyped = new U8x( src.buffer );

  for( let r = first2 ; r < last2 + 1 ; r++ )
  resultTyped[ r ] = srcTyped[ r - first2 ];

  if( ins !== undefined )
  {
    for( let r = 0 ; r < first2 ; r++ )
    resultTyped[ r ] = ins;

    for( let r = last2 + 1 ; r < resultLength ; r++ )
    resultTyped[ r ] = ins;
  }

  return result;
}

//

/**
 * Routine bufferRelength_() changes length of provided container {-dstArray-} by copying it elements to newly created container of the same
 * type using range {-range-} positions of the original containers and value to fill free space after copy {-srcArray-}.
 * Routine can grows and reduces size of container.
 *
 * If first and second provided arguments is containers, then fisrs argument is destination
 * container {-dst-} and second argument is source container {-dstArray-}. All data in {-dst-}
 * will be cleared. If {-dst-} container is not resizable and resulted container length
 * is not equal to original {-dst-} length, then routine makes new container of {-dst-} type.
 *
 * If first argument and second argument is the same container, routine will try change container inplace.
 *
 * If {-dst-} is not provided routine makes new container of {-dstArray-} type.
 *
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } dstArray - The container from which makes a shallow copy.
 * @param { Range|Number } range - The two-element array that defines the start index and the end index for copying elements from {-dstArray-} and adding {-srcArray-}.
 * If {-range-} is number, then it defines the start index, and the end index sets to dstArray.length.
 * If range[ 0 ] < 0, then start index sets to 0.
 * If range[ 1 ] <= range[ 0 ], then routine returns empty container.
 * @param { * } srcArray - The object of any type for insertion.
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferRelength_( buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferRelength_( null, buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferRelength_( buffer, buffer );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let dst = [ 0, 0 ]
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferRelength_( dst, buffer );
 * console.log( got );
 * // log [ 1, 2, 3, 4 ]
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferRelength_( buffer, [ 1, 6 ], 0 );
 * console.log( got );
 * // log Uint8Array[ 2, 3, 4, 0, 0 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferRelength_( null, buffer, 2, 1 );
 * console.log( got );
 * // log Uint8Array[ 3, 4 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferRelength_( buffer, buffer, [ 0, 3 ], 2 );
 * console.log( got );
 * // log Uint8Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * @example
 * let dst = [ 0, 0 ];
 * let buffer = new U8x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferRelength_( dst, buffer, [ 1, 6 ], [ 0, 0, 0 ] );
 * console.log( got );
 * // log [ 2, 3, 4, [ 0, 0, 0 ], [ 0, 0, 0 ] ]
 * console.log( got === dst );
 * // log true
 *
 * @returns { BufferAny|Long } If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-dstArray-} type.
 * If {-dst-} and {-dstArray-} is the same container, routine tries to return original container.
 * @function bufferRelength_
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} is not an any buffer, not a Long, not null.
 * @throws { Error } If {-dstArray-} is not an any buffer, not a Long.
 * @throws { Error } If ( range ) is not a Range or not a Number.
 * @namespace Tools
 */

function bufferRelength_( /* dst, src, cinterval, ins */ )
{
  let dst = arguments[ 0 ];
  let src = arguments[ 1 ];
  let cinterval = arguments[ 2 ];
  let ins = arguments[ 3 ];

  _.assert( 1 <= arguments.length && arguments.length <= 4 );

  if( arguments.length < 4 && dst !== null && dst !== src )
  {
    dst = arguments[ 0 ];
    src = arguments[ 0 ];
    cinterval = arguments[ 1 ];
    ins = arguments[ 2 ];
  }

  let dstLength = 0;
  if( dst !== null )
  dstLength = dst.length === undefined ? dst.byteLength : dst.length;
  let srcLength = src.length === undefined ? src.byteLength : src.length;

  if( cinterval === undefined )
  cinterval = [ 0, srcLength - 1 ];
  if( _.number.is( cinterval ) )
  cinterval = [ 0, cinterval-1 ];

  _.assert( _.bufferAnyIs( dst ) || _.longIs( dst ) || dst === null, 'Expects {-dst-} of any buffer type, long or null' );
  _.assert( _.bufferAnyIs( src ) || _.longIs( src ), 'Expects {-src-} of any buffer type or long' );
  _.assert( _.intervalIs( cinterval ), 'Expects cinterval {-cinterval-}' );

  let first = cinterval[ 0 ] = cinterval[ 0 ] === undefined ? 0 : cinterval[ 0 ];
  let last = cinterval[ 1 ] = cinterval[ 1 ] === undefined ? srcLength - 1 : cinterval[ 1 ];

  if( last < first )
  last = first - 1;

  if( cinterval[ 1 ] < 0 && cinterval[ 0 ] < 0 )
  cinterval[ 0 ] -= cinterval[ 1 ] + 1;

  if( first < 0 )
  {
    last -= first;
    first -= first;
  }

  let first2 = Math.max( Math.abs( cinterval[ 0 ] ), 0 );
  let last2 = Math.min( srcLength - 1, last );

  let resultLength = last - first + 1;

  let result = dst;
  if( dst === null )
  {
    result = _.bufferMakeUndefined( src, resultLength );
  }
  else if( dst === src )
  {
    if( dstLength === resultLength && cinterval[ 0 ] === 0 )
    {
      return dst;
    }
    if( _.arrayLikeResizable( dst ) )
    {
      _.assert( Object.isExtensible( dst ), 'dst is not extensible, cannot change dst' );
      if( cinterval[ 0 ] < 0 )
      {
        dst.splice( first, 0, ... _.dup( ins, first2 ) );
        dst.splice( last2 + 1, src.length - last2, ... _.dup( ins, last - last2 ) );
      }
      else
      {
        dst.splice( 0, first );
        dst.splice( last2 + 1 - first2, src.length - last2, ... _.dup( ins, last - last2 ) );
      }
      return dst;
    }
    else if( dstLength !== resultLength || _.argumentsArray.is( dst ) )
    {
      result = _.bufferMakeUndefined( dst, resultLength );
    }
  }
  else if( dstLength !== resultLength )
  {
    if( _.arrayLikeResizable( result ) )
    result.splice( resultLength );
    else
    result = _.bufferMakeUndefined( dst, resultLength );
  }

  let resultTyped = result;
  if( _.bufferRawIs( result ) )
  resultTyped = new U8x( result );
  else if( _.bufferViewIs( result ) )
  resultTyped = new U8x( result.buffer );
  let srcTyped = src;
  if( _.bufferRawIs( src ) )
  srcTyped = new U8x( src );
  else if( _.bufferViewIs( src ) )
  srcTyped = new U8x( src.buffer );

  if( resultLength === 0 )
  {
    return result;
  }
  if( cinterval[ 0 ] < 0 )
  {
    for( let r = first2 ; r < ( last2 + 1 + first2 ) && r < resultLength ; r++ )
    resultTyped[ r ] = srcTyped[ r - first2 ];
    if( ins !== undefined )
    {
      for( let r = 0 ; r < first2 ; r++ )
      resultTyped[ r ] = ins;
      for( let r = last2 + 1 + first2 ; r < resultLength ; r++ )
      resultTyped[ r ] = ins;
    }
  }
  else
  {
    for( let r = first2 ; r < last2 + 1 ; r++ )
    resultTyped[ r - first2 ] = srcTyped[ r ];
    if( ins !== undefined )
    {
      for( let r = last2 + 1 ; r < last + 1 ; r++ )
      resultTyped[ r - first2 ] = ins;
    }
  }

  return result;
}

//

function bufferResize_( dst, srcBuffer, size )
{
  if( dst === null )
  dst = _.nothing;

  if( arguments.length === 2 )
  {
    size = srcBuffer;
    srcBuffer = dst;
  }

  let range = _.intervalIs( size ) ? size : [ 0, size ];
  size = range[ 1 ] - range[ 0 ];

  if( range[ 1 ] < range[ 0 ] )
  range[ 1 ] = range[ 0 ];

  _.assert( _.bufferAnyIs( srcBuffer ) && srcBuffer.byteLength >= 0 );
  _.assert( _.intervalIs( range ) );
  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( dst === srcBuffer && range[ 0 ] === 0 && range[ 1 ] === srcBuffer.byteLength )
  return srcBuffer;

  let result;
  let newOffset = srcBuffer.byteOffset ? srcBuffer.byteOffset + range[ 0 ] : range[ 0 ];

  if( dst === _.nothing )
  {
    _.assert( dst === _.nothing );

    result = _.bufferMakeUndefined( srcBuffer, size / srcBuffer.BYTES_PER_ELEMENT || size );
    let resultTyped = _.bufferRawIs( result ) ? new U8x( result ) : new U8x( result.buffer );
    let srcBufferToU8x = _.bufferRawIs( srcBuffer ) ? new U8x( srcBuffer ) : new U8x( srcBuffer.buffer );

    let first = Math.max( newOffset, 0 );
    let last = Math.min( srcBufferToU8x.byteLength, newOffset + size );
    newOffset = newOffset < 0 ? -newOffset : 0;
    for( let r = first ; r < last ; r++ )
    resultTyped[ r - first + newOffset ] = srcBufferToU8x[ r ];
  }
  else
  {
    _.assert( _.bufferAnyIs( dst ) );

    if( dst === srcBuffer && !_.bufferRawIs( srcBuffer ) && newOffset >= 0 && newOffset + size <= srcBuffer.buffer.byteLength )
    {
      if( _.bufferNodeIs( srcBuffer ) )
      result = BufferNode.from( srcBuffer.buffer, newOffset, size );
      else if( _.bufferViewIs( srcBuffer ) )
      result = new BufferView( srcBuffer.buffer, newOffset, size );
      else
      result = new srcBuffer.constructor( srcBuffer.buffer, newOffset, size / srcBuffer.BYTES_PER_ELEMENT );
    }
    else if( _.bufferRawIs( dst ) )
    {
      if( size === dst.byteLength )
      result = dst;
      else
      result = _.bufferMakeUndefined( dst, size );
    }
    else if( size <= dst.byteLength )
    {
      result = dst;
    }
    else
    {
      result = _.bufferMakeUndefined( dst, size / dst.BYTES_PER_ELEMENT || size );
    }

    let dstTyped = _.bufferRawIs( result ) ? new U8x( result ) : new U8x( result.buffer );
    let srcBufferToU8x = _.bufferRawIs( srcBuffer ) ? new U8x( srcBuffer ) : new U8x( srcBuffer.buffer );

    let first = Math.max( newOffset, 0 );
    let last = Math.min( srcBufferToU8x.byteLength, newOffset + size );
    for( let r = first ; r < last ; r++ )
    dstTyped[ r - first ] = srcBufferToU8x[ r ];
    dstTyped.fill( 0, last - first, dstTyped.length );
  }

  return result;
}

//

function bufferReusing4Arguments_head( routine, args )
{
  _.assert( arguments.length === 2 );
  _.assert( args.length > 0, 'Expects arguments' );

  /* qqq : for Dmytro : use switch here and in similar code */
  let o = Object.create( null );
  if( args.length === 1 )
  {
    if( _.mapIs( args[ 0 ] ) )
    {
      o = args[ 0 ];
    }
    else
    {
      o.dst = null;
      o.src = args[ 0 ];
    }
  }
  else if( args.length === 2 )
  {
    o.dst = null;
    o.src = args[ 0 ];
    o.cinterval = args[ 1 ];
  }
  else if( args.length === 3 )
  {
    o.dst = null;
    o.src = args[ 0 ];
    o.cinterval = args[ 1 ];
    o.ins = args[ 2 ];
  }
  else if( args.length === 4 )
  {
    o.dst = args[ 0 ];
    o.src = args[ 1 ];
    o.cinterval = args[ 2 ];
    o.ins = args[ 3 ];
  }
  else
  {
    _.assert( 0, 'Expects less then 4 arguments' );
  }

  /* */

  _.routine.optionsWithoutUndefined( routine, o ); /* qqq : for Dmytro : use _.routine.options() */
  _.assert( _.bufferAnyIs( o.src ) || _.longIs( o.src ) );
  _.assert( _.intervalIs( o.cinterval ) || _.numberIs( o.cinterval ) || o.cinterval === null );
  _.assert( _.intIs( o.minSize ) && o.minSize >= 0 );

  o.growFactor = o.growFactor === 0 ? 1 : o.growFactor;
  o.shrinkFactor = o.shrinkFactor === 0 ? 1 : o.shrinkFactor;

  if( o.dst === _.self )
  o.dst = o.src;

  return o;
}

//

function bufferReusing3Arguments_head( routine, args )
{
  _.assert( arguments.length === 2 );
  _.assert( 1 <= args.length && args.length <= 3 );

  let o;
  if( args.length === 3 )
  {
    o = Object.create( null );
    o.dst = args[ 0 ];
    o.src = args[ 1 ];
    o.cinterval = args[ 2 ];
    o = _.bufferReusing4Arguments_head.call( this, routine, [ o ] );
  }
  else
  {
    o = _.bufferReusing4Arguments_head.apply( this, arguments );
  }

  return o;
}

//

function _bufferElementSizeGet( src )
{
  if( src.BYTES_PER_ELEMENT )
  return src.BYTES_PER_ELEMENT;
  else if( src.byteLength === undefined )
  return 8;
  else
  return 1;
}

//

function _dstBufferSizeRecount( o )
{
  if( !_.numberIs( o.dstSize ) )
  o.dstSize = ( o.cinterval[ 1 ] - o.cinterval[ 0 ] + 1 ) * o.dstElementSize;

  if( o.growFactor > 1 && o.reusing && o.dst !== null )
  {
    let dstSize = o.dst.length ? o.dst.length * o.dstElementSize : o.dst.byteLength;
    if( dstSize < o.dstSize )
    {
      let growed = dstSize * o.growFactor;
      o.dstSize = growed > o.dstSize ? growed : o.dstSize;
    }
  }

  o.dstSize = o.minSize > o.dstSize ? o.minSize : o.dstSize;
  return o.dstSize;
}

//

function _bufferTypedViewMake( src )
{
  let srcTyped = src;
  if( _.bufferRawIs( src ) )
  srcTyped = new U8x( src );
  if( _.bufferViewIs( src ) )
  srcTyped = new U8x( src.buffer );

  return srcTyped;
}

//

function _resultBufferReusedMaybe( o )
{
  let buffer;

  let dstOffset = 0;
  let dstSize = o.dst.length ? o.dst.length * o.dstElementSize : o.dst.byteLength;

  if( o.offsetting && !_.bufferNodeIs( o.dst ) && _.bufferAnyIs( o.dst ) )
  {
    dstOffset = o.dst.byteOffset ? o.dst.byteOffset : dstOffset;
    dstSize = o.dst.buffer ? o.dst.buffer.byteLength : dstSize;
  }

  let shouldReuse = insideBufferBounds( dstOffset, dstSize, o.dstSize );
  let shouldShrink = shrinkFactorCheck( dstSize, o.dstSize );

  if( shouldReuse && !shouldShrink )
  {
    buffer = o.dst;
    let leftOffset = dstOffset + o.cinterval[ 0 ];
    let bufferLength = buffer.buffer && !_.bufferViewIs( buffer ) ? buffer.length : buffer.byteLength;

    if( leftOffset !== dstOffset || o.dstSize !== bufferLength )
    {
      if( !o.offsetting )
      leftOffset += buffer.byteOffset ? buffer.byteOffset : 0;

      if( _.bufferNodeIs( buffer ) )
      buffer = BufferNode.from( buffer.buffer, leftOffset, o.dstSize );
      else if( buffer.buffer )
      buffer = new buffer.constructor( buffer.buffer, leftOffset, o.dstSize );
    }
  }
  else
  {
    buffer = _resultBufferMake( o );
  }

  return buffer;

  /* */

  function shrinkFactorCheck( dstSize, resultSize )
  {
    if( o.shrinkFactor > 1 )
    return ( dstSize / resultSize ) >= o.shrinkFactor;
    return false;
  }

  /* */
  function insideBufferBounds( dstOffset, dstSize, resultSize )
  {
    let leftOffset = dstOffset + o.cinterval[ 0 ];
    let insideLeftBound = leftOffset >= 0 && leftOffset < dstSize;
    let rightBound = leftOffset + resultSize;
    let insideRightBound = rightBound <= dstSize;
    return insideLeftBound && insideRightBound;
  }
}

//

function _resultBufferMake( o )
{
  let buffer;
  let dstResultedLength = o.dstSize / o.dstElementSize;
  _.assert( _.intIs( dstResultedLength ) );

  if( o.dst === null )
  {
    buffer = _.bufferMakeUndefined( o.src, dstResultedLength );
  }
  else if( o.dst.length === dstResultedLength )
  {
    buffer = o.dst;
  }
  else if( o.dst.byteLength === o.dstSize )
  {
    buffer = o.dst;
  }
  else if( _.arrayLikeResizable( o.dst ) )
  {
    buffer = o.dst;
    buffer.length = dstResultedLength;
  }
  else
  {
    buffer = _.bufferMakeUndefined( o.dst, dstResultedLength );
  }

  return buffer;
}

//

/**
 * Routine bufferReusingBut() copies elements from source buffer {-src-} to destination buffer {-dst-}.
 * Routine copies all elements excluding elements in interval {-cinterval-}, its elements replace by elements
 * from insertion buffer {-ins-}.
 *
 * Data in buffer {-dst-} overwrites. If {-dst-} container is not resizable and resulted length of destination
 * container is not equal to original {-dst-} length, then routine makes new container of {-dst-} type.
 *
 * If buffer {-dst-} and {-src-} are the same buffer, then routine tries to change container {-src-} inplace and
 * reuse original raw buffer.
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingBut( buffer, [ 1, 1 ], [ 5 ] );
 * console.log( got );
 * // log Float64Array[ 1, 5, 3, 4, 0, 0, 0, 0 ]
 * console.log( got === buffer );
 * // log false
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingBut
 * ({
 *   dst : buffer,
 *   src : buffer,
 *   cinterval : [ 1, 1 ],
 *   ins : [ 5 ],
 *   minSize : 2,
 * });
 * console.log( got );
 * // log Float64Array[ 1, 5, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 *
 * First parameter set :
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } src - The container from which makes a shallow copy.
 * @param { Interval|Number } cinterval - The closed interval that defines the start index and the end index for removing elements.
 * If {-cinterval-} is a Number, then it defines the index of removed element.
 * If cinterval[ 0 ] < 0, then start index sets to 0.
 * If cinterval[ 1 ] > src.length, end index sets to ( src.length - 1 ).
 * If cinterval[ 1 ] < cinterval[ 0 ], then routine removes not elements, the insertion of elements begins at start index.
 * @param { BufferAny|Long|Undefined } ins - The container with elements for insertion. Inserting begins at start index.
 *
 * Second parameter set :
 * @param { Aux } o - Options map.
 * @param { BufferAny|Long|Null } o.dst - The destination container.
 * @param { BufferAny|Long } o.src - The container from which makes a shallow copy.
 * @param { Interval|Number } o.cinterval - The closed interval that defines the start index and the end index for removing elements.
 * The behavior same to first parameter set.
 * @param { BufferAny|Long|Undefined } o.ins - The container with elements for insertion. Inserting begins at start index.
 * @param { BoolLike } o.reusing - Allows routine to reuse original raw buffer. Default is true.
 * @param { BoolLike } o.offsetting - Allows routine to change offset in destination buffer {-o.dst-}. Default is true.
 * @param { Number } o.minSize - Minimal size of resulted buffer. If resulted buffer size is less than {-o.minSize-}, routine makes
 * new buffer. Default is 64.
 * @param { Number } o.growFactor - If routine needs to make new container that is bigger than {-o.minSize-}, then routine multiplies
 * {-o.growFactor-} on resulted buffer size. If {-o.growFactor-} <= 1, routine does not grow size of resulted buffer. Default is 2.
 * @param { Number } o.shrinkFactor - If resulted buffer in {-o.shrinkFactor-} times less than its raw buffer, than routine makes
 * new buffer. If {-o.shrinkFactor-} <= 1, then routine not change original raw buffer. Default is 0.
 *
 * @returns { BufferAny|Long } - If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-src-} type.
 * If {-dst-} and {-src-} are the same container, routine tries to return original container.
 * Routine tries to save original raw buffer.
 * @function bufferReusingBut
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} has not valid type.
 * @throws { Error } If {-src-} has not valid type.
 * @throws { Error } If {-cinterval-} has not valid type.
 * @throws { Error } If {-ins-} has not valid type.
 * @throws { Error } If options map {-o-} has not valid type.
 * @throws { Error } If options map {-o-} has not known options.
 * @throws { Error } If {-o.minSize-} has not valid type or is not an Integer.
 * @throws { Error } If {-o.growFactor-} has not valid type or is not an Integer.
 * @throws { Error } If {-o.shrinkFactor-} has not valid type or is not an Integer.
 * @namespace Tools
 */

function bufferReusingBut_body( o )
{
  _.assert( _.intIs( o.growFactor ) && o.growFactor >= 0 );
  _.assert( _.intIs( o.shrinkFactor ) && o.shrinkFactor >= 0 );

  /* */

  let bufferLength = 0;
  if( o.dst )
  bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
  else
  bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;

  let _cinterval;
  o.cinterval = cintervalClamp();

  if( o.ins === null || o.ins === undefined )
  o.ins = [];

  _.assert( _.longIs( o.ins ) || _.bufferAnyIs( o.ins ) );

  /* */

  let newBufferCreate = o.dst === null;

  _.assert( newBufferCreate || _.bufferAnyIs( o.dst ) || _.longIs( o.dst ) );

  let dstElementSize;
  if( newBufferCreate )
  o.dstElementSize = _._bufferElementSizeGet( o.src );
  else
  o.dstElementSize = _._bufferElementSizeGet( o.dst );

  o.dstSize = bufferSizeCount( _cinterval, o.dstElementSize );
  o.dstSize = _._dstBufferSizeRecount( o );

  let dstBuffer
  if( o.reusing && !newBufferCreate )
  dstBuffer = _resultBufferReusedMaybe( o );
  else
  dstBuffer = _resultBufferMake( o );

  let dstTyped = _bufferTypedViewMake( dstBuffer );
  let srcTyped = _bufferTypedViewMake( o.src );
  let result = dstBufferFill( dstTyped, srcTyped, o.cinterval, o.ins );

  return dstBuffer;

  /* */

  function cintervalClamp()
  {
    if( o.cinterval === null )
    o.cinterval = [ 0, -1 ];
    else if( _.number.is( o.cinterval ) )
    o.cinterval = [ o.cinterval, o.cinterval ];

    if( o.cinterval[ 0 ] < 0 )
    o.cinterval[ 0 ] = 0;
    if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
    o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;

    _cinterval = o.cinterval;
    return [ 0, o.cinterval[ 1 ] ];
  }

  function bufferSizeCount( cinterval, elementSize )
  {
    let length = bufferLength - ( cinterval[ 1 ] - cinterval[ 0 ] + 1 ) + o.ins.length;
    return length * elementSize;
  }

  /* */

  function dstBufferFill( /* dstTyped, srcTyped, cinterval, ins */ )
  {
    let dstTyped = arguments[ 0 ];
    let srcTyped = arguments[ 1 ];
    let cinterval = arguments[ 2 ];
    let ins = arguments[ 3 ];

    /* */

    cinterval = _cinterval;

    let left = Math.max( 0, cinterval[ 0 ] );
    let right = left + ins.length
    let start = cinterval[ 1 ] + 1;

    if( srcTyped.length )
    {
      if( dstTyped.buffer === srcTyped.buffer )
      {
        let val = srcTyped[ srcTyped.length - 1 ];
        /* qqq for Dmytro : not optimal */
        for( let i = srcTyped.length - 1 ; i >= start ; i-- )
        {
          let temp = srcTyped[ i - 1 ];
          dstTyped[ right + i - start ] = val;
          val = temp;
        }
      }
      else
      {
        for( let i = srcTyped.length - 1 ; i >= start ; i-- )
        dstTyped[ right + i - start ] = srcTyped[ i ];
      }

      for( let i = 0 ; i < left ; i++ )
      dstTyped[ i ] = srcTyped[ i ];
    }

    for( let i = left ; i < right ; i++ )
    dstTyped[ i ] = ins[ i - left ];

    return dstTyped;
  }
}

bufferReusingBut_body.defaults =
{
  dst : null,
  src : null,
  cinterval : null,
  ins : null,
  offsetting : 1,
  reusing : 1,
  growFactor : 2,
  shrinkFactor : 0,
  minSize : 64,
};

//

let bufferReusingBut = _.routine.unite( bufferReusing4Arguments_head, bufferReusingBut_body );

//

/**
 * Routine bufferReusingOnly() gets the part of source buffer {-src-} and copies it to destination buffer {-dst-}.
 *
 * Data in buffer {-dst-} overwrites. If {-dst-} container is not resizable and resulted length of destination
 * container is not equal to original {-dst-} length, then routine makes new container of {-dst-} type.
 *
 * If buffer {-dst-} and {-src-} are the same buffer, then routine tries to change container {-src-} inplace and
 * reuse original raw buffer.
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingOnly( buffer, [ 1, 1 ] );
 * console.log( got );
 * // log Float64Array[ 2 ]
 * console.log( got === buffer );
 * // log false
 * console.log( got.buffer === buffer.buffer );
 * // log false
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingOnly
 * ({
 *   dst : buffer,
 *   src : buffer,
 *   cinterval : [ 1, 1 ],
 *   minSize : 1,
 * });
 * console.log( got );
 * // log Float64Array[ 2 ]
 * console.log( got === buffer );
 * // log false
 * console.log( got.buffer === buffer.buffer );
 * // log true
 *
 * First parameter set :
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } src - The container from which makes a shallow copy.
 * @param { Interval|Number } cinterval - The closed interval that defines the start index and the end index for removing elements.
 * If {-cinterval-} is a Number, then it defines the index of removed element.
 * If cinterval[ 0 ] < 0, then start index sets to 0.
 * If cinterval[ 1 ] > src.length, end index sets to ( src.length - 1 ).
 * If cinterval[ 1 ] < cinterval[ 0 ], then routine makes buffer of minimal size and fills by data.
 *
 * Second parameter set :
 * @param { Aux } o - Options map.
 * @param { BufferAny|Long|Null } o.dst - The destination container.
 * @param { BufferAny|Long } o.src - The container from which makes a shallow copy.
 * @param { Interval|Number } o.cinterval - The closed interval that defines the start index and the end index for removing elements.
 * The behavior same to first parameter set.
 * @param { BoolLike } o.reusing - Allows routine to reuse original raw buffer. Default is true.
 * @param { BoolLike } o.offsetting - Allows routine to change offset in destination buffer {-o.dst-}. Default is true.
 * @param { Number } o.minSize - Minimal size of resulted buffer. If resulted buffer size is less than {-o.minSize-}, routine makes
 * new buffer. Default is 64.
 * @param { Number } o.shrinkFactor - If resulted buffer in {-o.shrinkFactor-} times less than its raw buffer, than routine makes
 * new buffer. If {-o.shrinkFactor-} <= 1, then routine not change original raw buffer. Default is 0.
 *
 * @returns { BufferAny|Long } - If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-src-} type.
 * If {-dst-} and {-src-} are the same container, routine tries to return original container.
 * Routine tries to save original raw buffer.
 * @function bufferReusingOnly
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} has not valid type.
 * @throws { Error } If {-src-} has not valid type.
 * @throws { Error } If {-cinterval-} has not valid type.
 * @throws { Error } If options map {-o-} has not valid type.
 * @throws { Error } If options map {-o-} has not known options.
 * @throws { Error } If {-o.minSize-} has not valid type or is not an Integer.
 * @throws { Error } If {-o.shrinkFactor-} has not valid type or is not an Integer.
 * @namespace Tools
 */

// function bufferReusingOnly( /* dst, src, cinterval */ )
// {
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   let o;
//   if( arguments.length === 3 )
//   {
//     o = Object.create( null );
//     o.dst = arguments[ 0 ];
//     o.src = arguments[ 1 ];
//     o.cinterval = arguments[ 2 ];
//   }
//   else
//   {
//     o = _._bufferReusing_head.apply( this, arguments );
//   }
//   _.assert( o.ins === undefined, 'Expects no argument {-ins-}' );
//
//   o.cinterval = cintervalClamp();
//
//   _.routine.options( bufferReusingOnly, o );
//   o.growFactor = 1;
//   o.bufferFill = dstBufferFill;
//
//   return _._bufferReusing( o );
//
//   /* */
//
//   function cintervalClamp()
//   {
//     let bufferLength = 0;
//     if( o.dst )
//     bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
//     else
//     bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;
//
//     if( o.cinterval === undefined )
//     o.cinterval = [ 0, bufferLength - 1 ];
//     else if( _.numberIs( o.cinterval ) )
//     o.cinterval = [ 0, o.cinterval ];
//
//     if( o.cinterval[ 0 ] < 0 )
//     o.cinterval[ 0 ] = 0;
//     if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
//     o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;
//     if( o.cinterval[ 1 ] > bufferLength - 1 )
//     o.cinterval[ 1 ] = bufferLength - 1;
//
//     return o.cinterval;
//   }
//
//   /* */
//
//   function dstBufferFill( /* dstTyped, srcTyped, cinterval */ )
//   {
//     let dstTyped = arguments[ 0 ];
//     let srcTyped = arguments[ 1 ];
//     let cinterval = arguments[ 2 ];
//
//     /* */
//
//     let left = Math.max( 0, cinterval[ 0 ] );
//     let right = Math.min( cinterval[ 1 ], srcTyped.length - 1 );
//     let i;
//     for( i = left ; i < right + 1 ; i++ )
//     dstTyped[ i - left ] = srcTyped[ i ];
//
//     if( _.arrayLikeResizable( dstTyped ) && i - left < dstTyped.length )
//     for( ; i - left < dstTyped.length; i++ )
//     dstTyped[ i - left ] = undefined;
//   }
// }
//
// bufferReusingOnly.defaults =
// {
//   dst : null,
//   src : null,
//   cinterval : null,
//   offsetting : 1,
//   reusing : 1,
//   shrinkFactor : 0,
//   minSize : 64,
// };

function bufferReusingOnly_body( o )
{
  _.assert( _.intIs( o.shrinkFactor ) && o.shrinkFactor >= 0 );

  o.cinterval = cintervalClamp();
  o.growFactor = 1;

  /* */

  let newBufferCreate = o.dst === null;

  _.assert( newBufferCreate || _.bufferAnyIs( o.dst ) || _.longIs( o.dst ) );

  let dstElementSize;
  if( newBufferCreate )
  o.dstElementSize = _._bufferElementSizeGet( o.src );
  else
  o.dstElementSize = _._bufferElementSizeGet( o.dst );

  o.dstSize = _._dstBufferSizeRecount( o );

  let dstBuffer
  if( o.reusing && !newBufferCreate )
  dstBuffer = _resultBufferReusedMaybe( o );
  else
  dstBuffer = _resultBufferMake( o );

  let dstTyped = _bufferTypedViewMake( dstBuffer );
  let srcTyped = _bufferTypedViewMake( o.src );
  let result = dstBufferFill( dstTyped, srcTyped, o.cinterval, o.ins );

  return dstBuffer;

  /* */

  function cintervalClamp()
  {
    let bufferLength = 0;
    if( o.dst )
    bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
    else
    bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;

    if( o.cinterval === null )
    o.cinterval = [ 0, bufferLength - 1 ];
    else if( _.number.is( o.cinterval ) )
    o.cinterval = [ 0, o.cinterval ];

    if( o.cinterval[ 0 ] < 0 )
    o.cinterval[ 0 ] = 0;
    if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
    o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;
    if( o.cinterval[ 1 ] > bufferLength - 1 )
    o.cinterval[ 1 ] = bufferLength - 1;

    return o.cinterval;
  }

  /* */

  function dstBufferFill( /* dstTyped, srcTyped, cinterval */ )
  {
    let dstTyped = arguments[ 0 ];
    let srcTyped = arguments[ 1 ];
    let cinterval = arguments[ 2 ];

    /* */

    let left = Math.max( 0, cinterval[ 0 ] );
    let right = Math.min( cinterval[ 1 ], srcTyped.length - 1 );
    let i;
    for( i = left ; i < right + 1 ; i++ )
    dstTyped[ i - left ] = srcTyped[ i ];

    if( _.arrayLikeResizable( dstTyped ) && i - left < dstTyped.length )
    for( ; i - left < dstTyped.length; i++ )
    dstTyped[ i - left ] = undefined;
  }
}

bufferReusingOnly_body.defaults =
{
  dst : null,
  src : null,
  cinterval : null,
  offsetting : 1,
  reusing : 1,
  shrinkFactor : 0,
  minSize : 64,
};

//

let bufferReusingOnly = _.routine.unite( bufferReusing3Arguments_head, bufferReusingOnly_body );

//

/**
 * Routine bufferReusingGrow() copies elements from source buffer {-src-} to grow destination buffer {-dst-}.
 * All original source buffer will contains in destination buffer.
 *
 * Data in buffer {-dst-} overwrites. If {-dst-} container is not resizable and resulted length of destination
 * container is not equal to original {-dst-} length, then routine makes new container of {-dst-} type.
 *
 * If buffer {-dst-} and {-src-} are the same buffer, then routine tries to change container {-src-} inplace and
 * reuse original raw buffer.
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingGrow( buffer, [ -1, 3 ], 7 );
 * console.log( got );
 * // log Float64Array[ 7, 1, 2, 3, 4, 7, 7, 7 ]
 * console.log( got === buffer );
 * // log false
 * console.log( got.buffer === buffer.buffer );
 * // log false
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingGrow
 * ({
 *   dst : buffer,
 *   src : buffer,
 *   cinterval : [ 0, 3 ],
 *   ins : 7,
 *   minSize : 2,
 * });
 * console.log( got );
 * // log Float64Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 * console.log( got.buffer === buffer.buffer );
 * // log true
 *
 * First parameter set :
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } src - The container from which makes a shallow copy.
 * @param { Interval|Number } cinterval - The closed interval that defines the start index and the end index for removing elements.
 * If {-cinterval-} is a Number, then it defines the index of removed element.
 * If cinterval[ 0 ] < 0, then insertion element prepends to buffer.
 * If cinterval[ 0 ] > 0, then cinterval[ 0 ] sets to 0.
 * If cinterval[ 1 ] < src.length, then cinterval[ 1 ] sets to ( src.length - 1 ).
 * If cinterval[ 1 ] > src.length, then insertion element appends to buffer.
 * If cinterval[ 1 ] < cinterval[ 0 ], then routine change not source buffer.
 * @param { * } ins - Insertion element with compatible type to destination buffer.
 *
 * Second parameter set :
 * @param { Aux } o - Options map.
 * @param { BufferAny|Long|Null } o.dst - The destination container.
 * @param { BufferAny|Long } o.src - The container from which makes a shallow copy.
 * @param { Interval|Number } o.cinterval - The closed interval that defines the start index and the end index for removing elements.
 * The behavior same to first parameter set.
 * @param { * } o.ins - Insertion element with compatible type to destination buffer.
 * @param { BoolLike } o.reusing - Allows routine to reuse original raw buffer. Default is true.
 * @param { BoolLike } o.offsetting - Allows routine to change offset in destination buffer {-o.dst-}. Default is true.
 * @param { Number } o.minSize - Minimal size of resulted buffer. If resulted buffer size is less than {-o.minSize-}, routine makes
 * new buffer. Default is 64.
 * @param { Number } o.growFactor - If routine needs to make new container that is bigger than {-o.minSize-}, then routine multiplies
 * {-o.growFactor-} on resulted buffer size. If {-o.growFactor-} <= 1, routine does not grow size of resulted buffer. Default is 2.
 *
 * @returns { BufferAny|Long } - If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-src-} type.
 * If {-dst-} and {-src-} are the same container, routine tries to return original container.
 * Routine tries to save original raw buffer.
 * @function bufferReusingGrow
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} has not valid type.
 * @throws { Error } If {-src-} has not valid type.
 * @throws { Error } If {-cinterval-} has not valid type.
 * @throws { Error } If {-ins-} has not valid type.
 * @throws { Error } If options map {-o-} has not valid type.
 * @throws { Error } If options map {-o-} has not known options.
 * @throws { Error } If {-o.minSize-} has not valid type or is not an Integer.
 * @throws { Error } If {-o.growFactor-} has not valid type or is not an Integer.
 * @namespace Tools
 */

// function bufferReusingGrow( /* dst, src, cinterval, ins */ )
// {
//   let o = _._bufferReusing_head.apply( this, arguments );
//
//   let srcLength = o.src.byteLength;
//   if( o.src.length !== undefined )
//   srcLength = o.src.length;
//   o.cinterval = cintervalClamp();
//
//   _.routine.options( bufferReusingGrow, o );
//
//   o.bufferFill = dstBufferFill;
//
//   return _._bufferReusing( o );
//
//   /* */
//
//   function cintervalClamp()
//   {
//     let bufferLength = 0;
//     if( o.dst )
//     bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
//     else
//     bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;
//
//     if( o.cinterval === undefined )
//     o.cinterval = [ 0, bufferLength - 1 ];
//     else if( _.numberIs( o.cinterval ) )
//     o.cinterval = [ 0, o.cinterval - 1 ];
//
//     if( o.cinterval[ 0 ] > 0 )
//     o.cinterval[ 0 ] = 0;
//     if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
//     o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;
//     if( o.cinterval[ 1 ] < bufferLength - 1 )
//     o.cinterval[ 1 ] = bufferLength - 1;
//
//     return o.cinterval;
//   }
//
//   /* */
//
//   function dstBufferFill( /* dstTyped, srcTyped, cinterval, ins */ )
//   {
//     let dstTyped = arguments[ 0 ];
//     let srcTyped = arguments[ 1 ];
//     let cinterval = arguments[ 2 ];
//     let ins = arguments[ 3 ];
//
//     /* */
//
//     let offset = Math.max( 0, -cinterval[ 0 ] );
//     let rightBound = Math.min( dstTyped.length, srcLength );
//     let length = dstTyped.length;
//
//     if( dstTyped !== srcTyped )
//     {
//       for( let i = offset ; i < rightBound + offset ; i++ )
//       dstTyped[ i ] = srcTyped[ i - offset ];
//     }
//
//     for( let i = 0 ; i < offset ; i++ )
//     dstTyped[ i ] = o.ins;
//
//     for( let i = offset + rightBound ; i < length ; i++ )
//     dstTyped[ i ] = o.ins;
//
//     return dstTyped;
//
//   }
// }
//
// bufferReusingGrow.defaults =
// {
//   dst : null,
//   src : null,
//   cinterval : null,
//   ins : null,
//   offsetting : 1,
//   reusing : 1,
//   growFactor : 2,
//   minSize : 64,
// };

function bufferReusingGrow_body( o )
{
  _.assert( _.intIs( o.growFactor ) && o.growFactor >= 0 );

  let srcLength = o.src.byteLength;
  if( o.src.length !== undefined )
  srcLength = o.src.length;
  o.cinterval = cintervalClamp();

  /* */

  let newBufferCreate = o.dst === null;

  _.assert( newBufferCreate || _.bufferAnyIs( o.dst ) || _.longIs( o.dst ) );

  let dstElementSize;
  if( newBufferCreate )
  o.dstElementSize = _._bufferElementSizeGet( o.src );
  else
  o.dstElementSize = _._bufferElementSizeGet( o.dst );

  o.dstSize = _._dstBufferSizeRecount( o );

  let dstBuffer
  if( o.reusing && !newBufferCreate )
  dstBuffer = _resultBufferReusedMaybe( o );
  else
  dstBuffer = _resultBufferMake( o );

  let dstTyped = _bufferTypedViewMake( dstBuffer );
  let srcTyped = _bufferTypedViewMake( o.src );
  let result = dstBufferFill( dstTyped, srcTyped, o.cinterval, o.ins );

  return dstBuffer;

  /* */

  function cintervalClamp()
  {
    let bufferLength = 0;
    if( o.dst )
    bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
    else
    bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;

    if( o.cinterval === null )
    o.cinterval = [ 0, bufferLength - 1 ];
    else if( _.number.is( o.cinterval ) )
    o.cinterval = [ 0, o.cinterval - 1 ];

    if( o.cinterval[ 0 ] > 0 )
    o.cinterval[ 0 ] = 0;
    if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
    o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;
    if( o.cinterval[ 1 ] < bufferLength - 1 )
    o.cinterval[ 1 ] = bufferLength - 1;

    return o.cinterval;
  }

  /* */

  function dstBufferFill( /* dstTyped, srcTyped, cinterval, ins */ )
  {
    let dstTyped = arguments[ 0 ];
    let srcTyped = arguments[ 1 ];
    let cinterval = arguments[ 2 ];
    let ins = arguments[ 3 ];

    /* */

    let offset = Math.max( 0, -cinterval[ 0 ] );
    let rightBound = Math.min( dstTyped.length, srcLength );
    let length = dstTyped.length;

    if( dstTyped !== srcTyped )
    {
      for( let i = offset ; i < rightBound + offset ; i++ )
      dstTyped[ i ] = srcTyped[ i - offset ];
    }

    for( let i = 0 ; i < offset ; i++ )
    dstTyped[ i ] = o.ins;

    for( let i = offset + rightBound ; i < length ; i++ )
    dstTyped[ i ] = o.ins;

    return dstTyped;

  }
}

bufferReusingGrow_body.defaults =
{
  dst : null,
  src : null,
  cinterval : null,
  ins : null,
  offsetting : 1,
  reusing : 1,
  growFactor : 2,
  minSize : 64,
};

//

let bufferReusingGrow = _.routine.unite( bufferReusing4Arguments_head, bufferReusingGrow_body );

//

/**
 * Routine bufferReusingRelength() copies elements from source buffer {-src-} to destination buffer {-dst-}.
 * Routine applies any offsets from Interval {-cinterval-}.
 *
 * Data in buffer {-dst-} overwrites. If {-dst-} container is not resizable and resulted length of destination
 * container is not equal to original {-dst-} length, then routine makes new container of {-dst-} type.
 *
 * If buffer {-dst-} and {-src-} are the same buffer, then routine tries to change container {-src-} inplace and
 * reuse original raw buffer.
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingRelength( buffer, [ -1, 3 ], 7 );
 * console.log( got );
 * // log Float64Array[ 7, 1, 2, 3, 4, 7, 7, 7 ]
 * console.log( got === buffer );
 * // log false
 * console.log( got.buffer === buffer.buffer );
 * // log false
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingRelength
 * ({
 *   dst : buffer,
 *   src : buffer,
 *   cinterval : [ 0, 3 ],
 *   ins : 7,
 *   minSize : 2,
 * });
 * console.log( got );
 * // log Float64Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 * console.log( got.buffer === buffer.buffer );
 * // log true
 *
 * First parameter set :
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } src - The container from which makes a shallow copy.
 * @param { Interval|Number } cinterval - The closed interval that defines the start index and the end index for removing elements.
 * If {-cinterval-} is a Number, then it defines the index of removed element.
 * If cinterval[ 0 ] < 0, then insertion element prepends to buffer.
 * If cinterval[ 0 ] > 0, then routine skips elements until index cinterval[ 0 ].
 * If cinterval[ 1 ] < src.length, routine shrinks buffer on right side.
 * If cinterval[ 1 ] > src.length, then insertion element appends to buffer.
 * If cinterval[ 1 ] < cinterval[ 0 ], then routine makes buffer with minimal size.
 * @param { * } ins - Insertion element with compatible type to destination buffer.
 *
 * Second parameter set :
 * @param { Aux } o - Options map.
 * @param { BufferAny|Long|Null } o.dst - The destination container.
 * @param { BufferAny|Long } o.src - The container from which makes a shallow copy.
 * @param { Interval|Number } o.cinterval - The closed interval that defines the start index and the end index for removing elements.
 * The behavior same to first parameter set.
 * @param { * } o.ins - Insertion element with compatible type to destination buffer.
 * @param { BoolLike } o.reusing - Allows routine to reuse original raw buffer. Default is true.
 * @param { BoolLike } o.offsetting - Allows routine to change offset in destination buffer {-o.dst-}. Default is true.
 * @param { Number } o.minSize - Minimal size of resulted buffer. If resulted buffer size is less than {-o.minSize-}, routine makes
 * new buffer. Default is 64.
 * @param { Number } o.growFactor - If routine needs to make new container that is bigger than {-o.minSize-}, then routine multiplies
 * {-o.growFactor-} on resulted buffer size. If {-o.growFactor-} <= 1, routine does not grow size of resulted buffer. Default is 2.
 * @param { Number } o.shrinkFactor - If resulted buffer in {-o.shrinkFactor-} times less than its raw buffer, than routine makes
 * new buffer. If {-o.shrinkFactor-} <= 1, then routine not change original raw buffer. Default is 0.
 *
 * @returns { BufferAny|Long } - If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-src-} type.
 * If {-dst-} and {-src-} are the same container, routine tries to return original container.
 * Routine tries to save original raw buffer.
 * @function bufferReusingRelength
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} has not valid type.
 * @throws { Error } If {-src-} has not valid type.
 * @throws { Error } If {-cinterval-} has not valid type.
 * @throws { Error } If {-ins-} has not valid type.
 * @throws { Error } If options map {-o-} has not valid type.
 * @throws { Error } If options map {-o-} has not known options.
 * @throws { Error } If {-o.minSize-} has not valid type or is not an Integer.
 * @throws { Error } If {-o.growFactor-} has not valid type or is not an Integer.
 * @throws { Error } If {-o.shrinkFactor-} has not valid type or is not an Integer.
 * @namespace Tools
 */

// function bufferReusingRelength( /* dst, src, cinterval, ins */ )
// {
//   let o = _._bufferReusing_head.apply( this, arguments );
//
//   let left, right;
//   let srcLength = o.src.byteLength;
//   if( o.src.length !== undefined )
//   srcLength = o.src.length;
//   o.cinterval = cintervalClamp();
//
//   _.routine.options( bufferReusingRelength, o );
//
//   o.bufferFill = dstBufferFill;
//
//   return _._bufferReusing( o );
//
//   /* */
//
//   function cintervalClamp()
//   {
//
//     let bufferLength = 0;
//     if( o.dst )
//     bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
//     else
//     bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;
//
//     if( o.cinterval === undefined )
//     o.cinterval = [ 0, bufferLength - 1 ];
//     else if( _.numberIs( o.cinterval ) )
//     o.cinterval = [ 0, o.cinterval - 1 ];
//
//     left = o.cinterval[ 0 ];
//     right = o.cinterval[ 1 ];
//
//     if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
//     o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;
//
//     return o.cinterval;
//   }
//
//   /* */
//
//   function dstBufferFill( /* dstTyped, srcTyped, cinterval, ins */ )
//   {
//     let dstTyped = arguments[ 0 ];
//     let srcTyped = arguments[ 1 ];
//     let cinterval = arguments[ 2 ];
//     let ins = arguments[ 3 ];
//
//     /* */
//
//     let offset = left < 0 ? Math.max( 0, -left ) : 0;
//     left = left < 0 ? 0 : left;
//     let rightBound = Math.min( srcTyped.length, right - left + 1 );
//     rightBound = Math.min( rightBound, srcLength );
//     let length = dstTyped.length;
//
//     let i;
//     for( i = offset ; i < rightBound + offset && i - offset + left < srcTyped.length ; i++ )
//     dstTyped[ i ] = srcTyped[ i - offset + left ];
//
//     if( i > srcLength + offset - left )
//     i = srcLength + offset - left;
//
//     for( ; i < length ; i++ )
//     dstTyped[ i ] = o.ins;
//
//     for( let i = 0 ; i < offset ; i++ )
//     dstTyped[ i ] = o.ins;
//
//     return dstTyped;
//
//   }
// }
//
// bufferReusingRelength.defaults =
// {
//   dst : null,
//   src : null,
//   cinterval : null,
//   ins : null,
//   offsetting : 1,
//   reusing : 1,
//   growFactor : 2,
//   shrinkFactor : 0,
//   minSize : 64,
// };

function bufferReusingRelength_body( o )
{
  _.assert( _.intIs( o.growFactor ) && o.growFactor >= 0 );
  _.assert( _.intIs( o.shrinkFactor ) && o.shrinkFactor >= 0 );

  let left, right;
  let srcLength = o.src.byteLength;
  if( o.src.length !== undefined )
  srcLength = o.src.length;
  o.cinterval = cintervalClamp();

  let newBufferCreate = o.dst === null;

  _.assert( newBufferCreate || _.bufferAnyIs( o.dst ) || _.longIs( o.dst ) );

  let dstElementSize;
  if( newBufferCreate )
  o.dstElementSize = _._bufferElementSizeGet( o.src );
  else
  o.dstElementSize = _._bufferElementSizeGet( o.dst );

  o.dstSize = _._dstBufferSizeRecount( o );

  let dstBuffer
  if( o.reusing && !newBufferCreate )
  dstBuffer = _resultBufferReusedMaybe( o );
  else
  dstBuffer = _resultBufferMake( o );

  let dstTyped = _bufferTypedViewMake( dstBuffer );
  let srcTyped = _bufferTypedViewMake( o.src );
  let result = dstBufferFill( dstTyped, srcTyped, o.cinterval, o.ins );

  return dstBuffer;

  /* */

  function cintervalClamp()
  {

    let bufferLength = 0;
    if( o.dst )
    bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
    else
    bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;

    if( o.cinterval === null )
    o.cinterval = [ 0, bufferLength - 1 ];
    else if( _.number.is( o.cinterval ) )
    o.cinterval = [ 0, o.cinterval - 1 ];

    left = o.cinterval[ 0 ];
    right = o.cinterval[ 1 ];

    if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
    o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;

    return o.cinterval;
  }

  /* */

  function dstBufferFill( /* dstTyped, srcTyped, cinterval, ins */ )
  {
    let dstTyped = arguments[ 0 ];
    let srcTyped = arguments[ 1 ];
    let cinterval = arguments[ 2 ];
    let ins = arguments[ 3 ];

    /* */

    let offset = left < 0 ? Math.max( 0, -left ) : 0;
    left = left < 0 ? 0 : left;
    let rightBound = Math.min( srcTyped.length, right - left + 1 );
    rightBound = Math.min( rightBound, srcLength );
    let length = dstTyped.length;

    let i;
    for( i = offset ; i < rightBound + offset && i - offset + left < srcTyped.length ; i++ )
    dstTyped[ i ] = srcTyped[ i - offset + left ];

    if( i > srcLength + offset - left )
    i = srcLength + offset - left;

    for( ; i < length ; i++ )
    dstTyped[ i ] = o.ins;

    for( let i = 0 ; i < offset ; i++ )
    dstTyped[ i ] = o.ins;

    return dstTyped;

  }
}

bufferReusingRelength_body.defaults =
{
  dst : null,
  src : null,
  cinterval : null,
  ins : null,
  offsetting : 1,
  reusing : 1,
  growFactor : 2,
  shrinkFactor : 0,
  minSize : 64,
};

//

let bufferReusingRelength = _.routine.unite( bufferReusing4Arguments_head, bufferReusingRelength_body );

//

/**
 * Routine bufferReusingResize() resizes raw buffer of source buffer {-src-} in interval {-cinterval-}.
 *
 * If destination buffer {-dst-} is provided, then routine copies data to the buffer byte per byte. Data in
 * buffer {-dst-} overwrites. If {-dst-} container is not resizable and resulted length of destination container
 * is not equal to original {-dst-} length, then routine makes new container of {-dst-} type.
 *
 * If buffer {-dst-} and {-src-} are the same buffer, then routine tries to change container {-src-} inplace and
 * reuse original raw buffer.
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingResize( buffer, buffer, [ 8, 32 ] );
 * console.log( got );
 * // log Float64Array[ 2, 3, 4 ]
 * console.log( got === buffer );
 * // log false
 * console.log( got.buffer === buffer.buffer );
 * // log true
 *
 * @example
 * let buffer = new F64x( [ 1, 2, 3, 4 ] );
 * let got = _.bufferReusingResize
 * ({
 *   dst : buffer,
 *   src : buffer,
 *   cinterval : [ 0, 32 ],
 *   ins : 7,
 *   minSize : 2,
 * });
 * console.log( got );
 * // log Float64Array[ 1, 2, 3, 4 ]
 * console.log( got === buffer );
 * // log true
 * console.log( got.buffer === buffer.buffer );
 * // log true
 *
 * First parameter set :
 * @param { BufferAny|Long|Null } dst - The destination container.
 * @param { BufferAny|Long } src - The container from which makes a shallow copy.
 * @param { Interval|Number } cinterval - The closed interval that defines the start index and the end index for removing elements.
 * If {-cinterval-} is a Number, then it defines the index of removed element.
 * If cinterval[ 0 ] < 0, then routine resizes buffer left.
 * If cinterval[ 0 ] > 0, then routine skips bytes until index cinterval[ 0 ].
 * If cinterval[ 1 ] < src size, routine shrinks buffer on right side.
 * If cinterval[ 1 ] > src size, then routine resizes buffer right.
 * If cinterval[ 1 ] < cinterval[ 0 ], then routine makes buffer with minimal size.
 *
 * Second parameter set :
 * @param { Aux } o - Options map.
 * @param { BufferAny|Long|Null } o.dst - The destination container.
 * @param { BufferAny|Long } o.src - The container from which makes a shallow copy.
 * @param { Interval|Number } o.cinterval - The closed interval that defines the start index and the end index for removing elements.
 * The behavior same to first parameter set.
 * @param { BoolLike } o.reusing - Allows routine to reuse original raw buffer. Default is true.
 * @param { BoolLike } o.offsetting - Allows routine to change offset in destination buffer {-o.dst-}. Default is true.
 * @param { Number } o.minSize - Minimal size of resulted buffer. If resulted buffer size is less than {-o.minSize-}, routine makes
 * new buffer. Default is 64.
 * @param { Number } o.growFactor - If routine needs to make new container that is bigger than {-o.minSize-}, then routine multiplies
 * {-o.growFactor-} on resulted buffer size. If {-o.growFactor-} <= 1, routine does not grow size of resulted buffer. Default is 2.
 * @param { Number } o.shrinkFactor - If resulted buffer in {-o.shrinkFactor-} times less than its raw buffer, than routine makes
 * new buffer. If {-o.shrinkFactor-} <= 1, then routine not change original raw buffer. Default is 0.
 *
 * @returns { BufferAny|Long } - If {-dst-} is provided, routine returns container of {-dst-} type.
 * Otherwise, routine returns container of {-src-} type.
 * If {-dst-} and {-src-} are the same container, routine tries to return original container.
 * Routine tries to save original raw buffer.
 * @function bufferReusingResize
 * @throws { Error } If arguments.length is less then one or more then four.
 * @throws { Error } If {-dst-} has not valid type.
 * @throws { Error } If {-src-} has not valid type.
 * @throws { Error } If {-cinterval-} has not valid type.
 * @throws { Error } If options map {-o-} has not valid type.
 * @throws { Error } If options map {-o-} has not known options.
 * @throws { Error } If {-o.minSize-} has not valid type or is not an Integer.
 * @throws { Error } If {-o.growFactor-} has not valid type or is not an Integer.
 * @throws { Error } If {-o.shrinkFactor-} has not valid type or is not an Integer.
 * @namespace Tools
 */

// function bufferReusingResize( /* dst, src, cinterval */ )
// {
//   _.assert( 1 <= arguments.length && arguments.length <= 3 );
//
//   let o;
//   if( arguments.length === 3 )
//   {
//     o = Object.create( null );
//     o.dst = arguments[ 0 ];
//     o.src = arguments[ 1 ];
//     o.cinterval = arguments[ 2 ];
//   }
//   else
//   {
//     o = _._bufferReusing_head.apply( this, arguments );
//   }
//
//   _.assert( _.bufferAnyIs( o.src ), 'Expects buffer {-src-}' );
//
//   let left, right;
//   o.cinterval = cintervalClamp();
//
//   _.routine.options( bufferReusingResize, o );
//
//   o.bufferSizeCount = bufferSizeCount;
//   o.bufferFill = dstBufferFill;
//
//   return _._bufferReusing( o );
//
//   /* */
//
//   function cintervalClamp()
//   {
//     let bufferLength = 0;
//     if( o.dst )
//     bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
//     else
//     bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;
//
//     if( o.cinterval === undefined )
//     o.cinterval = [ 0, bufferLength - 1 ];
//     else if( _.numberIs( o.cinterval ) )
//     o.cinterval = [ 0, o.cinterval - 1 ];
//
//     left = o.cinterval[ 0 ];
//     right = o.cinterval[ 1 ];
//
//     if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
//     o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;
//
//     return o.cinterval;
//   }
//
//   /* */
//
//   function bufferSizeCount( cinterval, elementSize )
//   {
//     return cinterval[ 1 ] - cinterval[ 0 ] + 1;
//   }
//
//   /* */
//
//   function dstBufferFill( /* dstTyped, srcTyped, cinterval, ins */ )
//   {
//     let dstTyped = arguments[ 0 ];
//     let srcTyped = arguments[ 1 ];
//     let cinterval = arguments[ 2 ];
//     let ins = arguments[ 3 ];
//
//     /* */
//
//     if( srcTyped === dstTyped )
//     return dstTyped;
//
//     if( _.bufferAnyIs( dstTyped ) )
//     dstTyped = _.bufferBytesFrom( dstTyped.buffer ? dstTyped.buffer : dstTyped );
//
//     let srcBytesView = srcTyped;
//     if( _.bufferAnyIs( srcTyped ) )
//     srcBytesView = _.bufferBytesFrom( srcTyped.buffer ? srcTyped.buffer : srcTyped );
//
//     let offset = srcTyped.byteOffset ? srcTyped.byteOffset : 0;
//     offset += left;
//
//     let length = right - left + 1;
//     if( dstTyped.buffer === srcTyped.buffer )
//     {
//       dstTyped = new dstTyped.constructor( dstTyped.buffer, offset, length );
//     }
//     else
//     {
//       for( let i = 0; i < dstTyped.length && i < length ; i++ )
//       dstTyped[ i ] = srcBytesView[ offset + i ] ? srcBytesView[ offset + i ] : 0;
//     }
//
//     return dstTyped;
//
//   }
// }
//
// bufferReusingResize.defaults =
// {
//   dst : null,
//   src : null,
//   cinterval : null,
//   offsetting : 1,
//   reusing : 1,
//   growFactor : 2,
//   shrinkFactor : 0,
//   minSize : 64,
// };


function bufferReusingResize_body( o )
{
  _.assert( _.intIs( o.shrinkFactor ) && o.shrinkFactor >= 0 );
  _.assert( _.intIs( o.growFactor ) && o.growFactor >= 0 );
  _.assert( _.bufferAnyIs( o.src ), 'Expects buffer {-src-}' );

  let left, right;
  o.cinterval = cintervalClamp();

  let newBufferCreate = o.dst === null;

  _.assert( newBufferCreate || _.bufferAnyIs( o.dst ) || _.longIs( o.dst ) );

  let dstElementSize;
  if( newBufferCreate )
  o.dstElementSize = _._bufferElementSizeGet( o.src );
  else
  o.dstElementSize = _._bufferElementSizeGet( o.dst );

  o.dstSize = bufferSizeCount( o.cinterval );
  o.dstSize = _._dstBufferSizeRecount( o );

  let dstBuffer
  if( o.reusing && !newBufferCreate )
  dstBuffer = _resultBufferReusedMaybe( o );
  else
  dstBuffer = _resultBufferMake( o );

  let dstTyped = _bufferTypedViewMake( dstBuffer );
  let srcTyped = _bufferTypedViewMake( o.src );
  let result = dstBufferFill( dstTyped, srcTyped, o.cinterval, o.ins );

  return dstBuffer;

  /* */

  function cintervalClamp()
  {
    let bufferLength = 0;
    if( o.dst )
    bufferLength = o.dst && o.dst.length !== undefined ? o.dst.length : o.dst.byteLength;
    else
    bufferLength = o.src.length === undefined ? o.src.byteLength : o.src.length;

    if( o.cinterval === null )
    o.cinterval = [ 0, bufferLength - 1 ];
    else if( _.number.is( o.cinterval ) )
    o.cinterval = [ 0, o.cinterval - 1 ];

    left = o.cinterval[ 0 ];
    right = o.cinterval[ 1 ];

    if( o.cinterval[ 1 ] < o.cinterval[ 0 ] - 1 )
    o.cinterval[ 1 ] = o.cinterval[ 0 ] - 1;

    return o.cinterval;
  }

  /* */

  function bufferSizeCount( cinterval )
  {
    return cinterval[ 1 ] - cinterval[ 0 ] + 1;
  }

  /* */

  function dstBufferFill( /* dstTyped, srcTyped, cinterval, ins */ )
  {
    let dstTyped = arguments[ 0 ];
    let srcTyped = arguments[ 1 ];
    let cinterval = arguments[ 2 ];
    let ins = arguments[ 3 ];

    /* */

    if( srcTyped === dstTyped )
    return dstTyped;

    if( _.bufferAnyIs( dstTyped ) )
    dstTyped = _.bufferBytesFrom( dstTyped.buffer ? dstTyped.buffer : dstTyped );

    let srcBytesView = srcTyped;
    if( _.bufferAnyIs( srcTyped ) )
    srcBytesView = _.bufferBytesFrom( srcTyped.buffer ? srcTyped.buffer : srcTyped );

    let offset = srcTyped.byteOffset ? srcTyped.byteOffset : 0;
    offset += left;

    let length = right - left + 1;
    if( dstTyped.buffer === srcTyped.buffer )
    {
      dstTyped = new dstTyped.constructor( dstTyped.buffer, offset, length );
    }
    else
    {
      for( let i = 0; i < dstTyped.length && i < length ; i++ )
      dstTyped[ i ] = srcBytesView[ offset + i ] ? srcBytesView[ offset + i ] : 0;
    }

    return dstTyped;

  }
}

bufferReusingResize_body.defaults =
{
  dst : null,
  src : null,
  cinterval : null,
  offsetting : 1,
  reusing : 1,
  growFactor : 2,
  shrinkFactor : 0,
  minSize : 64,
};

//

let bufferReusingResize = _.routine.unite( bufferReusing3Arguments_head, bufferReusingResize_body );

//

/**
 * The routine bufferBytesGet() converts source buffer {-src-} and returns a new instance of buffer U8x ( array of 8-bit unsigned integers ).
 *
 * @param { BufferRaw|BufferNode|BufferTyped|BufferView|String } src - Instance of any buffer or string.
 *
 * @example
 * let src = new BufferRaw( 5 );
 * _.bufferBytesGet(src);
 * // returns [ 0, 0, 0, 0, 0, ]
 *
 * @example
 * let src = BufferNode.alloc( 5, 'a' );
 * _.bufferBytesGet(src);
 * // returns [ 97, 97, 97, 97, 97 ]
 *
 * @example
 * let src = new I32x( [ 5, 6, 7 ] );
 * _.bufferBytesGet(src);
 * // returns [ 5, 0, 6, 0, 7, 0 ]
 *
 * @example
 * let src = 'string';
 * _.bufferBytesGet(src);
 * // returns [ 115, 116, 114, 105, 110, 103 ]
 *
 * @returns { TypedArray } Returns a new instance of U8x constructor.
 * @function bufferBytesGet
 * @throws { Error } If arguments.length is less or more than 1.
 * @throws { Error } If {-src-} is not a instance of any buffer or string.
 * @memberof wTools
 */

function bufferBytesGet( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( src instanceof BufferRaw || src instanceof BufferRawShared )
  {
    return new U8x( src );
  }
  else if( typeof BufferNode !== 'undefined' && src instanceof BufferNode )
  {
    return new U8x( src.buffer, src.byteOffset, src.byteLength );
  }
  else if( _.bufferTypedIs( src ) )
  {
    return new U8x( src.buffer, src.byteOffset, src.byteLength );
  }
  else if( _.bufferViewIs( src ) )
  {
    return new U8x( src.buffer, src.byteOffset, src.byteLength );
  }
  else if( _.strIs( src ) )
  {
    if( _global_.BufferNode )
    return new U8x( _.bufferRawFrom( BufferNode.from( src, 'utf8' ) ) );
    else
    return new U8x( _.encode.utf8ToBuffer( src ) ); /* Dmytro : maybe it should have some improvement, base module should not use higher level modules */
  }
  else _.assert( 0, 'wrong argument' );

}

//

/**
 * The bufferRetype() routine converts and returns a new instance of (bufferType) constructor.
 *
 * @param { typedArray } src - The typed array.
 * @param { typedArray } bufferType - The type of typed array.
 *
 * @example
 * let view1 = new I8x( [ 1, 2, 3, 4, 5, 6 ] );
 * _.bufferRetype(view1, I16x);
 * // returns [ 513, 1027, 1541 ]
 *
 * @example
 * let view2 = new I16x( [ 513, 1027, 1541 ] );
 * _.bufferRetype(view2, I8x);
 * // returns [ 1, 2, 3, 4, 5, 6 ]
 *
 * @returns { typedArray } Returns a new instance of (bufferType) constructor.
 * @function bufferRetype
 * @throws { Error } Will throw an Error if {-srcMap-} is not a typed array object.
 * @throws { Error } Will throw an Error if (bufferType) is not a type of the typed array.
 * @namespace Tools
 */

function bufferRetype( src, bufferType )
{

  _.assert( arguments.length === 2, 'Expects source buffer {-src-} and constructor of buffer {-bufferTyped-}' );
  _.assert( _.bufferTypedIs( src ) );
  _.assert( _.constructorIsBuffer( bufferType ) );

  let o = src.byteOffset;
  let l = Math.floor( src.byteLength / bufferType.BYTES_PER_ELEMENT );
  let result = new bufferType( src.buffer, o, l );

  return result;
}

//

function bufferJoin()
{

  if( arguments.length < 2 )
  {
    _.assert( _.bufferAnyIs( arguments[ 0 ] ) || !arguments[ 0 ] );
    return arguments[ 0 ] || null;
  }

  let srcs = [];
  let size = 0;
  let firstSrc;
  for( let s = 0 ; s < arguments.length ; s++ )
  {
    let src = arguments[ s ];

    if( src === null )
    continue;

    if( !firstSrc )
    firstSrc = src;

    if( _.bufferRawIs( src ) )
    {
      srcs.push( new U8x( src ) );
    }
    else if( src instanceof U8x )
    {
      srcs.push( src );
    }
    else
    {
      srcs.push( new U8x( src.buffer, src.byteOffset, src.byteLength ) );
    }

    _.assert( src.byteLength >= 0, 'Expects buffers, but got', _.entity.strType( src ) );

    size += src.byteLength;
  }

  if( srcs.length === 0 )
  return null;

  /* */

  let resultBuffer = new BufferRaw( size );
  let result = _.bufferRawIs( firstSrc ) ? resultBuffer : new firstSrc.constructor( resultBuffer );
  let resultBytes = result.constructor === U8x ? result : new U8x( resultBuffer );

  /* */

  let offset = 0;
  for( let s = 0 ; s < srcs.length ; s++ )
  {
    let src = srcs[ s ];
    if( resultBytes.set )
    {
      resultBytes.set( src, offset );
    }
    else
    {
      for( let i = 0 ; i < src.length ; i++ )
      resultBytes[ offset+i ] = src[ i ];
    }
    offset += src.byteLength;
  }

  return result;
}

//

function bufferMove( dst, src )
{

  if( arguments.length === 2 )
  {

    _.assert( _.longIs( dst ) );
    _.assert( _.longIs( src ) );

    if( dst.length !== src.length )
    throw _.err( '_.bufferMove :', '"dst" and "src" must have same length' );

    if( dst.set && ( src instanceof U64x || src instanceof I64x ) )
    {
      for( let s = 0 ; s < src.length ; s++ )
      dst[ s ] = Number( src[ s ] );
    }
    else if( dst.set && ( dst instanceof U64x || dst instanceof I64x ) )
    {
      dst.set( _.bigInt.s.from( src ) );
    }
    else if( dst.set )
    {
      dst.set( src );
    }
    else
    {
      for( let s = 0 ; s < src.length ; s++ )
      dst[ s ] = src[ s ];
    }

  }
  else if( arguments.length === 1 )
  {

    let options = arguments[ 0 ];
    _.map.assertHasOnly( options, bufferMove.defaults );

    src = options.src;
    dst = options.dst;

    if( _.bufferRawIs( dst ) )
    {
      dst = new U8x( dst );
      if( _.bufferTypedIs( src ) && !( src instanceof U8x ) )
      src = new U8x( src.buffer, src.byteOffset, src.byteLength );
    }

    _.assert( _.longIs( dst ) );
    _.assert( _.longIs( src ) );

    options.dstOffset = options.dstOffset || 0;

    if( dst.set && ( src instanceof U64x || src instanceof I64x ) )
    {
      for( let s = 0, d = options.dstOffset ; s < src.length ; s++, d++ )
      dst[ d ] = Number( src[ s ] );
    }
    else if( dst.set && ( dst instanceof U64x || dst instanceof I64x ) )
    {
      dst.set( _.bigInt.s.from( src ), options.dstOffset );
    }
    else if( dst.set )
    {
      dst.set( src, options.dstOffset );
    }
    else
    {
      for( let s = 0, d = options.dstOffset ; s < src.length ; s++, d++ )
      dst[ d ] = src[ s ];
    }

  }
  else _.assert( 0, 'unexpected' );

  return dst;
}

bufferMove.defaults =
{
  dst : null,
  src : null,
  dstOffset : null,
}

//

function bufferToStr( src )
{
  let result = '';

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.bufferAnyIs( src ) );

  if( typeof BufferNode !== 'undefined' )
  src = _.bufferNodeFrom( src );
  else if( src instanceof BufferRaw )
  src = new U8x( src, 0, src.byteLength );

  if( _.bufferNodeIs( src ) )
  return src.toString( 'utf8' );

  try
  {
    result = String.fromCharCode.apply( null, src );
  }
  catch( e )
  {
    for( let i = 0 ; i < src.byteLength ; i++ )
    {
      result += String.fromCharCode( src[ i ] );
    }
  }

  return result;
}

//

function bufferToDom( xmlBuffer )
{
  let result;

  if( typeof DOMParser !== 'undefined' && DOMParser.prototype.parseFromBuffer )
  {

    let parser = new DOMParser();
    result = parser.parseFromBuffer( xmlBuffer, xmlBuffer.byteLength, 'text/xml' );
    throw _.err( 'not tested' );

  }
  else
  {

    let xmlStr = _.bufferToStr( xmlBuffer );
    result = this.strToDom( xmlStr );

  }

  return result;
}

//

function bufferLeft( src, ins )
{

  if( !_.bufferRawIs( src ) )
  src = _.bufferBytesGet( src );

  if( !_.bufferRawIs( ins ) )
  ins = _.bufferBytesGet( ins );

  _.assert( _.routine.is( src.indexOf ) );
  _.assert( _.routine.is( ins.indexOf ) );

  let index = src.indexOf( ins[ 0 ] );
  while( index !== -1 )
  {
    let i = 0;
    for( ; i < ins.length ; i++ )
    if( src[ index + i ] !== ins[ i ] )
    break;

    if( i === ins.length )
    return index;

    index += 1;
    index = src.indexOf( ins[ 0 ], index );

  }

  return index;
}

//

function bufferRight( src, ins )
{

  if( !_.bufferRawIs( src ) )
  src = _.bufferBytesGet( src );

  if( !_.bufferRawIs( ins ) )
  ins = _.bufferBytesGet( ins );

  _.assert( _.routine.is( src.indexOf ) );
  _.assert( _.routine.is( ins.indexOf ) );

  let index = src.lastIndexOf( ins[ 0 ] );
  while( index !== -1 )
  {

    let i = 0;
    for( ; i < ins.length; i++ )
    if( src[ index + i ] !== ins[ i ] )
    break;

    if( i === ins.length )
    return index;

    index -= 1;
    index = src.lastIndexOf( ins[ 0 ], index );

  }

  return index;
}

//

function bufferSplit( src, del )
{

  if( !_.bufferRawIs( src ) )
  src = _.bufferBytesGet( src );

  if( !_.bufferRawIs( del ) )
  del = _.bufferBytesGet( del );

  _.assert( _.routine.is( src.indexOf ) );
  _.assert( _.routine.is( del.indexOf ) );

  let result = [];
  let begin = 0;
  let index = src.indexOf( del[ 0 ] );
  while( index !== -1 )
  {

    for( let i = 0 ; i < del.length ; i++ )
    if( src[ index+i ] !== del[ i ] )
    break;

    if( i === del.length )
    {
      result.push( src.slice( begin, index ) );
      index += i;
      begin = index;
    }
    else
    {
      index += 1;
    }

    index = src.indexOf( del[ 0 ], index );

  }

  if( begin === 0 )
  result.push( src );
  else
  result.push( src.slice( begin, src.length ) );

  return result;
}

//

function bufferCutOffLeft( src, del )
{

  if( !_.bufferRawIs( src ) )
  src = _.bufferBytesGet( src );

  if( !_.bufferRawIs( del ) )
  del = _.bufferBytesGet( del );

  _.assert( _.routine.is( src.indexOf ) );
  _.assert( _.routine.is( del.indexOf ) );

  let result = [];
  let index = src.indexOf( del[ 0 ] );
  while( index !== -1 )
  {

    for( let i = 0 ; i < del.length ; i++ )
    if( src[ index+i ] !== del[ i ] )
    break;

    if( i === del.length )
    {
      result.push( src.slice( 0, index ) );
      result.push( src.slice( index, index+i ) );
      result.push( src.slice( index+i, src.length ) );
      return result;
    }
    else
    {
      index += 1;
    }

    index = src.indexOf( del[ 0 ], index );

  }

  result.push( null );
  result.push( null );
  result.push( src );

  return result;
}

//

function bufferIsolate_head( routine, args )
{
  let o;

  if( args.length > 1 )
  {
    if( args.length === 3 )
    o = { src : args[ 0 ], delimeter : args[ 1 ], times : args[ 2 ] };
    else if( args.length === 2 )
    o = { src : args[ 0 ], delimeter : args[ 1 ] };
    else
    o = { src : args[ 0 ] };
  }
  else
  {
    o = args[ 0 ];
    _.assert( args.length === 1, 'Expects single argument' );
  }

  _.routine.options( routine, o );
  _.assert( 1 <= args.length && args.length <= 3 );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.bufferAnyIs( o.src ) || _.strIs( o.src ) );
  _.assert( _.bufferAnyIs( o.delimeter ) || _.strIs( o.delimeter ) );
  _.assert( _.number.is( o.times ) );

  return o;
}

//

function bufferIsolate_body( o )
{
  _.routine.assertOptions( bufferIsolate_body, arguments );

  let src = o.src;
  if( _.strIs( o.src ) )
  src = o.src = _.bufferBytesGet( o.src );
  if( !_.bufferTypedIs( o.src ) )
  src = _.bufferBytesGet( o.src );

  let delimeter = o.delimeter;
  if( _.strIs( o.delimeter ) || !_.bufferTypedIs( o.delimeter ) )
  delimeter = _.bufferBytesGet( o.delimeter );

  delimeter = _.bufferRetype( delimeter, src.constructor );

  _.assert( _.routine.is( src.indexOf ) );
  _.assert( _.routine.is( delimeter.indexOf ) );

  let result = [];
  let times = o.times;
  let index = o.left ? 0 : src.length;
  let more = o.left ? bufferLeft : bufferRight;

  /* */

  while( times > 0 )
  {
    index = more( index );

    if( index === -1 )
    break;

    times -= 1;

    if( times === 0 )
    {
      if( o.src.constructor === src.constructor )
      {
        let del = delimeter;
        result.push( o.src.subarray( 0, index ) );
        result.push( new o.src.constructor( del.buffer, del.byteOffset, del.byteLength / ( o.src.BYTES_PER_ELEMENT || 1 ) ) );
        result.push( o.src.subarray( index + delimeter.length ) );
      }
      else
      {
        if( o.src.constructor === BufferRaw )
        {
          result.push( o.src.slice( 0, index ) );
          result.push( delimeter.buffer.slice( delimeter.byteOffset, delimeter.byteOffset + delimeter.byteLength ) );
          result.push( o.src.slice( index + delimeter.length, src.byteLength ) );
        }
        else
        {
          let del = delimeter;
          result.push( new o.src.constructor( o.src.buffer, o.src.byteOffset, index ) );
          result.push( new o.src.constructor( del.buffer, del.byteOffset, del.byteLength / ( o.src.BYTES_PER_ELEMENT || 1 ) ) );
          let secondOffset = src.byteOffset + index * ( o.src.BYTES_PER_ELEMENT || 1 ) + delimeter.length;
          result.push( new o.src.constructor( o.src.buffer, secondOffset, o.src.byteOffset + src.byteLength - secondOffset ) );
        }
      }
      return result;
    }

    /* */

    if( o.left )
    {
      index = index + 1;
      if( index >= src.length )
      break;
    }
    else
    {
      index = index - 1;
      if( index <= 0 )
      break;
    }

  }

  /* */

  if( !result.length )
  {
    if( o.times === 0 )
    return everything( !o.left );
    else if( times === o.times )
    return everything( o.left ^ o.none );
    else
    return everything( o.left );
  }

  return result;

  /* */

  function everything( side )
  {
    let empty = new U8x( 0 ).buffer;
    return ( side ) ? [ o.src, undefined, new o.src.constructor( empty ) ] : [ new o.src.constructor( empty ), undefined, o.src ];
  }

  /* */

  function bufferLeft( index )
  {
    index = src.indexOf( delimeter[ 0 ], index );
    while( index !== -1 )
    {
      let i = 0;
      for( ; i < delimeter.length; i++ )
      if( src[ index + i ] !== delimeter[ i ] )
      break;

      if( i === delimeter.length )
      return index;

      index += 1;
      index = src.indexOf( delimeter[ 0 ], index );
    }
    return index;
  }

  /* */

  function bufferRight( index )
  {
    index = src.lastIndexOf( delimeter[ 0 ], index );
    while( index !== -1 )
    {
      let i = 0;
      for( ; i < delimeter.length; i++ )
      if( src[ index + i ] !== delimeter[ i ] )
      break;

      if( i === delimeter.length )
      return index;

      index -= 1;
      index = src.lastIndexOf( delimeter[ 0 ], index );
    }
    return index;
  }
}

bufferIsolate_body.defaults =
{
  src : null,
  delimeter : ' ',
  left : 1,
  times : 1,
  none : 1,
};

//

let bufferIsolate = _.routine.unite( bufferIsolate_head, bufferIsolate_body );

//

function bufferIsolateLeftOrNone_body( o )
{
  o.left = 1;
  o.none = 1;
  let result = _.bufferIsolate.body( o );
  return result;
}

bufferIsolateLeftOrNone_body.defaults =
{
  src : null,
  delimeter : ' ',
  times : 1,
};

let bufferIsolateLeftOrNone = _.routine.unite( bufferIsolate_head, bufferIsolateLeftOrNone_body );

//

function bufferIsolateLeftOrAll_body( o )
{
  o.left = 1;
  o.none = 0;
  let result = _.bufferIsolate.body( o );
  return result;
}

bufferIsolateLeftOrAll_body.defaults =
{
  src : null,
  delimeter : ' ',
  times : 1,
};

let bufferIsolateLeftOrAll = _.routine.unite( bufferIsolate_head, bufferIsolateLeftOrAll_body );

//

function bufferIsolateRightOrNone_body( o )
{
  o.left = 0;
  o.none = 1;
  let result = _.bufferIsolate.body( o );
  return result;
}

bufferIsolateRightOrNone_body.defaults =
{
  src : null,
  delimeter : ' ',
  times : 1,
};

let bufferIsolateRightOrNone = _.routine.unite( bufferIsolate_head, bufferIsolateRightOrNone_body );

//

function bufferIsolateRightOrAll_body( o )
{
  o.left = 0;
  o.none = 0;
  let result = _.bufferIsolate.body( o );
  return result;
}

bufferIsolateRightOrAll_body.defaults =
{
  src : null,
  delimeter : ' ',
  times : 1,
};

let bufferIsolateRightOrAll = _.routine.unite( bufferIsolate_head, bufferIsolateRightOrAll_body );

// --
// declaration
// --

let BufferExtension =
{
}

Object.assign( _.buffer, BufferExtension );

//

let ToolsExtension =
{

  bufferRelen, /* xxx : investigate */

  bufferBut_,
  bufferOnly_,
  bufferGrow_,
  bufferRelength_,
  bufferResize_,

  //

  // _bufferReusing_head,
  // _bufferReusing,
  bufferReusing4Arguments_head,
  bufferReusing3Arguments_head,
  _bufferElementSizeGet,
  _dstBufferSizeRecount,
  _bufferTypedViewMake,
  _resultBufferReusedMaybe,
  _resultBufferMake,
  bufferReusingBut,
  bufferReusingOnly,
  bufferReusingGrow,
  bufferReusingRelength,
  bufferReusingResize,

  //

  bufferBytesGet,
  bufferRetype,

  bufferJoin, /* qqq for Dmytro : look, analyze and cover _.longJoin */

  bufferMove,
  bufferToStr,
  bufferToDom, /* qqq for Dmytro : move out to DomTools */

  bufferLeft,
  bufferRight,
  bufferSplit,
  bufferCutOffLeft,

  bufferIsolate,
  bufferIsolateLeftOrNone,
  bufferIsolateLeftOrAll,
  bufferIsolateRightOrNone,
  bufferIsolateRightOrAll,

  // buffersSerialize, /* deprecated */
  // buffersDeserialize, /* deprecated */

  // to replace

  /*
  | routine           | makes new dst container                        | saves dst container                                        |
  | ----------------- | ---------------------------------------------- | ---------------------------------------------------------- |
  | bufferBut_        | _.bufferBut_( src, range )                     | _.bufferBut_( src )                                        |
  |                   | if src is not resizable and  change length     | _.bufferBut_( dst, dst )                                   |
  |                   | _.bufferBut_( null, src, range )               | _.bufferBut_( dst, dst, range ) if dst is resizable        |
  |                   | _.bufferBut_( dst, src, range )                | or dst not change length                                   |
  |                   | if dst not resizable and change length         | _.bufferBut_( dst, src, range ) if dst is resizable        |
  |                   |                                                | or dst not change length                                   |
  | ----------------- | ---------------------------------------------- | ---------------------------------------------------------- |
  | bufferOnly__    | _.bufferOnly__( src, range )                 | _.bufferOnly__( src )                                    |
  |                   | if src is not resizable and  change length     | _.bufferOnly__( dst, dst )                               |
  |                   | _.bufferOnly__( null, src, range )           | _.bufferOnly__( dst, dst, range ) if dst is resizable    |
  |                   | _.bufferOnly__( dst, src, range )            | or dst not change length                                   |
  |                   | if dst not resizable and change length         | _.bufferOnly__( dst, src, range ) if dst is resizable    |
  |                   |                                                | or dst not change length                                   |
  | ----------------- | ---------------------------------------------- | ---------------------------------------------------------- |
  | bufferGrow_       | _.bufferGrow_( src, range )                    | _.bufferGrow_( src )                                       |
  |                   | if src is not resizable and  change length     | _.bufferGrow_( dst, dst )                                  |
  |                   | _.bufferGrow_( null, src, range )              | _.bufferGrow_( dst, dst, range ) if dst is resizable       |
  |                   | _.bufferGrow_( dst, src, range )               | or dst not change length                                   |
  |                   | if dst not resizable and change length         | _.bufferGrow_( dst, src, range ) if dst is resizable       |
  |                   |                                                | or dst not change length                                   |
  | ----------------- | ---------------------------------------------- | ---------------------------------------------------------- |
  | bufferRelength_   | _.bufferRelength_( src, range )                | _.bufferRelength_( src )                                   |
  |                   | if src is not resizable and  change length     | _.bufferRelength_( dst, dst )                              |
  |                   | _.bufferRelength_( null, src, range )          | _.bufferRelength_( dst, dst, range ) if dst is resizable   |
  |                   | _.bufferRelength_( dst, src, range )           | or dst not change length                                   |
  |                   | if dst not resizable and change length         | _.bufferRelength_( dst, src, range ) if dst is resizable   |
  |                   |                                                | or dst not change length                                   |
  | ----------------- | ---------------------------------------------- | ---------------------------------------------------------- |
  | bufferResize_     | _.bufferResize_( null, src, size )             | _.bufferResize_( src, size )                               |
  | bufferResize_     | every time                                     | if src is not BufferRaw or buffer not changes length       |
  |                   | _.bufferResize_( src, size )                   | _.bufferResize_( dst, dst, size ) if buffer not changes    |
  |                   | if src is BufferRaw or buffer changes length   | _.bufferResize_( dst, src, size )                          |
  |                   | _.bufferResize_( dst, src, range )             | if dst.byteLength >= size                                  |
  |                   | if dst.byteLength < size                       |                                                            |
  | ----------------- | ---------------------------------------------- | ---------------------------------------------------------- |
  */

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Buffer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Buffer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Buffer_s */ })();

/* */  /* begin of file Constructible_s */ ( function Constructible_s() { function Constructible_s_naked() { ( function _l7_Constructible_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.constructible = _.constructible || Object.create( null );

// --
// dichotomy
// --

// --
// extension
// --

let Extension =
{
}

//

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Constructible.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Constructible_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Constructible_s */ })();

/* */  /* begin of file Container_s */ ( function Container_s() { function Container_s_naked() { ( function _l7_Container_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function extendReplacing( dst, src )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( dst === null || dst === undefined )
  {

    if( _.aux.is( src ) )
    dst = _.props.extend( null, src );
    else if( _.longLike( src ) )
    dst = _.arrayExtendAppending( null, src );
    else if( _.hashMap.like( src ) )
    dst = _.hashMap.extend( null, src );
    else if( _.set.like( src ) )
    dst = _.arraySet.union_( null, src );
    else
    dst = src;

  }
  else if( _.aux.is( src ) )
  {

    if( _.aux.is( dst ) )
    dst = _.props.extend( dst, src );
    else if( _.hashMap.like( dst ) )
    dst = _.hashMap.extend( dst, src );
    else
    dst = _.container.extendReplacing( null, src );

  }
  else if( _.longLike( src ) )
  {

    if( _.longIs( dst ) )
    {
      for( let i = src.length - 1 ; i >= 0 ; i-- )
      dst[ i ] = src[ i ];
    }
    else
    {
      dst = _.container.extendReplacing( null, src );
    }

  }
  else if( _.hashMap.like( src ) )
  {

    if( _.hashMap.like( dst ) || _.aux.is( dst ) )
    dst = _.hashMap.extend( dst, src );
    else
    dst = _.container.extendReplacing( null, src );

  }
  else if( _.set.like( src ) )
  {

    if( _.set.like( dst ) || _.longLike( dst ) )
    dst = _.arraySet.union_( dst, src );
    else
    dst = _.container.extendReplacing( null, src );

  }
  else
  {

    dst = src;

  }

  return dst;
}

//

function extendAppending( dst, src )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( dst === null || dst === undefined )
  {

    if( _.aux.is( src ) )
    dst = _.props.extend( null, src );
    else if( _.longLike( src ) )
    dst = _.arrayExtendAppending( null, src );
    else if( _.hashMap.like( src ) )
    dst = _.hashMap.extend( null, src );
    else if( _.set.like( src ) )
    dst = _.arraySet.union_( null, src );
    else
    dst = src;

  }
  else if( _.aux.is( dst ) )
  {

    if( _.aux.is( src ) )
    dst = _.props.extend( dst, src );
    else if( _.hashMap.like( src ) )
    dst = _.hashMap.extend( dst, src );
    else
    dst = _.arrayExtendAppending( dst, src );

  }
  else if( _.longLike( dst ) )
  {

    dst = _.arrayExtendAppending( dst, src );

  }
  else if( _.hashMap.like( dst ) )
  {

    if( _.hashMap.like( src ) || _.aux.is( src ) )
    dst = _.hashMap.extend( dst, src );
    else
    dst = _.arrayExtendAppending( dst, src );

  }
  else if( _.set.like( dst ) )
  {

    if( _.set.like( src ) || _.longLike( src ) )
    dst = _.arraySet.union_( dst, src );
    else
    dst = _.arrayExtendAppending( dst, src );

  }
  else
  {

    dst = src;

  }

  return dst;
}

// --
// declaration
// --

let ContainerExtension =
{

  extendReplacing, /* zzz : dubious */
  extendAppending, /* zzz : dubious */

}

_.props.supplement( _.container, ContainerExtension );

//

let ToolsExtension =
{
}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Container.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Container_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Container_s */ })();

/* */  /* begin of file Countable_s */ ( function Countable_s() { function Countable_s_naked() { ( function _l7_Countable_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.countable = _.countable || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{

}

//

Object.assign( _.countable, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Countable.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Countable_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Countable_s */ })();

/* */  /* begin of file Ct_s */ ( function Ct_s() { function Ct_s_naked() { ( function _l7_Ct_s_()
{

'use strict';

/* = Glossary::

CT -- colorful text.

*/

//

const _global = _global_;
const _ = _global_.wTools;
const Self = _.ct = _.ct || Object.create( null );

// --
// implementation
// --

function _formatAffixesBackground( color )
{
  let result = Object.create( null );

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( color ) );

  result.head = `background : ${color}`;
  result.post = `background : default`;

  return result;
}

//

function formatBackground( srcStr, color )
{

  if( _.number.is( color ) )
  color = _.color.colorNameNearest( color );

  _.assert( arguments.length === 2, 'Expects 2 arguments' );
  _.assert( _.strIs( srcStr ), 'Expects string {-srcStr-}' );
  _.assert( _.strIs( color ), 'Expects string {-color-}' );

  return `background : ${color}${srcStr}background : default`;
}

//

function _formatAffixesForeground( color )
{
  let result = Object.create( null );

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( color ) );

  result.head = `foreground : ${color}`;
  result.post = `foreground : default`;

  return result;
}

//

function formatForeground( srcStr, color )
{

  if( _.number.is( color ) )
  color = _.color.colorNameNearest( color );

  _.assert( arguments.length === 2, 'Expects 2 arguments' );
  _.assert( _.strIs( srcStr ), 'Expects string {-srcStr-}' );
  _.assert( _.strIs( color ), 'Expects string {-color-}' );

  return `foreground : ${color}${srcStr}foreground : default`;
}

//

function _strEscape( srcStr )
{
  let result = srcStr;
  if( _.number.is( result ) )
  result = result + '';
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.strIs( result ), 'Expects string got', _.entity.strType( result ) );
  return 'inputRaw:1' + srcStr + 'inputRaw:0'
}

let escape = _.routineVectorize_functor( _strEscape );

//

function _strUnescape( srcStr )
{
  let result = srcStr;
  if( _.number.is( result ) )
  result = result + '';
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.strIs( result ), 'Expects string got', _.entity.strType( result ) );
  return 'inputRaw:0' + srcStr + 'inputRaw:1'
}

let unescape = _.routineVectorize_functor( _strUnescape );

//

function styleObjectFor( style )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( style ), 'Expects string got', _.entity.strType( style ) );

  let result = _.ct.Style[ style ];

  _.assert( _.mapIs( result ), `No such style : ${style}` );

  return result;
}

//

function _affixesJoin()
{

  _.assert( _.mapIs( arguments[ 0 ] ) );

  for( let a = 1 ; a < arguments.length ; a++ )
  {
    arguments[ 0 ].head = arguments[ a ].head + arguments[ 0 ].head;
    arguments[ 0 ].post = arguments[ 0 ].post + arguments[ a ].post;
  }

  return arguments[ 0 ];
}

//

function _formatAffixesForStyleObject( styleObject )
{
  let result = Object.create( null );
  result.head = '';
  result.post = '';

  _.map.assertHasOnly( styleObject, _formatAffixesForStyleObject.defaults );

  if( styleObject.fg )
  _.ct._affixesJoin( result, _.ct._formatAffixesForeground( styleObject.fg ) );

  if( styleObject.bg )
  _.ct._affixesJoin( result, _.ct._formatAffixesBackground( styleObject.bg ) );

  return result;
}

_formatAffixesForStyleObject.defaults =
{
  fg : null,
  bg : null,
}

//

function _formatAffixes( styles )
{
  let result = Object.create( null );
  result.head = '';
  result.post = '';

  styles = _.array.as( styles );

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.arrayIs( styles ), 'Expects string or array of strings {- styles -}' );

  for( let s = 0 ; s < styles.length ; s++ )
  {
    let style = styles[ s ];

    if( _.object.isBasic( style ) )
    {
      let affixes = _.ct._formatAffixesForStyleObject( style );
      _.ct._affixesJoin( result, affixes );
      continue;
    }

    _.assert( _.strIs( style ), 'Expects string or array of strings { style }' );

    let styleObject = _.ct.styleObjectFor( style );
    _.assert( !!styleObject, 'Unknown style', _.strQuote( style ) );

    let affixes = _.ct._formatAffixesForStyleObject( styleObject );
    _.ct._affixesJoin( result, affixes );

  }

  return result;
}

//

function _format( srcStr, style )
{
  let result = srcStr;

  if( _.number.is( result ) )
  result = result + '';
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.strIs( result ), 'Expects string got', _.entity.strType( result ) );

  let r = _.ct._formatAffixes( style );

  result = r.head + result + r.post;

  return result;
}

let format = _.routineVectorize_functor( _format );

//

function _strip( srcStr )
{

  _.assert( _.strIs( srcStr ) );

  let splitted = _.strSplitInlinedStereo_
  ({
    src : srcStr,
    preservingEmpty : 0,
    stripping : 0,
    preservingInlined : 0,
    inliningDelimeters : 1,
  });

  return splitted.join( '' );
}

let strip = _.vectorize( _strip );

//

function parse( o )
{
  if( _.strIs( arguments[ 0 ] ) )
  o = { src : arguments[ 0 ] };
  _.routine.options_( parse, o );
  o.inliningDelimeters = 1;
  o.preservingOrdinary = 1;
  o.preservingInlined = 1;
  return _.strSplitInlinedStereo_( o );
}

parse.defaults =
{
  src : null,
  prefix : '',
  postfix : '',
  onInlined : ( e ) => [ e ],
  onOrdinary : null,
  stripping : 0,
  quoting : 0,
  preservingDelimeters : 0,
  preservingEmpty : 0,
}

//

let StripAnsi;
function _stripAnsi( src )
{

  _.assert( arguments.length === 1 );
  _.assert( _.strIs( src ) );

  if( StripAnsi === undefined )
  StripAnsi = require( 'strip-ansi' );
  /* xxx : move to module::wCt, routine _.ct.stripAnsi() with lazy including of strip-ansi */
  /* qqq : implement without dependency */
  /* qqq : implement routine _.ct.fromAnsi() */

  return StripAnsi( src );
}

let stripAnsi = _.vectorize( _stripAnsi );

// --
// relation
// --

let Style =
{

  'positive' : { fg : 'green' },
  'negative' : { fg : 'red' },

  'path' : { fg : 'dark cyan' },
  'code' : { fg : 'dark green' },
  'entity' : { fg : 'bright blue' },

  'topic.up' : { fg : 'white', bg : 'dark blue' },
  'topic.down' : { fg : 'dark black', bg : 'dark blue' },

  'head' : { fg : 'dark black', bg : 'white' },
  'tail' : { fg : 'white', bg : 'dark black' },

  'highlighted' : { fg : 'white', bg : 'dark black' },
  'selected' : { fg : 'dark yellow', bg : 'dark blue' },
  'neutral' : { fg : 'smoke', bg : 'dim' },
  'secondary' : { fg : 'silver' },
  'tertiary' : { fg : 'gray' },

  'pipe.neutral' : { fg : 'dark magenta' },
  'pipe.negative' : { fg : 'dark red' },

  'exclusiveOutput.neutral' : { fg : 'dark black', bg : 'dark yellow' },
  'exclusiveOutput.negative' : { fg : 'dark red', bg : 'dark yellow' },

  'info.neutral' : { fg : 'white', bg : 'magenta' },
  'info.negative' : { fg : 'dark red', bg : 'magenta' },

}

// --
// declare
// --

let Extension =
{

  // implementation

  _formatAffixesBackground,
  formatBackground,
  bg : formatBackground,

  _formatAffixesForeground,
  formatForeground,
  fg : formatForeground,

  escape,
  unescape,

  styleObjectFor,
  _affixesJoin,
  _formatAffixesForStyleObject,
  _formatAffixes,
  _format,
  format,
  formatFinal : format,

  strip,
  parse, /* qqq : for junior : test? */

  _stripAnsi,
  stripAnsi, /* xxx : qqq : move out to module::wCtBasic */

  // fields

  Style,

}

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Ct.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Ct_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Ct_s */ })();

/* */  /* begin of file Date_s */ ( function Date_s() { function Date_s_naked() { ( function _l7_Date_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.date = _.date || Object.create( null );

// --
// dichotomy
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

//

Object.assign( _, ToolsExtension );
Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Date.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Date_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Date_s */ })();

/* */  /* begin of file Diagnostic_s */ ( function Diagnostic_s() { function Diagnostic_s_naked() { ( function _l7_Diagnostic_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.diagnostic = _.diagnostic || Object.create( null );

// --
// diagnostic
// --

function beep()
{
  console.log( '\x07' );
}

//

/*

_.diagnostic.watchFields
({
  target : _global_,
  names : 'Uniforms',
});

_.diagnostic.watchFields
({
  target : state,
  names : 'filterColor',
});

_.diagnostic.watchFields
({
  target : _global_,
  names : 'Config',
});

_.diagnostic.watchFields
({
  target : _global_,
  names : 'logger',
});

_.diagnostic.watchFields
({
  target : self,
  names : 'catalogPath',
});

*/

function watchFields( o )
{

  if( arguments[ 1 ] !== undefined )
  o = { target : arguments[ 0 ], names : arguments[ 1 ] }
  o = _.routine.options( watchFields, o );

  if( o.names )
  o.names = o.names;
  // o.names = _.nameFielded( o.names );
  else
  o.names = o.target;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.object.like( o.target ) );
  _.assert( _.object.like( o.names ) );

  for( let f in o.names ) ( function()
  {

    let propName = f;
    let fieldSymbol = Symbol.for( f );
    //o.target[ fieldSymbol ] = o.target[ f ];
    let val = o.target[ f ];

    /* */

    function read()
    {
      //let result = o.target[ fieldSymbol ];
      let result = val;
      if( o.verbosity > 1 )
      console.log( 'reading ' + propName + ' ' + _.entity.exportString( result ) );
      else
      console.log( 'reading ' + propName );
      if( o.debugging > 1 )
      debugger;
      return result;
    }

    /* */

    function write( src )
    {
      if( o.verbosity > 1 )
      console.log( 'writing ' + propName + ' ' + _.entity.exportString( o.target[ propName ] ) + ' -> ' + _.entity.exportString( src ) );
      else
      console.log( 'writing ' + propName );
      if( o.debugging )
      debugger;
      //o.target[ fieldSymbol ] = src;
      val = src;
    }

    /* */

    if( o.debugging > 1 )
    debugger;

    if( o.verbosity > 1 )
    console.log( 'watching for', propName, 'in', o.target );
    let properties =
    {
      enumerable : true,
      configurable : true,
      get : read,
      set : write,
    };
    Object.defineProperty( o.target, propName, properties );

  })();

}

watchFields.defaults =
{
  target : null,
  names : null,
  verbosity : 2,
  debugging : 1,
}

//

/*

_.diagnostic.proxyFields
({
  target : _.props,
});

_.diagnostic.watchFields
({
  target : _,
  names : 'field',
});

*/

function proxyFields( o )
{

  if( arguments[ 1 ] !== undefined )
  o = { target : arguments[ 0 ], names : arguments[ 1 ] }
  o = _.routine.options( proxyFields, o );

  // if( o.names )
  // o.names = _.nameFielded( o.names );

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.object.like( o.target ) );
  _.assert( _.object.like( o.names ) || o.names === null );

  let handler =
  {
    set : function( obj, k, e )
    {
      if( o.names && !( k in o.names ) )
      return;
      if( o.verbosity > 1 )
      console.log( 'writing ' + k + ' ' + _.entity.exportString( o.target[ k ] ) + ' -> ' + _.entity.exportString( e ) );
      else
      console.log( 'writing ' + k );
      if( o.debug )
      debugger;
      obj[ k ] = e;
      return true;
    }
  }

  let result = new Proxy( o.target, handler );
  if( o.verbosity > 1 )
  console.log( 'watching for', o.target );

  if( o.debug )
  debugger;

  return result;
}

proxyFields.defaults =
{
  ... watchFields.defaults,
}

//

function eachLongType( o )
{
  let result = Object.create( null );

  if( _.routine.is( o ) )
  o = { onEach : o }
  o = _.routine.options( eachLongType, o );

  if( o.onEach === null )
  o.onEach = function onEach( make, descriptor )
  {
    return make;
  }

  _.assert( arguments.length === 0 || arguments.length === 1 );
  _.assert( _.routine.is( o.onEach ) )

  // debugger;

  for( let k in _.long.namespaces )
  {
    let namespace = _.long.namespaces[ k ];
    let long = _.withLong[ namespace.TypeName ];
    debugger;
    result[ long.TypeName ] = o.onEach( long.make, long );
  }

  // debugger;

  return result;
}

eachLongType.defaults =
{
  onEach : null,
}

//

function eachElementComparator( o )
{
  let result = [];

  if( arguments[ 1 ] !== undefined )
  o = { onMake : arguments[ 0 ], onEach : arguments[ 1 ] || null }
  else if( _.routine.is( arguments[ 0 ] ) )
  o = { onEach : arguments[ 1 ] || null }

  o = _.routine.options( eachElementComparator, o );

  if( o.onEach === null )
  o.onEach = function onEach( make, evaluate, description )
  {
    return evaluate;
  }

  if( o.onMake === null )
  o.onMake = function onMake( src )
  {
    return src;
  }

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.routine.is( o.onEach ) );
  _.assert( _.routine.is( o.onMake ) );

  result.push( o.onEach( o.onMake, undefined, 'no evaluator' ) );
  result.push( o.onEach( make, evaluator, 'evaluator' ) );
  result.push( o.onEach( make, [ evaluator, evaluator ], 'tandem of evaluators' ) );
  result.push( o.onEach( make, equalizer, 'equalizer' ) );

  return result;

  /* */

  function evaluator( e )
  {
    _.assert( e.length === 1 );
    return e[ 0 ];
  }

  /* */

  function equalizer( e1, e2 )
  {
    _.assert( e1.length === 1 );
    _.assert( e2.length === 1 );
    return e1[ 0 ] === e2[ 0 ];
  }

  /* */

  function make( long )
  {
    _.assert( _.longIs( long ) );
    let result = [];
    for( let l = 0 ; l < long.length ; l++ )
    result[ l ] = [ long[ l ] ];
    return o.onMake( result );
  }

}

eachElementComparator.defaults =
{
  onMake : null,
  onEach : null,
}

//

function diagnosticStructureGenerate_head( routine, args )
{
  _.assert( args.length === 0 || args.length === 1, () => `Expects optional argument, but got ${args.length} arguments` );

  let o;
  if( args.length === 1 )
  o = args[ 0 ];
  else
  o = Object.create( null );

  o = _.routine.options( structureGenerate, o );

  if( o.arrayLength === null )
  o.arrayLength = o.defaultLength;
  if( o.mapLength === null )
  o.mapLength = o.defaultLength;
  if( o.hashMapLength === null )
  o.hashMapLength = o.defaultLength;
  if( o.setLength === null )
  o.setLength = o.defaultLength;

  if( o.stringSize === null )
  o.stringSize = o.defaultSize;
  if( o.bufferSize === null )
  o.bufferSize = o.defaultSize;
  if( o.regexpSize === null )
  o.regexpSize = o.defaultSize;

  if( o.primitiveComplexity === null )
  o.primitiveComplexity = from( o.defaultComplexity );

  if( o.nullComplexity === null )
  o.nullComplexity = from( o.primitiveComplexity );
  if( o.undefinedComplexity === null )
  o.undefinedComplexity = from( o.primitiveComplexity );
  if( o.booleanComplexity === null )
  o.booleanComplexity = from( o.primitiveComplexity );
  if( o.stringComplexity === null )
  o.stringComplexity = from( o.primitiveComplexity );
  if( o.bigIntComplexity === null )
  o.bigIntComplexity = from( o.primitiveComplexity );

  if( o.numberComplexity === null )
  o.numberComplexity = from( o.primitiveComplexity );
  if( o.numberInfinityComplexity === null )
  o.numberInfinityComplexity = from( o.numberComplexity );
  if( o.numberNanComplexity === null )
  o.numberNanComplexity = from( o.numberComplexity );
  if( o.numberSignedZeroComplexity === null )
  o.numberSignedZeroComplexity = from( o.numberComplexity );

  if( o.objectComplexity === null )
  o.objectComplexity = from( o.defaultComplexity );
  if( o.dateComplexity === null )
  o.dateComplexity = from( o.objectComplexity );
  if( o.regexpComplexity === null )
  o.regexpComplexity = from( o.objectComplexity );

  if( o.bufferComplexity === null )
  o.bufferComplexity = from( o.objectComplexity );
  if( o.bufferNodeComplexity === null )
  o.bufferNodeComplexity = from( o.bufferComplexity );
  if( o.bufferRawComplexity === null )
  o.bufferRawComplexity = from( o.bufferComplexity );
  if( o.bufferBytesComplexity === null )
  o.bufferBytesComplexity = from( o.bufferComplexity );

  if( o.containerComplexity === null )
  o.containerComplexity = from( o.defaultComplexity );
  if( o.recursionComplexity === null )
  o.recursionComplexity = from( o.containerComplexity );
  if( o.arrayComplexity === null )
  o.arrayComplexity = from( o.containerComplexity );
  if( o.mapComplexity === null )
  o.mapComplexity = from( o.containerComplexity );
  if( o.setComplexity === null )
  o.setComplexity = from( o.containerComplexity );
  if( o.hashMapComplexity === null )
  o.hashMapComplexity = from( o.containerComplexity );

  _.assert( _.number.is( o.depth ) );

  function from( complexity, min )
  {
    if( min === undefined )
    return complexity;

    if( complexity >= min )
    return complexity;

    return 0;
  }

  return o;
}

//

function diagnosticStructureGenerate_body( o )
{

  /**/

  o.result = structureMake( 0 );
  o.size = _.entity.sizeOf( o.result );

  return o;

  /*  */

  function structureMake( level )
  {
    let struct = Object.create( null );

    if( !( level <= o.depth ) )
    {
      return null;
    }

    if( o.nullComplexity >= 2 )
    {
      struct[ 'null' ] = null;
    }

    if( o.undefinedComplexity >= 3 )
    {
      struct[ 'undefined' ] = undefined;
    }

    if( o.booleanComplexity )
    {
      struct[ 'boolean.true' ] = true;
      struct[ 'boolean.false' ] = false;
    }

    if( o.stringComplexity )
    {
      if( o.random )
      struct[ 'string.defined' ] = _.strRandom( o.stringSize );
      else
      struct[ 'string.defined' ] = new RegExp( _.strDup( 'a', o.stringSize ) );
      struct[ 'string.empty' ] = '';
    }

    if( o.numberComplexity )
    {
      struct[ 'number.zero' ] = 0;
      struct[ 'number.small' ] = 13;
    }

    if( o.numberComplexity >= 2 )
    {
      struct[ 'number.big' ] = 1 << 30;
    }

    if( o.numberInfinityComplexity >= 2 )
    {
      struct[ 'number.infinity.positive' ] = +Infinity;
      struct[ 'number.infinity.negative' ] = -Infinity;
    }

    if( o.numberNanComplexity >= 2 )
    {
      struct[ 'number.nan' ] = NaN;
    }

    if( o.numberSignedZeroComplexity >= 3 )
    {
      struct[ 'number.signed.zero.negative' ] = -0;
      struct[ 'number.signed.zero.positive' ] = +0;
    }

    if( o.bigIntComplexity >= 3 )
    if( typeof BigInt !== 'undefined' )
    {
      struct[ 'bigInt.zero' ] = BigInt( 0 );
      struct[ 'bigInt.small' ] = BigInt( 1 );
      struct[ 'bigInt.big' ] = BigInt( 1 ) << BigInt( 100 );
    }

    if( o.regexpComplexity >= 2 )
    {
      if( o.random )
      struct[ 'regexp.defined' ] = new RegExp( _.strRandom( o.regexpSize ) );
      else
      struct[ 'regexp.defined' ] = new RegExp( _.strDup( 'a', o.regexpSize ) );
      struct[ 'regexp.simple1' ] = /ab|cd/;
      struct[ 'regexp.simple2' ] = /a[bc]d/;
      struct[ 'regexp.simple3' ] = /ab{1, }bc/;
      struct[ 'regexp.simple4' ] = /\.js$/;
      struct[ 'regexp.simple5' ] = /.reg/;
    }

    if( o.regexpComplexity >= 3 )
    {
      struct[ 'regexp.complex0' ] = /^(?:(?!ab|cd).)+$/gm;
      struct[ 'regexp.complex1' ] = /\/\*[\s\S]*?\*\/|\/\/.*/g;
      struct[ 'regexp.complex2' ] = /^[1-9]+[0-9]*$/gm;
      struct[ 'regexp.complex3' ] = /aBc/i;
      struct[ 'regexp.complex4' ] = /^\d+/gm;
      struct[ 'regexp.complex5' ] = /^a.*c$/g;
      struct[ 'regexp.complex6' ] = /[a-z]/m;
      struct[ 'regexp.complex7' ] = /^[A-Za-z0-9]$/;
    }

    if( o.dateComplexity >= 3 )
    {
      struct[ 'date.now' ] = new Date();
      struct[ 'date.fixed' ] = new Date( 1987, 1, 4, 5, 13, 0 );
    }

    // let bufferSrc = _.longFillTimes( [], o.bufferSize || o.defaultSize, 0 );
    let bufferSrc = _.longRandom( [], [ 0, 1 ], [ 0, o.bufferSize ] );
    /* qqq : suspicious! */

    if( o.bufferNodeComplexity >= 4 )
    if( typeof BufferNode !== 'undefined' )
    struct[ 'buffer.node' ] = BufferNode.from( bufferSrc );

    if( o.bufferRawComplexity >= 3 )
    struct[ 'buffer.raw' ] = new U8x( bufferSrc ).buffer;

    if( o.bufferBytesComplexity >= 3 )
    struct[ 'buffer.bytes' ] = new U8x( bufferSrc );

    if( o.arrayComplexity )
    struct[ 'array.simple' ] = _.longFill( [], 0, [ 0, o.arrayLength ] )

    if( o.arrayComplexity >= 3 )
    {
      struct[ 'array.complex' ] = [];
      for( let a = 0 ; a < o.arrayLength ; a++ )
      struct[ 'array.complex' ][ a ] = structureMake( level+1 );
    }

    /*  */

    if( o.setComplexity >= 3 )
    {
      struct[ 'set' ] = new Set;
      for( let m = 0 ; m < o.setLength ; m++ )
      struct[ 'set' ].add( structureMake( level+1 ) );
    }

    /*  */

    if( o.hashMapComplexity >= 4 )
    {
      struct[ 'hashMap' ] = new HashMap;
      for( let m = 0 ; m < o.hashMapLength ; m++ )
      struct[ 'hashMap' ].set( 'element' + m, structureMake( level+1 ) );
    }

    /*  */

    if( o.mapComplexity )
    {
      // let map = struct[ 'mapComplex' ] = { 0 : '1', 1 : { b : 2 }, 2 : [ 1, 2, 3 ] };
      // if( o.mapLength )
      // struct[ 'map.complex' ] = mapFor( map, [ 0, 3 ] );
      struct[ 'map' ] = Object.create( null );
      for( let m = 0 ; m < o.mapLength ; m++ )
      struct[ 'map' ][ 'element' + m ] = structureMake( level+1 );
    }

    // if( o.map || o.result )
    // if( o.mapComplexity )
    // {
    //   // let map = struct[ 'map' ] = { 0 : string, 1 : 1, 2 : true  };
    //   // if( o.mapLength )
    //   debugger;
    //   let map = struct[ 'map' ] = { 0 : string, 1 : 1, true : true  };
    //   struct[ 'map.simple' ] = mapFor( map, [ 0, 1 << 25 ] );
    // }

    if( level < o.depth )
    {
      struct[ 'level' + ( level + 1 ) ] = structureMake( level+1 );
    }

    if( o.recursionComplexity >= 2 )
    {
      struct[ 'recursion.self' ] = struct;
    }

    if( o.recursionComplexity >= 3 && struct[ 'level' + ( level + 1 ) ] )
    {
      struct[ 'level' + ( level + 1 ) ][ 'recursion.super' ] = struct;
    }

    return struct;

    /*  */

    function mapFor( src, range )
    {
      let map = {};
      for( var i = 0; i < o.mapLength; i++ )
      {
        let k = _.intRandom( range );
        map[ i ] = src[ k ];
      }
      return map;
    }
  }

  /* */

  // function from( complexity, min )
  // {
  //   if( min === undefined )
  //   return complexity;

  //   if( complexity >= min )
  //   return complexity;

  //   return 0;
  // }

  /*

    if( o.booleanComplexity || o.primitiveComplexity )
    currentLevel[ 'booleanComplexity' ] = true;

    if( o.numberComplexity || o.primitiveComplexity )
    currentLevel[ 'numberComplexity' ] = 0;

    if( o.numberSignedZeroComplexity || o.primitiveComplexity > 2 )
    {
      currentLevel[ '-0' ] = -0;
      currentLevel[ '+0' ] = +0;
    }

    if( o.string || o.primitiveComplexity )
    currentLevel[ 'string' ] = string;

    if( o.nullComplexity || o.primitiveComplexity > 1 )
    currentLevel[ 'null' ] = null;

    if( o.numberInfinityComplexity || o.primitiveComplexity > 1 )
    {
      currentLevel[ '+numberInfinityComplexity' ] = +Infinity;
      currentLevel[ '-numberInfinityComplexity' ] = -Infinity;
    }

    if( o.numberNanComplexity || o.primitiveComplexity > 1 )
    currentLevel[ 'numberNanComplexity' ] = NaN;

    if( o.undefinedComplexity || o.primitiveComplexity > 2 )
    currentLevel[ 'undefined' ] = undefined;

    if( o.dateComplexity || o.primitiveComplexity > 2 )
    currentLevel[ 'dateComplexity' ] = new Date();

    if( o.bigIntComplexity || o.primitiveComplexity > 2 )
    if( typeof BigInt !== 'undefined' )
    currentLevel[ 'bigInt' ] = BigInt( 1 );

  */

}

diagnosticStructureGenerate_body.defaults =
{

  result : null,

  /*  */

  depth : 1, /* qqq : cover the option */
  random : 1, /* qqq : cover the option */
  stringSize : null,
  bufferSize : null,
  regexpSize : null,
  defaultSize : 50,

  arrayLength : null,
  mapLength : null,
  hashMapLength : null,
  setLength : null,
  defaultLength : 4,

  /* */

  defaultComplexity : 2,

  primitiveComplexity : null,
  nullComplexity : null,
  undefinedComplexity : null,
  booleanComplexity : null,
  stringComplexity : null,
  bigIntComplexity : null,
  numberComplexity : null,
  numberInfinityComplexity : null,
  numberNanComplexity : null,
  numberSignedZeroComplexity : null,

  objectComplexity : null,
  dateComplexity : null,
  regexpComplexity : null,
  bufferComplexity : null,
  bufferNodeComplexity : null,
  bufferRawComplexity : null,
  bufferBytesComplexity : null,

  containerComplexity : null,
  recursionComplexity : null,
  arrayComplexity : null,
  mapComplexity : null,
  setComplexity : null,
  hashMapComplexity : null,

}

//

/**
 * Routine diagnosticStructureGenerate generates structure with different data types in provided options map {-o-}. The final resulted structure almost defined by
 * property {-o.defaultComplexity-} of options map {-o-} and other separate options.
 * If routine calls without arguments, then routine returns new map with structure that generates from default parameters.
 *
 * @param { Map } o - The options map. Options map includes next options:
 *
 * @param { Number } o.defaultComplexity - The complexity of data types, options of which is not defined directly. Default value - 2.
 *
 * @param { Number } o.primitiveComplexity - The default complexity for primitives. If option is not defined, then it inherits {-o.defaultComplexity-}.
 * @param { Number } o.nullComplexity - Option for enabling generating of null. To generate null, it should be 2 or more.
 * @param { Number } o.undefinedComplexity - Option for enabling generating of undefined. To generate undefined, it should be 3 or more.
 * @param { Number } o.booleanComplexity - Option for enabling generating of boolean values. To generate true and false, it should be 1 or more.
 * @param { Number } o.stringComplexity - Option for enabling generating of string. To generate random string with {-o.stringSize-} length
 * and empty string, it should be 1 or more.
 * @param { Number } o.bigIntComplexity - Option for enabling generating of bigInt numbers. To generate bigInt zero, small and big value, it should be 3 or more.
 * @param { Number } o.numberComplexity - Option for enabling generating of numbers. To generate zero and small value, it should be 1. If option is 2 or more,
 * then routine generates big value.
 * @param { Number } o.numberInfinityComplexity - Option for enabling generating of Infinity values. To generate positive and negative Infinity,
 * it should be 2 or more.
 * @param { Number } o.numberNanComplexity - Option for enabling generating of NaN. To generate NaN, it should be 2 or more.
 * @param { Number } o.numberSignedZeroComplexity - Option for enabling generating of signed zero values. To generate positive and negative zero,
 * it should be 3 or more.
 *
 * @param { Number } o.objectComplexity - The default complexity for Date, RegExp and buffers. If option is not defined, then it inherits {-o.defaultComplexity-}.
 * @param { Number } o.dateComplexity - Option for enabling generating of Date instances. To generate Date instance with current date and with fixed date,
 * it should be 3 or more.
 * @param { Number } o.regexpComplexity - Option for enabling generating of regexps. To generate simple regexps, it should be 2. To generate complex
 * regexps it should be 3 or more.
 * @param { Number } o.bufferComplexity - The default complexity for buffers ( raw, typed, view, node ). If option is not defined,
 * then it inherits {-o.objectComplexity-}
 * @param { Number } o.bufferNodeComplexity - Option for enabling generating of BufferNode. To generate BufferNode, it should be 4 or more.
 * @param { Number } o.bufferRawComplexity - Option for enabling generating of BufferRaw. To generate BufferRaw it should be 3 or more.
 * @param { Number } o.bufferBytesComplexity - Option for enabling generating of typed U8x buffer. To generate BufferBytes, it should be 3 or more.

 * @param { Number } o.containerComplexity - The default complexity array, map, Set, HashMap and recursion. If option is not defined, then
 * it inherits {-o.defaultComplexity-}.
 * @param { Number } o.recursionComplexity - Option for enabling generating field with recursive link to current structure. To generate link,
 * it should be 2 or more.
 * @param { Number } o.arrayComplexity - Option for enabling generating of array. To generate flat array, it should be 2. If option set to 3 or more,
 * then routine generated array with nested arrays. Depth of nesting defines by option {-o.depth-}.
 * @param { Number } o.mapComplexity - Option for enabling generating of map. To generate map, it should be 1 or more.
 * @param { Number } o.setComplexity - Option for enabling generating of Set. To generate Set, it should be 3 or more.
 * @param { Number } o.hashMapComplexity - Option for enabling generating of HashMap. To generate HashMap, it should be 4 or more.
 *
 * @param { Number } o.depth - Defines maximal generated level of nesting for complex data structure. Default value - 1.
 * @param { Number } defaultSize - The default size of generated string, buffer, regexp. Default value - 50.
 * @param { Number } o.stringSize - The length of generated string.
 * @param { Number } o.bufferSize - The length of generated buffer ( raw, typed, view, node ).
 * @param { Number } o.regexpSize - The length of generated regexp.
 * @param { Number } o.defaultLength - The default length for generated array, map, HashMap, Set. Default value - 4.
 * @param { Number } o.arrayLength - The length of generated array.
 * @param { Number } o.mapLength - The length of generated map.
 * @param { Number } o.hashMapLength - The length of generated HashMap.
 * @param { Number } o.setLength - The length of generated Set.
 *
 * @example
 * _.diagnostic.structureGenerate()
 * //returns
 * // [Object: null prototype]
 * // {
 * //   result: [Object: null prototype]
 * //   {
 * //     // generated structure
 * //   },
 * //   depth: 1,
 * //   stringSize: 50,
 * //   bufferSize: 50,
 * //   regexpSize: 50,
 * //   defaultSize: 50,
 * //   arrayLength: 4,
 * //   mapLength: 4,
 * //   hashMapLength: 4,
 * //   setLength: 4,
 * //   defaultLength: 4,
 * //   defaultComplexity: 2,
 * //   primitiveComplexity: 2,
 * //   nullComplexity: 2,
 * //   undefinedComplexity: 2,
 * //   booleanComplexity: 2,
 * //   ...
 * //   // other options
 * // }
 *
 * @returns { Map } - Returns map with diagnostic data types of defined complexity.
 * @function diagnosticStructureGenerate
 * @throws { Error } If arguments.length is more then one.
 * @throws { Error } If options map {-o-} is not aixiliary.
 * @throws { Error } If options map {-o-} has unknown options.
 * @namespace Tools
 */

let structureGenerate = _.routine.unite( diagnosticStructureGenerate_head, diagnosticStructureGenerate_body );

// //
//
// function objectMake( o )
// {
//   let result;
//
//   _.assert( arguments.length === 1 );
//   countableConstructorPure.prototype = Object.create( null );
//   if( o.withConstructor )
//   countableConstructorPure.prototype.constructor = countableConstructorPure;
//
//   /* xxx : replace countableMake */
//
//   if( o.new )
//   {
//     if( o.pure )
//     result = new countableConstructorPure( o );
//     else
//     result = new countableConstructorPolluted( o );
//   }
//   else
//   {
//     result = _objectMake( null, o );
//   }
//
//   if( o.withOwnConstructor )
//   result.constructor = function ownConstructor(){}
//
//   return result;
//
//   /* - */
//
//   function _iterate()
//   {
//
//     let iterator = Object.create( null );
//     iterator.next = next;
//     iterator.index = 0;
//     iterator.instance = this;
//     return iterator;
//
//     function next()
//     {
//       let result = Object.create( null );
//       result.done = this.index === this.instance.elements.length;
//       if( result.done )
//       return result;
//       result.value = this.instance.elements[ this.index ];
//       this.index += 1;
//       return result;
//     }
//
//   }
//
//   /* */
//
//   function countableConstructorPure( o )
//   {
//     return _objectMake( this, o );
//   }
//
//   /* */
//
//   function countableConstructorPolluted( o )
//   {
//     let result = _objectMake( this, o );
//     if( !o.withConstructor )
//     delete Object.getPrototypeOf( result ).constructor;
//     return result
//   }
//
//   /* */
//
//   function _objectMake( dst, o )
//   {
//     if( dst === null )
//     if( o.pure )
//     dst = Object.create( null );
//     else
//     dst = {};
//     _.props.extend( dst, o );
//     if( o.countable )
//     dst[ Symbol.iterator ] = _iterate;
//     return dst;
//   }
//
//   /* */
//
// }
//
// objectMake.defaults =
// {
//   new : 0,
//   pure : 0,
//   countable : 0,
//   withOwnConstructor : 0,
//   withConstructor : 0,
//   elements : null,
// }

// --
// extension
// --

let ToolsExtension =
{
  // diagnosticCode,
  diagnosticBeep : beep,

  diagnosticWatchFields : watchFields, /* experimental */
  diagnosticProxyFields : proxyFields, /* experimental */
  diagnosticEachLongType : eachLongType,
  diagnosticEachElementComparator : eachElementComparator,

  diagnosticStructureGenerate : structureGenerate, /* xxx : move */
  // diagnosticObjectMake,

}

Object.assign( _, ToolsExtension );

//

let DiagnosticExtension =
{

  // diagnosticCode,
  beep,

  watchFields, /* experimental */
  proxyFields, /* experimental */
  eachLongType,
  eachElementComparator,

  structureGenerate,

}

//

Object.assign( _.diagnostic, DiagnosticExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Diagnostic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Diagnostic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Diagnostic_s */ })();

/* */  /* begin of file Entity_s */ ( function Entity_s() { function Entity_s_naked() { ( function _l7_Entity_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _global_.wTools;

// --
// entity getter
// --

/**
 * Returns "size" of entity( src ). Representation of "size" depends on type of( src ):
 *  - For string returns value of it own length property;
 *  - For array-like entity returns value of it own byteLength property for( BufferRaw, TypedArray, etc )
 *    or length property for other;
 *  - In other cases returns null.
 *
 * @param {*} src - Source entity.
 * @returns {number} Returns "size" of entity.
 *
 * @example
 * _.entity.sizeOfUncountable( 'string' );
 * // returns 6
 *
 * @example
 * _.entity.sizeOfUncountable( new BufferRaw( 8 ) );
 * // returns 8
 *
 * @example
 * _.entity.sizeOfUncountable( 123 );
 * // returns null
 *
 * @function sizeOfUncountable
 * @namespace Tools
*/

/* qqq : cover argument sizeOfContainer */
function sizeOfUncountable( src, sizeOfContainer )
{
  if( arguments.length === 1 )
  sizeOfContainer = 8;

  _.assert( _.number.defined( sizeOfContainer ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( _.strIs( src ) )
  {
    if( src.length )
    return _.bufferBytesFrom( src ).byteLength + sizeOfContainer;
    return src.length + sizeOfContainer;
  }

  if( _.primitive.is( src ) )
  return sizeOfContainer || 8;

  if( _.routine.is( src ) )
  return sizeOfContainer;

  if( _.number.is( src.byteLength ) )
  return src.byteLength + sizeOfContainer;

  if( _.regexpIs( src ) )
  return _.entity.sizeOfUncountable( src.source, 0 ) + src.flags.length + sizeOfContainer;

  // if( !_.iterableIs( src ) ) /* yyy */ /* Dmytro : simulate behavior of routine iterableIs, routine countableIs has different behavior */
  // return sizeOfContainer;
  // if( !_.aux.is( src ) )
  // if( !_.class.methodIteratorOf( src ) )
  // return sizeOfContainer;
  // if( _.countable.is( src ) )
  // return _.countable.lengthOf( src ) + sizeOfContainer;

  return NaN;
}

//

/**
 * Returns "size" of entity( src ). Representation of "size" depends on type of( src ):
 *  - For string returns value of it own length property;
 *  - For array-like entity returns value of it own byteLength property for( BufferRaw, TypedArray, etc )
 *    or length property for other;
 *  - In other cases returns null.
 *
 * @param {*} src - Source entity.
 * @returns {number} Returns "size" of entity.
 *
 * @example
 * _.entity.sizeOf( 'string' );
 * // returns 6
 *
 * @example
 * _.entity.sizeOf( [ 1, 2, 3 ] );
 * // returns 3
 *
 * @example
 * _.entity.sizeOf( new BufferRaw( 8 ) );
 * // returns 8
 *
 * @example
 * _.entity.sizeOf( 123 );
 * // returns null
 *
 * @function entitySize
 * @namespace Tools
*/

/* qqq : review */

/* qqq : cover argument sizeOfContainer */
function sizeOf( src, sizeOfContainer )
{
  let result = 0;

  if( arguments.length === 1 )
  sizeOfContainer = 8;

  _.assert( _.number.defined( sizeOfContainer ) );
  _.assert( arguments.length === 1 || arguments.length === 2 );

  // if( _.primitive.is( src ) || _.bufferAnyIs( src ) || !( _.mapIs( src ) || _.class.methodIteratorOf( src ) ) )
  if( _.primitive.is( src ) || _.bufferAnyIs( src ) || _.routineIs( src ) || _.regexpIs( src ) )
  return _.entity.sizeOfUncountable( src, sizeOfContainer );

  /*
  full implementation of routine _.entity.sizeOf() in the module::LookerExtra
  */

  return NaN;
}

// --
// entity extension
// --

let EntityExtension =
{

  sizeOfUncountable,
  sizeOf,

}

Object.assign( _.entity, EntityExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  // sizeOfUncountable,
  // entitySize,
  // sizeOf : entitySize,

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Entity.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Entity_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Entity_s */ })();

/* */  /* begin of file Err_s */ ( function Err_s() { function Err_s_naked() { ( function _l7_Err_s_()
{

'use strict';

const _global = _global_;
const _ = _global.wTools;
const _err = _._err;

// --
// dichotomy
// --

function _isInstanceOrClass( _constructor, _this )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  debugger;
  let result =
  (
    _this === _constructor
    || _this instanceof _constructor
    || Object.isPrototypeOf.call( _constructor, _this )
    || Object.isPrototypeOf.call( _constructor, _this.prototype )
  );
  return result;
}

// //
//
// function _ownNoConstructor( ins )
// {
//   _.assert( !_.primitive.is( ins ) );
//   _.assert( arguments.length === 1 );
//   let result = !Object.hasOwnProperty.call( ins, 'constructor' );
//   return result;
// }

//

function sureInstanceOrClass( _constructor, _this )
{
  _.sure( arguments.length === 2, 'Expects exactly two arguments' );
  _.sure( _._isInstanceOrClass( _constructor, _this ) );
}

//

function sureOwnNoConstructor( ins )
{
  _.sure( !_.primitive.is( ins ) );
  let args = Array.prototype.slice.call( arguments );
  args[ 0 ] = !Object.hasOwnProperty.call( ins, 'constructor' );
  _.sure.apply( _, args );
}

//

function assertInstanceOrClass( _constructor, _this )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _._isInstanceOrClass( _constructor, _this ) );
}

//

function assertOwnNoConstructor( ins )
{
  _.assert( !_.primitive.is( ins ) );
  let args = Array.prototype.slice.call( arguments );
  args[ 0 ] = !Object.hasOwnProperty.call( ins, 'constructor' );
  _.assert.apply( _, args );
  // _.assert( !_.primitive.is( ins ) );
  // let args = Array.prototype.slice.call( arguments );
  // args[ 0 ] = _.sureOwnNoConstructor( ins );
  //
  // if( args.length === 1 )
  // args.push( () => 'Entity should not own constructor, but own ' + _.entity.exportStringDiagnosticShallow( ins ) );
  //
  // _.assert.apply( _, args );
}

// --
// errrors
// --

let ErrorAbort = _.error.error_functor( 'ErrorAbort' );

// --
// declare
// --

/* zzz : move into independent module or namespace */

let ErrorExtension =
{
  ErrorAbort,
}

let ToolsExtension =
{

  // dichotomy

  _isInstanceOrClass,
  // _ownNoConstructor,

  // sure

  sureInstanceOrClass,
  sureOwnNoConstructor,

  // assert

  assertInstanceOrClass,
  assertOwnNoConstructor,

}

Object.assign( _.error, ErrorExtension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Err.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Err_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Err_s */ })();

/* */  /* begin of file Escape_s */ ( function Escape_s() { function Escape_s_naked() { ( function _l7_Escape_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.escape = _.escape || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{
}

//

_.props.supplement( _.escape, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Escape.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Escape_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Escape_s */ })();

/* */  /* begin of file Event_s */ ( function Event_s() { function Event_s_naked() { ( function _l7_Event_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

// --
// declare
// --

let Extension =
{
};

Object.assign( _.event, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Event.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Event_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Event_s */ })();

/* */  /* begin of file Functional_s */ ( function Functional_s() { function Functional_s_naked() { ( function _l7_Functional_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _global_.wTools;

// --
//
// --

function _entityFilterDeep( o )
{

  let result;
  let onEach = _._filter_functor( o.onEach, o.conditionLevels );

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.object.like( o.src ) || _.longIs( o.src ), 'entityFilter : expects objectLike or longIs src, but got', _.entity.strType( o.src ) );
  _.assert( _.routine.is( onEach ) );

  /* */

  if( _.longIs( o.src ) )
  {
    if( _.argumentsArray.is( o.src ) ) /* Dmytro : seems as hack, this primitive realization use type check. The more type independent realization creates resulted container of full length and routine longBut_ */ /* qqq xxx : Dmytro : please, discuss it */
    result = [];
    else
    result = _.long.make( o.src, 0 );

    // result = _.long.make( o.src, o.src.length ); /* Dmytro : second variant */
    let s, d;
    for( s = 0, d = 0 ; s < o.src.length ; s++ )
    // for( let s = 0, d = 0 ; s < o.src.length ; s++, d++ )
    {
      let r = onEach.call( o.src, o.src[ s ], s, o.src );

      if( _.unrollIs( r ) )
      {
        _.arrayAppendArray( result, r );
        // _.longBut_( result, d, r ); /* Dmytro : second variant */
        d += r.length;
      }
      else if( r !== undefined )
      {
        result[ d ] = r;
        d += 1;
      }

      // if( r === undefined )
      // d--;
      // else
      // result[ d ] = r;

    }
    if( d < o.src.length )
    result = _.longSlice( result, 0, d );
    // result = _.array.slice( result, 0, d );
  }
  else
  {
    result = _.entity.makeUndefined( o.src );
    for( let s in o.src )
    {
      let r = onEach.call( o.src, o.src[ s ], s, o.src );
      // r = onEach.call( o.src, o.src[ s ], s, o.src );
      if( r !== undefined )
      result[ s ] = r;
    }
  }

  /* */

  return result;
}

_entityFilterDeep.defaults =
{
  src : null,
  onEach : null,
  conditionLevels : 1,
}

//

function entityFilterDeep( src, onEach )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  return _entityFilterDeep
  ({
    src,
    onEach,
    conditionLevels : 1024,
  });
}

//

/*
qqq : for Dmytro : poor coverage and implementation was wrong!
*/

function _entityIndex_functor( fop )
{

  fop = _.routine.options( _entityIndex_functor, fop );

  let extendRoutine = fop.extendRoutine;

  return function entityIndex( src, onEach )
  {
    let result = Object.create( null );

    if( onEach === undefined )
    onEach = function( e, k )
    {
      if( k === undefined && extendRoutine )
      return { [ e ] : undefined };
      return k;
    }
    else if( _.strIs( onEach ) )
    {
      let selector = onEach;
      _.assert( _.routine.is( _.select ) );
      _.assert( _.strBegins( selector, '*/' ), () => `Selector should begins with "*/", but "${selector}" does not` );
      selector = _.strRemoveBegin( selector, '*/' );
      onEach = function( e, k )
      {
        return _.select( e, selector );
      }
      /* Dmytro : Note. Selector selects properties of entities. For example:
      var got = ( 'str', '\*\/length' );
      var exp = { 3 : 'str' };
      test.identical( got, exp );
      */
    }

    _.assert( arguments.length === 1 || arguments.length === 2 );
    _.assert( _.routine.is( onEach ) );
    _.assert( src !== undefined, 'Expects {-src-}' );

    /* */

    if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        let val = src[ k ];
        let r = onEach( val, k, src );
        extend( r, val );
      }

    }
    else if( _.longIs( src ) )
    {

      for( let k = 0 ; k < src.length ; k++ )
      {
        let val = src[ k ];
        let r = onEach( val, k, src );
        extend( r, val );
      }

    }
    else
    {

      let val = src;
      let r = onEach( val, undefined, undefined );
      extend( r, val );

    }

    return result;

    /* */

    function extend( ext, val )
    {
      if( ext === undefined )
      return;

      if( _.unrollIs( ext ) )
      return ext.forEach( ( ext ) => extend( ext, val ) );

      if( extendRoutine === null )
      {
        // if( ext !== undefined ) // Dmytro : it's unnecessary condition, see 10 lines above
        result[ ext ] = val;
      }
      else
      {
        if( !_.aux.is( ext ) )
        {
          _.assert( _.primitive.is( ext ) );
          ext = { [ ext ] : val }
        }
        extendRoutine( result, ext );
        // // else if( ext !== undefined ) // Dmytro : it's unnecessary condition, see 16 lines above
        // else
        // result[ ext ] = val;
      }

    }

  }

}

_entityIndex_functor.defaults =
{
  extendRoutine : null,
}

//

/**
 * The routine entityIndex() returns a new pure map. The values of the map defined by elements of provided
 * entity {-src-} and keys defined by result of callback execution on the correspond elements.
 * If callback returns undefined, then element will not exist in resulted map.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns index of element.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityIndex( null );
 * // returns {}
 *
 * @example
 * _.entityIndex( null, ( el ) => el );
 * // returns { 'null' : null }
 *
 * @example
 * _.entityIndex( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndex( [ 1, 2, 3, 4 ], ( el, key ) => el + key );
 * // returns { '1' : 1, '3' : 2, '5' : 3, '7' : 4 }
 *
 * @example
 * _.entityIndex( { a : 1, b : 2, c : 3 } );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityIndex( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { '1' : 1, '2' : 2, '3' : 3 }
 *
 * @example
 * _.entityIndex( { a : { f1 : 1, f2 : 3 }, b : { f1 : 2, f2 : 4 } }, '*\/f1' );
 * // returns { '1' : { f1 : 1, f2 : 3 }, '2' : { f1 : 2, f2 : 4 } }
 *
 * @returns { PureMap } - Returns the pure map. Values of the map defined by elements of provided entity {-src-}
 * and keys defined by results of callback execution on corresponding elements.
 * @function entityIndex
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityIndex = _entityIndex_functor({ extendRoutine : null });

//

/**
 * The routine entityIndexSupplementing() returns a new pure map. The pairs key-value of the map formed by results
 * of callback execution on the entity elements.
 * If callback returns undefined, then element will not exist in resulted map.
 * If callback returns map with key existed in resulted map, then routine does not change existed value.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns index of element.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityIndexSupplementing( null );
 * // returns { 'null' : undefined }
 *
 * @example
 * _.entityIndexSupplementing( null, ( el ) => el );
 * // returns { 'null' : null }
 *
 * @example
 * _.entityIndexSupplementing( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndexSupplementing( [ 1, 2, 3, 4 ], ( el, key ) => key > 2 ? key : 1 );
 * // returns { '1' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndexSupplementing( { a : 1, b : 1, c : 1 } );
 * // returns { a : 1, b : 1, c : 1 }
 *
 * @example
 * _.entityIndexSupplementing( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityIndexSupplementing( { a : 1, b : 2, c : 3 }, ( el, key, container ) => { return { [ key ] : key, 'x' : el } } );
 * // returns { a : 'a', x : 1, b : 'b', c : 'c' }
 *
 * @example
 * _.entityIndexSupplementing( { a : { f1 : 1, f2 : 3 }, b : { f1 : 1, f2 : 4 } }, '*\/f1' );
 * // returns { '1' : { f1 : 1, f2 : 4 } }
 *
 * @returns { PureMap } - Returns the pure map. Values of the map defined by elements of provided entity {-src-}
 * and keys of defines by results of callback execution on corresponding elements. If the callback returns map
 * with existed key, then routine does not replaces the previous value with the new one.
 * @function entityIndexSupplementing
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityIndexSupplementing = _entityIndex_functor({ extendRoutine : _.props.supplement.bind( _.props ) });

//

/**
 * The routine entityIndexExtending() returns a new pure map. The pairs key-value of the map formed by results
 * of callback execution on the entity elements.
 * If callback returns undefined, then element will not exist in resulted map.
 * If callback returns map with key existed in resulted map, then routine replaces existed value to the new.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns index of element.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityIndexExtending( null );
 * // returns { 'null' : undefined }
 *
 * @example
 * _.entityIndexExtending( null, ( el ) => el );
 * // returns { 'null' : null }
 *
 * @example
 * _.entityIndexExtending( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndexExtending( [ 1, 2, 3, 4 ], ( el, key ) => key > 2 ? key : 1 );
 * // returns { '1' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndexExtending( { a : 1, b : 1, c : 1 } );
 * // returns { a : 1, b : 1, c : 1 }
 *
 * @example
 * _.entityIndexExtending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityIndexExtending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => { return { [ key ] : key, 'x' : el } } );
 * // returns { a : 'a', x : 3, b : 'b', c : 'c' }
 *
 * @example
 * _.entityIndexExtending( { a : { f1 : 1, f2 : 3 }, b : { f1 : 1, f2 : 4 } }, '*\/f1' );
 * // returns { '1' : { f1 : 1, f2 : 4 } }
 *
 * @returns { PureMap } - Returns the pure map. Values of the map defined by elements of provided entity {-src-}
 * and keys of defines by results of callback execution on corresponding elements. If the callback returns map
 * with existed key, then routine replaces the previous value with the new one.
 * @function entityIndexExtending
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityIndexExtending = _entityIndex_functor({ extendRoutine : _.props.extend.bind( _.props ) });

//

/**
 * The routine entityIndexPrepending() returns a new pure map. The pairs key-value of the map formed by results
 * of callback execution on the entity elements.
 * If callback returns undefined, then element will not exist in resulted map.
 * If callback returns map with key existed in resulted map, then routine prepends new values to the existed value.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns index of element.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityIndexPrepending( null );
 * // returns { 'null' : undefined }
 *
 * @example
 * _.entityIndexPrepending( null, ( el ) => el );
 * // returns { 'null' : null }
 *
 * @example
 * _.entityIndexPrepending( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndexPrepending( [ 1, 2, 3, 4 ], ( el, key ) => key > 2 ? key : 1 );
 * // returns { '1' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndexPrepending( { a : 1, b : 1, c : 1 } );
 * // returns { a : 1, b : 1, c : 1 }
 *
 * @example
 * _.entityIndexPrepending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityIndexPrepending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => { return { [ key ] : key, 'x' : el } } );
 * // returns { a : 'a', x : [ 3, 2, 1 ], b : 'b', c : 'c' }
 *
 * @example
 * _.entityIndexPrepending( { a : { f1 : 1, f2 : 3 }, b : { f1 : 1, f2 : 4 } }, '*\/f1' );
 * // returns { '1' : { f1 : 1, f2 : 4 } }
 *
 * @returns { PureMap } - Returns the pure map. Values of the map defined by elements of provided entity {-src-}
 * and keys of defines by results of callback execution on corresponding elements. If the callback returns map
 * with existed key, then routine prepends new value to the previous.
 * @function entityIndexPrepending
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityIndexPrepending = _entityIndex_functor({ extendRoutine : _.mapExtendPrepending });

//

/**
 * The routine entityIndexAppending() returns a new pure map. The pairs key-value of the map formed by results
 * of callback execution on the entity elements.
 * If callback returns undefined, then element will not exist in resulted map.
 * If callback returns map with key existed in resulted map, then routine appends new values to the existed value.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns index of element.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityIndexAppending( null );
 * // returns { 'null' : undefined }
 *
 * @example
 * _.entityIndexAppending( null, ( el ) => el );
 * // returns { 'null' : null }
 *
 * @example
 * _.entityIndexAppending( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndexAppending( [ 1, 2, 3, 4 ], ( el, key ) => key > 2 ? key : 1 );
 * // returns { '1' : 3, '3' : 4 }
 *
 * @example
 * _.entityIndexAppending( { a : 1, b : 1, c : 1 } );
 * // returns { a : 1, b : 1, c : 1 }
 *
 * @example
 * _.entityIndexAppending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityIndexAppending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => { return { [ key ] : key, 'x' : el } } );
 * // returns { a : 'a', x : [ 1, 2, 3 ], b : 'b', c : 'c' }
 *
 * @example
 * _.entityIndexAppending( { a : { f1 : 1, f2 : 3 }, b : { f1 : 1, f2 : 4 } }, '*\/f1' );
 * // returns { '1' : { f1 : 1, f2 : 4 } }
 *
 * @returns { PureMap } - Returns the pure map. Values of the map defined by elements of provided entity {-src-}
 * and keys of defines by results of callback execution on corresponding elements. If the callback returns map
 * with existed key, then routine appends new value to the previous.
 * @function entityIndexAppending
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityIndexAppending = _entityIndex_functor({ extendRoutine : _.mapExtendAppending });

//

function _entityRemap_functor( fop )
{

  fop = _.routine.options( _entityRemap_functor, fop );

  let extendRoutine = fop.extendRoutine;

  return function entityRemap( src, onEach )
  {
    let result = Object.create( null );

    if( onEach === undefined )
    onEach = function( e, k )
    {
      if( e === undefined && extendRoutine )
      return { [ k ] : e };
      return e;
    }
    else if( _.strIs( onEach ) )
    {
      let selector = onEach;
      _.assert( _.routine.is( _.select ) );
      _.assert( _.strBegins( selector, '*/' ), () => `Selector should begins with "*/", but "${selector}" does not` );
      selector = _.strRemoveBegin( selector, '*/' );
      onEach = function( e, k )
      {
        return _.select( e, selector );
      }
    }

    _.assert( arguments.length === 1 || arguments.length === 2 );
    _.assert( _.routine.is( onEach ) );
    _.assert( src !== undefined, 'Expects src' );

    /* */

    if( _.aux.is( src ) )
    {

      for( let k in src )
      {
        let val = src[ k ];
        let r = onEach( val, k, src );
        extend( r, k );
      }

    }
    else if( _.longIs( src ) )
    {

      for( let k = 0 ; k < src.length ; k++ )
      {
        let val = src[ k ];
        let r = onEach( val, k, src );
        extend( r, k );
      }

    }
    else
    {

      let val = src;
      let r = onEach( val, undefined, undefined );
      extend( r, undefined );

    }

    return result;

    /* */

    function extend( res, key )
    {
      if( res === undefined )
      return;

      if( _.unrollIs( res ) )
      return res.forEach( ( res ) => extend( res, key ) );

      if( extendRoutine === null )
      {
        if( key !== undefined )
        result[ key ] = res;
      }
      else
      {
        if( _.aux.is( res ) )
        extendRoutine( result, res );
        else if( key !== undefined )
        result[ key ] = res;
      }

    }

  }

}

_entityRemap_functor.defaults =
{
  extendRoutine : null,
}

//

/**
 * The routine entityRemap() returns a new pure map. The keys of the map defined by keys of provided
 * entity {-src-} and values defined by result of callback execution on the correspond elements.
 * If callback returns undefined, then element will not exist in resulted map.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns map with pair key-value for Longs
 * and maps or element for other types.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityRemap( null );
 * // returns {}
 *
 * @example
 * _.entityRemap( null, ( el ) => el );
 * // returns {}
 *
 * @example
 * _.entityRemap( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityRemap( [ 1, 2, 3, 4 ], ( el, key ) => el + key );
 * // returns { '0' : 1, '1' : 3, '2' : 5, '3' : 7 }
 *
 * @example
 * _.entityRemap( { a : 1, b : 2, c : 3 } );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityRemap( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 'a', b : 'b', c : 'c' }
 *
 * @example
 * _.entityRemap( { a : { f1 : 1, f2 : 3 }, b : { f1 : 2, f2 : 4 } }, '*\/f1' );
 * // returns { a : 1, b : 2 }
 *
 * @returns { PureMap } - Returns the pure map. Keys of the map defined by keys of provided entity {-src-}
 * and values defined by results of callback execution on corresponding elements.
 * @function entityRemap
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityRemap = _entityRemap_functor({ extendRoutine : null });

//

/**
 * The routine entityRemapSupplementing() returns a new pure map. The keys of the map defined by keys of provided
 * entity {-src-} and values defined by result of callback execution on the correspond elements.
 * If callback returns undefined, then element will not exist in resulted map.
 * If callback returns map with key existed in resulted map, then routine does not change existed value.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns map with pair key-value for Longs
 * and maps or element for other types.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityRemapSupplementing( null );
 * // returns {}
 *
 * @example
 * _.entityRemapSupplementing( null, ( el ) => el );
 * // returns {}
 *
 * @example
 * _.entityRemapSupplementing( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityRemapSupplementing( [ 1, 2, 3, 4 ], ( el, key ) => el + key );
 * // returns { '0' : 1, '1' : 3, '2' : 5, '3' : 7 }
 *
 * @example
 * _.entityRemapSupplementing( { a : 1, b : 2, c : 3 } );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityRemapSupplementing( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 'a', b : 'b', c : 'c' }
 *
 * @example
 * _.entityRemapSupplementing( { a : 1, b : 2, c : 3 }, ( el, key, container ) => { return { [ key ] : el, x : el } } );
 * // returns { a : 1, x : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityRemapSupplementing( { a : { f1 : 1, f2 : 3 }, b : { f1 : 2, f2 : 4 } }, '*\/f1' );
 * // returns { a : 1, b : 2 }
 *
 * @returns { PureMap } - Returns the pure map. Keys of the map defined by keys of provided entity {-src-}
 * and values defined by results of callback execution on corresponding elements. If the callback returns map
 * with existed key, then routine does not replaces the previous value with the new one.
 * @function entityRemapSupplementing
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */


let entityRemapSupplementing = _entityRemap_functor({ extendRoutine : _.props.supplement.bind( _.props ) });

//

/**
 * The routine entityRemapExtending() returns a new pure map. The keys of the map defined by keys of provided
 * entity {-src-} and values defined by result of callback execution on the correspond elements.
 * If callback returns undefined, then element will not exist in resulted map.
 * If callback returns map with key existed in resulted map, then routine does change existed value to the new one.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns map with pair key-value for Longs
 * and maps or element for other types.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityRemapExtending( null );
 * // returns {}
 *
 * @example
 * _.entityRemapExtending( null, ( el ) => el );
 * // returns {}
 *
 * @example
 * _.entityRemapExtending( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityRemapExtending( [ 1, 2, 3, 4 ], ( el, key ) => el + key );
 * // returns { '0' : 1, '1' : 3, '2' : 5, '3' : 7 }
 *
 * @example
 * _.entityRemapExtending( { a : 1, b : 2, c : 3 } );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityRemapExtending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 'a', b : 'b', c : 'c' }
 *
 * @example
 * _.entityRemapExtending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => { return { [ key ] : el, x : el } } );
 * // returns { a : 1, x : 3, b : 2, c : 3 }
 *
 * @example
 * _.entityRemapExtending( { a : { f1 : 1, f2 : 3 }, b : { f1 : 2, f2 : 4 } }, '*\/f1' );
 * // returns { a : 1, b : 2 }
 *
 * @returns { PureMap } - Returns the pure map. Keys of the map defined by keys of provided entity {-src-}
 * and values defined by results of callback execution on corresponding elements. If the callback returns map
 * with existed key, then routine replaces the previous value with the new one.
 * @function entityRemapExtending
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityRemapExtending = _entityRemap_functor({ extendRoutine : _.props.extend.bind( _.props ) });

//

/**
 * The routine entityRemapPrepending() returns a new pure map. The keys of the map defined by keys of provided
 * entity {-src-} and values defined by result of callback execution on the correspond elements.
 * If callback returns undefined, then element will not exist in resulted map.
 * If callback returns map with key existed in resulted map, then routine prepends new values to the existed value.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns map with pair key-value for Longs
 * and maps or element for other types.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityRemapPrepending( null );
 * // returns {}
 *
 * @example
 * _.entityRemapPrepending( null, ( el ) => el );
 * // returns {}
 *
 * @example
 * _.entityRemapPrepending( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityRemapPrepending( [ 1, 2, 3, 4 ], ( el, key ) => el + key );
 * // returns { '0' : 1, '1' : 3, '2' : 5, '3' : 7 }
 *
 * @example
 * _.entityRemapPrepending( { a : 1, b : 2, c : 3 } );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityRemapPrepending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 'a', b : 'b', c : 'c' }
 *
 * @example
 * _.entityRemapPrepending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => { return { [ key ] : el, x : el } } );
 * // returns { a : 1, x : [ 3, 2, 1 ], b : 2, c : 3 }
 *
 * @example
 * _.entityRemapPrepending( { a : { f1 : 1, f2 : 3 }, b : { f1 : 2, f2 : 4 } }, '*\/f1' );
 * // returns { a : 1, b : 2 }
 *
 * @returns { PureMap } - Returns the pure map. Keys of the map defined by keys of provided entity {-src-}
 * and values defined by results of callback execution on corresponding elements. If the callback returns map
 * with existed key, then routine prepends new values to the existed value.
 * @function entityRemapPrepending
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityRemapPrepending = _entityRemap_functor({ extendRoutine : _.mapExtendPrepending });

//

/**
 * The routine entityRemapAppending() returns a new pure map. The keys of the map defined by keys of provided
 * entity {-src-} and values defined by result of callback execution on the correspond elements.
 * If callback returns undefined, then element will not exist in resulted map.
 * If callback returns map with key existed in resulted map, then routine appends new values to the existed value.
 *
 * @param { * } src - Any entity to make map of indexes.
 * @param { String|Function } onEach - The callback executed on elements of entity.
 * If {-onEach-} is not defined, then routine uses callback that returns map with pair key-value for Longs
 * and maps or element for other types.
 * If {-onEach-} is a string, then routine searches elements with equal key. String value should has
 * prefix "*\/" ( asterisk + slash ).
 * By default, {-onEach-} applies three parameters: element, key, container. If entity is primitive, then
 * routine applies only element value, other parameters is undefined.
 *
 * @example
 * _.entityRemapAppending( null );
 * // returns {}
 *
 * @example
 * _.entityRemapAppending( null, ( el ) => el );
 * // returns {}
 *
 * @example
 * _.entityRemapAppending( [ 1, 2, 3, 4 ] );
 * // returns { '0' : 1, '1' : 2, '2' : 3, '3' : 4 }
 *
 * @example
 * _.entityRemapAppending( [ 1, 2, 3, 4 ], ( el, key ) => el + key );
 * // returns { '0' : 1, '1' : 3, '2' : 5, '3' : 7 }
 *
 * @example
 * _.entityRemapAppending( { a : 1, b : 2, c : 3 } );
 * // returns { a : 1, b : 2, c : 3 }
 *
 * @example
 * _.entityRemapAppending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => container.a > 0 ? key : el );
 * // returns { a : 'a', b : 'b', c : 'c' }
 *
 * @example
 * _.entityRemapAppending( { a : 1, b : 2, c : 3 }, ( el, key, container ) => { return { [ key ] : el, x : el } } );
 * // returns { a : 1, x : [ 3, 2, 1 ], b : 2, c : 3 }
 *
 * @example
 * _.entityRemapAppending( { a : { f1 : 1, f2 : 3 }, b : { f1 : 2, f2 : 4 } }, '*\/f1' );
 * // returns { a : 1, b : 2 }
 *
 * @returns { PureMap } - Returns the pure map. Keys of the map defined by keys of provided entity {-src-}
 * and values defined by results of callback execution on corresponding elements. If the callback returns map
 * with existed key, then routine appends new values to the existed value.
 * @function entityRemapAppending
 * @throws { Error } If arguments.length is less then one or more then two.
 * @throws { Error } If {-src-} has value undefined.
 * @throws { Error } If {-onEach-} is not undefined, not a function, not a String.
 * @throws { Error } If {-onEach-} is a String, but has not prefix '*\/' ( asterisk + slash ).
 * @namespace Tools
 */

let entityRemapAppending = _entityRemap_functor({ extendRoutine : _.mapExtendAppending });

// --
// implementation
// --

let ToolsExtension =
{

  // eachSample_, /* xxx : review */
  // eachPermutation_, /* xxx : move out */
  // swapsCount, /* xxx : move out */
  // _factorial, /* xxx : move out */
  // factorial, /* xxx : move out */

  _entityFilterDeep,
  entityFilterDeep,
  filterDeep : entityFilterDeep,

  _entityIndex_functor,
  entityIndex,
  index : entityIndex,
  entityIndexSupplementing,
  indexSupplementing : entityIndexSupplementing,
  entityIndexExtending,
  indexExtending : entityIndexExtending,
  entityIndexPrepending,
  indexPrepending : entityIndexPrepending,
  entityIndexAppending,
  indexAppending : entityIndexAppending,

  _entityRemap_functor,
  entityRemap,
  remap : entityRemap,
  entityRemapSupplementing,
  remapSupplementing : entityRemapSupplementing,
  entityRemapExtending,
  remapExtending : entityRemapExtending,
  entityRemapPrepending,
  remapPrepending : entityRemapPrepending,
  entityRemapAppending,
  remapAppending : entityRemapAppending,

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Functional.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Functional_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Functional_s */ })();

/* */  /* begin of file Fuzzy_s */ ( function Fuzzy_s() { function Fuzzy_s_naked() { ( function _l7_Fuzzy_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.fuzzy = _.fuzzy || Object.create( null );

// --
// fuzzy
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( _, ToolsExtension );
Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Fuzzy.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Fuzzy_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Fuzzy_s */ })();

/* */  /* begin of file Global_s */ ( function Global_s() { function Global_s_naked() { ( function _l7_Global_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.global = _.global || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{

}

//

Object.assign( _.global, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Global.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Global_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Global_s */ })();

/* */  /* begin of file HashMap_s */ ( function HashMap_s() { function HashMap_s_naked() { ( function _l7_HashMap_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.hashMap = _.hashMap || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( _, ToolsExtension );
Object.assign( _.hashMap, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/HashMap.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, HashMap_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file HashMap_s */ })();

/* */  /* begin of file Interval_s */ ( function Interval_s() { function Interval_s_naked() { ( function _l7_Interval_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

let Extension =
{

}

//

_.props.supplement( _, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Interval.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Interval_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Interval_s */ })();

/* */  /* begin of file Intervalc_s */ ( function Intervalc_s() { function Intervalc_s_naked() { ( function _l7_Intervalc_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.cinterval = _.cinterval || Object.create( null );

// --
//
// --

// --
// implementation
// --

let Extension =
{
};

//

_.props.supplement( _.cinterval, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Intervalc.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervalc_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervalc_s */ })();

/* */  /* begin of file Intervall_s */ ( function Intervall_s() { function Intervall_s_naked() { ( function _l7_Intervall_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.linterval = _.linterval || Object.create( null );

// --
//
// --

// --
//
// --

let Extension =
{
};

//

_.props.supplement( _.linterval, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Intervall.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervall_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervall_s */ })();

/* */  /* begin of file Intervalo_s */ ( function Intervalo_s() { function Intervalo_s_naked() { ( function _l7_Intervalo_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.ointerval = _.ointerval || Object.create( null );

// --
//
// --

// --
// implementation
// --

let Extension =
{
};

//

_.props.supplement( _.ointerval, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Intervalo.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Intervalo_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Intervalo_s */ })();

/* */  /* begin of file Introspector_s */ ( function Introspector_s() { function Introspector_s_naked() { ( function _l7_Introspector_s_()
{

'use strict';

const _global = _global_;
const _ = _global.wTools;
_.introspector = _.introspector || Object.create( null );

// --
// diagnostics
// --

let _diagnosticCodeExecuting = 0;
function code( o )
{

  _.routine.options( code, o );
  _.assert( arguments.length === 0 || arguments.length === 1 );

  if( _diagnosticCodeExecuting )
  return;
  _diagnosticCodeExecuting += 1;

  try
  {

    if( !o.location )
    {
      if( o.error )
      o.location = _.introspector.location({ error : o.error, level : o.level });
      else
      o.location = _.introspector.location({ stack : o.stack, level : o.stack ? o.level : o.level+1 });
    }

    if( !_.number.is( o.location.line ) )
    return end();

    /* */

    if( !o.sourceCode )
    {

      if( !o.location.filePath )
      return end();

      let codeProvider = _.codeProvider || _.fileProvider;
      if( !codeProvider && _globals_.testing && _globals_.testing.wTools )
      codeProvider = _globals_.testing.wTools.codeProvider || _globals_.testing.wTools.fileProvider;

      if( !codeProvider )
      return end();

      try
      {

        let filePath = codeProvider.path.normalizeTolerant( o.location.filePath );
        if( codeProvider.path.isAbsolute( filePath ) )
        o.sourceCode = read( codeProvider, filePath );

      }
      catch( err )
      {
        o.sourceCode = ` ! Cant load source code of "${ o.location.filePath }"`;
      }

      if( !o.sourceCode )
      return end();

    }

    /* */

    let code = _.strLinesSelect
    ({
      src : o.sourceCode,
      line : o.location.line,
      nearestLines : o.nearestLines,
      selectMode : o.selectMode,
      zeroLine : 1,
      numbering : 1,
    });

    if( code && _.strLinesIndentation && o.identation )
    code = o.identation + _.strLinesIndentation( code, o.identation );

    let result = code;
    if( o.withPath )
    {
      if( o.asMap )
      result = { path : o.location.filePathLineCol, code };
      else
      result = o.location.filePathLineCol + '\n' + code;
    }

    return end( result );
  }
  catch( err )
  {
    console.log( err.toString() );
    return;
  }

  /* */

  function end( result )
  {
    _diagnosticCodeExecuting -= 1;
    return result;
  }

  /* */

  function read( codeProvider, filePath )
  {
    let result = codeProvider.fileRead
    ({
      filePath,
      sync : 1,
      throwing : 0,
    });
    return result;
  }

  /* */

}

code.defaults =
{
  level : 0,
  nearestLines : 5,
  withPath : 1,
  asMap : 0,
  selectMode : 'center',
  identation : null,
  stack : null,
  error : null,
  location : null,
  sourceCode : null,
}

//

function memoryUsageInfo()
{
  var usage = process.memoryUsage();
  return ( usage.heapUsed >> 20 ) + ' / ' + ( usage.heapTotal >> 20 ) + ' / ' + ( usage.rss >> 20 ) + ' Mb';
}

// --
// declare
// --

let Extension =
{

  code,
  memoryUsageInfo,

}

Object.assign( _.introspector, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Introspector.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Introspector_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Introspector_s */ })();

/* */  /* begin of file Logic_s */ ( function Logic_s() { function Logic_s_naked() { ( function _l7_Logic_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// logic extension
// --

let LogicExtension =
{

}

Object.assign( _.logic, LogicExtension );

// --
// tools extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Logic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Logic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Logic_s */ })();

/* */  /* begin of file Long_s */ ( function Long_s() { function Long_s_naked() { ( function _l7_Long_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

//

const _ArrayIndexOf = Array.prototype.indexOf;
const _ArrayLastIndexOf = Array.prototype.lastIndexOf;
const _ArraySlice = Array.prototype.slice;
const _ArraySplice = Array.prototype.splice;
const _FunctionBind = Function.prototype.bind;
const _ObjectToString = Object.prototype.toString;
const _ObjectPropertyIsEumerable = Object.propertyIsEnumerable;

// --
// long transformer
// --

/**
 * The routine longOnce() returns the {-dstLong-} with the duplicated elements removed.
 * The {-dstLong-} instance will be returned when possible, if not a new instance of the same type is created.
 *
 * @param { Long } dstLong - The source and destination Long.
 * @param { Function } onEvaluate - A callback function.
 *
 * @example
 * _.longOnce( [ 1, 1, 2, 'abc', 'abc', 4, true, true ] );
 * // returns [ 1, 2, 'abc', 4, true ]
 *
 * @example
 * _.longOnce( [ 1, 2, 3, 4, 5 ] );
 * // returns [ 1, 2, 3, 4, 5 ]
 *
 * @example
 * _.longOnce( [ { v : 1 },{ v : 1 }, { v : 1 } ], ( e ) => e.v );
 * // returns [ { v : 1 } ]
 *
 * @example
 * _.longOnce( [ { v : 1 },{ v : 1 }, { v : 1 } ], ( e ) => e.k );
 * // returns [ { v : 1 },{ v : 1 }, { v : 1 } ]
 *
 * @returns { Long } - If it is possible, returns the source Long without the duplicated elements.
 * Otherwise, returns copy of the source Long without the duplicated elements.
 * @function longOnce
 * @throws { Error } If passed arguments is less than one or more than two.
 * @throws { Error } If the first argument is not an long.
 * @throws { Error } If the second argument is not a Routine.
 * @namespace Tools
 */

function longOnce( dstLong, onEvaluate )
{
  _.assert( 1 <= arguments.length || arguments.length <= 2 );
  _.assert( _.longIs( dstLong ), 'Expects Long' );

  if( _.arrayIs( dstLong ) )
  return _.arrayRemoveDuplicates( dstLong, onEvaluate );

  if( !dstLong.length )
  return dstLong;

  let length = dstLong.length;

  for( let i = 0; i < dstLong.length; i++ )
  if( _.longLeftIndex( dstLong, dstLong[ i ], i+1, onEvaluate ) !== -1 )
  length--;

  if( length === dstLong.length )
  return dstLong;

  let result = _.long.makeUndefined( dstLong, length );
  result[ 0 ] = dstLong[ 0 ];

  let j = 1;
  for( let i = 1; i < dstLong.length && j < length; i++ )
  if( _.longRightIndex( result, dstLong[ i ], j-1, onEvaluate ) === -1 )
  result[ j++ ] = dstLong[ i ];

  _.assert( j === length );

  return result;
}

//

function longOnce_( dstLong, srcLong, onEvaluate )
{
  _.assert( dstLong === null || _.longIs( dstLong ), 'Expects Long' );

  if( dstLong === null )
  {
    if( _.longIs( srcLong ) )
    dstLong = _.long.makeUndefined( srcLong, 0 );
    else
    return [];
  }
  if( arguments.length === 1 )
  {
    srcLong = dstLong;
  }
  else if( arguments.length === 2 )
  {
    if( _.routine.is( srcLong ) )
    {
      onEvaluate = arguments[ 1 ];
      srcLong = arguments[ 0 ];
    }
  }
  else if( arguments.length !== 3 )
  _.assert( 0 );

  _.assert( _.longIs( srcLong ) );

  let result;

  if( dstLong === srcLong )
  {
    if( !dstLong.length )
    return dstLong;

    if( _.arrayIs( dstLong ) )
    return _.arrayRemoveDuplicates( dstLong, onEvaluate );

    let length = dstLong.length;

    for( let i = 0; i < dstLong.length; i++ )
    if( _.longLeftIndex( dstLong, dstLong[ i ], i + 1, onEvaluate ) !== -1 )
    length--;

    if( length === dstLong.length )
    return dstLong;

    result = _.long.makeUndefined( dstLong, length );
    result[ 0 ] = dstLong[ 0 ];

    let j = 1;
    for( let i = 1; i < dstLong.length && j < length; i++ )
    if( _.longRightIndex( result, dstLong[ i ], j - 1, onEvaluate ) === -1 )
    result[ j++ ] = dstLong[ i ];

    _.assert( j === length );
  }
  else
  {
    if( _.arrayIs( dstLong ) )
    {
      result = _.arrayAppendArrayOnce( dstLong, srcLong, onEvaluate );
    }
    else
    {
      let length = srcLong.length + dstLong.length;

      for( let i = 0; i < srcLong.length; i++ )
      if
      (
        _.longLeftIndex( dstLong, srcLong[ i ], onEvaluate ) !== -1
        || _.longLeftIndex( srcLong, srcLong[ i ], i + 1, onEvaluate ) !== -1
      )
      length--;

      if( length === dstLong.length )
      return dstLong;

      result = _.long.makeUndefined( dstLong, length );

      for( let i = 0; i < dstLong.length; i++ )
      result[ i ] = dstLong[ i ]

      let offset = dstLong.length;
      for( let i = dstLong.length ; i < result.length && offset >= -result.length ;  )
      {
        if( _.longLeftIndex( result, srcLong[ i - offset ], onEvaluate ) === -1 )
        {
          result[ i ] = srcLong[ i - offset ];
          i++;
        }
        else
        {
          offset--;
        }
      }
    }
  }


  return result;
}

//

function longHasUniques( o )
{

  if( _.longIs( o ) )
  o = { src : o };

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.longIs( o.src ) );
  _.map.assertHasOnly( o, longHasUniques.defaults );

  /* */

  // if( o.onEvaluate )
  // {
  //   o.src = _.entity.map_( null, o.src, ( e ) => o.onEvaluate( e ) );
  // }

  /* */

  let number = o.src.length;
  let isUnique = [];
  let index;

  for( let i = 0 ; i < o.src.length ; i++ )
  isUnique[ i ] = 1;

  for( let i = 0 ; i < o.src.length ; i++ )
  {
    index = i;

    if( !isUnique[ i ] )
    continue;

    let currentUnique = 1;
    index = _.longLeftIndex( o.src, o.src[ i ], index+1, o.onEvaluate );
    if( index >= 0 )
    do
    {
      isUnique[ index ] = 0;
      number -= 1;
      currentUnique = 0;
      index = _.longLeftIndex( o.src, o.src[ i ], index+1, o.onEvaluate );
    }
    while( index >= 0 );

    // if( currentUnique && o.src2 )
    // do
    // {
    //   index = o.src2.indexOf( o.src2[ i ], index+1 );
    //   if( index !== -1 )
    //   currentUnique = 0;
    // }
    // while( index !== -1 );

    if( !o.includeFirst )
    if( !currentUnique )
    {
      isUnique[ i ] = 0;
      number -= 1;
    }

  }

  return { number, is : isUnique };
}

longHasUniques.defaults =
{
  src : null,
  // src2 : null,
  onEvaluate : null,
  includeFirst : 0,
}

//

function longAreRepeatedProbe( srcArray, onEvaluate )
{
  let isUnique = _.long.makeUndefined( srcArray );
  let result = Object.create( null );
  result.array = _.array.make( srcArray.length );
  result.uniques = srcArray.length;
  result.condensed = srcArray.length;

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.longIs( srcArray ) );

  for( let i = 0 ; i < srcArray.length ; i++ )
  {
    let element = srcArray[ i ];

    if( result.array[ i ] > 0 )
    continue;

    result.array[ i ] = 0;

    let left = _.longLeftIndex( srcArray, element, i+1, onEvaluate );
    if( left >= 0 )
    {
      result.array[ i ] = 1;
      result.uniques -= 1;
      do
      {
        result.uniques -= 1;
        result.condensed -= 1;
        result.array[ left ] = 1;
        left = _.longLeftIndex( srcArray, element, left+1, onEvaluate );
      }
      while( left >= 0 );
    }

  }

  return result;

}

//

function longAllAreRepeated( src, onEvalutate )
{
  let areRepated = _.longAreRepeatedProbe.apply( this, arguments );
  return !areRepated.uniques;
}

//

function longAnyAreRepeated( src, onEvalutate )
{
  let areRepated = _.longAreRepeatedProbe.apply( this, arguments );
  return areRepated.uniques !== src.length;
}

//

function longNoneAreRepeated( src, onEvalutate )
{
  let areRepated = _.longAreRepeatedProbe.apply( this, arguments );
  return areRepated.uniques === src.length;
}

//

/**
 * The longMask() routine returns a new instance of array that contains the certain value(s) from array (srcArray),
 * if an array (mask) contains the truth-value(s).
 *
 * The longMask() routine checks, how much an array (mask) contain the truth value(s),
 * and from that amount of truth values it builds a new array, that contains the certain value(s) of an array (srcArray),
 * by corresponding index(es) (the truth value(s)) of the array (mask).
 * If amount is equal 0, it returns an empty array.
 *
 * @param { longIs } srcArray - The source array.
 * @param { longIs } mask - The target array.
 *
 * @example
 * _.longMask( [ 1, 2, 3, 4 ], [ undefined, null, 0, '' ] );
 * // returns []
 *
 * @example
 * _longMask( [ 'a', 'b', 'c', 4, 5 ], [ 0, '', 1, 2, 3 ] );
 * // returns [ "c", 4, 5 ]
 *
 * @example
 * _.longMask( [ 'a', 'b', 'c', 4, 5, 'd' ], [ 3, 7, 0, '', 13, 33 ] );
 * // returns [ 'a', 'b', 5, 'd' ]
 *
 * @returns { longIs } Returns a new instance of array that contains the certain value(s) from array (srcArray),
 * if an array (mask) contains the truth-value(s).
 * If (mask) contains all falsy values, it returns an empty array.
 * Otherwise, it returns a new array with certain value(s) of an array (srcArray).
 * @function longMask
 * @throws { Error } Will throw an Error if (arguments.length) is less or more that two.
 * @throws { Error } Will throw an Error if (srcArray) is not an array-like.
 * @throws { Error } Will throw an Error if (mask) is not an array-like.
 * @throws { Error } Will throw an Error if length of both (srcArray and mask) is not equal.
 * @namespace Tools
 */

function longMask( srcArray, mask )
{

  let scalarsPerElement = mask.length;
  let length = srcArray.length / scalarsPerElement;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( srcArray ), 'longMask :', 'Expects array-like as srcArray' );
  _.assert( _.longIs( mask ), 'longMask :', 'Expects array-like as mask' );
  _.assert
  (
    _.intIs( length ),
    'longMask :', 'Expects mask that has component for each atom of srcArray',
    _.entity.exportString
    ({
      scalarsPerElement,
      'srcArray.length' : srcArray.length,
    })
  );

  let preserve = 0;
  for( let m = 0 ; m < mask.length ; m++ )
  if( mask[ m ] )
  preserve += 1;

  // let dstArray = new srcArray.constructor( length*preserve );
  let dstArray = _.long.makeUndefined( srcArray, length*preserve );

  if( !preserve )
  return dstArray;

  let c = 0;
  for( let i = 0 ; i < length ; i++ )
  for( let m = 0 ; m < mask.length ; m++ )
  if( mask[ m ] )
  {
    dstArray[ c ] = srcArray[ i*scalarsPerElement + m ];
    c += 1;
  }

  return dstArray;
}

//

function longUnmask( o )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );

  if( arguments.length === 2 )
  o =
  {
    src : arguments[ 0 ],
    mask : arguments[ 1 ],
  }

  _.map.assertHasOnly( o, longUnmask.defaults );
  _.assert( _.longIs( o.src ), 'Expects o.src as ArrayLike' );

  let scalarsPerElement = o.mask.length;

  let scalarsPerElementPreserved = 0;
  for( let m = 0 ; m < o.mask.length ; m++ )
  if( o.mask[ m ] )
  scalarsPerElementPreserved += 1;

  let length = o.src.length / scalarsPerElementPreserved;
  if( Math.floor( length ) !== length )
  throw _.err
  (
    'longMask :',
    'Expects mask that has component for each atom of o.src',
    _.entity.exportString({ scalarsPerElementPreserved, 'o.src.length' : o.src.length  })
  );

  let dstArray = _.long.makeUndefined( o.src, scalarsPerElement*length );
  // let dstArray = new o.src.constructor( scalarsPerElement*length );

  let e = [];
  for( let i = 0 ; i < length ; i++ )
  {

    for( let m = 0, p = 0 ; m < o.mask.length ; m++ )
    if( o.mask[ m ] )
    {
      e[ m ] = o.src[ i*scalarsPerElementPreserved + p ];
      p += 1;
    }
    else
    {
      e[ m ] = 0;
    }

    if( o.onEach )
    o.onEach( e, i );

    for( let m = 0 ; m < o.mask.length ; m++ )
    dstArray[ i*scalarsPerElement + m ] = e[ m ];

  }

  return dstArray;
}

longUnmask.defaults =
{
  src : null,
  mask : null,
  onEach : null,
}

// --
// array maker
// --

/**
 * The routine longRandom() returns an array which contains random numbers.
 *
 * Routine accepts one or three arguments.
 * Optionally, routine can accepts one of two sets of parameters. First of them
 * is one or three arguments, the other is options map.
 *
 * Set 1:
 * @param { ArrayLike } dst - The destination array.
 * @param { Range|Number } range - The range for generating random numbers.
 * If {-range-} is number, routine makes range [ range, range ].
 * @param { Number|Range } length - The quantity of generated random numbers.
 * If dst.length < {-length-}, then routine makes new container of {-dst-} type.
 * If {-length-} is Range, then routine choose random lenght from provided range.
 *
 * Set 2:
 * @param { Object } o - The options map. Options map includes next fields:
 * @param { Function } o.onEach - The callback for generating random numbers.
 * Accepts three parameters - range, index of element, source container.
 * @param { ArrayLike } o.dst - The destination array.
 * @param { Range|Number } o.range -  The range for generating random numbers.
 * If {-range-} is number, routine makes range [ range, range ].
 * @param { Number|Range } o.length - The length of an array.
 * If dst.length < length, then routine makes new container of {-dst-} type.
 * If {-length-} is Range, then routine choose random lenght from provided range.
 *
 * @example
 * let got = _.longRandom( 3 );
 * // returns array with three elements in range [ 0, 1 ]
 * console.log( got );
 * // log [ 0.2054268445, 0.8651654684, 0.5564687461 ]
 *
 * @example
 * let dst = [ 0, 0, 0 ];
 * let got _.longRandom( dst, [ 1, 5 ], 3 );
 * // returns dst array with three elements in range [ 1, 5 ]
 * console.log( got );
 * // log [ 4.9883513548, 1.2313468546, 3.8973544247 ]
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let dst = [ 0, 0, 0 ];
 * let got _.longRandom( dst, [ 1, 5 ], 4 );
 * // returns dst array with three elements in range [ 1, 5 ]
 * console.log( got );
 * // log [ 4.9883513548, 1.2313468546, 3.8973544247, 2.6782254287 ]
 * console.log( got === dst );
 * // log false
 *
 * @example
 * _.longRandom
 * ({
 *   length : 5,
 *   range : [ 1, 10 ],
 *   onEach : ( range ) => _.intRandom( range ),
 * });
 * // returns [ 6, 2, 4, 7, 8 ]
 *
 * @example
 * let dst = [ 0, 0, 0, 0, 0 ]
 * var got = _.longRandom
 * ({
 *   length : 3,
 *   range : [ 1, 10 ],
 *   onEach : ( range ) => _.intRandom( range ),
 * });
 * console.log( got );
 * // log [ 1, 10, 4, 0, 0 ]
 * console.log( got === dst );
 * // log true
 *
 * @returns { ArrayLike } - Returns an array of random numbers.
 * @function longRandom
 * @throws { Error } If arguments.length === 0, arguments.length === 2, arguments.lenght > 3.
 * @throws { Error } If arguments.length === 1, and passed argument is not options map {-o-} or {-length-}.
 * @throws { Error } If options map {-o-} has unnacessary fields.
 * @throws { Error } If {-dst-} or {-o.dst-} is not ArrayLike.
 * @throws { Error } If {-range-} or {-o.range-} is not Range or not Number.
 * @throws { Error } If {-length-} or {-o.length-} is not Number or not Range.
 * @throws { Error } If {-o.onEach-} is not routine.
 * @namespace Tools
 */

function longRandom( o )
{

  if( arguments[ 2 ] !== undefined )
  o = { dst : arguments[ 0 ], value : arguments[ 1 ], length : arguments[ 2 ] }
  else if( _.number.is( o ) || _.intervalIs( o ) )
  o = { length : o }
  _.assert( arguments.length === 1 || arguments.length === 3 );
  _.routine.options( longRandom, o );

  if( o.onEach === null )
  o.onEach = ( value ) => _.number.random( value );

  if( o.value === null )
  o.value = [ 0, 1 ];
  if( _.number.is( o.value ) )
  o.value = [ 0, o.value ]
  // o.value = [ o.value, o.value ]

  if( _.intervalIs( o.length ) )
  o.length = _.intRandom( o.length );
  if( o.length === null && o.dst )
  o.length = o.dst.length;
  if( o.length === null )
  o.length = 1;

  _.assert( _.intIs( o.length ) );

  if( o.dst === null || o.dst.length < o.length )
  o.dst = _.long.make( o.dst, o.length );

  for( let i = 0 ; i < o.length ; i++ )
  {
    o.dst[ i ] = o.onEach( o.value, i, o );
  }

  return o.dst;
}

longRandom.defaults =
{
  dst : null,
  onEach : null,
  value : null,
  length : null,
}

//

/**
 * The longFromRange() routine generate array of arithmetic progression series,
 * from the range[ 0 ] to the range[ 1 ] with increment 1.
 *
 * It iterates over loop from (range[0]) to the (range[ 1 ] - range[ 0 ]),
 * and assigns to the each index of the (result) array (range[ 0 ] + 1).
 *
 * @param { longIs } range - The first (range[ 0 ]) and the last (range[ 1 ] - range[ 0 ]) elements of the progression.
 *
 * @example
 * _.longFromRange( [ 1, 5 ] );
 * // returns [ 1, 2, 3, 4 ]
 *
 * @example
 * _.longFromRange( 5 );
 * // returns [ 0, 1, 2, 3, 4 ]
 *
 * @returns { array } Returns an array of numbers for the requested range with increment 1.
 * May be an empty array if adding the step would not converge toward the end value.
 * @function longFromRange
 * @throws { Error } If passed arguments is less than one or more than one.
 * @throws { Error } If the first argument is not an array-like object.
 * @throws { Error } If the length of the (range) is not equal to the two.
 * @namespace Tools
 */

function longFromRange( range )
{

  if( _.number.is( range ) )
  range = [ 0, range ];

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( range.length === 2 );
  _.assert( _.longIs( range ) );

  let step = range[ 0 ] <= range[ 1 ] ? +1 : -1;

  return this.longFromRangeWithStep( range, step );
}

//

function longFromProgressionArithmetic( progression, numberOfSteps )
{
  let result; /* zzz : review */

  debugger;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( progression ) )
  _.assert( isFinite( progression[ 0 ] ) );
  _.assert( isFinite( progression[ 1 ] ) );
  _.assert( isFinite( numberOfSteps ) );
  _.assert( _.routine.is( this.tools.long.default.from ) );

  debugger;

  if( numberOfSteps === 0 )
  return this.tools.long.default.from();

  if( numberOfSteps === 1 )
  return this.tools.long.default.from([ progression[ 0 ] ]);

  let range = [ progression[ 0 ], progression[ 0 ]+progression[ 1 ]*(numberOfSteps+1) ];
  let step = ( range[ 1 ]-range[ 0 ] ) / ( numberOfSteps-1 );

  return this.longFromRangeWithStep( range, step );
}

//

function longFromRangeWithStep( range, step )
{
  let result;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( isFinite( range[ 0 ] ) );
  _.assert( isFinite( range[ 1 ] ) );
  _.assert( step === undefined || step < 0 || step > 0 );
  _.assert( _.routine.is( this.tools.long.default.from ) );

  if( range[ 0 ] === range[ 1 ] )
  return this.long.default.make();
  // return this.tools.long.default.from();

  if( range[ 0 ] < range[ 1 ] )
  {

    if( step === undefined )
    step = 1;

    _.assert( step > 0 );

    // debugger;
    result = this.long.default.from( Math.round( ( range[ 1 ]-range[ 0 ] ) / step ) );
    // result = this.tools.long.default.from( Math.round( ( range[ 1 ]-range[ 0 ] ) / step ) );

    let i = 0;
    while( range[ 0 ] < range[ 1 ] )
    {
      result[ i ] = range[ 0 ];
      range[ 0 ] += step;
      i += 1;
    }

  }
  else
  {

    if( step === undefined )
    step = -1;

    _.assert( step < 0 );

    // result = this.tools.long.default.from( Math.round( ( range[ 1 ]-range[ 0 ] ) / step ) ); // Dmytro it's more optimal, range[ 0 ] > range[ 1 ] and step < 0 so result will be positive number
    result = this.long.default.from( Math.abs( Math.round( ( range[ 0 ]-range[ 1 ] ) / step ) ) );
    // result = this.tools.long.default.from( Math.abs( Math.round( ( range[ 0 ]-range[ 1 ] ) / step ) ) );

    let i = 0;
    while( range[ 0 ] > range[ 1 ] )
    {
      result[ i ] = range[ 0 ];
      range[ 0 ] += step;
      i += 1;
    }

  }

  return result;
}

//

function longFromRangeWithNumberOfSteps( range, numberOfSteps )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( isFinite( range[ 0 ] ) );
  _.assert( isFinite( range[ 1 ] ) );
  _.assert( numberOfSteps >= 0 );
  _.assert( _.routine.is( this.tools.long.default.from ) );

  if( numberOfSteps === 0 )
  return this.tools.long.default.from();

  if( numberOfSteps === 1 )
  return this.tools.long.default.from( range[ 0 ] );

  let step;

  if( range[ 0 ] < range[ 1 ] )
  step = ( range[ 1 ]-range[ 0 ] ) / (numberOfSteps-1);
  else
  step = ( range[ 0 ]-range[ 1 ] ) / (numberOfSteps-1);

  return this.longFromRangeWithStep( range, step );
}

// --
// array converter
// --

/**
 * The longToMap() converts an (array) into Object.
 *
 * @param { longIs } array - To convert into Object.
 *
 * @example
 * _.longToMap( [] );
 * // returns {}
 *
 * @example
 * _.longToMap( [ 3, [ 1, 2, 3 ], 'abc', false, undefined, null, {} ] );
 * // returns { '0' : 3, '1' : [ 1, 2, 3 ], '2' : 'abc', '3' : false, '4' : undefined, '5' : null, '6' : {} }
 *
 * @example
 * let args = ( function() {
 *   return arguments;
 * } )( 3, 'abc', false, undefined, null, { greeting: 'Hello there!' } );
 * _.longToMap( args );
 * // returns { '0' : 3, '1' : 'abc', '2' : false, '3' : undefined, '4' : null, '5' : { greeting: 'Hello there!' } }
 *
 * @returns { Object } Returns an Object.
 * @function longToMap
 * @throws { Error } Will throw an Error if (array) is not an array-like.
 * @namespace Tools
 */

function longToMap( array )
{
  let result = Object.create( null );

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.longIs( array ) );

  for( let a = 0 ; a < array.length ; a++ )
  result[ a ] = array[ a ];
  return result;
}
//
// //
//
// /**
//  * The longToStr() routine joins an array {-srcMap-} and returns one string containing each array element separated by space,
//  * only types of integer or floating point.
//  *
//  * @param { longIs } src - The source array.
//  * @param { objectLike } [ options = {  } ] options - The options.
//  * @param { Number } [ options.precision = 5 ] - The precision of numbers.
//  * @param { String } [ options.type = 'mixed' ] - The type of elements.
//  *
//  * @example
//  * _.longToStr( [ 1, 2, 3 ], { type : 'int' } );
//  * // returns "1 2 3 "
//  *
//  * @example
//  * _.longToStr( [ 3.5, 13.77, 7.33 ], { type : 'float', precission : 4 } );
//  * // returns "3.500 13.77 7.330"
//  *
//  * @returns { String } Returns one string containing each array element separated by space,
//  * only types of integer or floating point.
//  * If (src.length) is empty, it returns the empty string.
//  * @function longToStr
//  * @throws { Error } Will throw an Error If (options.type) is not the number or float.
//  * @namespace Tools
//  */
//
// function longToStr( src, options )
// {
//
//   let result = '';
//   options = options || Object.create( null );
//
//   if( options.precission === undefined ) options.precission = 5;
//   if( options.type === undefined ) options.type = 'mixed';
//
//   if( !src.length ) return result;
//
//   if( options.type === 'float' )
//   {
//     for( var s = 0 ; s < src.length-1 ; s++ )
//     {
//       result += src[ s ].toPrecision( options.precission ) + ' ';
//     }
//     result += src[ s ].toPrecision( options.precission );
//   }
//   else if( options.type === 'int' )
//   {
//     for( var s = 0 ; s < src.length-1 ; s++ )
//     {
//       result += String( src[ s ] ) + ' ';
//     }
//     result += String( src[ s ] ) + ' ';
//   }
//   else
//   {
//     throw _.err( 'not tested' );
//     for( let s = 0 ; s < src.length-1 ; s++ )
//     {
//       result += String( src[ s ] ) + ' ';
//     }
//     result += String( src[ s ] ) + ' ';
//   }
//
//   return result;
// }

// --
// array transformer
// --

/**
 * The longOnlyWithIndices() routine selects elements from (srcArray) by indexes of (indicesArray).
 *
 * @param { longIs } srcArray - Values for the new array.
 * @param { ( longIs | object ) } [ indicesArray = indicesArray.indices ] - Indexes of elements from the (srcArray) or options map.
 *
 * @example
 * _.longOnlyWithIndices( [ 1, 2, 3, 4, 5 ], [ 2, 3, 4 ] );
 * // returns [ 3, 4, 5 ]
 *
 * @example
 * _.longOnlyWithIndices( [ 1, 2, 3 ], [ 4, 5 ] );
 * // returns [ undefined, undefined ]
 *
 * @returns { longIs } - Returns a new array with the length equal (indicesArray.length) and elements from (srcArray).
   If there is no element with necessary index than the value will be undefined.
 * @function longOnlyWithIndices
 * @throws { Error } If passed arguments is not array like object.
 * @throws { Error } If the scalarsPerElement property is not equal to 1.
 * @namespace Tools
 */

function longOnlyWithIndices( srcArray, indicesArray )
{
  let scalarsPerElement = 1;

  if( _.object.isBasic( indicesArray ) )
  {
    scalarsPerElement = indicesArray.scalarsPerElement || 1;
    indicesArray = indicesArray.indices;
  }

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( srcArray ) );
  _.assert( _.longIs( indicesArray ) );

  // let result = new srcArray.constructor( indicesArray.length );
  let result = _.long.makeUndefined( srcArray, indicesArray.length );

  if( scalarsPerElement === 1 )
  for( let i = 0, l = indicesArray.length ; i < l ; i += 1 )
  {
    result[ i ] = srcArray[ indicesArray[ i ] ];
  }
  else
  for( let i = 0, l = indicesArray.length ; i < l ; i += 1 )
  {
    for( let a = 0 ; a < scalarsPerElement ; a += 1 )
    result[ i*scalarsPerElement+a ] = srcArray[ indicesArray[ i ]*scalarsPerElement+a ];
  }

  return result;
}

// --
// long mutator
// --

function longShuffle( dst, times )
{
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.longIs( dst ) );

  if( times === undefined )
  times = dst.length;

  let l = dst.length;
  let e1, e2;
  for( let t1 = 0 ; t1 < times ; t1++ )
  {
    let t2 = Math.floor( Math.random() * l );
    e1 = dst[ t1 ];
    e2 = dst[ t2 ];
    dst[ t1 ] = e2;
    dst[ t2 ] = e1;
  }

  return dst;
}

// --
// array mutator
// --

// function longAssign( dst, index, value )
// {
//   _.assert( arguments.length === 3, 'Expects exactly three arguments' );
//   _.assert( dst.length > index );
//   dst[ index ] = value;
//   return dst;
// }

//

/**
 * The longSwapElements() routine reverses the elements by indices (index1) and (index2) in the (dst) array.
 *
 * @param { Array } dst - The initial array.
 * @param { Number } index1 - The first index.
 * @param { Number } index2 - The second index.
 *
 * @example
 * _.longSwapElements( [ 1, 2, 3, 4, 5 ], 0, 4 );
 * // returns [ 5, 2, 3, 4, 1 ]
 *
 * @returns { Array } - Returns the (dst) array that has been modified in place by indexes (index1) and (index2).
 * @function longSwapElements
 * @throws { Error } If the first argument in not an array.
 * @throws { Error } If the second argument is less than 0 and more than a length initial array.
 * @throws { Error } If the third argument is less than 0 and more than a length initial array.
 * @namespace Tools
 */

function longSwapElements( dst, index1, index2 )
{

  if( arguments.length === 1 )
  {
    index1 = 0;
    index2 = 1;
  }

  _.assert( arguments.length === 1 || arguments.length === 3 );
  _.assert( _.longIs( dst ), 'Expects long' );
  _.assert( 0 <= index1 && index1 < dst.length > 0, 'index1 is out of bound' );
  _.assert( 0 <= index2 && index2 < dst.length > 0, 'index2 is out of bound' );

  let e = dst[ index1 ];
  dst[ index1 ] = dst[ index2 ];
  dst[ index2 ] = e;

  return dst;
}

//

/**
 * The longPut() routine puts all values of (arguments[]) after the second argument to the (dstArray)
 * in the position (dstOffset) and changes values of the following index.
 *
 * @param { longIs } dstArray - The source array.
 * @param { Number } [ dstOffset = 0 ] dstOffset - The index of element where need to put the new values.
 * @param {*} arguments[] - One or more argument(s).
 * If the (argument) is an array it iterates over array and adds each element to the next (dstOffset++) index of the (dstArray).
 * Otherwise, it adds each (argument) to the next (dstOffset++) index of the (dstArray).
 *
 * @example
 * _.longPut( [ 1, 2, 3, 4, 5, 6, 9 ], 2, 'str', true, [ 7, 8 ] );
 * // returns [ 1, 2, 'str', true, 7, 8, 9 ]
 *
 * @example
 * _.longPut( [ 1, 2, 3, 4, 5, 6, 9 ], 0, 'str', true, [ 7, 8 ] );
 * // returns [ 'str', true, 7, 8, 5, 6, 9 ]
 *
 * @returns { longIs } - Returns an array containing the changed values.
 * @function longPut
 * @throws { Error } Will throw an Error if (arguments.length) is less than one.
 * @throws { Error } Will throw an Error if (dstArray) is not an array-like.
 * @throws { Error } Will throw an Error if (dstOffset) is not a Number.
 * @namespace Tools
 */

function longPut( dstArray, dstOffset )
{
  _.assert( arguments.length >= 1, 'Expects at least one argument' );
  _.assert( _.longIs( dstArray ) );
  _.assert( _.number.is( dstOffset ) );

  dstOffset = dstOffset || 0;

  for( let a = 2 ; a < arguments.length ; a++ )
  {
    let argument = arguments[ a ];
    let aIs = _.arrayIs( argument ) || _.bufferTypedIs( argument );

    if( aIs && _.bufferTypedIs( dstArray ) )
    {
      dstArray.set( argument, dstOffset );
      dstOffset += argument.length;
    }
    else if( aIs )
    for( let i = 0 ; i < argument.length ; i++ )
    {
      dstArray[ dstOffset ] = argument[ i ];
      dstOffset += 1;
    }
    else
    {
      dstArray[ dstOffset ] = argument;
      dstOffset += 1;
    }

  }

  return dstArray;
}

//

/**
 * The longSupplement() routine returns an array (dstArray), that contains values from following arrays only type of numbers.
 * If the initial (dstArray) isn't contain numbers, they are replaced.
 *
 * It finds among the arrays the biggest array, and assigns to the variable (length), iterates over from 0 to the (length),
 * creates inner loop that iterates over (arguments[...]) from the right (arguments.length - 1) to the (arguments[0]) left,
 * checks each element of the arrays, if it contains only type of number.
 * If true, it adds element to the array (dstArray) by corresponding index.
 * Otherwise, it skips and checks following array from the last executable index, previous array.
 * If the last executable index doesn't exist, it adds 'undefined' to the array (dstArray).
 * After that it returns to the previous array, and executes again, until (length).
 *
 * @param { longIs } dstArray - The initial array.
 * @param { ...longIs } arguments[...] - The following array(s).
 *
 * @example
 * _.longSupplement( [ 4, 5 ], [ 1, 2, 3 ], [ 6, 7, 8, true, 9 ], [ 'a', 'b', 33, 13, 'e', 7 ] );
 * // returns ?
 *
 * @returns { longIs } - Returns an array that contains values only type of numbers.
 * @function longSupplement
 * @throws { Error } Will throw an Error if (dstArray) is not an array-like.
 * @throws { Error } Will throw an Error if (arguments[...]) is/are not the array-like.
 * @namespace Tools
 */

function longSupplement( dstArray )
{
  let result = dstArray;
  if( result === null )
  result = [];

  let length = result.length;
  _.assert( _.longIs( result ) || _.number.is( result ), 'Expects object as argument' );

  for( let a = arguments.length-1 ; a >= 1 ; a-- )
  {
    _.assert( _.longIs( arguments[ a ] ), 'argument is not defined :', a );
    length = Math.max( length, arguments[ a ].length );
  }

  if( _.number.is( result ) )
  result = arrayFill
  ({
    value : result,
    times : length,
  });

  for( let k = 0 ; k < length ; k++ )
  {

    if( k in dstArray && isFinite( dstArray[ k ] ) )
    continue;

    let a;
    for( a = arguments.length-1 ; a >= 1 ; a-- )
    if( k in arguments[ a ] && !isNaN( arguments[ a ][ k ] ) )
    break;

    if( a === 0 )
    continue;

    result[ k ] = arguments[ a ][ k ];

  }

  return result;
}

//

/**
 * The longExtendScreening() routine iterates over (arguments[...]) from the right to the left (arguments[1]),
 * and returns a (dstArray) containing the values of the following arrays,
 * if the following arrays contains the indexes of the (screenArray).
 *
 * @param { longIs } screenArray - The source array.
 * @param { longIs } dstArray - To add the values from the following arrays,
 * if the following arrays contains indexes of the (screenArray).
 * If (dstArray) contains values, the certain values will be replaced.
 * @param { ...longIs } arguments[...] - The following arrays.
 *
 * @example
 * _.longExtendScreening( [ 1, 2, 3 ], [  ], [ 0, 1, 2 ], [ 3, 4 ], [ 5, 6 ] );
 * // returns [ 5, 6, 2 ]
 *
 * @example
 * _.longExtendScreening( [ 1, 2, 3 ], [ 3, 'abc', 7, 13 ], [ 0, 1, 2 ], [ 3, 4 ], [ 'a', 6 ] );
 * // returns [ 'a', 6, 2, 13 ]
 *
 * @example
 * _.longExtendScreening( [  ], [ 3, 'abc', 7, 13 ], [ 0, 1, 2 ], [ 3, 4 ], [ 'a', 6 ] );
 * // returns [ 3, 'abc', 7, 13 ]
 *
 * @returns { longIs } Returns a (dstArray) containing the values of the following arrays,
 * if the following arrays contains the indexes of the (screenArray).
 * If (screenArray) is empty, it returns a (dstArray).
 * If (dstArray) is equal to the null, it creates a new array,
 * and returns the corresponding values of the following arrays by the indexes of a (screenArray).
 * @function longExtendScreening
 * @throws { Error } Will throw an Error if (screenArray) is not an array-like.
 * @throws { Error } Will throw an Error if (dstArray) is not an array-like.
 * @throws { Error } Will throw an Error if (arguments[...]) is/are not an array-like.
 * @namespace Tools
 */

function longExtendScreening( screenArray, dstArray )
{
  let result = dstArray;
  if( result === null )
  result = [];

  if( Config.debug )
  {
    _.assert( _.longIs( screenArray ), 'Expects object as screenArray' );
    _.assert( _.longIs( result ), 'Expects object as argument' );
    for( let a = arguments.length-1 ; a >= 2 ; a-- )
    _.assert( !!arguments[ a ], () => `Argument #${a} is not defined` );
  }

  for( let k = 0 ; k < screenArray.length ; k++ )
  {

    if( screenArray[ k ] === undefined )
    continue;

    let a;
    for( a = arguments.length-1 ; a >= 2 ; a-- )
    if( k in arguments[ a ] )
    break;
    if( a === 1 )
    continue;

    result[ k ] = arguments[ a ][ k ];

  }

  return result;
}

//

/**
 * The routine longSort() sorts destination Long {-dstLong-}.
 *
 * @param { Long|Null } dstLong - The destination Long. If {-dstLong-} is null, then routine makes copy from {-srcLong-}.
 * @param { Long } srcArray - Source long. Uses if {-dstLong-} is null.
 * @param { Function } onEvaluate - Callback - evaluator or comparator for sorting elements.
 *
 * @example
 * let src = [ 1, 30, -2, 5, -43 ];
 * _.longSort( null, src );
 * // returns [ -43, -2, 1, 30, 5 ]
 *
 * @example
 * let dst = [ 1, 30, -2, 5, -43 ];
 * let src = [ 0 ];
 * let got = _.longSort( dst, src );
 * console.log( got );
 * // log [ -43, -2, 1, 30, 5 ]
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let dst = [ 1, 50, -2, 3, -43 ];
 * let onEval = ( e ) => e;
 * let got = _.longSort( dst, onEval );
 * console.log( got );
 * // log [ -43, -2, 1, 3, 50 ]
 * console.log( got === dst );
 * // log true
 *
 * @example
 * let dst = [ 1, 50, -2, 3, -43 ];
 * let onEval = ( a, b ) => a < b;
 * let got = _.longSort( dst, onEval );
 * console.log( got );
 * // log [ 50, 3, 1, -2, -43 ]
 * console.log( got === dst );
 * // log true
 *
 * @returns { Long } Returns sorted {-dstLong-}.
 * @function longSort
 * @throws { Error } If arguments.length is less then one or more then three.
 * @throws { Error } If {-onEvaluate-} is not a routine or not undefined.
 * @throws { Error } If {-dstLong-} is not null or not a Long.
 * @throws { Error } If arguments.length === 3 and {-srcLong-} is not a Long.
 * @throws { Error } If onEvaluate.length is less then one or more then two.
 * @namespace Tools
 */

function longSort( dstLong, srcLong, onEvaluate )
{

  if( _.routine.is( arguments[ 1 ] ) )
  {
    onEvaluate = arguments[ 1 ];
    srcLong = dstLong;
  }

  _.assert( arguments.length === 1 || arguments.length === 2 || arguments.length === 3 );
  _.assert( onEvaluate === undefined || _.routine.is( onEvaluate ) );
  _.assert( _.longIs( srcLong ) );
  _.assert( dstLong === null || _.longIs( dstLong ) );

  if( dstLong === null )
  dstLong = _.array.make( srcLong );
  if( _.argumentsArray.is( dstLong ) ) // Dmytro : missed
  dstLong = this.tools.long.default.from( dstLong );

  if( onEvaluate === undefined )
  {
    dstLong.sort();
  }
  else if( onEvaluate.length === 2 )
  {
    dstLong.sort( onEvaluate );
  }
  else if( onEvaluate.length === 1 )
  {
    dstLong.sort( function( a, b )
    {
      a = onEvaluate( a );
      b = onEvaluate( b );

      if( a > b )
      return +1;
      else if( a < b )
      return -1;
      else
      return 0;
    });
  }
  else _.assert( 0, 'Expects signle-argument evaluator or two-argument comparator' );

  return dstLong;
}

// --
// array etc
// --

// function longIndicesOfGreatest( srcArray, numberOfElements, comparator )
// {
//   let result = [];
//   let l = srcArray.length;
//
//   debugger;
//   throw _.err( 'not tested' );
//
//   comparator = _.routine._comparatorFromEvaluator( comparator );
//
//   function rcomparator( a, b )
//   {
//     return comparator( srcArray[ a ], srcArray[ b ] );
//   };
//
//   for( let i = 0 ; i < l ; i += 1 )
//   {
//
//     if( result.length < numberOfElements )
//     {
//       _.sorted.add( result, i, rcomparator );
//       continue;
//     }
//
//     _.sorted.add( result, i, rcomparator );
//     result.splice( result.length-1, 1 );
//
//   }
//
//   return result;
// }
//
// //
//
// /**
//  * The longSum() routine returns the sum of an array {-srcMap-}.
//  *
//  * @param { longIs } src - The source array.
//  * @param { Routine } [ onEvaluate = function( e ) { return e } ] - A callback function.
//  *
//  * @example
//  * _.longSum( [ 1, 2, 3, 4, 5 ] );
//  * // returns 15
//  *
//  * @example
//  * _.longSum( [ 1, 2, 3, 4, 5 ], function( e ) { return e * 2 } );
//  * // returns 29
//  *
//  * @example
//  * _.longSum( [ true, false, 13, '33' ], function( e ) { return e * 2 } );
//  * // returns 94
//  *
//  * @returns { Number } - Returns the sum of an array {-srcMap-}.
//  * @function longSum
//  * @throws { Error } If passed arguments is less than one or more than two.
//  * @throws { Error } If the first argument is not an array-like object.
//  * @throws { Error } If the second argument is not a Routine.
//  * @namespace Tools
//  */
//
// function longSum( src, onEvaluate )
// {
//   let result = 0;
//
//   _.assert( arguments.length === 1 || arguments.length === 2 );
//   _.assert( _.longIs( src ), 'Expects ArrayLike' );
//
//   if( onEvaluate === undefined )
//   onEvaluate = function( e ){ return e; };
//
//   _.assert( _.routine.is( onEvaluate ) );
//
//   for( let i = 0 ; i < src.length ; i++ )
//   {
//     result += onEvaluate( src[ i ], i, src );
//   }
//
//   return result;
// }

// --
// declaration
// --

let ToolsExtension =
{

  // long repeater

  longOnce, /* zzz : review */ /* !!! : use instead of longOnce */
  longOnce_,

  longHasUniques,
  longAreRepeatedProbe,
  longAllAreRepeated,
  longAnyAreRepeated,
  longNoneAreRepeated,

  longMask, /* dubious */
  longUnmask, /* dubious */

  // array maker

  longRandom,

  longFromRange,
  longFromProgressionArithmetic, /* qqq : light coverage required */
  longFromRangeWithStep,
  longFromRangeWithNumberOfSteps,

  // // array converter
  //
  longToMap, /* dubious */ /* Yevhen : uncommented, routine is used in module::wChangeTransactor */
  // longToStr, /* dubious */

  // long transformer

  longOnlyWithIndices,

  // long mutator

  longShuffle,

  // long mutator

  longSwapElements,
  longPut,

  longSupplement, /* experimental */
  longExtendScreening, /* experimental */

  longSort,

  // // array etc
  //
  // longIndicesOfGreatest, /* dubious */
  // longSum, /* dubious */

}

//

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Long.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Long_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Long_s */ })();

/* */  /* begin of file Map_s */ ( function Map_s() { function Map_s_naked() { ( function _l0_l7_Map_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.map = _.map || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

let ExtensionMap =
{

}

Object.assign( _.map, ExtensionMap );
_.assert( _.aux.is( _.map ) );

//

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Map.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Map_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Map_s */ })();

/* */  /* begin of file Module_s */ ( function Module_s() { function Module_s_naked() { ( function _l5_Module_s_()
{

'use strict';

//

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// declare
// --

var ModuleExtension =
{

}

Object.assign( _.module, ModuleExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Module.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Module_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Module_s */ })();

/* */  /* begin of file Number_s */ ( function Number_s() { function Number_s_naked() { ( function _l7_Number_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// number
// --

function numbersTotal( numbers )
{
  let result = 0;
  _.assert( _.longIs( numbers ) );
  _.assert( arguments.length === 1, 'Expects single argument' );
  for( let n = 0 ; n < numbers.length ; n++ )
  {
    let number = numbers[ n ];
    _.assert( _.number.is( number ) )
    result += number;
  }
  return result;
}

//

function from( src )
{
  _.assert( arguments.length === 1 );
  if( _.strIs( src ) )
  {
    return parseFloat( src );
  }
  return Number( src );
}

//

function numbersFrom( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.strIs( src ) )
  return _.number.from( src );

  if( _.number.is( src ) )
  return src;

  let result;

  if( _.longIs( src ) )
  {
    result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _.number.from( src[ s ] );
  }
  else if( _.object.isBasic( src ) )
  {
    result = Object.create( null );
    for( let s in src )
    result[ s ] = _.number.from( src[ s ] );
  }
  else
  {
    result = _.number.from( src );
  }

  return result;
}

//

function fromStr( src )
{
  _.assert( arguments.length === 1 );
  _.assert( _.strIs( src ) )
  let result = parseFloat( src );
  return result;
}

//

// function numberFromStrMaybe( src )
function fromStrMaybe( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) || _.number.is( src ) );

  if( _.number.is( src ) )
  return src;
  if( !src ) /* qqq : cover */
  return src;

  // let parsed = !src ? NaN : Number( src ); /* Dmytro : it is strange code, the previous branch checks this condition */
  // if( !isNaN( parsed ) )
  // return parsed;
  // return src;

  let parsed = src ? Number( src ) : NaN;
  if( !isNaN( parsed ) )
  return parsed;
  return src;
}

//

function numbersSlice( src, f, l )
{
  if( _.argumentsArray.like( src ) )
  _.assert( _.number.s.areAll( src ) )

  if( _.number.is( src ) )
  return src;
  return _.longSlice( src, f, l );
}

//

/**
 * The routine numberRandom() returns a random float number, the value of which is within a
 * range {-range-} .
 *
 * @param { Range|Number } range - The range for generating random numbers.
 * If {-range-} is number, routine generates random number from zero to provided value.
 *
 * @example
 * let got = _.number.random( 0 );
 * // returns random number in range [ 0, 0 ]
 * console.log( got );
 * // log 0
 *
 * @example
 * let got = _.number.random( 3 );
 * // returns random number in range [ 0, 3 ]
 * console.log( got );
 * // log 0.10161347203073712
 *
 * @example
 * let got = _.number.random( -3 );
 * // returns random number in range [ -3, 0 ]
 * console.log( got );
 * // log -1.4184648844870276
 *
 * @example
 * let got = _.number.random( [ 3, 3 ] );
 * console.log( got );
 * // log 3
 *
 * @example
 * let got = _.number.random( [ -3, 0 ] );
 * console.log( got );
 * // log -1.5699334307486583
 *
 * @example
 * let got = _.number.random( [ 0, 3 ] );
 * console.log( got );
 * // log 0.6154656826553855
 *
 * @example
 * let got = _.number.random( [ -3, 3 ] );
 * console.log( got );
 * // log 1.9835540787557022
 *
 * @returns { Number } - Returns a random float number.
 * @function numberRandom
 * @throws { Error } If arguments.length is less or more then one.
 * @throws { Error } If range {-range-} is not a Number or not a Range.
 * @namespace Tools
 */

function random( range )
{

  if( _.number.is( range ) )
  range = range >= 0 ? [ 0, range ] : [ range, 0 ];
  _.assert( arguments.length === 1 && _.intervalIs( range ), 'Expects range' );

  let result = Math.random()*( range[ 1 ] - range[ 0 ] ) + range[ 0 ];
  return result;
}

//

/**
 * The routine intRandom() returns a random integer number, the value of which is within a
 * range {-range-} .
 *
 * @param { Range|Number } range - The range for generating random numbers.
 * If {-range-} is number, routine generates random number from zero to provided value.
 *
 * @example
 * let got = _.intRandom( 0 );
 * // returns random number in range [ 0, 0 ]
 * console.log( got );
 * // log 0
 *
 * @example
 * let got = _.intRandom( 1 );
 * // returns random number in range [ 0, 1 ]
 * console.log( got );
 * // log 1
 *
 * @example
 * let got = _.intRandom( 3 );
 * // returns random number in range [ 0, 3 ]
 * console.log( got );
 * // log 1
 *
 * @example
 * let got = _.intRandom( -3 );
 * // returns random number in range [ -3, 0 ]
 * console.log( got );
 * // log -2
 *
 * @example
 * let got = _.intRandom( [ 3, 3 ] );
 * console.log( got );
 * // log 3
 *
 * @example
 * let got = _.intRandom( [ -3, 0 ] );
 * console.log( got );
 * // log -1
 *
 * @example
 * let got = _.intRandom( [ 0, 3 ] );
 * console.log( got );
 * // log 1
 *
 * @example
 * let got = _.intRandom( [ -3, 3 ] );
 * console.log( got );
 * // log -2
 *
 * @returns { Number } - Returns a random integer number.
 * @function intRandom
 * @throws { Error } If arguments.length is less or more then one.
 * @throws { Error } If range {-range-} is not a Number or not a Range.
 * @namespace Tools
 */

function intRandom( range )
{

  if( _.number.is( range ) )
  range = range >= 0 ? [ 0, range ] : [ range, 0 ];
  _.assert( arguments.length === 1 && _.intervalIs( range ), 'Expects range' );

  let result = Math.floor( range[ 0 ] + Math.random()*( range[ 1 ] - range[ 0 ] ) );
  return result;
}

//

function intRandomBut( range )
{
  let result;
  let attempts = 50;

  if( _.number.is( range ) )
  range = [ 0, range ];
  else if( _.arrayIs( range ) )
  range = range;
  else throw _.err( 'intRandom', 'unexpected argument' );

  for( let attempt = 0 ; attempt < attempts ; attempt++ )
  {
    // if( attempt === attempts-2 )
    // debugger;
    // if( attempt === attempts-1 )
    // debugger;

    /*result = _.intRandom( range ); */
    let result = Math.floor( range[ 0 ] + Math.random()*( range[ 1 ] - range[ 0 ] ) );

    let bad = false;
    for( let a = 1 ; a < arguments.length ; a++ )
    if( _.routine.is( arguments[ a ] ) )
    {
      if( !arguments[ a ]( result ) )
      bad = true;
    }
    else
    {
      if( result === arguments[ a ] )
      bad = true;
    }

    if( bad )
    continue;
    return result;
  }

  result = NaN;
  return result;
}

//

/**
 * The routine numbersMake() returns an array of numbers with a length of {-length-} .
 *
 * @param { src|Number|Array } src - source number or array of numbers.
 * If {-src-} is a Number, routine generates an array of length {-length-} filled with {-src-}.
 * If {-src-} is an Array of numbers and {-src-}.length === {-length-}, the routine returns {-src-}.
 *
 * @param { length|Number } length - the size of the returned array.
 *
 * @example
 * let got = _.number.s.make( 1, 0 );
 * // returns an empty array
 * console.log( got )
 * // log []
 *
 * @example
 * let got = _.number.s.make( 1, 3 );
 * // returns an array of size 3 filled with ones
 * console.log( got )
 * // log [ 1, 1, 1 ]
 *
 * @example
 * let got = _.number.s.make( -5.22, 3 );
 * // returns an array of size 3 filled with -5.22
 * console.log( got )
 * // log [ -5.22, -5.22, -5.22 ]
 *
 * @example
 * let got = _.number.s.make( NaN, 3 );
 * // returns an array of size 3 filled with NaN
 * console.log( got )
 * // log [ NaN, NaN, NaN ]
 *
 * @example
 * let got = _.number.s.make( [ 1, 2, 3 ], 3 );
 * // returns source array
 * console.log( got )
 * // log [ 1, 2, 3 ]
 *
 * @example
 * let got = _.number.s.make( [ 1.00, -2.777, 3.00 ], 3 );
 * // returns source array
 * console.log( got )
 * // log [ 1.00, -2.777, 3.00 ]
 *
 * @example
 * let got = _.number.s.make( [ NaN, Infinity, -Infinity ], 3 );
 * // returns source array
 * console.log( got )
 * // log [ NaN, Infinity, -Infinity ]
 *
 * @returns { Array } - Returns an array of numbers.
 * @function numbersMake
 * @throws { Error } If {-src-} is array and {-src-}.length !== {-length-}.
 * @throws { Error } If {-src-} is array and {-src-} contains not a number.
 * @throws { Error } If {-src-} is not an array or a Number.
 * @throws { Error } arguments.length === 0 or arguments.length > 2.
 * @namespace Tools
 */

function numbersMake( src, length )
{
  let result;

  if( _.vector.adapterIs( src ) )
  src = _.vectorAdapter.slice( src );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.number.is( src ) || _.argumentsArray.like( src ) );

  if( _.argumentsArray.like( src ) )
  {
    _.assert( src.length === length );
    result = _.long.makeUndefined( length );
    for( let i = 0 ; i < length ; i++ )
    result[ i ] = src[ i ];
  }
  else
  {
    result = _.long.makeUndefined( length );
    for( let i = 0 ; i < length ; i++ )
    result[ i ] = src;
  }

  return result;
}

//

/**
 * The routine numbersFromNumber() returns an array of numbers with a length of {-length-} .
 *
 * @param { src|Number|Array } src - source number or array of numbers.
 * If {-src-} is a Number, routine generates an array of length {-length-} filled with {-src-}.
 * If {-src-} is an Array of numbers and {-src-}.length === {-length-}, the routine returns {-src-}.
 *
 * @param { length|Number } length - the size of the returned array.
 *
 * @example
 * let got = _.number.s.fromNumber( 1, 0 );
 * // returns an empty array
 * console.log( got )
 * // log []
 *
 * @example
 * let got = _.number.s.fromNumber( 1, 3 );
 * // returns an array of size 3 filled with ones
 * console.log( got )
 * // log [ 1, 1, 1 ]
 *
 * @example
 * let got = _.number.s.fromNumber( -5.22, 3 );
 * // returns an array of size 3 filled with -5.22
 * console.log( got )
 * // log [ -5.22, -5.22, -5.22 ]
 *
 * @example
 * let got = _.number.s.fromNumber( NaN, 3 );
 * // returns an array of size 3 filled with NaN
 * console.log( got )
 * // log [ NaN, NaN, NaN ]
 *
 * @example
 * let got = _.number.s.fromNumber( [ 1, 2, 3 ], 3 );
 * // returns source array
 * console.log( got )
 * // log [ 1, 2, 3 ]
 *
 * @example
 * let got = _.number.s.fromNumber( [ 1.00, -2.777, 3.00 ], 3 );
 * // returns source array
 * console.log( got )
 * // log [ 1.00, -2.777, 3.00 ]
 *
 * @example
 * let got = _.number.s.fromNumber( [ NaN, Infinity, -Infinity ], 3 );
 * // returns source array
 * console.log( got )
 * // log [ NaN, Infinity, -Infinity ]
 *
 * @returns { Array } - Returns an array of numbers.
 * @function numbersFromNumber
 * @throws { Error } If {-src-} is array and {-src-}.length !== {-length-}.
 * @throws { Error } If {-src-} is array and {-src-} contains not a number.
 * @throws { Error } If {-src-} is not an array or a Number.
 * @throws { Error } arguments.length === 0 or arguments.length > 2.
 * @namespace Tools
 */

function numbersFromNumber( src, length )
{

  if( _.vector.adapterIs( src ) )
  src = _.vectorAdapter.slice( src );

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.number.is( src ) || _.argumentsArray.like( src ) );

  if( _.argumentsArray.like( src ) )
  {
    _.assert( src.length === length );
    return src;
  }

  // debugger; /* xxx2 : test */
  let result = _.long.makeUndefined( length );
  for( let i = 0 ; i < length ; i++ )
  result[ i ] = src;

  return result;
}

//

/**
 * The routine numbersFromInt() returns an array of integers with a length of {-length-} .
 *
 * @param { src|Number|Array } src - source number or array of integers.
 * If {-src-} is an integer Number, routine generates an array of length {-length-} filled with {-src-}.
 * If {-src-} is an Array of integers and {-src-}.length === {-length-}, the routine returns {-src-}.
 *
 * @param { length|Number } length - the size of the returned array.
 *
 * @example
 * let got = _.number.s.fromInt( 1, 0 );
 * // returns an empty array
 * console.log( got )
 * // log []
 *
 * @example
 * let got = _.number.s.fromInt( 1, 3 );
 * // returns an array of size 3 filled with ones
 * console.log( got )
 * // log [ 1, 1, 1 ]
 *
 * @example
 * let got = _.number.s.fromInt( [ 1, 2, 3 ], 3 );
 * // returns source array
 * console.log( got )
 * // log [ 1, 2, 3 ]
 *
 * @example
 * let got = _.number.s.fromInt( [ 1.00, -2.00, 3.00 ], 3 );
 * // returns source array
 * console.log( got )
 * // log [ 1.00, -2.00, 3.00 ]
 *
 * @returns { Array } - Returns an array of integers.
 * @function numbersFromInt
 * @throws { Error } If {-src-} is array and {-src-}.length !== {-length-}.
 * @throws { Error } If {-src-} is array and {-src-} contains not an integer Number.
 * @throws { Error } If {-src-} is not an array or an integer.
 * @throws { Error } arguments.length === 0 or arguments.length > 2.
 * @namespace Tools
 */

function numbersFromInt( dst, length )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.intIs( dst ) || _.arrayIs( dst ), 'Expects array of number as argument' );
  _.assert( length >= 0 );

  if( _.number.is( dst ) )
  {
    debugger;
    // dst = _.longFillTimes( [], length , dst );
    dst = _.longFill( [], dst, length );
  }
  else
  {
    for( let i = 0 ; i < dst.length ; i++ )
    _.assert( _.intIs( dst[ i ] ), 'Expects integer, but got', dst[ i ] );
    _.assert( dst.length === length, 'Expects array of length', length, 'but got', dst );
  }

  return dst;
}

//

function numbersMake_functor( length )
{
  // let _ = this;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.number.is( length ) );

  function numbersMake( src )
  {
    return _.number.s.make( src, length );
  }

  return numbersMake;
}

//

function numbersFrom_functor( length )
{
  // let _ = this;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.number.is( length ) );

  function numbersFromNumber( src )
  {
    return _.number.s.fromNumber( src, length );
  }

  return numbersFromNumber;
}

// --
// extension
// --

let ToolsExtension =
{

  numbersTotal,

  numberFrom : from,
  numbersFrom,
  numberFromStr : fromStr,
  numberFromStrMaybe : fromStrMaybe, /* qqq : cover */

  numbersSlice,

  numberRandom : random,
  intRandom,
  intRandomBut, /* dubious */

  numbersMake,
  numbersFromNumber,
  numbersFromInt,

  numbersMake_functor,
  numbersFrom_functor,

}

Object.assign( _, ToolsExtension );

//

let NumberExtension =
{


  from,
  fromStr,
  fromStrMaybe, /* qqq : cover */

  random,
  intRandom,
  intRandomBut, /* dubious */

}

Object.assign( _.number, NumberExtension );

//

let NumbersExtension =
{

  total : numbersTotal,
  from : numbersFrom,
  slice : numbersSlice,

  make : numbersMake,
  fromNumber : numbersFromNumber,
  fromInt : numbersFromInt,

  make_functor : numbersMake_functor,
  from_functor : numbersFrom_functor,

}

Object.assign( _.number.s, NumbersExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Number.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Number_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Number_s */ })();

/* */  /* begin of file Object_s */ ( function Object_s() { function Object_s_naked() { ( function _l7_Object_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.object = _.object || Object.create( null );

// --
// dichotomy
// --

// --
// extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

let ObjectExtension =
{

}

Object.assign( _.object, ObjectExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Object.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Object_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Object_s */ })();

/* */  /* begin of file Pair_s */ ( function Pair_s() { function Pair_s_naked() { ( function _l7_Pair_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function isOf( src, Element )
{
  if( !Element )
  return false;
  if( !this.is( src ) )
  return false;
  return src[ 0 ] instanceof Element && src[ 1 ] instanceof Element;
}

//

var Extension =
{
  isOf,
}

//

_.assert( _.pair !== undefined );
_.props.supplement( _.pair, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Pair.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Pair_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Pair_s */ })();

/* */  /* begin of file Path_s */ ( function Path_s() { function Path_s_naked() { ( function _l7_Path_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.path = _.path || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

let Extension =
{
}

//

Object.assign( _.path, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Path.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Path_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Path_s */ })();

/* */  /* begin of file Primitive_s */ ( function Primitive_s() { function Primitive_s_naked() { ( function _l7_Primitive_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.primitive = _.primitive || Object.create( null );

// --
// primitive
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( _, ToolsExtension );
Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Primitive.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Primitive_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Primitive_s */ })();

/* */  /* begin of file Printer_s */ ( function Printer_s() { function Printer_s_naked() { ( function _l7_Printer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.printer = _.printer || Object.create( null );

// --
// printer
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( Self, Extension );
Object.assign( _, ToolsExtension );

/* xxx : investigate */

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Printer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Printer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Printer_s */ })();

/* */  /* begin of file Process_s */ ( function Process_s() { function Process_s_naked() { ( function _l7_Process_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.process = _.process || Object.create( null );

// --
// implementation
// --

/**
 * The routine ready() delays execution of code to moment when web-page ( or program itself ) is loaded.
 * Optionally routine accept additional time out {-timeOut-} and callback {-onReady-} to execute after
 * loading.
 *
 * @example
 * let result = [];
 * _.process.ready();
 * // the code will continue execution when the page is loaded
 *
 * @example
 * let result = [];
 * let onReady = () => result.push( 'ready' );
 * _.process.ready( 500, onReady );
 * // the code will continue execution when the page is loaded and simultaneously routine adds delayed
 * // execution of callback `onReady`
 *
 * First parameter set :
 * @param { Number } timeOut - The time delay.
 * @param { Function } onReady - Callback to execute.
 * Second parameter set :
 * @param { Map|Aux } o - Options map.
 * @param { Number } o.timeOut - The time delay.
 * @param { Function } o.onReady - Callback to execute.
 * @returns { Undefined } - Returns not a value, executes code when a web-page is ready.
 * @function ready
 * @throws { Error } If arguments.length is greater than 2.
 * @throws { Error } If {-timeOut-} has defined non integer value or not finite value.
 * @namespace wTools.process
 * @extends Tools
 */

function ready_head( routine, args )
{
  let o = args[ 0 ];
  if( !_.mapIs( o ) )
  {
    o = Object.create( null );

    if( args.length === 2 )
    {
      o.timeOut = args[ 0 ];
      o.onReady = args[ 1 ];
    }
    else
    {
      o.onReady = args[ 0 ];
    }
  }

  _.routine.options( routine, o );

  if( !o.timeOut )
  o.timeOut = 0;

  _.assert( 0 <= args.length || args.length <= 2 );
  _.assert( _.intIs( o.timeOut ) );
  _.assert( _.routine.is( o.onReady ) || o.onReady === null || o.onReady === undefined );

  return o;
}

//

function ready_body( o )
{

  if( typeof window !== 'undefined' && typeof document !== 'undefined' && document.readyState !== 'complete' )
  window.addEventListener( 'load', handleReady );
  else
  handleReady();

  /* */

  function handleReady()
  {
    _.time.begin( o.timeOut, o.onReady );
  }
}

ready_body.defaults =
{
  timeOut : 0,
  onReady : null,
};

//

let ready = _.routine.unite( ready_head, ready_body );

// --
// declaration
// --

let Extension =
{

  ready,

}

Object.assign( _.process, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Process.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Process_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Process_s */ })();

/* */  /* begin of file PropertyTransformer_s */ ( function PropertyTransformer_s() { function PropertyTransformer_s_naked() { ( function _l7_PropertyTransformer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

// --
//
// --

let Extension =
{
};

_.props.supplement( _.props, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/PropertyTransformer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, PropertyTransformer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file PropertyTransformer_s */ })();

/* */  /* begin of file Props_s */ ( function Props_s() { function Props_s_naked() { ( function _l7_Property_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// extension
// --

let Extension =
{
}

//

Object.assign( _.props, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Props.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Props_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Props_s */ })();

/* */  /* begin of file Prototype_s */ ( function Prototype_s() { function Prototype_s_naked() { ( function _l7_Prototype_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.prototype = _.prototype || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{
}

//

Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Prototype.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Prototype_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Prototype_s */ })();

/* */  /* begin of file Regexp_s */ ( function Regexp_s() { function Regexp_s_naked() { ( function _l7_Regexp_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

const _ArrayIndexOf = Array.prototype.indexOf;
const _ArrayLastIndexOf = Array.prototype.lastIndexOf;
const _ArraySlice = Array.prototype.slice;
const _ArraySplice = Array.prototype.splice;
const _FunctionBind = Function.prototype.bind;
const _ObjectToString = Object.prototype.toString;
const _ObjectPropertyIsEumerable = Object.propertyIsEnumerable;

// --
// regexp
// --

let regexpsEscape = null;

//

/**
 * Make regexp from string.
 *
 * @example
 * _.regexp.from( 'Hello. How are you?' );
 * // returns /Hello\. How are you\?/
 *
 * @param {RegexpLike} src - string or regexp
 * @returns {String} Regexp
 * @throws {Error} Throw error with message 'unknown type of expression, expects regexp or string, but got' error
 if src not string-like ( string or regexp )
 * @function from
 * @namespace Tools
 */

function from( src, flags )
{

  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( flags === undefined || _.strIs( flags ) );

  if( _.regexpIs( src ) )
  return src;

  _.assert( _.strIs( src ) );

  return new RegExp( _.regexpEscape( src ), flags );
}

//

function maybeFrom( o )
{
  if( !_.mapIs( o ) )
  o = { srcStr : arguments[ 0 ] }

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( o.srcStr ) || _.regexpIs( o.srcStr ) );
  _.routine.options( maybeFrom, o );

  let result = o.srcStr;
  let strips;

  if( _.strIs( result ) )
  {

    if( o.stringWithRegexp )
    {
      let optionsExtract =
      {
        delimeter : '//',
        src : result,
      }
      // let strips = _.strSplitInlined( optionsExtract ); // Dmytro : it's local variable
      strips = _.strSplitInlined( optionsExtract );
    }
    else
    {
      // let strips = [ result ]; // Dmytro : it's local variable
      strips = [ result ];
    }

    for( let s = 0 ; s < strips.length ; s++ )
    {
      let strip = strips[ s ];

      if( s % 2 === 0 )
      {
        strip = _.regexpEscape( strip );
        if( o.toleratingSpaces )
        strip = strip.replace( /\s+/g, '\\s*' );
      }

      strips[ s ] = strip;
    }

    result = RegExp( strips.join( '' ), o.flags );
  }

  return result;
}

maybeFrom.defaults =
{
  srcStr : null,
  stringWithRegexp : 1,
  toleratingSpaces : 1,
  flags : 'g',
}

//

let regexpsMaybeFrom = _.routineVectorize_functor( { routine : maybeFrom, select : 'srcStr' } );

//

function regexpsSources( o )
{
  if( _.arrayIs( arguments[ 0 ] ) )
  {
    o = Object.create( null );
    o.sources = arguments[ 0 ];
  }

  // o.sources = o.sources ? _.longSlice( o.sources ) : [];
  o.sources = _.longSlice( o.sources );
  if( o.flags === undefined )
  o.flags = null;

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.routine.options( regexpsSources, o );

  /* */

  for( let s = 0 ; s < o.sources.length ; s++ )
  {
    let src = o.sources[ s ];
    if( _.regexpIs( src ) )
    {
      o.sources[ s ] = src.source;
      _.assert
      (
        o.flags === null || src.flags === o.flags,
        () => `All RegExps should have flags field with the same value "${ src.flags }" != "${ o.flags }"`
      );
      if( o.flags === null )
      o.flags = src.flags;
    }
    else
    {
      if( o.escaping )
      o.sources[ s ] = _.regexpEscape( src );
    }
    _.assert( _.strIs( o.sources[ s ] ) );
  }

  /* */

  return o;
}

regexpsSources.defaults =
{
  sources : null,
  flags : null,
  escaping : 0,
}

//

function regexpsJoin( o )
{
  if( !_.mapIs( o ) )
  o = { sources : o }

  _.routine.options( regexpsJoin, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  let src = o.sources[ 0 ];
  o = _.regexpsSources( o );
  if( o.sources.length === 1 && _.regexpIs( src ) )
  return src;

  let result = o.sources.join( '' );

  return new RegExp( result, o.flags || '' );
}

regexpsJoin.defaults =
{
  flags : null,
  sources : null,
  escaping : 0,
}

//

function regexpsJoinEscaping( o )
{
  if( !_.mapIs( o ) )
  o = { sources : o }

  _.routine.options( regexpsJoinEscaping, o );
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( !!o.escaping );

  return _.regexpsJoin( o );
}

var defaults = regexpsJoinEscaping.defaults = Object.create( regexpsJoin.defaults );

defaults.escaping = 1;

//

function regexpsAtLeastFirst( o )
{

  if( !_.mapIs( o ) )
  o = { sources : o }

  _.routine.options( regexpsAtLeastFirst, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  let src = o.sources[ 0 ];
  o = _.regexpsSources( o );
  if( o.sources.length === 1 && _.regexpIs( src ) )
  return src;

  let result = '';
  let prefix = '';
  let postfix = '';

  for( let s = 0 ; s < o.sources.length ; s++ )
  {
    let src = o.sources[ s ];

    if( s === 0 )
    {
      prefix = prefix + src;
    }
    else
    {
      prefix = prefix + '(?:' + src;
      postfix =  ')?' + postfix
    }

  }

  result = prefix + postfix;
  return new RegExp( result, o.flags || '' );
}

regexpsAtLeastFirst.defaults =
{
  flags : null,
  sources : null,
  escaping : 0,
}

//

function regexpsAtLeastFirstOnly( o )
{

  if( !_.mapIs( o ) )
  o = { sources : o }

  _.routine.options( regexpsAtLeastFirst, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  let src = o.sources[ 0 ];
  o = _.regexpsSources( o );
  if( o.sources.length === 1 && _.regexpIs( src ) )
  return src;

  let result = '';

  if( o.sources.length === 1 )
  {
    result = o.sources[ 0 ]
  }
  else for( let s = 0 ; s < o.sources.length ; s++ )
  {
    let src = o.sources[ s ];
    if( s < o.sources.length-1 )
    result += '(?:' + o.sources.slice( 0, s+1 ).join( '' ) + '$)|';
    else
    result += '(?:' + o.sources.slice( 0, s+1 ).join( '' ) + ')';
  }

  return new RegExp( result, o.flags || '' );
}

regexpsAtLeastFirst.defaults =
{
  flags : null,
  sources : null,
  escaping : 0,
}

//

/**
 *  Generates "but" regular expression pattern. Accepts a list of words, which will be used in regexp.
 *  The result regexp matches the strings that do not contain any of those words.
 *
 * @example
 * _.regexpsNone( 'yellow', 'red', 'green' );
 * // returns /^(?:(?!yellow|red|green).)+$/
 *
 * let options =
 * {
 *    but : [ 'yellow', 'red', 'green' ],
 *    atLeastOnce : false
 * };
 * _.regexpsNone(options);
 * // returns /^(?:(?!yellow|red|green).)*$/
 *
 * @param {Object} [options] options for generate regexp. If this argument omitted then default options will be used
 * @param {String[]} [options.but=null] a list of words, from each will consist regexp
 * @param {boolean} [options.atLeastOne=true] indicates whether search matches at least once
 * @param {...String} [words] a list of words, from each will consist regexp. This arguments can be used instead
 * options map.
 * @returns {RegExp} Result regexp
 * @throws {Error} If passed arguments are not strings or options map.
 * @throws {Error} If options contains any different from 'but' or 'atLeastOnce' properties.
 * @function regexpsNone
 * @namespace Tools
 */

function regexpsNone( o )
{
  if( !_.mapIs( o ) )
  o = { sources : o }

  _.routine.options( regexpsNone, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  o = _.regexpsSources( o );

  /* ^(?:(?!(?:abc)).)+$ */

  let result = '^(?:(?!(?:';
  result += o.sources.join( ')|(?:' );
  result += ')).)+$';

  return new RegExp( result, o.flags || '' );
}

regexpsNone.defaults =
{
  flags : null,
  sources : null,
  escaping : 0,
}

//

function regexpsAny( o )
{
  if( !_.mapIs( o ) )
  o = { sources : o }

  _.routine.options( regexpsAny, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.regexpIs( o.sources ) )
  {
    _.assert( o.sources.flags === o.flags || o.flags === null );
    return o.sources;
  }

  _.assert( !!o.sources );
  let src = o.sources[ 0 ];
  o = _.regexpsSources( o );
  if( o.sources.length === 1 && _.regexpIs( src ) )
  return src;

  let result = '(?:';
  result += o.sources.join( ')|(?:' );
  result += ')';

  return new RegExp( result, o.flags || '' );
}

regexpsAny.defaults =
{
  flags : null,
  sources : null,
  escaping : 0,
}

//

function regexpsAll( o )
{
  if( !_.mapIs( o ) )
  o = { sources : o }

  _.routine.options( regexpsAll, o );
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( _.regexpIs( o.sources ) )
  {
    _.assert( o.sources.flags === o.flags || o.flags === null );
    return o.sources;
  }

  let src = o.sources[ 0 ];
  o = _.regexpsSources( o );
  if( o.sources.length === 1 && _.regexpIs( src ) )
  return src;

  let result = ''

  if( o.sources.length > 0 )
  {

    if( o.sources.length > 1 )
    {
      result += '(?=';
      result += o.sources.slice( 0, o.sources.length-1 ).join( ')(?=' );
      result += ')';
    }

    result += '(?:';
    result += o.sources[ o.sources.length-1 ];
    result += ')';

  }

  return new RegExp( result, o.flags || '' );
}

regexpsAll.defaults =
{
  flags : null,
  sources : null,
  escaping : 0,
}

//

/**
 * Wraps regexp(s) into array and returns it. If in `src` passed string - turn it into regexp
 *
 * @example
 * _.regexp.array.make( ['red', 'white', /[a-z]/] );
 * // returns [ /red/, /white/, /[a-z]/ ]
 *
 * @param {String[]|String} src - array of strings/regexps or single string/regexp
 * @returns {RegExp[]} Array of regexps
 * @throw {Error} if `src` in not string, regexp, or array
 * @function arrayMake
 * @namespace Tools
 */

function arrayMake( src )
{

  _.assert( _.regexpLike( src ) || _.argumentsArray.like( src ), 'Expects array/regexp/string, got ' + _.entity.strType( src ) );

  src = _.arrayFlatten( [], _.array.as( src ) );

  for( let k = src.length-1 ; k >= 0 ; k-- )
  {
    let e = src[ k ]

    if( e === null )
    {
      src.splice( k, 1 );
      continue;
    }

    src[ k ] = _.regexpFrom( e );

  }

  return src;
}

//

/**
 * Routine arrayIndex() returns the index of the first regular expression that matches substring
 * Otherwise, it returns -1.
 *
 * @example
 * let str = "The RGB color model is an additive color model in which red, green, and blue light are added together in various ways to reproduce a broad array of colors";
 * let regArr1 = [/white/, /green/, /blue/];
 * _.regexp.arrayIndex(regArr1, str);
 * // returns 1
 *
 * @param {RegExp[]} arr Array for regular expressions.
 * @param {String} ins String, inside which will be execute search
 * @returns {number} Index of first matching or -1.
 * @throws {Error} If first argument is not array.
 * @throws {Error} If second argument is not string.
 * @throws {Error} If element of array is not RegExp.
 * @function arrayIndex
 * @namespace Tools
 */

function arrayIndex( arr, ins )
{
  _.assert( _.arrayIs( arr ) );
  _.assert( _.strIs( ins ) );

  for( let a = 0 ; a < arr.length ; a++ )
  {
    let regexp = arr[ a ];
    _.assert( _.regexpIs( regexp ) );
    if( regexp.test( ins ) )
    return a;
  }

  return -1;
}

//

/**
 * Checks if any regexp passed in `arr` is found in string `ins`
 * If match was found - returns match index
 * If no matches found and regexp array is not empty - returns false
 * If regexp array is empty - returns some default value passed in the `ifEmpty` input param
 *
 * @example
 * let str = "The RGB color model is an additive color model in which red, green, and blue light are added together in various ways to reproduce a broad array of colors";
 * let regArr2 = [/yellow/, /blue/, /red/];
 * _.arrayAny(regArr2, str, false);
 * // returns 1
 *
 * @example
 * let regArr3 = [/yellow/, /white/, /greey/]
 * _.regexp.arrayAny(regArr3, str, false);
 * // returns false
 *
 * @param {String[]} arr Array of regular expressions strings
 * @param {String} ins - string that is tested by regular expressions passed in `arr` parameter
 * @param {*} none - Default return value if array is empty
 * @returns {*} Returns the first match index, false if input array of regexp was empty or default value otherwise
 * @thows {Error} If missed one of arguments
 * @function arrayAny
 * @namespace Tools
 */

function arrayAny( arr, ins, ifEmpty )
{

  _.assert( _.arrayIs( arr ) || _.regexpIs( src ) );
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );

  arr = _.array.as( arr );
  for( let m = 0 ; m < arr.length ; m++ )
  {
    _.assert( _.routine.is( arr[ m ].test ) );
    if( arr[ m ].test( ins ) )
    return m;
  }

  return arr.length ? false : ifEmpty;
}

//

/**
 * Checks if all regexps passed in `arr` are found in string `ins`
 * If any of regex was not found - returns match index
 * If regexp array is not empty and all regexps passed test - returns true
 * If regexp array is empty - returns some default value passed in the `ifEmpty` input param
 *
 * @example
 * let str = "The RGB color model is an additive color model in which red, green, and blue light are added together in various ways to reproduce a broad array of colors";
 * let regArr1 = [/red/, /green/, /blue/];
 * _.regexp.arrayAll(regArr1, str, false);
 * // returns true
 *
 * @example
 * let regArr2 = [/yellow/, /blue/, /red/];
 * _.regexp.arrayAll(regArr2, str, false);
 * // returns 0
 *
 * @param {String[]} arr Array of regular expressions strings
 * @param {String} ins - string that is tested by regular expressions passed in `arr` parameter
 * @param {*} none - Default return value if array is empty
 * @returns {*} Returns the first match index, false if input array of regexp was empty or default value otherwise
 * @thows {Error} If missed one of arguments
 * @function arrayAll
 * @namespace Tools
 */

function arrayAll( arr, ins, ifEmpty )
{
  _.assert( _.arrayIs( arr ) || _.regexpIs( src ) );
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );

  arr = _.array.as( arr );
  for( let m = 0 ; m < arr.length ; m++ )
  {
    if( !arr[ m ].test( ins ) )
    return m;
  }

  return arr.length ? true : ifEmpty;
}

//

function arrayNone( arr, ins, ifEmpty )
{

  _.assert( _.arrayIs( arr ) || _.regexpIs( src ) );
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );

  arr = _.array.as( arr );
  for( let m = 0 ; m < arr.length ; m++ )
  {
    _.assert( _.routine.is( arr[ m ].test ) );
    if( arr[ m ].test( ins ) )
    return false;
  }

  return arr.length ? true : ifEmpty;
}

// --
// regexp extension
// --

let RegexpExtension =
{

  // regexp

  from,

  maybeFrom,

  arrayMake,
  arrayIndex,
  arrayAny,
  arrayAll,
  arrayNone,

}

Object.assign( _.regexp, RegexpExtension );

// --
// regexps extension
// --

let RegexpsExtension =
{

  // regexps

  maybeFrom : regexpsMaybeFrom,

  sources : regexpsSources,
  join : regexpsJoin,
  joinEscaping : regexpsJoinEscaping,
  atLeastFirst : regexpsAtLeastFirst,
  atLeastFirstOnly : regexpsAtLeastFirstOnly,

  none : regexpsNone,
  any : regexpsAny,
  all : regexpsAll,

}

Object.assign( _.regexps, RegexpsExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  regexpFrom : from,

  regexpMaybeFrom : maybeFrom,
  regexpsMaybeFrom,

  regexpsSources,
  regexpsJoin,
  regexpsJoinEscaping,
  regexpsAtLeastFirst,
  regexpsAtLeastFirstOnly,

  regexpsNone,
  regexpsAny,
  regexpsAll,

  regexpArrayMake : arrayMake,
  regexpArrayIndex : arrayIndex,
  regexpArrayAny : arrayAny,
  regexpArrayAll : arrayAll,
  regexpArrayNone : arrayNone,

}

Object.assign( _, ToolsExtension );

//

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Regexp.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Regexp_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Regexp_s */ })();

/* */  /* begin of file Routine_s */ ( function Routine_s() { function Routine_s_naked() { ( function _l7_Routine_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// routine
// --

function routineCallButOnly( /* context, routine, options, but, only */ )
{
  let context = arguments[ 0 ];
  let routine = arguments[ 1 ];
  let options = arguments[ 2 ];
  let but = arguments[ 3 ];
  let only = arguments[ 4 ];

  if( _.routine.is( routine ) || _.strIs( routine ) )
  {

    _.assert( arguments.length === 3 || arguments.length === 4 || arguments.length === 5 );
    _.assert( _.mapIs( options ) );

    if( _.strIs( routine ) )
    routine = context[ routine ];

  }
  else
  {

    routine = arguments[ 0 ];
    options = arguments[ 1 ];
    but = arguments[ 2 ];
    only = arguments[ 3 ];

    _.assert( arguments.length === 2 || arguments.length === 3 || arguments.length === 4 );
    _.assert( _.mapIs( options ) );

  }

  _.assert( _.routine.is( routine ) );

  if( !only )
  only = routine.defaults

  if( but )
  options = _.mapBut_( null, options, but )
  if( only )
  options = _.mapOnly_( null, options, only )

  return routine.call( context, options );
}

//

function _routinesComposeWithSingleArgument_head( routine, args )
{
  let o = _.routine.s.compose.head.call( this, routine, args );

  _.assert( args.length === 1 );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  return o;
}

//

function routinesComposeReturningLast()
{
  let o = _.routine.s.composeReturningLast.head( routinesComposeReturningLast, arguments );
  let result = _.routine.s.composeReturningLast.body( o );
  return result;
}

routinesComposeReturningLast.head = _.routine.s.compose.head;
routinesComposeReturningLast.body = _.routine.s.compose.body;
routinesComposeReturningLast.defaults = Object.create( _.routine.s.compose.defaults );

routinesComposeReturningLast.defaults.tail = _.routine.tail.returningLast;

function routinesComposeAll()
{
  let o = _.routine.s.composeAll.head( routinesComposeAll, arguments );
  let result = _.routine.s.composeAll.body( o );
  return result;
}

routinesComposeAll.head = _routinesComposeWithSingleArgument_head;
routinesComposeAll.body = _.routine.s.compose.body;

var defaults = routinesComposeAll.defaults = Object.create( _.routine.s.compose.defaults );
defaults.chainer = _.routine.chainer.composeAll;
defaults.tail = _.routine.tail.composeAll;

_.assert( _.routine.is( _.routine.chainer.originalWithDont ) );
_.assert( _.routine.is( _.routine.tail.composeAll ) );

//

function routinesComposeAllReturningLast()
{
  let o = _.routine.s.composeAllReturningLast.head( routinesComposeAllReturningLast, arguments );
  let result = _.routine.s.composeAllReturningLast.body( o );
  return result;
}

routinesComposeAllReturningLast.head = _routinesComposeWithSingleArgument_head;
routinesComposeAllReturningLast.body = _.routine.s.compose.body;

var defaults = routinesComposeAllReturningLast.defaults = Object.create( _.routine.s.compose.defaults );
defaults.chainer = _.routine.chainer.originalWithDont;
defaults.tail = _.routine.tail.returningLast;

//

function routinesChain()
{
  let o = _.routine.s.chain.head( routinesChain, arguments );
  let result = _.routine.s.chain.body( o );
  return result;
}

routinesChain.head = _routinesComposeWithSingleArgument_head;
routinesChain.body = _.routine.s.compose.body;

var defaults = routinesChain.defaults = Object.create( _.routine.s.compose.defaults );
defaults.chainer = _.routine.chainer.chaining;
defaults.tail = _.routine.tail.chaining;

//

function _equalizerFromMapper( mapper )
{

  if( mapper === undefined )
  mapper = function mapper( a, b ){ return a === b };

  _.assert( 0, 'not tested' )
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( mapper.length === 1 || mapper.length === 2 );

  if( mapper.length === 1 )
  {
    let equalizer = equalizerFromMapper;
    return equalizer;
  }

  return mapper;

  function equalizerFromMapper( a, b )
  {
    return mapper( a ) === mapper( b );
  }
}

//

function _comparatorFromEvaluator( evaluator )
{

  if( evaluator === undefined )
  evaluator = function comparator( a, b ){ return a-b };

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( evaluator.length === 1 || evaluator.length === 2 );

  if( evaluator.length === 1 )
  {
    let comparator = comparatorFromEvaluator;
    return comparator;
  }

  return evaluator;

  function comparatorFromEvaluator( a, b )
  {
    return evaluator( a ) - evaluator( b );
  }
}

// --
// routine extension
// --

let RoutineExtension =
{

  callButOnly : routineCallButOnly, /* qqq : cover please */

  _equalizerFromMapper,
  _comparatorFromEvaluator, /* xxx : move out */

}

Object.assign( _.routine, RoutineExtension );

// --
// routines extension
// --

let RoutinesExtension =
{

  composeReturningLast : routinesComposeReturningLast,
  composeAll : routinesComposeAll,
  composeAllReturningLast : routinesComposeAllReturningLast, /* xxx */
  chain : routinesChain,

}

Object.assign( _.routines, RoutinesExtension );

// --
// tools extension
// --

let ToolsExtension =
{

  routineCallButOnly, /* qqq : cover please */

  routinesComposeReturningLast,
  routinesComposeAll,
  routinesComposeAllReturningLast, /* xxx */
  routinesChain,

  _equalizerFromMapper,
  _comparatorFromEvaluator, /* xxx : move out */

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Routine.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Routine_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Routine_s */ })();

/* */  /* begin of file Seeker_s */ ( function Seeker_s() { function Seeker_s_naked() { ( function _l7_Seeker_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// seeker extension
// --

let SeekerExtension =
{

}

Object.assign( _.seeker, SeekerExtension );

// --
// tools extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Seeker.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Seeker_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Seeker_s */ })();

/* */  /* begin of file Set_s */ ( function Set_s() { function Set_s_naked() { ( function _l7_Set_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// function adapterLike( src )
// {
//   if( !src )
//   return false;
//   if( _.set.like( src ) )
//   return true;
//   if( !_.containerAdapter || _.containerAdapter.Set )
//   return false;
//   if( src instanceof _.containerAdapter.Set )
//   return true;
//   return false;
// }

// --
// extension
// --

let ToolsExtension =
{

  // setAdapterLike : adapterLike,

}

Object.assign( _, ToolsExtension );

//

let SetExtension =
{

  // adapterLike, /* xxx : move out */

}

Object.assign( _.set, SetExtension );

//

let SetsExtension =
{

}

//

Object.assign( _.set.s, SetsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Set.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Set_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Set_s */ })();

/* */  /* begin of file Sorted_s */ ( function Sorted_s() { function Sorted_s_naked() { ( function _l5_Sorted_s_()
{

'use strict';

//

const _global = _global_;
const _ = _global_.wTools;
_.sorted = _.sorted || Object.create( null );

// --
//
// --

// --
// extension
// --

let Extension =
{
};

_.props.supplement( _.sorted, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Sorted.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Sorted_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Sorted_s */ })();

/* */  /* begin of file Str_s */ ( function Str_s() { function Str_s_naked() { ( function _l7_String_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

const _ArraySlice = Array.prototype.slice;
const _FunctionBind = Function.prototype.bind;
const _ObjectToString = Object.prototype.toString;

// --
// str
// --

function strIsolate_head( routine, args )
{
  let o;

  if( args.length > 1 )
  {
    if( args.length === 3 )
    o = { src : args[ 0 ], delimeter : args[ 1 ], times : args[ 2 ] };
    else if( args.length === 2 )
    o = { src : args[ 0 ], delimeter : args[ 1 ] };
    else
    o = { src : args[ 0 ] };
  }
  else
  {
    o = args[ 0 ];
    _.assert( args.length === 1, 'Expects single argument' );
  }

  _.routine.options( routine, o );
  _.assert( args.length === 1 || args.length === 2 || args.length === 3 );
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( o.src ) );
  _.assert( _.regexpsLikeAll( o.delimeter ) )
  _.assert( _.number.is( o.times ) );

  return o;
}

//

/**
* @typedef {object} wTools.entity.exportStringInhalfOptions
* @property {string} [ o.src=null ] - Source string.
* @property {string | array} [ o.delimeter=' ' ] - Splitter of the string.
* @property {boolean} [ o.left=1 ] - Finds occurrence from begining of the string.
*/

/**
 * Finds occurrence of delimeter( o.delimeter ) in source( o.src ) and splits string in finded position by half.
 * If function finds  more then one occurrence, it separates string in the position of the last.
 *
 * @param {wTools.entity.exportStringInhalfOptions} o - Contains data and options {@link wTools.entity.exportStringInhalfOptions}.
 * @returns {array} Returns array with separated parts of string( o.src ) or original string if nothing finded.
 *
 * @example
 * _.strIsolate( { src : 'sample, string', delimeter : [ ',' ] } );
 * // returns [ 'sample', 'string' ]
 *
 * @example
 *_.strIsolate( { src : 'sample string', delimeter : ' ' } )
 * // returns [ 'sample', 'string' ]
 *
 * @example
 * _.strIsolate( { src : 'sample string, name string', delimeter : [ ',', ' ' ] } )
 * // returns [ 'sample string, name', 'string' ]
 *
 * @method strIsolate
 * @throws { Exception } Throw an exception if no argument provided.
 * @throws { Exception } Throw an exception if( o ) is not a Map.
 * @throws { Exception } Throw an exception if( o.src ) is not a String.
 * @throws { Exception } Throw an exception if( o.delimeter ) is not a Array or String.
 * @throws { Exception } Throw an exception if( o ) is extended by unknown property.
 * @namespace Tools
 *
 */

// function strIsolate( o )
// {
//   let result = [];
//   let times = o.times;
//   let delimeter
//   let index = o.left ? -1 : o.src.length;
//
//   _.routine.assertOptions( strIsolate, o );
//   _.assert( arguments.length === 1, 'Expects single argument' );
//   _.assert( _.strIs( o.src ), 'Expects string {-o.src-}, got', _.entity.strType( o.src ) );
//   _.assert( _.strIs( o.delimeter ) || _.arrayIs( o.delimeter ) );
//   _.assert( _.number.is( o.times ) );
//
//   /* */
//
//   if( !( times >= 1 ) )
//   {
//     return everything( o.left ^ o.none );
//   }
//
//   if( _.arrayIs( o.delimeter ) && o.delimeter.length === 1 )
//   o.delimeter = o.delimeter[ 0 ];
//
//   let closest = o.left ? strLeft : strRight;
//
//   /* */
//
//   while( times > 0 )
//   {
//
//     index += o.left ? +1 : -1;
//
//     if( _.arrayIs( o.delimeter ) )
//     {
//
//       if( !o.delimeter.length )
//       {
//         return everything( o.left ^ o.none );
//       }
//
//       let c = closest( index );
//
//       delimeter = c.element;
//       index = c.value;
//
//       if( o.times === 1 && index === o.src.length && o.left )
//       index = -1;
//
//     }
//     else
//     {
//
//       delimeter = o.delimeter;
//       index = o.left ? o.src.indexOf( delimeter, index ) : o.src.lastIndexOf( delimeter, index );
//
//       if( o.left && !( index >= 0 ) && o.times > 1 )
//       {
//         index = o.src.length;
//         break;
//       }
//
//     }
//
//     /* */
//
//     if( !o.left && times > 1 && index === 0  )
//     {
//       return everything( !o.none )
//     }
//
//     if( !( index >= 0 ) && o.times === 1 )
//     {
//       return everything( o.left ^ o.none )
//     }
//
//     times -= 1;
//
//   }
//
//   /* */
//
//   result.push( o.src.substring( 0, index ) );
//   result.push( delimeter );
//   result.push( o.src.substring( index + delimeter.length ) );
//
//   return result;
//
//   /* */
//
//   function everything( side )
//   {
//     return ( side ) ? [ o.src, '', '' ] : [ '', '', o.src ];
//   }
//
//   /* */
//
//   function strLeft( index )
//   {
//     return _.entityMin( o.delimeter, function( a )
//     {
//       let i = o.src.indexOf( a, index );
//       if( i === -1 )
//       return o.src.length;
//       return i;
//     });
//   }
//
//   /* */
//
//   function strRight( index )
//   {
//     return _.entityMax( o.delimeter, function( a )
//     {
//       let i = o.src.lastIndexOf( a, index );
//       return i;
//     });
//   }
//
// }
//
// strIsolate.defaults =
// {
//   src : null,
//   delimeter : ' ',
//   quote : null,
//   left : 1,
//   times : 1,
//   none : 1,
// }

function strIsolate_body( o )
{
  let result = [];
  let times = o.times;
  let delimeter
  let index = o.left ? 0 : o.src.length;
  let more = o.left ? strLeft : strRight;
  let delta = ( o.left ? +1 : -1 );

  _.routine.assertOptions( strIsolate_body, arguments );

  /* */

  if( _.arrayIs( o.delimeter ) && o.delimeter.length === 1 )
  o.delimeter = o.delimeter[ 0 ];

  let quote;
  if( o.quote )
  quote = _.strQuoteAnalyze({ src : o.src, quote : o.quote });

  /* */

  while( times > 0 )
  {
    let found = more( index );

    if( found.entry === undefined )
    break;

    times -= 1;

    if( o.left )
    index = found.index + delta;
    else
    index = found.index + found.entry.length + delta;

    if( times === 0 )
    {
      result.push( o.src.substring( 0, found.index ) );
      result.push( found.entry );
      result.push( o.src.substring( found.index + found.entry.length ) );
      return result;
    }

    /* */

    if( o.left )
    {
      if( index >= o.src.length )
      break;
    }
    else
    {
      if( index <= 0 )
      break;
    }

  }

  /* */

  if( !result.length )
  {

    if( o.times === 0 )
    return everything( !o.left );
    else if( times === o.times )
    return everything( o.left ^ o.none );
    else
    return everything( o.left );

  }

  return result;

  /* */

  function everything( side )
  {
    return ( side ) ? [ o.src, undefined, '' ] : [ '', undefined, o.src ];
  }

  /* */

  function strLeft( index )
  {
    // let r = _._strLeftSingle( o.src, o.delimeter, [ index, undefined ] );
    let r = _._strLeftSingle_( o.src, o.delimeter, [ index, undefined ] );
    if( quote )
    if( r.entry !== undefined )
    {
      let range = inQuoteRange( r.index );
      if( range )
      return strLeft( range[ 1 ]+1 );
    }
    return r;
  }

  /* */

  function strRight( index )
  {
    // let r = _._strRightSingle( o.src, o.delimeter, [ undefined, index ] );
    let r = _._strRightSingle_( o.src, o.delimeter, [ undefined, index-1 ] );
    if( quote )
    if( r.entry !== undefined )
    {
      let range = inQuoteRange( r.index );
      if( range )
      return strRight( range[ 0 ] );
    }
    return r;
  }

  /* */

  function inQuoteRange( offset )
  {
    let i = _.sorted.searchFirstIndex( quote.ranges, offset );
    if( i % 2 )
    {
      i -= 1;
    }
    if( i < 0 || i >= quote.ranges.length )
    return false;
    let b = quote.ranges[ i ];
    let e = quote.ranges[ i+1 ];
    if( !( b <= offset && offset <= e ) )
    return false;
    return [ b, e ];
  }

  /* */

  // function binSearch( val )
  // {
  //   let l = 0;
  //   let r = quote.ranges.length;
  //   let m;
  //   if( quote.ranges.length )
  //   debugger;
  //   do
  //   {
  //     m = Math.floor( ( l + r ) / 2 );
  //     if( quote.ranges[ m ] < val )
  //     l = m+1;
  //     else if( quote.ranges[ m ] > val )
  //     r = m;
  //     else
  //     return m;
  //   }
  //   while( l < r );
  //   if( quote.ranges[ m ] < val )
  //   return m+1;
  //   return m;
  // }

  /* */

  // let quotedRanges = [];
  //
  // function quoteRangesSetup( index )
  // {
  //   let quotes = [];
  //   for( let i = 0 ; i < o.src.length ; i++ )
  //   {
  //     if( _.arrayHas( o.quote,  ) )
  //   }
  // }
  //
  // function quoteRange( index )
  // {
  //   for( let i = 0 ; i < x ; i++ )
  //
  // }

}

strIsolate_body.defaults =
{
  src : null,
  delimeter : ' ',
  quote : 0,
  // quoting : [ '"', '`', '\'' ],
  left : 1,
  times : 1,
  none : 1,
}

//

/**
 * Short-cut for strIsolate function.
 * Finds occurrence of delimeter( o.delimeter ) from begining of ( o.src ) and splits string in finded position by half.
 *
 * @param {wTools.entity.exportStringInhalfOptions} o - Contains data and options {@link wTools.entity.exportStringInhalfOptions}.
 * @returns {array} Returns array with separated parts of string( o.src ) or original string if nothing finded.
 *
 * @example
 * _.strIsolateLeftOrNone( { src : 'sample, string', delimeter : [ ', ' ] } );
 * // returns [ 'sample', 'string' ]
 *
 * @example
 *_.strIsolateLeftOrNone( { src : 'sample string', delimeter : ' ' } )
 * // returns [ 'sample', 'string' ]
 *
 * @example
 * _.strIsolateLeftOrNone( 'sample string, name string', ',' )
 * // returns [ 'sample string, name', 'string' ]
 *
 * @method strIsolateLeftOrNone
 * @throws { Exception } Throw an exception if no argument provided.
 * @throws { Exception } Throw an exception if( o ) is not a Map.
 * @throws { Exception } Throw an exception if( o.src ) is not a String.
 * @namespace Tools
 *
 */

function strIsolateLeftOrNone_body( o )
{
  o.left = 1;
  o.none = 1;
  let result = _.strIsolate.body( o );
  return result;
}

strIsolateLeftOrNone_body.defaults =
{
  src : null,
  delimeter : ' ',
  times : 1,
  quote : null,
}

//

function strIsolateLeftOrAll_body( o )
{
  o.left = 1;
  o.none = 0;
  let result = _.strIsolate.body( o );
  return result;
}

strIsolateLeftOrAll_body.defaults =
{
  src : null,
  delimeter : ' ',
  times : 1,
  quote : null,
}

//

/**
 * Short-cut for strIsolate function.
 * Finds occurrence of delimeter( o.delimeter ) from end of ( o.src ) and splits string in finded position by half.
 *
 * @param {wTools.entity.exportStringInhalfOptions} o - Contains data and options {@link wTools.entity.exportStringInhalfOptions}.
 * @returns {array} Returns array with separated parts of string( o.src ) or original string if nothing finded.
 *
 * @example
 * _.strIsolateRightOrNone( { src : 'sample, string', delimeter : [ ',' ] } );
 * // returns [ 'sample', 'string' ]
 *
 * @example
 *_.strIsolateRightOrNone( { src : 'sample string', delimeter : ' ' } )
 * // returns [ 'sample', 'string' ]
 *
 * @method strIsolateRightOrNone
 * @throws { Exception } Throw an exception if no argument provided.
 * @throws { Exception } Throw an exception if( o ) is not a Map.
 * @throws { Exception } Throw an exception if( o.src ) is not a String.
 * @namespace Tools
 *
 */

function strIsolateRightOrNone_body( o )
{
  o.left = 0;
  o.none = 1;
  let result = _.strIsolate.body( o );
  return result;
}

strIsolateRightOrNone_body.defaults =
{
  src : null,
  delimeter : ' ',
  times : 1,
  quote : null,
}

//

function strIsolateRightOrAll_body( o )
{
  o.left = 0;
  o.none = 0;
  let result = _.strIsolate.body( o );
  return result;
}

strIsolateRightOrAll_body.defaults =
{
  src : null,
  delimeter : ' ',
  times : 1,
  quote : null,
}

//

// function strIsolateInsideOrNoneSingle( src, begin, end )
// {
//
//   _.assert( _.strIs( src ), 'Expects string {-src-}' );
//   _.assert( arguments.length === 3, 'Expects exactly three arguments' );
//
//   let b = _.strLeft( src, begin );
//
//   if( b.entry === undefined )
//   return notFound();
//
//   let e = _.strRight( src, end );
//
//   if( e.entry === undefined )
//   return notFound();
//
//   if( e.index < b.index + b.entry.length )
//   return notFound();
//
//   let result =
//   [
//     src.substring( 0, b.index ),
//     b.entry,
//     src.substring( b.index + b.entry.length, e.index ),
//     e.entry,
//     src.substring( e.index+e.entry.length, src.length )
//   ];
//
//   return result;
//
//   function notFound()
//   {
//     return [];
//   }
// }
//
// //
//
// function strIsolateInsideOrNone( src, begin, end )
// {
//
//   _.assert( arguments.length === 3, 'Expects exactly three arguments' );
//
//   if( _.argumentsArray.like( src ) )
//   {
//     let result = [];
//     for( let s = 0 ; s < src.length ; s++ )
//     result[ s ] = _.strIsolateInsideOrNoneSingle( src[ s ], begin, end );
//     return result;
//   }
//   else
//   {
//     return _.strIsolateInsideOrNoneSingle( src, begin, end );
//   }
//
// }

//

/**
  * Routine isolateInsideSignle() split source strings {-src-} into parts separated by delimeters {-begin-} and {-end-}. Routine returns
  * an array with parts of source string {-src-}.
  * The array contains of five parts:
  * - substring from start of source string to begin of first delimeter {-begin-}.
  * - delimeter {-begin-}.
  * - substring between delimeters {-begin-} and {-end-}.
  * - delimeter {-end-}.
  * - substring from end of delimeter {-end-} to end of source line.
  * If routine does not find part between {-begin-} and {-end-} delimeters, then routine transform begin and end substrings to empty
  * strings and delimeters to undefined.
  * So, finally routine returns the array with source string: [ '', undefined, {-src-}, undefined, '' ].
  *
  * @param { String } src - The source string.
  * @param { String|Array } begin - String or array of strings to find begin of split part in the source string.
  * @param { String|Array } end - String or array of strings to find end of split part in the source source.
  *
  * @example
  * _.strIsolateInsideSignle( 'aabdcdd', 'a', 'd' );
  * // returns [ '', 'a', 'abdcd', 'd', '' ]
  *
  * @example
  * _.strIsolateInsideSignle( 'cabdcdc', 'a', 'd' );
  * // returns [ 'c', 'a', 'bdc', 'd', 'c' ]
  *
  * @example
  * _.strIsolateInsideSignle( 'cabdcdc', 'f', 'd' );
  * // returns [ '', undefined, 'cabdcdc', undefined, '' ]
  *
  * @example
  * _.strIsolateInsideSignle( 'cabdcdc', 'a', 'f' );
  * // returns [ '', undefined, 'cabdcdc', undefined, '' ]
  *
  * @example
  * _.strIsolateInsideSignle( 'cabdcdc', [ 'f', 'b' ], 'd' );
  * // returns [ 'ca', 'b', 'dc', 'd', 'c' ]
  *
  * @example
  * _.strIsolateInsideSignle( 'cabdcdc', 'b', [ 'f', 'd' ] );
  * // returns [ 'ca', 'b', 'dc', 'd', 'c' ]
  *
  * @example
  * _.strIsolateInsideSignle( 'cabdcdc', [ 'b', 'c' ], [ 'c', 'd' ] );
  * // returns [ 'ca', 'b', 'dcd', 'c', '' ]
  *
  * @returns { Array } - Returns array with parts of source string.
  * @function isolateInsideSignle
  * @throws { Exception } If arguments.length is less then one or more then three.
  * @throws { Exception } If source string {-str-} is not a String.
  * @throws { Exception } If delimeter {-begin-} is not a String or an Array of strings.
  * @throws { Exception } If delimeter {-end-} is not a String or an Array of strings.
  * @namespace Tools
  */

function isolateInsideSignle( src, begin, end )
{

  _.assert( _.strIs( src ), 'Expects string {-src-}' );
  _.assert( arguments.length === 2 || arguments.length === 3 );
  let b, e;

  if( end === undefined )
  {
    let pairs = arguments[ 1 ];
    _.assert( _.strIs( pairs ) || _.arrayIs( pairs ) );
    pairs = _.strQuotePairsNormalize( pairs );

    let l = 0;
    let begin = [];
    for( let q = 0 ; q < pairs.length ; q++ )
    {
      let quotingPair = pairs[ q ];
      begin.push( quotingPair[ 0 ] );
    }

    do
    {

      // b = _.strLeft( src, begin, [ l, src.length ] );
      b = _.strLeft_( src, begin, [ l, src.length-1 ] );

      if( b.entry === undefined )
      return notFound();

      _.assert( _.number.is( b.instanceIndex ) );
      let end = pairs[ b.instanceIndex ][ 1 ];

      // e = _.strRight( src, end, Math.min( b.index+1, src.length ) );
      // e = _.strRight_( src, end, Math.min( b.index, src.length-1 ) ); /* Dmytro : if cinterval is a Number, it is defined first index, not last */
      e = _.strRight_( src, end, Math.min( b.index, src.length ) );

      if( e.entry === undefined )
      l = b.index+1;
      else
      break;
      // return notFound();

    }
    while( l < src.length );

    if( e.entry === undefined )
    return notFound();

  }
  else
  {

    // b = _.strLeft( src, begin );
    b = _.strLeft_( src, begin );

    if( b.entry === undefined )
    return notFound();

    // e = _.strRight( src, end, Math.min( b.index+1, src.length ) );
    // e = _.strRight_( src, end, Math.min( b.index, src.length-1 ) ); /* Dmytro : if cinterval is a Number, it is defined first index, not last */
    e = _.strRight_( src, end, Math.min( b.index, src.length ) );

    if( e.entry === undefined )
    return notFound();

  }

  if( e.index < b.index + b.entry.length )
  return notFound();

  let result =
  [
    src.substring( 0, b.index ),
    b.entry,
    src.substring( b.index + b.entry.length, e.index ),
    e.entry,
    src.substring( e.index + e.entry.length, src.length )
  ];

  return result;

  function notFound()
  {
    // return [ '', '', src, '', '' ];
    return [ '', undefined, src, undefined, '' ];
  }
}

//

/**
  * Routine isolateInside() split source strings of vector {-src-} into parts separated by delimeters {-begin-} and {-end-}. Routine
  * returns a vector with arrays. Each array of vector corresponds to element of vector {-src-}.
  * Each array contains of five parts:
  * - substring from start of source string to begin of first delimeter {-begin-}.
  * - delimeter {-begin-}.
  * - substring between delimeters {-begin-} and {-end-}.
  * - delimeter {-end-}.
  * - substring from end of delimeter {-end-} to end of source line.
  * If routine does not find part between {-begin-} and {-end-} delimeters, then routine transform begin and end substrings to empty
  * strings and delimeters to undefined.
  * So, finally routine returns the array with source string: [ '', undefined, {-src-}, undefined, '' ].
  *
  * @param { String|Array } src - The source string or vector of source strings. If {-src-} is a vector, then routine returns vector
  * with resulted arrays. Otherwise, routine returns only one resulted array for scalar source string.
  * @param { String|Array } begin - String or array of strings to find begin of split part in the source string.
  * @param { String|Array } end - String or array of strings to find end of split part in the source source.
  *
  * @example
  * _.strIsolateInside( 'aabdcdd', 'a', 'd' );
  * // returns [ '', 'a', 'abdcd', 'd', '' ]
  *
  * @example
  * _.strIsolateInside( 'cabdcdc', 'a', 'd' );
  * // returns [ 'c', 'a', 'bdc', 'd', 'c' ]
  *
  * @example
  * _.strIsolateInside( 'cabdcdc', 'f', 'd' );
  * // returns [ '', undefined, 'cabdcdc', undefined, '' ]
  *
  * @example
  * _.strIsolateInsideSignle( 'cabdcdc', 'a', 'f' );
  * // returns [ '', undefined, 'cabdcdc', undefined, '' ]
  *
  * @example
  * _.strIsolateInside( 'cabdcdc', [ 'f', 'b' ], 'd' );
  * // returns [ 'ca', 'b', 'dc', 'd', 'c' ]
  *
  * @example
  * _.strIsolateInside( 'cabdcdc', 'b', [ 'f', 'd' ] );
  * // returns [ 'ca', 'b', 'dc', 'd', 'c' ]
  *
  * @example
  * _.strIsolateInside( 'cabdcdc', [ 'b', 'c' ], [ 'c', 'd' ] );
  * // returns [ 'ca', 'b', 'dcd', 'c', '' ]
  *
  * @example
  * _.strIsolateInside( [ 'cabdcdc', 'ddccbbaa' ], 'b', 'd' );
  * // returns [ [ 'ca', 'b', 'dc', 'd', 'c' ], [ '', '', 'ddccbbaa', '', '' ] ]
  *
  * @example
  * _.strIsolateInside( [ 'cabdcdc', 'ddccbbaa' ], [ 'b', 'c' ], [ 'c', 'd' ] );
  * // returns [ [ 'ca', 'b', 'dcd', 'c', '' ], [ 'dd', 'c', '', 'c', 'bbaa' ] ]
  *
  * @returns { Array|ArraysVector } - If source string is a scalar, then routine returns array with parts of source string.
  * If source string is a vector, then routine returns vector of arrays.
  * @function isolateInside
  * @throws { Exception } If arguments.length is less then one or more then three.
  * @throws { Exception } If source string {-str-} is not a String.
  * @throws { Exception } If delimeter {-begin-} is not a String or an Array of strings.
  * @throws { Exception } If delimeter {-end-} is not a String or an Array of strings.
  * @namespace Tools
  */

function isolateInside( src, begin, end )
{

  _.assert( arguments.length === 2 || arguments.length === 3 );

  if( _.argumentsArray.like( src ) )
  {
    let result = [];
    for( let s = 0 ; s < src.length ; s++ )
    result[ s ] = _.strIsolateInsideSignle( src[ s ], begin, end );
    return result;
  }
  else
  {
    return _.strIsolateInsideSignle( src, begin, end );
  }

}

// --
// str extension
// --

let StrExtension =
{

  isolate : _.routine.unite( strIsolate_head, strIsolate_body ),
  isolateLeftOrNone : _.routine.unite( strIsolate_head, strIsolateLeftOrNone_body ),
  isolateLeftOrAll : _.routine.unite( strIsolate_head, strIsolateLeftOrAll_body ),
  isolateRightOrNone : _.routine.unite( strIsolate_head, strIsolateRightOrNone_body ),
  isolateRightOrAll : _.routine.unite( strIsolate_head, strIsolateRightOrAll_body ),

  isolateInsideSignle,
  isolateInside,

}

Object.assign( _.str, StrExtension );

// --
// extension
// --

let ToolsExtension =
{

  strIsolate : _.routine.unite( strIsolate_head, strIsolate_body ),
  strIsolateLeftOrNone : _.routine.unite( strIsolate_head, strIsolateLeftOrNone_body ),
  strIsolateLeftOrAll : _.routine.unite( strIsolate_head, strIsolateLeftOrAll_body ),
  strIsolateRightOrNone : _.routine.unite( strIsolate_head, strIsolateRightOrNone_body ),
  strIsolateRightOrAll : _.routine.unite( strIsolate_head, strIsolateRightOrAll_body ),

  // strIsolateInsideOrNoneSingle,
  // strIsolateInsideOrNone,
  strIsolateInsideSignle : isolateInsideSignle,
  strIsolateInside : isolateInside,

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Str.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Str_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Str_s */ })();

/* */  /* begin of file Stringer_s */ ( function Stringer_s() { function Stringer_s_naked() { ( function _l7_Stringer_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

// --
// stringer extension
// --

let StringerExtension =
{

}

Object.assign( _.stringer, StringerExtension );

// --
// tools extension
// --

let ToolsExtension =
{

}

Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Stringer.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Stringer_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Stringer_s */ })();

/* */  /* begin of file Symbol_s */ ( function Symbol_s() { function Symbol_s_naked() { ( function _l7_Symbol_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.symbol = _.symbol || Object.create( null );

// --
// symbol
// --

// --
// extension
// --

let ToolsExtension =
{

}

//

let Extension =
{

}

Object.assign( _, ToolsExtension );
Object.assign( Self, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Symbol.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Symbol_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Symbol_s */ })();

/* */  /* begin of file Time_s */ ( function Time_s() { function Time_s_naked() { ( function _l7_Time_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
// implementation
// --

function rarely_functor( perTime, routine )
{
  let lastTime = _.time.now() - perTime;

  _.assert( arguments.length === 2 );
  _.assert( _.number.is( perTime ) );
  _.assert( _.routine.is( routine ) );

  return function fewer()
  {
    let now = _.time.now();
    let elapsed = now - lastTime;
    if( elapsed < perTime )
    return;
    lastTime = now;
    return routine.apply( this, arguments );
  }

}

//

function once( delay, onBegin, onEnd )
{
  let con = _.Consequence ? new _.Consequence({ /* sourcePath : 2 */ }) : undefined;
  let taken = false;
  let options;
  let optionsDefault =
  {
    delay : null,
    onBegin : null,
    onEnd : null,
  }

  if( _.object.isBasic( delay ) )
  {
    options = delay;
    _.assert( arguments.length === 1, 'Expects single argument' );
    _.map.assertHasOnly( options, optionsDefault );
    delay = options.delay;
    onBegin = options.onBegin;
    onEnd = options.onEnd;
  }
  else
  {
    _.assert( 2 <= arguments.length && arguments.length <= 3 );
  }

  // _.assert( 0, 'not tested' );
  _.assert( delay >= 0 );
  _.assert( _.primitive.is( onBegin ) || _.routine.is( onBegin ) || _.object.isBasic( onBegin ) );
  _.assert( _.primitive.is( onEnd ) || _.routine.is( onEnd ) || _.object.isBasic( onEnd ) );

  return function once()
  {

    if( taken )
    {
      /*console.log( 'once :', 'was taken' );*/
      return;
    }
    taken = true;

    if( onBegin )
    {
      if( _.routine.is( onBegin ) ) onBegin.apply( this, arguments );
      else if( _.object.isBasic( onBegin ) ) onBegin.take( arguments );
      if( con )
      con.take( null );
    }

    _.time.out( delay, function()
    {

      if( onEnd )
      {
        if( _.routine.is( onEnd ) ) onEnd.apply( this, arguments );
        else if( _.object.isBasic( onEnd ) ) onEnd.take( arguments );
        if( con )
        con.take( null );
      }
      taken = false;

    });

    return con;
  }

}

//

function debounce( o ) /* Dmytro : routine returns routine. Is it valid result? */
{
  _.assert( arguments.length <= 3 );

  if( arguments.length > 1 )
  {
    o =
    {
      routine : arguments[ 0 ],
      delay : arguments[ 1 ],
      immediate : ( arguments.length > 2 ? arguments[ 2 ] : null ),
    }
  }

  _.routine.options( debounce, o  );

  _.assert( _.routine.is( o.routine ) );
  _.assert( _.number.is( o.delay ) );

  let timer, lastCallTime, routine, result;

  return debounced;

  /* */

  function debounced()
  {
    lastCallTime = _.time.now();
    routine = _.routine.join( this, o.routine, arguments );
    let execNow = o.immediate && !timer
    if( !timer )
    timer = setTimeout( onDelay, o.delay );
    if( execNow )
    result = routine();
    return result;
  };

  function onDelay()
  {
    var elapsed = _.time.now() - lastCallTime;

    if( elapsed > o.delay )
    {
      timer = null;
      if( !o.immediate )
      result = routine();
    }
    else
    {
      timer = setTimeout( onDelay, o.delay - elapsed );
    }
  };
}

debounce.defaults =
{
  routine : null,
  delay : 100,
  immediate : false
}

// --
// declaration
// --

let TimeExtension =
{

  rarely_functor, /* check */
  once, /* qqq : cover by light test */

  debounce

}

//

_.props.supplement( _.time, TimeExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Time.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Time_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Time_s */ })();

/* */  /* begin of file Type_s */ ( function Type_s() { function Type_s_naked() { ( function _l7_Type_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

// --
//
// --

let Extension =
{
};

//

_.props.supplement( _, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Type.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Type_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Type_s */ })();

/* */  /* begin of file Units_s */ ( function Units_s() { function Units_s_naked() { ( function _l7_Units_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.units = _.units || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{

}

//

var ToolsExtension =
{

}

//

Object.assign( _.units, Extension );
Object.assign( _, ToolsExtension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Units.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Units_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Units_s */ })();

/* */  /* begin of file Unroll_s */ ( function Unroll_s() { function Unroll_s_naked() { ( function _l7_Unroll_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

// --
//
// --

// --
//
// --

let Extension =
{
};

//

_.props.supplement( _, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Unroll.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Unroll_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Unroll_s */ })();

/* */  /* begin of file Vector_s */ ( function Vector_s() { function Vector_s_naked() { ( function _l7_Vector_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
_.vector = _.vector || Object.create( null );

// --
// implementation
// --

// --
// extension
// --

var Extension =
{

}

//

Object.assign( _.vector, Extension );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7/Vector.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l7' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Vector_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Vector_s */ })();

/* */  /* begin of file Setup_s */ ( function Setup_s() { function Setup_s_naked() { ( function _Setup_s_()
{

'use strict';

const _global = _global_;
const _ = _global.wTools;
const Self = _.setup = _.setup || Object.create( null );
_.error = _.error || Object.create( null );

// --
// setup
// --

function _setupConfig()
{

  if( _global.__GLOBAL_NAME__ !== 'real' )
  return;

  if( !_global.Config )
  _global.Config = Object.create( null );

  if( _global.Config.debug === undefined )
  _global.Config.debug = true;

  _global.Config.debug = !!_global.Config.debug;

}

//

function _setupLoggerPlaceholder()
{

  if( !_global.console.debug )
  _global.console.debug = function debug()
  {
    this.log.apply( this, arguments );
  }

  if( !_global.logger )
  _global.logger =
  {
    log : function log() { console.log.apply( console, arguments ); },
    logUp : function logUp() { console.log.apply( console, arguments ); },
    logDown : function logDown() { console.log.apply( console, arguments ); },
    error : function error() { console.error.apply( console, arguments ); },
    errorUp : function errorUp() { console.error.apply( console, arguments ); },
    errorDown : function errorDown() { console.error.apply( console, arguments ); },
    info : function info() { console.info.apply( console, arguments ); },
    warn : function warn() { console.warn.apply( console, arguments ); },
    debug : function debug() { console.debug.apply( console, arguments ); },
  }

}

//

function _setupTesterPlaceholder()
{

  if( !_global.wTestSuite )
  _global.wTestSuite = function wTestSuite( testSuit )
  {

    if( !_realGlobal_.wTests )
    _realGlobal_.wTests = Object.create( null );

    if( !testSuit.suiteFilePath )
    testSuit.suiteFilePath = _.introspector.location( 1 ).filePath;

    if( !testSuit.suiteFileLocation )
    testSuit.suiteFileLocation = _.introspector.location( 1 ).fileNameLineCol;

    _.assert( _.strDefined( testSuit.suiteFileLocation ), 'Test suit expects a mandatory option ( suiteFileLocation )' );
    _.assert( _.object.isBasic( testSuit ) );

    if( !testSuit.abstract )
    _.assert( !_realGlobal_.wTests[ testSuit.name ], 'Test suit with name "' + testSuit.name + '" already registered!' );
    _realGlobal_.wTests[ testSuit.name ] = testSuit;

    testSuit.inherit = function inherit()
    {
      this.inherit = _.longSlice( arguments );
    }

    return testSuit;
  }

  /* */

  if( !_realGlobal_.wTester )
  {
    _realGlobal_.wTester = Object.create( null );
    _realGlobal_.wTester.test = function test( testSuitName )
    {
      if( _.workerIs() ) /* xxx : temp */
      return;
      if( Config.interpreter !== 'njs' ) /* xxx : temp. remove aster fixing starter */
      return;
      _.assert( arguments.length === 0 || arguments.length === 1 );
      _.assert( _.strIs( testSuitName ) || testSuitName === undefined, 'test : expects string {-testSuitName-}' );
      debugger;
      _.process.ready( function()
      {
        debugger;
        if( _realGlobal_.wTester.test === test )
        throw _.err( 'Cant run tests. Include module::wTesting.' );
        _realGlobal_.wTester.test.call( _realGlobal_.wTester, testSuitName );
      });
    }
  }

}

//

function _setupProcedure()
{

  if
  (
    _realGlobal_ !== _global
    && _realGlobal_.wTools
    && _realGlobal_.wTools.setup
    && _realGlobal_.wTools.setup._entryProcedureStack
  )
  {
    Self._entryProcedureStack =  _realGlobal_.wTools.setup._entryProcedureStack;
  }

  if( Self._entryProcedureStack )
  return;

  let stack = _.introspector.stack().split( '\n' );
  for( let s = stack.length-1 ; s >= 0 ; s-- )
  {
    let call = stack[ s ];
    let location = _.introspector.locationFromStackFrame( call );
    if( !location.internal && !location.abstraction )
    {
      stack.splice( s+1, stack.length );
      stack.splice( 0, s );
      break;
    }
  }

  Self._entryProcedureStack = stack.join( '\n' );
}

//

function _setupTime()
{

  _.assert( !!_.time && !!_.time.now );
  _.setup.startTime = _.time.now();

}

//

function _validate()
{

  if( !Config.debug )
  return;

  _.assert( _.routine.is( _.array._elementWithKey ) );
  _.assert( _.routine.is( _.argumentsArray._elementWithKey ) );
  _.assert( _.routine.is( _.long._elementWithKey ) );
  _.assert( _.routine.is( _.map._elementWithKey ) );
  _.assert( _.routine.is( _.object._elementWithKey ) );

  if( !Object.hasOwnProperty.call( _global_, 'wTools' ) || !_global_.wTools.maybe )
  {
    debugger;
    throw new Error( 'Failed to include module::wTools' );
  }

}

//

function _Setup9()
{

  _.assert( _global._WTOOLS_SETUP_EXPECTED_ !== false );

  if( _global._WTOOLS_SETUP_EXPECTED_ !== false )
  {
    _.setup._setupConfig();
    _.error._setupUncaughtErrorHandler9();
    _.setup._setupLoggerPlaceholder();
    _.setup._setupTesterPlaceholder();
    _.setup._setupProcedure();
    _.setup._setupTime();
    _.setup._validate();
  }

}

// --
// implementation
// --

let SetupExtension =
{

  _setupConfig,
  _setupLoggerPlaceholder,
  _setupTesterPlaceholder,
  _setupProcedure,
  _setupTime,
  _validate,

  _Setup9,

  //

  startTime : null,
  _entryProcedureStack : null,

}

Object.assign( _.setup, SetupExtension );
Self._Setup9();

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l8/Setup.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l0/l8' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Setup_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Setup_s */ })();

/* */  /* begin of file Include_s */ ( function Include_s() { function Include_s_naked() { //#! /usr/bin/env node
( function _l1_Include_s_()
{

'use strict';

if( typeof module !== 'undefined' )
{
  module[ 'exports' ] = require( '../l0/Include.s' );

  require( './l1/Collection.s' );
  require( './l1/ContainerAdapter.s' );
  require( './l1/ContainerAdapterArray.s' );
  require( './l1/ContainerAdapterSet.s' );
  require( './l1/NameTools.s' );
  require( './l1/StrBasic.s' );
  // require( './l1/TreeMap.s' );
  // require( './l1/Trie.s' );
}

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/Include.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Include_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Include_s */ })();

/* */  /* begin of file Collection_s */ ( function Collection_s() { function Collection_s_naked() { ( function _l1_Collection_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;
const Self = _.collection = _.collection || Object.create( null );

// --
// implementation
// --

function _commandPreform( command, commandRoutine, commandPhrase )
{
  let aggregator = this;

  if( commandRoutine === null )
  commandRoutine = command.routine || command.e;
  if( command === null )
  command = commandRoutine.command || Object.create( null );

  if( command.phrase )
  command.phrase = aggregator.vocabulary.phraseNormalize( command.phrase );
  if( commandPhrase )
  commandPhrase = aggregator.vocabulary.phraseNormalize( commandPhrase );
  commandPhrase = commandPhrase || command.phrase || ( commandRoutine.command ? commandRoutine.command.phrase : null ) || null;

  if( commandRoutine && commandRoutine.command )
  if( command !== commandRoutine.command )
  {
    _.assert( _.aux.is( commandRoutine.command ) );
    if( commandRoutine.command.phrase )
    commandRoutine.command.phrase = aggregator.vocabulary.phraseNormalize( commandRoutine.command.phrase );
    for( let k in commandRoutine.command )
    {
      _.assert
      (
        !_.props.has( command, k ) || command[ k ] === commandRoutine.command[ k ]
        , () => `Inconsistent field "${k}" of command "${commandPhrase}"`
      );
      command[ k ] = commandRoutine.command[ k ];
    }
    delete commandRoutine.command;
  }

  /* qqq : fill in asserts explanations */
  _.assert
  (
    !command.aggregator,
    () => `Command "${command.phrase}" already associated with a command aggregator.`
    + ` Each Command should be used only once.`
  );
  _.assert( _.routine.is( commandRoutine ), `Command "${commandPhrase}" does not have defined routine.` );
  _.assert( _.aux.is( command ) );
  _.assert( !_.props.has( command, 'ro' ) || commandRoutine === command.ro ); /* xxx : rename e to ro? */
  _.assert( !_.props.has( command, 'routine' ) || commandRoutine === command.routine );
  _.assert
  (
    !_.props.has( command, 'phrase' ) || commandPhrase === command.phrase,
    () => `Command ${commandPhrase} has phrases mismatch ${commandPhrase} <> ${command.phrase}`
  );
  _.assert( !_.props.own( commandRoutine, 'command' ) || commandRoutine.command === command );
  _.map.assertHasOnly( command, aggregator.CommandAllFields );

  if( commandPhrase )
  command.phrase = commandPhrase;
  command.routine = commandRoutine;
  commandRoutine.command = command;
  aggregator._CommandShortFiledsToLongFields( command, command );

  return command;

  /* - */

  function _CommandShortFiledsToLongFields( dst, fields )
  {
    _.assert( arguments.length === 2 );
    let filter = Self.CommandShortToLongFields;
    for( let k in fields )
    {
      if( _.props.has( filter, k ) )
      {
        _.assert
        (
          !_.props.has( dst, filter[ k ] ) || dst[ filter[ k ] ] === fields[ k ]
          , () => `Inconsistent field "${k}" of command "${commandPhraseGet()}"`
        );
        _.assert( !_.props.has( dst, filter[ k ] ) || dst[ filter[ k ] ] === fields[ k ] );
        dst[ filter[ k ] ] = fields[ k ];
        delete fields[ k ];
      }
    }

    function commandPhraseGet()
    {
      return dst.phrase || ( dst.command ? dst.command.phrase : null ) || null;
    }
  }

}

//

function toMapOfHandles( commandMap )
{
  let aggregator = this;
  let result = Object.create( null );
  let visited = new Set();

  if( _.aux.is( commandMap ) )
  {
    for( let k in commandMap )
    {
      let command = commandMap[ k ];
      let commandRoutine = command;

      if( _.routine.is( commandRoutine ) )
      command = null;
      else
      commandRoutine = command.ro || command.routine;

      let commandPhrase = aggregator.vocabulary.phraseNormalize( k );
      command = aggregator._commandPreform( command, commandRoutine, commandPhrase );
      command.aggregator = aggregator;
      aggregator.commandValidate( command );

      _.assert
      (
        !visited.has( command.routine ),
        `Duplication of command "${command.phrase}"`
      );
      visited.add( command.routine );

      result[ command.phrase ] = command;
    }
  }
  else if( _.longIs( commandMap ) )
  {
    for( let k = 0 ; k < commandMap.length ; k++ )
    {
      let command = commandMap[ k ];
      let commandRoutine = command;
      if( _.routine.is( commandRoutine ) )
      command = null;
      else
      commandRoutine = command.ro || command.routine;

      command = aggregator._commandPreform( command, commandRoutine );
      command.aggregator = aggregator;
      aggregator.commandValidate( command );

      _.assert
      (
        !visited.has( command.routine ),
        `Duplication of command "${command.phrase}"`
      );
      visited.add( command.routine );

      result[ command.phrase ] = command;
    }
  }
  else _.assert( 0 );

  _.assert( _.aux.is( result ) );

  return result;

  /* - */

  function commandIs( src )
  {
    if( !_.aux.is( src ) )
    return false;
    if( src.handle === undefined )
    return false;
    return true;
  }

  /* - */

  function commandValidate( command )
  {
    let aggregator = this;
    _.assert( aggregator.commandIs( command ), 'Not a command' );
    _.assert( _.routineIs( command.routine ) );
    _.assert( command.routine.command === command );
    _.assert( _.strDefined( command.phrase ) );
    _.assert( command.aggregator === undefined || command.aggregator === aggregator );
    if( _.routineIs( command.routine ) )
    _.map.assertHasOnly( command.routine, aggregator.CommandRoutineFields, 'Command routine should not have redundant fields' );
    _.map.assertHasOnly( command, aggregator.CommandNormalFields, 'Command should not have' );
    return true;
  }

  /* - */

  function _commandMapValidate( commandMap )
  {
    let aggregator = this;
    _.assert( _.mapIs( commandMap ) );
    for( let k in commandMap )
    {
      let command = commandMap[ k ]
      aggregator.commandValidate( command );
    }
    return commandMap;
  }

  /* - */

}

// --
// extension
// --

let ToolsExtension =
{

}

//

let ExtensionMap =
{

  toMapOfHandles,

}

Object.assign( _, ToolsExtension );
Object.assign( _.collection, ExtensionMap );
_.assert( _.aux.is( _.collection ) );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1/Collection.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Collection_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Collection_s */ })();

/* */  /* begin of file ContainerAdapter_s */ ( function ContainerAdapter_s() { function ContainerAdapter_s_naked() { ( function _ContainerAdapter_s_()
{

'use strict';

const _global = _realGlobal_;
const _ = _global_.wTools;

if( _global !== _realGlobal_ && _realGlobal_.wTools.containerAdapter )
return ExportTo( _global, _realGlobal_ );

_.assert( _.routine.is( _.longLeft ) );

// --
// type test
// --

function make( container )
{

  _.assert( arguments.length === 1 );

  if( _.set.is( container ) )
  {
    return new _.containerAdapter.Set( container );
  }
  else if( _.arrayIs( container ) )
  {
    return new _.containerAdapter.Array( container );
  }
  else if( this.is( container ) )
  {
    return container.make();
  }
  else _.assert( 0, 'Unknown type of container' );

}

//

function from( container )
{
  _.assert( arguments.length === 1 );
  if( container instanceof ContainerAdapterAbstract )
  {
    return container;
  }
  else if( _.set.is( container ) )
  {
    return new _.containerAdapter.Set( container );
  }
  else if( _.arrayIs( container ) )
  {
    return new _.containerAdapter.Array( container );
  }
  else _.assert( 0, 'Unknown type of container' );
}

//

function toOriginal( dst )
{
  if( !dst )
  return dst;
  if( dst instanceof ContainerAdapterAbstract )
  return dst.original;
  return dst;
}

//

function toOriginals( dsts, srcs )
{
  if( srcs === undefined )
  srcs = dsts;

  if( srcs === dsts )
  {
    if( _.longIs( dsts ) ) /* Dmytro : in this context needs to check instance of some long */
    // if( _.argumentsArray.like( dsts ) )
    {
      for( let s = 0 ; s < dsts.length ; s++ )
      dsts[ s ] = this.toOriginal( dsts[ s ] );
      return dsts;
    }
    return this.toOriginal( dsts );
  }
  else
  {
    if( dsts === null )
    dsts = [];

    if( _.arrayIs( dsts ) )
    {
      if( _.longIs( srcs ) ) /* Dmytro : in this context needs to check instance of some long */
      // if( _.argumentsArray.like( srcs ) )
      {
        for( let s = 0 ; s < srcs.length ; s++ )
        // for( let e of srcs ) /* Dmytro : not optimal for longs */
        dsts.push( this.toOriginal( srcs[ s ] ) );
        return dsts;
      }
      else
      dsts.push( this.toOriginal( srcs ) );
      return dsts;
    }
    else
    {
      if( _.longIs( srcs ) ) /* Dmytro : in this context needs to check instance of some long */
      // if( _.argumentsArray.like( srcs ) )
      {
        let result = [];
        result.push( this.toOriginal( dsts ) );
        for( let e of srcs )
        result.push( this.toOriginal( e ) );
        return result;
      }
      return this.toOriginals( [], arguments );
    }
  }
}

// --
//
// --

class ContainerAdapterAbstract
{
  constructor( container )
  {
    _.assert( arguments.length === 1 );
    this.original = container;
  }
  static ToOriginal( container )
  {
    if( container instanceof ContainerAdapterAbstract )
    return container.original;
    return container;
  }
  ToOriginal( container )
  {
    return this.constructor.ToOriginal( container );
  }
  static Is( src )
  {
    return _.containerAdapter.is( src );
  }
  Is( src )
  {
    return this.constructor.Is( src );
  }
  static IsContainer( src )
  {
    return _.containerAdapter.isContainer( src );
  }
  IsContainer( src )
  {
    return this.constructor.IsContainer( src );
  }
  static Make( src )
  {
    return _.containerAdapter.make( ... arguments );
  }
  Make( src )
  {
    return this.constructor.Make( ... arguments );
  }
  static From( src )
  {
    return _.containerAdapter.from( src );
  }
  From( src )
  {
    return this.constructor.From( src );
  }
  _filterArguments( dst, onEach )
  {
    if( _.routine.is( arguments[ 0 ] ) )
    {
      _.assert( onEach === undefined );
      onEach = dst;
      dst = null;
    }
    if( dst === null || ( !dst && !onEach ) )
    dst = this.MakeEmpty();
    else if( dst === _.self )
    dst = this;
    else
    dst = this.From( dst );
    return [ dst, onEach ];
  }
  _onlyArguments( /* dst, src2, onEvaluate1, onEvaluate2 */ )
  {
    let dst = arguments[ 0 ];
    let src2 = arguments[ 1 ];
    let onEvaluate1 = arguments[ 2 ];
    let onEvaluate2 = arguments[ 3 ];

    if( _.routine.is( src2 ) || src2 === undefined )
    {
      if( dst === undefined )
      dst = null;

      onEvaluate2 = onEvaluate1;
      onEvaluate1 = src2;
      src2 = dst;
      dst = null;
    }

    if( dst === _.self )
    dst = this;
    else if( dst )
    dst = this.From( dst );
    else
    dst = this.MakeEmpty();

    if( src2 === _.self )
    src2 = this;
    else if( src2 )
    src2 = this.From( src2 );
    else
    src2 = this.MakeEmpty();

    return [ dst, src2, onEvaluate1, onEvaluate2 ];
  }
  _same( src )
  {
    return src.original === this.original;
  }
  same( src )
  {
    if( !src )
    return false;
    if( src instanceof ContainerAdapterAbstract )
    return this._same( src );
    return this.original === src;
  }
  removedContainer( src )
  {
    let result = 0;
    let self = this;

    if( self._same( src ) )
    src = self.From( [ ... src.original ] );
    else
    src = self.From( src );

    src.each( ( e ) => result += self.removed( e ) );
    return result;
  }
  removedContainerOnce( src, onEvaluate1, onEvaluate2 )
  {
    let result = 0;
    let self = this;

    if( self._same( src ) )
    src = self.From( [ ... src.original ] );
    else
    src = self.From( src );

    src.each( ( e ) =>
    {
      let r = self.removedOnce( e, onEvaluate1, onEvaluate2 );
      if( r !== -1 )
      result++;
    });
    return result;
  }
  removedContainerOnceStrictly( src, onEvaluate1, onEvaluate2 )
  {
    let self = this;

    if( self._same( src ) )
    src = self.From( [ ... src.original ] );
    else
    src = self.From( src );

    let result = src.length;
    src.each( ( e ) => self.removeOnceStrictly( e, onEvaluate1, onEvaluate2 ) );

    return result;
  }
  removeContainer( src )
  {
    let self = this;
    self.removedContainer.apply( self, arguments );
    return self;
  }
  removeContainerOnce( src, onEvaluate1, onEvaluate2 )
  {
    let self = this;
    self.removedContainerOnce.apply( self, arguments );
    return self;
  }
  removeContainerOnceStrictly( src, onEvaluate1, onEvaluate2 )
  {
    let self = this;
    self.removedContainerOnceStrictly.apply( self, arguments );
    return self;
  }
  min( onEach )
  {
    let self = this;
    if( onEach )
    return self.reduce( +Infinity, ( a, e ) => Math.min( a, onEach( e ) ) );
    else
    return self.reduce( +Infinity, ( a, e ) => Math.min( a, e ) );
  }
  max( onEach )
  {
    let self = this;
    if( onEach )
    return self.reduce( -Infinity, ( a, e ) => Math.max( a, onEach( e ) ) );
    else
    return self.reduce( -Infinity, ( a, e ) => Math.max( a, e ) );
  }
  least( dst, onEach )
  {
    let self = this;
    [ dst, onEach ] = this._filterArguments( ... arguments );
    let min = self.min( onEach );
    if( onEach )
    return self.filter( dst, ( e ) => onEach( e ) === min ? e : undefined );
    else
    return self.filter( dst, ( e ) => e === min ? e : undefined );
  }
  most( dst, onEach )
  {
    let self = this;
    [ dst, onEach ] = this._filterArguments( ... arguments );
    let max = self.max( onEach );
    if( onEach )
    return self.filter( dst, ( e ) => onEach( e ) === max ? e : undefined );
    else
    return self.filter( dst, ( e ) => e === max ? e : undefined );
  }
  only( /* dst, src2, onEvaluate1, onEvaluate2 */ )
  {
    let dst = arguments[ 0 ];
    let src2 = arguments[ 1 ];
    let onEvaluate1 = arguments[ 2 ];
    let onEvaluate2 = arguments[ 3 ];

    _.assert( 1 <= arguments.length && arguments.length <= 4 );

    let self = this;
    let container = self.original;

    [ dst, src2, onEvaluate1, onEvaluate2 ] = self._onlyArguments( ... arguments );

    if( self._same( src2 ) )
    {
      return self;
    }

    if( self._same( dst ) )
    {
      let temp = [ ... container ];

      for( let i = 0; i < temp.length; i++ )
      {
        if( !src2.has( temp[ i ], onEvaluate1, onEvaluate2 ) )
        dst.removeOnce( temp[ i ] );
      }
    }
    else
    {
      src2.each( ( e ) =>
      {
        if( self.has( e, onEvaluate1, onEvaluate2 ) )
        dst.appendOnce( e );
      });
    }

    return dst;
  }
  but( /* dst, src2, onEvaluate1, onEvaluate2 */ )
  {
    let dst = arguments[ 0 ];
    let src2 = arguments[ 1 ];
    let onEvaluate1 = arguments[ 2 ];
    let onEvaluate2 = arguments[ 3 ];

    _.assert( 1 <= arguments.length && arguments.length <= 4 );

    let self = this;
    let container = self.original;

    [ dst, src2, onEvaluate1, onEvaluate2 ] = self._onlyArguments( ... arguments );

    if( self._same( src2 ) )
    {
      self.empty();
      return self;
    }

    if( self._same( dst ) )
    {
      let temp = [ ... container ];

      for( let i = 0; i < temp.length; i++ )
      {
        if( src2.has( temp[ i ], onEvaluate1, onEvaluate2 ) )
        dst.removeOnce( temp[ i ] );
      }
    }
    else
    {
      self.each( ( e ) =>
      {
        if( !src2.has( e, onEvaluate1, onEvaluate2 ) )
        dst.appendOnce( e );
      });
    }

    return dst;
  }
  select( selector )
  {
    let self = this;
    let container = self.original;

    let result = [];
    for( let e of container )
    {
      if( _.select( e, selector ) )
      result.push( e )
    }

    return result;
  }
}

// --
// meta
// --

function ExportTo( dstGlobal, srcGlobal )
{
  let _ = dstGlobal.wTools;
  _.assert( _.containerAdapter === undefined );
  _.assert( _.mapIs( srcGlobal.wTools.containerAdapter ) );
  _.containerAdapter = srcGlobal.wTools.containerAdapter;
  if( typeof module !== 'undefined' )
  module[ 'exports' ] = _.containerAdapter;
}

// --
// declare
// --

var Extension =
{

  make,
  from,

  toOriginal,
  toOriginals,

  Abstract : ContainerAdapterAbstract,

}

//

Object.assign( _.containerAdapter, Extension );

// --
// export
// --

if( typeof module !== 'undefined' )
module[ 'exports' ] = _;

if( _global !== _realGlobal_ )
return ExportTo( _realGlobal_, _global );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1/ContainerAdapter.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ContainerAdapter_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ContainerAdapter_s */ })();

/* */  /* begin of file ContainerAdapterArray_s */ ( function ContainerAdapterArray_s() { function ContainerAdapterArray_s_naked() { ( function _ContainerAdapterArray_s_()
{

'use strict';

const _global = _realGlobal_;
const _ = _global_.wTools;

if( _global !== _realGlobal_ && _realGlobal_.wTools.containerAdapter )
return ExportTo( _global, _realGlobal_ );

_.assert( _.routine.is( _.containerAdapter.Abstract ) );
_.assert( _.routine.is( _.longLeft ) );

// --
// implementation
// --

function make()
{
  _.assert( arguments.length === 0, 'Expects no arguments' );
  return new ContainerAdapterArray( this.original.slice() );
}

//

function MakeEmpty()
{
  _.assert( arguments.length === 0, 'Expects no arguments' );
  return new ContainerAdapterArray( new Array );
}

//

function makeEmpty()
{
  return this.constructor.MakeEmpty();
}

//

function Make( src )
{
  if( src === undefined || src === null )
  return this.MakeEmpty();
  else if( _.number.is( src ) )
  return new ContainerAdapterArray( new Array( src ) );
  else if( this.IsContainer( src ) )
  return new ContainerAdapterArray( [ ... src ] );
  else if( this.Is( src ) )
  return new ContainerAdapterArray( [ ... src.original ] );
}

//

class ContainerAdapterArray extends _.containerAdapter.Abstract
{
  constructor( container )
  {
    if( container === undefined )
    container = new Array;
    super( container );
    _.assert( arguments.length === 0 || arguments.length === 1 );
    _.assert( _.longLike( container ) );
  }
  // make = make; // Dmytro : simple assigning methods as a property is able in NodeJs v12 and later. So, I assign this properties after class declaration.
  // static MakeEmpty = MakeEmpty;
  // MakeEmpty = makeEmpty;
  // static Make = Make;
  has( e, onEvaluate1, onEvaluate2 )
  {
    if( _.routine.is( onEvaluate1 ) || _.routine.is( onEvaluate2 ) )
    {
      if( _.longLeftIndex( this.original, e, onEvaluate1, onEvaluate2 ) !== -1 )
      return true;
      return false;
    }
    return this.original.includes( e );
  }
  count( e, onEvaluate1, onEvaluate2 )
  {
    return _.longCountElement( this.original, e, onEvaluate1, onEvaluate2 );
  }
  copyFrom( src )
  {
    let self = this;
    let container = self.original;

    if( self.same( src ) )
    return self;

    if( !self.IsContainer( src ) && !self.Is( src ) )
    _.assert( 0, '{-src-} should be container' );

    let i = 0;
    for( let e of src )
    {
      container[ i ] = e;
      i++;
    }

    return self;
  }
  append( e )
  {
    this.original.push( e );
    return this;
  }
  appendOnce( e, onEvaluate1, onEvaluate2 )
  {
    _.arrayAppendOnce( this.original, e, onEvaluate1, onEvaluate2 );
    return this;
  }
  appendOnceStrictly( e, onEvaluate1, onEvaluate2 )
  {
    _.arrayAppendOnceStrictly( this.original, e, onEvaluate1, onEvaluate2 )
    return this;
  }
  push( e )
  {
    return this.original.push( e );
  }
  appendContainer( container )
  {
    container = this.ToOriginal( container );
    if( _.longIs( container ) )
    {
      _.arrayAppendArray( this.original, container );
    }
    else if( _.set.is( container ) )
    {
      for( let e of container )
      {
        this.original.push( e );
      }
    }
    else
    {
      _.assert( 0, 'Unexpected data type' );
    }
    return this;
  }
  appendContainerOnce( container, onEvaluate1, onEvaluate2 )
  {
    container = this.ToOriginal( container );
    if( _.longIs( container ) )
    _.arrayAppendArrayOnce( this.original, container, onEvaluate1, onEvaluate2 );
    else if( _.set.is( container ) )
    _.arrayAppendArrayOnce( this.original, [ ... container ], onEvaluate1, onEvaluate2 );
    else _.assert( 0, 'Unexpected data type' );
    return this;
  }
  appendContainerOnceStrictly( container, onEvaluate1, onEvaluate2 )
  {
    container = this.ToOriginal( container );
    if( _.longIs( container ) )
    _.arrayAppendArrayOnceStrictly( this.original, container, onEvaluate1, onEvaluate2 );
    else if( _.set.is( container ) )
    _.arrayAppendArrayOnceStrictly( this.original, [ ... container ], onEvaluate1, onEvaluate2 );
    else _.assert( 0, 'Unexpected data type' );
    return this;
  }
  pop( e, onEvaluate1, onEvaluate2 )
  {
    var poped = this.original.pop();
    _.assert( e === undefined || _.entity.equal( poped, e, onEvaluate1, onEvaluate2 ) );
    return poped;
  }
  popStrictly( e, onEvaluate1, onEvaluate2 )
  {
    _.assert( 1 <= arguments.length && arguments.length <= 3 );
    _.assert( _.entity.equal( this.last(), e, onEvaluate1, onEvaluate2 ), 'Container does not have such element' );

    var poped = this.original.pop();
    return poped;
  }
  removed( e, onEvaluate1, onEvaluate2 )
  {
    return _.arrayRemoved( this.original, e, onEvaluate1, onEvaluate2 );
  }
  removedOnce( e, onEvaluate1, onEvaluate2 )
  {
    return _.arrayRemovedOnce( this.original, e, onEvaluate1, onEvaluate2 );
  }
  removedOnceLeft( e, onEvaluate1, onEvaluate2 )
  {
    return _.arrayRemovedOnce( this.original, e, onEvaluate1, onEvaluate2 );
  }
  removedOnceRight( e, onEvaluate1, onEvaluate2 )
  {
    let index = _.longRightIndex( this.original, e, onEvaluate1, onEvaluate2 );
    if( index !== -1 )
    this.original.splice( index, 1 );
    return index;
  }
  removedOnceStrictly( e, onEvaluate1, onEvaluate2 )
  {
    return _.arrayRemovedOnceStrictly( this.original, e, onEvaluate1, onEvaluate2 );
  }
  removedOnceStrictlyLeft( e, onEvaluate1, onEvaluate2 )
  {
    return _.arrayRemovedOnceStrictly( this.original, e, onEvaluate1, onEvaluate2 );
  }
  removedOnceStrictlyRight( e, onEvaluate1, onEvaluate2 )
  {
    let container = this.original;
    let index = _.longRightIndex( container, e, onEvaluate1, onEvaluate2 );
    _.assert( index !== -1, () => 'Container has not element ' + _.entity.exportStringDiagnosticShallow( e ) );
    container.splice( index, 1 );
    if( _.number.is( onEvaluate1 ) )
    onEvaluate1--;
    _.assert( _.longRightIndex( container, e, onEvaluate1, onEvaluate2 ) === -1, () => 'The element ' + _.entity.exportStringDiagnosticShallow( e ) + ' is several times in dstArray' );
    return index;
  }
  remove( e, onEvaluate1, onEvaluate2 )
  {
    _.arrayRemove( this.original, e, onEvaluate1, onEvaluate2 );
    return this;
  }
  removeOnce( e, onEvaluate1, onEvaluate2 )
  {
    _.arrayRemoveOnce( this.original, e, onEvaluate1, onEvaluate2 );
    return this;
  }
  removeOnceLeft( e, onEvaluate1, onEvaluate2 )
  {
    _.arrayRemoveOnce( this.original, e, onEvaluate1, onEvaluate2 );
    return this;
  }
  removeOnceRight( e, onEvaluate1, onEvaluate2 )
  {
    this.removedOnceRight( e, onEvaluate1, onEvaluate2 );
    return this;
  }
  removeOnceStrictly( e, onEvaluate1, onEvaluate2 )
  {
    _.arrayRemovedOnceStrictly( this.original, e, onEvaluate1, onEvaluate2 );
    return this;
  }
  removeOnceStrictlyLeft( e, onEvaluate1, onEvaluate2 )
  {
    _.arrayRemovedOnceStrictly( this.original, e, onEvaluate1, onEvaluate2 );
    return this;
  }
  removeOnceStrictlyRight( e, onEvaluate1, onEvaluate2 )
  {
    this.removedOnceStrictlyRight( e, onEvaluate1, onEvaluate2 );
    return this;
  }
  empty()
  {
    this.original.splice( 0, this.original.length );
  }
  map( dst, onEach )
  {
    let self = this;
    let container = this.original;
    [ dst, onEach ] = this._filterArguments( ... arguments );
    if( this._same( dst ) )
    {
      for( let k = 0 ; k < container.length ; k++ )
      {
        let e = container[ k ];
        let e2 = onEach( e, k, self );
        if( e2 !== undefined )
        {
          container[ k ] = e2;
        }
      }
    }
    else
    {
      for( let k = 0 ; k < container.length ; k++ )
      {
        let e = container[ k ];
        let e2 = onEach( e, k, self );
        if( e2 !== undefined )
        dst.append( e2 );
        else
        dst.append( e );
      }
    }
    return dst;
  }
  mapLeft( dst, onEach )
  {
    return this.map.apply( this, arguments );
  }
  mapRight( dst, onEach )
  {
    let container = this.original;
    [ dst, onEach ] = this._filterArguments( ... arguments );
    if( this._same( dst ) )
    {
      for( let k = container.length - 1; k >= 0; k-- )
      {
        let e2 = onEach( container[ k ], k, this );
        if( e2 !== undefined )
        container[ k ] = e2;
      }
    }
    else
    {
      for( let k = container.length - 1; k >= 0; k-- )
      {
        let e2 = onEach( container[ k ], k, this );
        if( e2 !== undefined )
        dst.append( e2 );
        else
        dst.append( container[ k ] );
      }
    }
    return dst;
  }
  filter( dst, onEach )
  {
    let self = this;
    let container = this.original;
    [ dst, onEach ] = this._filterArguments( ... arguments );

    if( this._same( dst ) )
    {
      for( let k = 0; k < container.length; k++ )
      {
        let e = container[ k ];
        let e2 = onEach( e, k, container );
        if( e2 === undefined )
        {
          container.splice( k, 1 );
          k--;
        }
        else if( e2 !== e )
        {
          container[ k ] = e2;
        }
      }
    }
    else
    {
      for( let k = 0; k < container.length; k++ )
      {
        let e = container[ k ];
        let e2 = onEach( e, k, container );
        if( e2 !== undefined )
        dst.append( e2 );
      }
    }

    return dst;
  }
  filterLeft( dst, onEach )
  {
    return this.filter.apply( this, arguments );
  }
  filterRight( dst, onEach )
  {
    let self = this;
    let container = this.original;
    [ dst, onEach ] = this._filterArguments( ... arguments );

    if( this._same( dst ) )
    {
      for( let k = container.length - 1; k >= 0; k-- )
      {
        let e2 = onEach( container[ k ], k, container );
        if( e2 === undefined )
        container.splice( k, 1 );
        else if( container[ k ] !== e2 )
        container[ k ] = e2;
      }
    }
    else
    {
      for( let k = container.length - 1; k >= 0; k-- )
      {
        let e2 = onEach( container[ k ], k, container );
        if( e2 !== undefined )
        dst.append( e2 );
      }
    }

    return dst;
  }
  flatFilter( dst, onEach )
  {
    let self = this;
    let container = self.original;
    [ dst, onEach ] = self._filterArguments( ... arguments );

    if( self._same( dst ) )
    {
      for( let k = 0; k < container.length; k++ )
      {
        let e = container[ k ];
        let e2 = onEach( e, k, self );
        if( e2 === undefined )
        {
          container.splice( k, 1 )
          k--;
        }
        else if( self.IsContainer( e2 ) || self.Is( e2 ) )
        {
          k += e2.length - 1;
          container.splice( k, 1, ... e2 );
        }
        else if( e2 !== e )
        {
          container[ k ] = e2;
        }
      }
    }
    else
    {
      for( let k = 0; k < container.length; k++ )
      {
        let e = container[ k ];
        let e2 = onEach( e, k, container );
        if( self.IsContainer( e2 ) || self.Is( e2 ) )
        dst.appendContainer( e2 )
        else if( e2 !== undefined )
        dst.append( e2 );
      }
    }

    return dst;
  }
  flatFilterLeft( dst, onEach )
  {
    return this.flatFilter.apply( this, arguments );
  }
  flatFilterRight( dst, onEach )
  {
    let self = this;
    let container = self.original;
    [ dst, onEach ] = self._filterArguments( ... arguments );

    if( self._same( dst ) )
    {
      for( let k = container.length - 1; k >= 0; k-- )
      {
        let e = container[ k ];
        let e2 = onEach( e, k, self );

        if( e2 === undefined )
        container.splice( k, 1 );
        else if( self.IsContainer( e2 ) || self.Is( e2 ) )
        container.splice( k, 1, ... e2 );
        else if( e2 !== e )
        container[ k ] = e2;
      }
    }
    else
    {
      for( let k = container.length - 1; k >= 0; k-- )
      {
        let e = container[ k ];
        let e2 = onEach( e, k, container );

        if( self.IsContainer( e2 ) || self.Is( e2 ) )
        dst.appendContainer( e2 )
        else if( e2 !== undefined )
        dst.append( e2 );
      }
    }

    return dst;
  }
  once( dst, onEvaluate1, onEvaluate2 )
  {
    let container = this.original;
    [ dst, dst, onEvaluate1, onEvaluate2 ] = this._onlyArguments( null, dst, onEvaluate1, onEvaluate2 );

    if( this._same( dst ) )
    _.longOnce( container, onEvaluate1, onEvaluate2 );
    else
    dst.appendContainerOnce( container, onEvaluate1, onEvaluate2 );

    return dst;
  }
  onceLeft( dst, onEvaluate1, onEvaluate2 )
  {
    return this.once.apply( this, arguments );
  }
  onceRight( dst, onEvaluate1, onEvaluate2 )
  {
    let container = this.original;
    [ dst, dst, onEvaluate1, onEvaluate2 ] = this._onlyArguments( null, dst, onEvaluate1, onEvaluate2 );

    if( this._same( dst ) )
    {
      _.longOnce( container, onEvaluate1, onEvaluate2 );
    }
    else
    {
      for( let i = container.length - 1; i >= 0; i-- )
      dst.appendOnce( container[ i ], onEvaluate1, onEvaluate2 );
    }

    return dst;
  }
  withIndex( index )
  {
    let self = this;
    return self.original[ index ];
  }
  first( onEach )
  {
    let self = this;
    let container = this.original;
    if( onEach )
    {
      if( !container.length )
      return undefined;
      return onEach( container[ 0 ], 0, self );
    }
    else
    {
      return container[ 0 ];
    }
  }
  last( onEach )
  {
    let self = this;
    let container = this.original;
    let l = container.length-1;
    if( onEach )
    {
      if( !container.length )
      return undefined;
      return onEach( container[ l ], l, self );
    }
    else
    {
      return container[ l ];
    }
  }
  each( onEach )
  {
    return this.eachLeft( onEach );
  }
  eachLeft( onEach )
  {
    let container = this.original;
    for( let i = 0; i < container.length; i++ )
    onEach( container[ i ], i, this );
    return this;
  }
  eachRight( onEach )
  {
    let self = this;
    let container = this.original;
    for( let k = container.length - 1 ; k >= 0 ; k-- )
    onEach( container[ k ], k, container );
    return this;
  }
  reduce( accumulator, onEach )
  {
    let self = this;
    let container = this.original;
    if( arguments[ 1 ] === undefined )
    {
      onEach = arguments[ 0 ];
      accumulator = undefined;
    }
    for( let k = 0, l = container.length ; k < l ; k++ )
    {
      let e = container[ k ];
      accumulator = onEach( accumulator, e, k, self );
    }
    return accumulator;
  }
  reduceLeft( accumulator, onEach )
  {
    return this.reduce.apply( this, arguments );
  }
  reduceRight( accumulator, onEach )
  {
    let self = this;
    let container = this.original;
    if( arguments[ 1 ] === undefined )
    {
      onEach = arguments[ 0 ];
      accumulator = undefined;
    }
    for( let k = container.length - 1; k >= 0; k-- )
    {
      let e = container[ k ];
      accumulator = onEach( accumulator, e, k, self );
    }
    return accumulator;
  }
  all( onEach )
  {
    return this.allLeft( onEach );
  }
  allLeft( onEach )
  {
    let container = this.original;
    for( let i = 0; i < container.length; i++ )
    {
      let r = onEach( container[ i ], i, container );
      if( !r )
      return false;
    }
    return true;
  }
  allRight( onEach )
  {
    let container = this.original;
    for( let i = container.length - 1; i >= 0; i-- )
    {
      let r = onEach( container[ i ], i, container );
      if( !r )
      return false;
    }
    return true;
  }
  any( onEach )
  {
    return this.anyLeft( onEach );
  }
  anyLeft( onEach )
  {
    let container = this.original;
    for( let i = 0; i < container.length; i++ )
    {
      let r = onEach( container[ i ], i, container );
      if( r )
      return true;
    }
    return false;
  }
  anyRight( onEach )
  {
    let container = this.original;
    for( let i = container.length-1; i >= 0; i-- )
    {
      let r = onEach( container[ i ], i, container );
      if( r )
      return true;
    }
    return false;
  }
  none( onEach )
  {
    return this.noneLeft( onEach );
  }
  noneLeft( onEach )
  {
    let container = this.original;
    for( let i = 0; i < container.length; i++ )
    {
      let r = onEach( container[ i ], i, container );
      if( r )
      return false;
    }
    return true;
  }
  noneRight( onEach )
  {
    let container = this.original;
    for( let i = container.length - 1; i >= 0; i-- )
    {
      let r = onEach( container[ i ], i, container );
      if( r )
      return false;
    }
    return true;
  }
  left( /* element, fromIndex, onEvaluate1, onEvaluate2 */ )
  {
    let element = arguments[ 0 ];
    let fromIndex = arguments[ 1 ];
    let onEvaluate1 = arguments[ 2 ];
    let onEvaluate2 = arguments[ 3 ];

    _.assert( 1 <= arguments.length && arguments.length <= 4 );
    return _.longLeft( this.original, element, fromIndex, onEvaluate1, onEvaluate2 );
  }
  right( /* element, fromIndex, onEvaluate1, onEvaluate2 */ )
  {
    let element = arguments[ 0 ];
    let fromIndex = arguments[ 1 ];
    let onEvaluate1 = arguments[ 2 ];
    let onEvaluate2 = arguments[ 3 ];

    _.assert( 1 <= arguments.length && arguments.length <= 4 );
    return _.longRight( this.original, element, fromIndex, onEvaluate1, onEvaluate2 );
  }
  reverse( dst )
  {
    let srcContainer = this.original;

    if( !dst )
    {
      dst = this.Make( this.length );
      let dstContainer = dst.original;
      for( let i1 = srcContainer.length - 1, i2 = 0; i1 >= 0; i1--, i2++ )
      {
        dstContainer[ i1 ] = srcContainer[ i2 ];
      }
    }
    else
    {
      dst = this.From( dst );
      let dstContainer = dst.original;
      if( srcContainer === dstContainer )
      {
        let last2 = ( srcContainer.length - srcContainer.length % 2 ) / 2;
        let last1 = ( srcContainer.length % 2 ? last2 : last2-1 );
        for( let i1 = last1, i2 = last2; i1 >= 0; i1--, i2++ )
        {
          let e = srcContainer[ i1 ];
          srcContainer[ i1 ] = srcContainer[ i2 ];
          srcContainer[ i2 ] = e;
        }
      }
      else
      {
        for( let i = srcContainer.length - 1; i >= 0; i-- )
        {
          dst.append( srcContainer[ i ] );
        }
      }
    }
    return dst;
  }
  join( delimeter )
  {
    return this.original.join( delimeter );
  }
  toArray()
  {
    return this;
  }
  toSet()
  {
    return new _.containerAdapter.Set( new Set([ ... this.original ]) );
  }
  [ Symbol.iterator ]()
  {
    return this.original[ Symbol.iterator ]();
  }
  get length()
  {
    return this.original.length;
  }
}
ContainerAdapterArray.Make = Make;
ContainerAdapterArray.MakeEmpty = MakeEmpty;
ContainerAdapterArray.prototype.make = make;
ContainerAdapterArray.prototype.MakeEmpty = makeEmpty;

// --
// meta
// --

function ExportTo( dstGlobal, srcGlobal )
{
  debugger;
  let _ = dstGlobal.wTools;
  _.assert( _.containerAdapter === srcGlobal.wTools.containerAdapter );
  _.assert( _.mapIs( srcGlobal.wTools.containerAdapter ) );
  if( typeof module !== 'undefined' )
  module[ 'exports' ] = _.containerAdapter;
}

// --
// declare
// --

const Self = _.containerAdapter;

//

var Extension =
{

  Array : ContainerAdapterArray,

}

//

Object.assign( _.containerAdapter, Extension );
_.assert( _.containerAdapter === Self );

// --
// export
// --

if( typeof module !== 'undefined' )
module[ 'exports' ] = _;

if( _global !== _realGlobal_ )
return ExportTo( _realGlobal_, _global );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1/ContainerAdapterArray.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ContainerAdapterArray_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ContainerAdapterArray_s */ })();

/* */  /* begin of file ContainerAdapterSet_s */ ( function ContainerAdapterSet_s() { function ContainerAdapterSet_s_naked() { ( function _ContainerAdapterSet_s_()
{

'use strict';

const _global = _realGlobal_;
const _ = _global_.wTools;

if( _global !== _realGlobal_ && _realGlobal_.wTools.containerAdapter )
return ExportTo( _global, _realGlobal_ );

_.assert( _.routine.is( _.containerAdapter.Abstract ) );
_.assert( _.routine.is( _.longLeft ) );

// --
// implementation
// --

function make()
{
  _.assert( arguments.length === 0, 'Expects no arguments' );
  return new ContainerAdapterSet( new Set( this.original ) );
}

//

function MakeEmpty()
{
  _.assert( arguments.length === 0, 'Expects no arguments' );
  return new ContainerAdapterSet( new Set );
}

//

function Make( src )
{
  if( src === undefined || src === null )
  return this.MakeEmpty();
  else if( _.number.is( src ) )
  return new ContainerAdapterSet( new Set );
  else if( this.IsContainer( src ) )
  return new ContainerAdapterSet( new Set( src ) );
  else if( this.Is( src ) )
  return new ContainerAdapterSet( new Set( src.original ) );
}

//

function makeEmpty()
{
  return this.constructor.MakeEmpty();
}

//

class ContainerAdapterSet extends _.containerAdapter.Abstract
{
  // Dmytro : using constructor and super() method is old syntax, it can be deleted
  // aaa : cover constructors /* Dmytro : covered */
  constructor( container )
  {
    if( container === undefined )
    container = new Set;
    super( container );
    _.assert( arguments.length === 0 || arguments.length === 1 );
    _.assert( _.set.like( container ) );
  }
  // make = make; // Dmytro : simple assigning methods as a property is able in NodeJs v12 and later. So, I assign this properties after class declaration.
  // static MakeEmpty = MakeEmpty;
  // MakeEmpty = makeEmpty;
  // static Make = Make;
  has( e, onEvaluate1, onEvaluate2 )
  {
    _.assert( onEvaluate2 === undefined || _.routine.is( onEvaluate2 ) );

    let fromIndex = 0;
    if( _.number.is( onEvaluate1 ) )
    {
      fromIndex = onEvaluate1;
      onEvaluate1 = onEvaluate2;
      onEvaluate2 = undefined;
    }

    if( _.routine.is( onEvaluate1 ) )
    {
      if( onEvaluate1.length === 2 )
      {
        _.assert( !onEvaluate2 );

        for( let el of this.original )
        {
          if( fromIndex === 0 )
          {
            if( onEvaluate1( el, e ) )
            return true;
          }
          else
          {
            fromIndex -= 1;
          }
        }

        return false;
      }
      else if( onEvaluate1.length === 1 )
      {
        _.assert( !onEvaluate2 || onEvaluate2.length === 1 );

        if( onEvaluate2 )
        e = onEvaluate2( e );
        else
        e = onEvaluate1( e );

        for( let el of this.original )
        {
          if( fromIndex === 0 )
          {
            if( onEvaluate1( el ) === e )
            return true;
          }
          else
          {
            fromIndex -= 1;
          }
        }

        return false;
      }
      else _.assert( 0 );
    }
    else if( onEvaluate1 === undefined || onEvaluate1 === null )
    {
      return this.original.has( e );
    }
    else _.assert( 0 );
  }
  count( e, onEvaluate1, onEvaluate2 )
  {
    let container = this.original;

    if( _.routine.is( onEvaluate1 ) || _.routine.is( onEvaluate2 ) )
    {
      let from = 0;
      let result = 0;
      if( _.number.is( onEvaluate1 ) )
      {
        from = onEvaluate1;
        onEvaluate1 = onEvaluate2;
        onEvaluate2 = undefined;
      }

      for( let v of this.original )
      {
        if( from === 0 )
        {
          if( _.entity.equal( v, e, onEvaluate1, onEvaluate2 ) )
          result++;
        }
        else
        {
          from--;
        }
      }
      return result;
    }
    else
    {
      return container.has( e ) ? 1 : 0;
    }
  }
  copyFrom( src )
  {
    let self = this;
    let container = self.original;

    if( self.same( src ) )
    return self;

    if( !self.IsContainer( src ) && !self.Is( src ) )
    _.assert( 0, '{-src-} should be container' );

    if( self.length <= ( src.length || src.size ) )
    {
      self.empty();
      for( let e of src )
      {
        self.append( e );
      }
    }
    else
    {
      // let temp = [ ... container ];
      //
      // self.empty();
      // for( let e of src )
      // self.append( e );
      // for( let i = self.length; i < temp.length; i++ )
      // self.append( temp[ i ] );

      let length = this.length;
      let srcLength = src.length !== undefined ? src.length : src.size;
      let lengthDiff = length - srcLength;
      for( let e of src )
      {
        for( let v of container )
        {
          self.remove( v );
          break;
        }
        self.append( e );
      }
      for( let e of container )
      {
        if( lengthDiff !== 0 )
        {
          self.remove( e );
          self.append( e );
          lengthDiff--;
        }
        else
        {
          break;
        }
      }
    }

    return self;
  }
  append( e )
  {
    this.original.add( e );
    return this;
  }
  appendOnce( e, onEvaluate1, onEvaluate2 )
  {
    let container = this.original;

    if( onEvaluate1 || _.routine.is( onEvaluate2 ) )
    {
      if( !this.has( e, onEvaluate1, onEvaluate2 ) )
      container.add( e );
    }
    else
    {
      container.add( e );
    }

    return this;
  }
  appendOnceStrictly( e, onEvaluate1, onEvaluate2 )
  {
    let container = this.original;

    if( onEvaluate1 || _.routine.is( onEvaluate2 ) )
    {
      if( !this.has( e, onEvaluate1, onEvaluate2 ) )
      container.add( e );
      else
      _.assert( 0, 'Set already has such element' );
    }
    else
    {
      _.assert( !this.original.has( e ), 'Set already has such element' );
      container.add( e );
    }
    return this;
  }
  appendContainer( container )
  {
    container = this.ToOriginal( container );
    if( _.longIs( container ) )
    {
      for( let k = 0, l = container.length ; k < l ; k++ )
      this.original.add( container[ k ] );
    }
    else if( _.set.is( container ) )
    {
      for( let e of container )
      this.original.add( e );
    }
    else
    {
      _.assert( 0, 'Unexpected data type' );
    }
    return this;
  }
  appendContainerOnce( container, onEvaluate1, onEvaluate2 )
  {
    if( onEvaluate1 || _.routine.is( onEvaluate2 ) )
    {
      container = this.ToOriginal( container );

      if( _.longIs( container ) )
      {
        for( let i = 0; i < container.length; i++ )
        if( !this.has( container[ i ], onEvaluate1, onEvaluate2 ) )
        this.append( container[ i ] );
      }
      else if( _.set.is( container ) )
      {
        for( let e of container )
        if( !this.has( e, onEvaluate1, onEvaluate2 ) )
        this.append( e );
      }

      return this;
    }
    else
    {
      return this.appendContainer( container );
    }
  }
  appendContainerOnceStrictly( container, onEvaluate1, onEvaluate2 )
  {
    container = this.ToOriginal( container );

    if( _.longIs( container ) )
    {
      for( let i = 0; i < container.length; i++ )
      {
        _.assert( !this.has( container[ i ], onEvaluate1, onEvaluate2 ) );
        this.append( container[ i ] );
      }
    }
    else if( _.set.is( container ) )
    {
      for( let e of container )
      {
        _.assert( !this.has( e, onEvaluate1, onEvaluate2 ) );
        this.append( e );
      }
    }
    else _.assert( 0, 'Unexpected data type' );

    return this;
  }
  push( e )
  {
    this.original.add( e );
    return this.original.size;
  }
  pop( e, onEvaluate1, onEvaluate2 )
  {
    let self = this;
    let container = self.original;

    if( !onEvaluate1 || e === undefined )
    {
      if( e === undefined )
      e = self.last();
      let r = container.delete( e );
      _.assert( r === true );
      return e;
    }
    else
    {
      // aaa | Dmytro : tabs are removed
      // aaa : not clear. explain during call
      let last = _.nothing;
      self.reduce( ( a, e2 ) => _.entity.equal( e2, e, onEvaluate1, onEvaluate2 ) ? last = e2 : undefined );
      _.assert( last !== _.nothing );
      container.delete( last );
      return last;
    }
  }
  popStrictly( e, onEvaluate1, onEvaluate2 )
  {
    let last = this.last();
    _.assert( 1 <= arguments.length && arguments.length <= 3 );
    _.assert( _.entity.equal( last, e, onEvaluate1, onEvaluate2 ), 'Set does not have such an element' );

    this.original.delete( last );
    return last;
  }
  removed( e, onEvaluate1, onEvaluate2 )
  {
    if( onEvaluate1 || _.routine.is( onEvaluate2 ) )
    {
      let from = 0;
      let result = 0;
      if( _.number.is( onEvaluate1 ) )
      {
        from = onEvaluate1;
        onEvaluate1 = onEvaluate2;
        onEvaluate2 = undefined;
      }

      for( let v of this.original )
      {
        if( from === 0 )
        {
          if( _.entity.equal( v, e, onEvaluate1, onEvaluate2 ) )
          {
            this.original.delete( v );
            result++;
          }
        }
        else
        {
          from--;
        }
      }

      return result;
    }
    else
    {
      return this.original.delete( e ) ? 1 : 0;
    }
  }
  removedOnce( e, onEvaluate1, onEvaluate2 )
  {
    let from = 0;
    let index = -1;

    if( _.number.is( onEvaluate1 ) )
    {
      from = onEvaluate1;
      onEvaluate1 = onEvaluate2;
      onEvaluate2 = undefined;
    }

    for( let v of this.original )
    {
      if( from === 0 )
      {
        if( _.entity.equal( v, e, onEvaluate1, onEvaluate2 ) )
        {
          this.original.delete( v );
          return ++index;
        }
      }
      else
      {
        from--;
      }
      index++;
    }
    return -1;
  }
  removedOnceLeft( e, onEvaluate1, onEvaluate2 )
  {
    return this.removedOnce.apply( this, arguments );
  }
  removedOnceRight( e, onEvaluate1, onEvaluate2 )
  {
    let temp = [ ... this.original ];
    let to = this.length;
    if( _.number.is( onEvaluate1 ) )
    {
      to = onEvaluate1;
      onEvaluate1 = onEvaluate2;
      onEvaluate2 = undefined;
    }

    for( let i = to - 1; i >= 0; i-- )
    {
      if( _.entity.equal( temp[ i ], e, onEvaluate1, onEvaluate2 ) )
      {
        this.original.delete( temp[ i ] );
        return i;
      }
    }
    return -1;
  }
  removedOnceStrictly( e, onEvaluate1, onEvaluate2 )
  {
    let from = 0;
    let index = -1;
    let result;

    if( _.number.is( onEvaluate1 ) )
    {
      from = onEvaluate1;
      onEvaluate1 = onEvaluate2;
      onEvaluate2 = undefined;
    }

    for( let v of this.original )
    {
      if( from === 0 )
      {
        if( _.entity.equal( v, e, onEvaluate1, onEvaluate2 ) )
        {
          if( result === undefined )
          {
            this.original.delete( v );
            result = index + 1;
          }
          else
          {
            _.assert( 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( e ) + ' is several times in dstArray' );
          }
        }
      }
      else
      {
        from--;
      }
      index++;
    }

    _.assert( result !== undefined, 'Container does not have such an element' );
    return result;
  }
  removedOnceStrictlyLeft( e, onEvaluate1, onEvaluate2 )
  {
    return this.removedOnceStrictly.apply( this, arguments );
  }
  removedOnceStrictlyRight( e, onEvaluate1, onEvaluate2 )
  {
    let to = this.length;
    let temp = [ ... this.original ];
    let result;

    if( _.number.is( onEvaluate1 ) )
    {
      to = onEvaluate1;
      onEvaluate1 = onEvaluate2;
      onEvaluate2 = undefined;
    }

    for( let i = to - 1; i >= 0; i-- )
    {
      if( _.entity.equal( temp[ i ], e, onEvaluate1, onEvaluate2 ) )
      {
        if( result === undefined )
        {
          this.original.delete( temp[ i ] );
          result = i;
        }
        else
        {
          _.assert( 0, () => 'The element ' + _.entity.exportStringDiagnosticShallow( e ) + ' is several times in dstArray' )
        }
      }
    }
    _.assert( result !== undefined, 'Container does not have such an element' );
    return result;
  }
  remove( e, onEvaluate1, onEvaluate2 )
  {
    this.removed.apply( this, arguments );
    return this;
  }
  removeOnce( e, onEvaluate1, onEvaluate2 )
  {
    this.removedOnce.apply( this, arguments );
    return this;
  }
  removeOnceLeft( e, onEvaluate1, onEvaluate2 )
  {
    this.removedOnceLeft.apply( this, arguments );
    return this;
  }
  removeOnceRight( e, onEvaluate1, onEvaluate2 )
  {
    this.removedOnceRight.apply( this, arguments );
    return this;
  }
  removeOnceStrictly( e, onEvaluate1, onEvaluate2 )
  {
    this.removedOnceStrictly.apply( this, arguments );
    return this;
  }
  removeOnceStrictlyLeft( e, onEvaluate1, onEvaluate2 )
  {
    this.removedOnceStrictlyLeft.apply( this, arguments );
    return this;
  }
  removeOnceStrictlyRight( e, onEvaluate1, onEvaluate2 )
  {
    this.removedOnceStrictlyRight.apply( this, arguments );
    return this;
  }
  empty()
  {
    this.original.clear();
  }
  map( dst, onEach )
  {
    let self = this;
    let container = self.original;
    [ dst, onEach ] = self._filterArguments( ... arguments );
    let length = self.length;
    let index = -1;

    if( self._same( dst ) )
    {
      for( let e of container )
      {
        index += 1;
        if( index === length )
        break;

        let e2 = onEach( e, index, container );
        container.delete( e );
        if( e2 !== undefined && e !== e2 )
        container.add( e2 );
        else
        container.add( e );
      }
    }
    else
    {
      for( let e of container )
      {
        index += 1;
        let e2 = onEach( e, index, self );
        if( e2 !== undefined )
        dst.append( e2 );
        else
        dst.append( e );
      }
    }

    return dst;
  }
  mapLeft( dst, onEach )
  {
    return this.map.apply( this, arguments );
  }
  mapRight( dst, onEach )
  {
    let self = this;
    let container = self.original;
    let temp = [ ... container ];
    [ dst, onEach ] = self._filterArguments( ... arguments );

    if( this._same( dst ) )
    {
      for( let i = temp.length - 1; i >= 0; i-- )
      {
        let e2 = onEach( temp[ i ], i, container );
        if( e2 !== undefined && temp[ i ] !== e2 )
        temp[ i ] = e2;
      }
      self.empty();
      temp.forEach( ( e ) => self.push( e ) )
    }
    else
    {
      for( let i = temp.length - 1; i >= 0; i-- )
      {
        let e2 = onEach( temp[ i ], i, self );
        if( e2 !== undefined )
        dst.append( e2 );
        else
        dst.append( temp[ i ] );
      }
    }

    return dst;
  }
  filter( dst, onEach )
  {
    let self = this;
    let container = self.original;
    [ dst, onEach ] = self._filterArguments( ... arguments );
    let length = self.length;
    let index = -1;

    if( self._same( dst ) )
    {

      for( let e of container )
      {
        index += 1;
        if( index === length )
        break;

        let e2 = onEach( e, index, container );

        if( e2 === undefined )
        {
          container.delete( e );
        }
        else if( e !== e2 )
        {
          container.add( e2 );
          container.delete( e );
        }
        else
        {
          container.add( e );
        }
      }
    }
    else
    {
      for( let e of container )
      {
        index += 1;
        let e2 = onEach( e, index, self );
        if( e2 !== undefined )
        dst.append( e2 );
      }
    }

    return dst;
  }
  filterLeft( dst, onEach )
  {
    return this.filter.apply( this, arguments );
  }
  filterRight( dst, onEach )
  {
    let self = this;
    let container = self.original;
    let temp = [ ... container ];
    [ dst, onEach ] = self._filterArguments( ... arguments );

    if( self._same( dst ) )
    {
      for( let i = temp.length - 1; i >= 0; i-- )
      {
        let e2 = onEach( temp[ i ], i, container );
        if( e2 === undefined )
        temp.splice( i, 1 );
        else if( temp[ i ] !== e2 )
        temp[ i ] = e2;
      }
      self.empty();
      temp.forEach( ( e ) => self.push( e ) );
    }
    else
    {
      for( let i = temp.length - 1; i >= 0; i-- )
      {
        let e2 = onEach( temp[ i ], i, self );
        if( e2 !== undefined )
        dst.append( e2 );
      }
    }

    return dst;
  }
  flatFilter( dst, onEach )
  {
    let self = this;
    let container = self.original;
    [ dst, onEach ] = self._filterArguments( ... arguments );
    let length = container.size;
    let index = -1;

    if( self._same( dst ) )
    {
      for( let e of container )
      {
        index += 1;
        if( index === length )
        break;

        let e2 = onEach( e, index, self );
        self.remove( e );

        if( self.IsContainer( e2 ) || self.Is( e2 ) )
        self.appendContainer( e2 );
        else if( e2 !== undefined )
        self.append( e2 )
        else if( e2 === e && e !== undefined )
        self.append( e );
      }
    }
    else
    {
      for( let e of container )
      {
        index += 1;
        let e2 = onEach( e, index, self );

        if( self.IsContainer( e2 ) || self.Is( e2 ) )
        dst.appendContainer( e2 );
        else if( e2 !== undefined )
        dst.append( e2 );
      }
    }
    return dst;
  }
  flatFilterLeft( dst, onEach )
  {
    return this.flatFilter.apply( this, arguments );
  }
  flatFilterRight( dst, onEach )
  {
    let self = this;
    let container = self.original;
    let temp = [ ... container ];
    [ dst, onEach ] = self._filterArguments( ... arguments );
    let length = container.size;
    let index = -1;

    if( self._same( dst ) )
    {
      for( let i = temp.length - 1; i >= 0; i-- )
      {
        let e2 = onEach( temp[ i ], i, self );

        if( self.IsContainer( e2 ) || self.Is( e2 ) )
        temp.splice( i, 1, ... e2 );
        else if( e2 !== undefined && e2 !== temp[ i ] )
        temp[ i ] = e2;
        else if( e2 === undefined )
        temp.splice( i, 1 );
        self.empty();
        temp.forEach( ( e ) => self.push( e ) );
      }
    }
    else
    {
      for( let i = temp.length - 1; i >= 0; i-- )
      {
        let e2 = onEach( temp[ i ], i, self );

        if( self.IsContainer( e2 ) || self.Is( e2 ) )
        dst.appendContainer( e2 );
        else if( e2 !== undefined )
        dst.append( e2 );
      }
    }
    return dst;
  }
  once( dst, onEvaluate1, onEvaluate2 )
  {
    let self = this;
    let container = self.original;
    [ dst, dst, onEvaluate1, onEvaluate2 ] = self._onlyArguments( null, dst, onEvaluate1, onEvaluate2 );
    if( self._same( dst ) )
    {
      if( onEvaluate1 || _.routine.is( onEvaluate2 ) )
      {
        let length = this.length;
        let startLength = length;
        for( let e of container )
        {
          if( length === startLength )
          {
            self.append( e );
            length--;
          }
          else if( length !== 0 )
          {
            self.remove( e );
            self.appendOnce( e, onEvaluate1, onEvaluate2 )
            length--;
          }
        }
      }
    }
    else
    {
      dst.appendContainerOnce( container, onEvaluate1, onEvaluate2 );
    }

    return dst;
  }
  onceLeft( dst, onEvaluate1, onEvaluate2 )
  {
    return this.once.apply( this, arguments );
  }
  onceRight( dst, onEvaluate1, onEvaluate2 )
  {
    let self = this;
    let container = self.original;
    let temp = [ ... container ];
    [ dst, dst, onEvaluate1, onEvaluate2 ] = self._onlyArguments( null, dst, onEvaluate1, onEvaluate2 );
    if( self._same( dst ) )
    {
      if( onEvaluate1 || _.routine.is( onEvaluate2 ) )
      {
        self.empty();
        for( let i = 0; i < temp.length; i++ )
        self.appendOnce( temp[ i ], onEvaluate1, onEvaluate2 );
      }
    }
    else
    {
      for( let i = temp.length - 1; i >= 0; i-- )
      dst.appendOnce( temp[ i ], onEvaluate1, onEvaluate2 );
    }

    return dst;
  }
  withIndex( index )
  {
    let self = this;
    return [ ... self.original ][ index ];
  }
  first( onEach )
  {
    let self = this;
    let container = this.original;
    if( !container.size )
    return undefined;
    if( onEach )
    for( let e of container )
    {
      return onEach( e, 0, self );
    }
    else
    {
      for( let e of container )
      {
        return e;
      }
    }
  }
  last( onEach )
  {
    let last = this.reduce( ( a, e ) => e );
    if( onEach )
    return onEach( last, this.length - 1, this );
    else
    return last;
  }
  each( onEach )
  {
    return this.eachLeft( onEach );
  }
  eachLeft( onEach )
  {
    let self = this;
    let container = self.original;
    let index = -1;
    for( let e of container )
    {
      index += 1;
      onEach( e, index, self );
    }
    return self;
  }
  eachRight( onEach )
  {
    let self = this;
    let container = self.original;
    let temp = [ ... container ];
    for( let i = temp.length - 1; i >= 0; i-- )
    onEach( temp[ i ], i, self );
    return self;
  }
  reduce( accumulator, onEach )
  {
    let self = this;
    let container = self.original;
    if( arguments[ 1 ] === undefined )
    {
      onEach = arguments[ 0 ];
      accumulator = undefined;
    }
    let index = -1;
    for( let e of container )
    {
      index += 1;
      accumulator = onEach( accumulator, e, index, self );
    }
    return accumulator;
  }
  reduceLeft( accumulator, onEach )
  {
    return this.reduce.apply( this, arguments );
  }
  reduceRight( accumulator, onEach )
  {
    let self = this;
    let container = self.original;
    let temp = [ ... container ];
    if( arguments[ 1 ] === undefined )
    {
      onEach = arguments[ 0 ];
      accumulator = undefined;
    }
    for( let i = temp.length - 1; i >= 0; i-- )
    {
      accumulator = onEach( accumulator, temp[ i ], i, self );
    }
    return accumulator;
  }
  all( onEach )
  {
    return this.allLeft( onEach );
  }
  allLeft( onEach )
  {
    let self = this;
    let container = self.original;
    let index = -1;
    for( let e of container )
    {
      index += 1;
      let r = onEach( e, index, self );
      if( !r )
      return false;
    }
    return true;
  }
  allRight( onEach )
  {
    let self = this;
    let container = this.original;
    let temp = [ ... container ];
    for( let k = temp.length - 1; k >= 0; k-- )
    {
      let r = onEach( temp[ k ], k, self );
      if( !r )
      return false;
    }
    return true;
  }
  any( onEach )
  {
    return this.anyLeft( onEach );
  }
  anyLeft( onEach )
  {
    let self = this;
    let container = self.original;
    let index = -1;
    for( let e of container )
    {
      index += 1;
      let r = onEach( e, index, self );
      if( r )
      return true;
    }
    return false;
  }
  anyRight( onEach )
  {
    let self = this;
    let container = self.original;
    let temp = [ ... container ];
    for( let k = temp.length - 1; k >= 0; k-- )
    {
      let r = onEach( temp[ k ], k, self );
      if( r )
      return true;
    }
    return false;
  }
  none( onEach )
  {
    return this.noneLeft( onEach );
  }
  noneLeft( onEach )
  {
    let self = this;
    let container = self.original;
    let index = -1;
    for( let e of container )
    {
      index += 1;
      let r = onEach( e, index, self );
      if( r )
      return false;
    }
    return true;
  }
  noneRight( onEach )
  {
    let self = this;
    let container = self.original;
    let temp = [ ... container ];
    for( let k = temp.length - 1; k >= 0; k-- )
    {
      let r = onEach( temp[ k ], k, self );
      if( r )
      return false;
    }
    return true;
  }
  left( /* element, fromIndex, onEvaluate1, onEvaluate2 */ )
  {
    let element = arguments[ 0 ];
    let fromIndex = arguments[ 1 ];
    let onEvaluate1 = arguments[ 2 ];
    let onEvaluate2 = arguments[ 3 ];

    _.assert( 1 <= arguments.length && arguments.length <= 4 );
    return _.arraySet.left( this.original, element, fromIndex, onEvaluate1, onEvaluate2 );
  }
  right( /* element, fromIndex, onEvaluate1, onEvaluate2 */ )
  {
    let element = arguments[ 0 ];
    let fromIndex = arguments[ 1 ];
    let onEvaluate1 = arguments[ 2 ];
    let onEvaluate2 = arguments[ 3 ];

    _.assert( 1 <= arguments.length && arguments.length <= 4 );
    return _.arraySet.right( this.original, element, fromIndex, onEvaluate1, onEvaluate2 );
  }
  reverse( dst )
  {

    let self = this;
    let container = self.original;
    let temp = [ ... container ];

    if( !dst )
    dst = this.MakeEmpty();
    else
    dst = this.From( dst );

    if( self._same( dst ) )
    {
      self.empty();
      for( let i = temp.length - 1; i >= 0; i-- )
      self.append( temp[ i ] );
    }
    else
    {
      for( let i = temp.length - 1; i >= 0; i-- )
      dst.append( temp[ i ] );
    }

    return dst;
  }
  join( delimeter )
  {
    return [ ... this.original ].join( delimeter );
  }
  toArray()
  {
    return new _.containerAdapter.Array( [ ... this.original ] );
  }
  toSet()
  {
    return this;
  }
  [ Symbol.iterator ]()
  {
    let container = this.original;
    return container[ Symbol.iterator ]();
  }
  get length()
  {
    return this.original.size;
  }
}
ContainerAdapterSet.Make = Make;
ContainerAdapterSet.MakeEmpty = MakeEmpty;
ContainerAdapterSet.prototype.make = make;
ContainerAdapterSet.prototype.MakeEmpty = makeEmpty;

// --
// meta
// --

function ExportTo( dstGlobal, srcGlobal )
{
  debugger;
  let _ = dstGlobal.wTools;
  _.assert( _.containerAdapter === srcGlobal.wTools.containerAdapter );
  _.assert( _.mapIs( srcGlobal.wTools.containerAdapter ) );
  if( typeof module !== 'undefined' )
  module[ 'exports' ] = _.containerAdapter;
}

// --
// declare
// --

const Self = _.containerAdapter;

//

var Extension =
{

  Set : ContainerAdapterSet,

}

//

Object.assign( _.containerAdapter, Extension );
_.assert( _.containerAdapter === Self );

// --
// export
// --

if( typeof module !== 'undefined' )
module[ 'exports' ] = _;

if( _global !== _realGlobal_ )
return ExportTo( _realGlobal_, _global );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1/ContainerAdapterSet.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, ContainerAdapterSet_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file ContainerAdapterSet_s */ })();

/* */  /* begin of file NameTools_s */ ( function NameTools_s() { function NameTools_s_naked() { ( function _NameTools_s_()
{

'use strict';

const _global = _global_;
const _ = _global_.wTools;

const _ArraySlice = Array.prototype.slice;
const _FunctionBind = Function.prototype.bind;
const _ObjectToString = Object.prototype.toString;
const _ObjectHasOwnProperty = Object.hasOwnProperty;

// --
// name and symbol
// --

// /**
//  * Produce fielded name from string.
//  * @param {string} nameString - object coded name or string.
//  * @return {object} nameKeyValue - name in key/value format.
//  * @method nameFielded
//  * @namespace Tools
//  */
//
// function nameFielded( nameString )
// {
//
//   if( _.object.isBasic( nameString ) )
//   {
//     return nameString;
//   }
//   else if( _.strIs( nameString ) )
//   {
//     var name = {};
//     name[ nameString ] = nameString;
//     return name;
//   }
//   else _.assert( 0, 'nameFielded :', 'Expects string or ' );
//
// }

//

/**
 * Returns name splitted in coded/raw fields.
 * @param {object} nameObject - fielded name or name as string.
 * @return {object} name splitted in coded/raw fields.
 * @method nameUnfielded
 * @namespace Tools
 */

function nameUnfielded( nameObject )
{
  var name = {};

  if( _.mapIs( nameObject ) )
  {
    var keys = Object.keys( nameObject );
    _.assert( keys.length === 1 );
    name.coded = keys[ 0 ];
    name.raw = nameObject[ name.coded ];
  }
  else if( _.strIs( nameObject ) )
  {
    name.raw = nameObject;
    name.coded = nameObject;
  }
  else if( _.symbol.is( nameObject ) )
  {
    name.raw = nameObject;
    name.coded = nameObject;
  }
  else _.assert( 0, 'nameUnfielded :', 'Unknown arguments' );

  // _.assert( arguments.length === 1 );
  // _.assert( _.strIs( name.raw ) || _.symbol.is( name.raw ), 'nameUnfielded :', 'not a string, something wrong :', nameObject );
  // _.assert( _.strIs( name.coded ) || _.symbol.is( name.coded ), 'nameUnfielded :', 'not a string, something wrong :', nameObject );

  return name;
}

// //
//
// /**
//  * Returns name splitted in coded/coded fields. Drops raw part replacing it by coded.
//  * @param {object} namesMap - fielded names.
//  * @return {object} expected map.
//  * @method namesCoded
//  * @namespace Tools
//  */
//
// function namesCoded( namesMap )
// {
//   var result = {}
//
//   if( _.assert )
//   _.assert( arguments.length === 1 );
//   if( _.assert )
//   _.assert( _.object.isBasic( namesMap ) );
//
//   for( var n in namesMap )
//   result[ n ] = n;
//
//   return result;
// }

// --
// id
// --

function idWithOnlyDate( prefix, postfix )
{
  var date = new Date;

  _.assert( 0 <= arguments.length && arguments.length <= 2 );

  prefix = prefix ? prefix : '';
  postfix = postfix ? postfix : '';

  var d =
  [
    date.getFullYear(),
    date.getMonth()+1,
    date.getDate(),
  ].join( '-' );

  return prefix + d + postfix
}

//

function idWithDateAndTime( prefix, postfix, fast )
{
  var date = new Date;

  _.assert( 0 <= arguments.length && arguments.length <= 3 );

  prefix = prefix ? prefix : '';
  postfix = postfix ? postfix : '';

  if( fast )
  return prefix + date.valueOf() + postfix;

  var d =
  [
    date.getFullYear(),
    date.getMonth()+1,
    date.getDate(),
    date.getHours(),
    date.getMinutes(),
    date.getSeconds(),
    date.getMilliseconds(),
    Math.floor( Math.random()*0x10000 ).toString( 16 ),
  ].join( '-' );

  return prefix + d + postfix
}

//

function idWithTime( prefix, postfix )
{
  var date = new Date;

  _.assert( 0 <= arguments.length && arguments.length <= 2 );

  prefix = prefix ? prefix : '';
  postfix = postfix ? postfix : '';

  var d =
  [
    String( date.getHours() ) + String( date.getMinutes() ) + String( date.getSeconds() ),
    String( date.getMilliseconds() ),
    Math.floor( Math.random()*0x10000 ).toString( 16 ),
  ].join( '-' );

  return prefix + d + postfix
}

//

/* aaa : reimplement it more properly | Dmytro : new implementation is written below, it use futures of random RFC4122 GUIDs v4. Guids can be more complex for example https://www.npmjs.com/package/uuid */

function idWithGuid()
{

  _.assert( arguments.length === 0 );

  var result =
  [
    s4() + s4(),
    s4(),
    s4(),
    s4(),
    s4() + s4() + s4(),
  ].join( '-' );

  return result;

  function s4()
  {
    return Math.floor( ( 1 + Math.random() ) * 0x10000 )
    .toString( 16 )
    .substring( 1 );
  }

}

//

// function idWithGuid()
// {
//   let guid = '$$$$$$$$-$$$$-4$$$-y$$$-$$$$$$$$$$$$';
//
//   return guid.replace( /[$y]/g, replaceSymbol );
//
//   /* */
//
//   function replaceSymbol( sym )
//   {
//     let r = Math.random() * 16 | 0;
//     return ( sym === '$' ? r : ( r & 0x3 | 0x8 ) ).toString( 16 );
//   }
// }

//

/**
 * Routine idWithTimeGuid() returns random GUID of RFC4122 standard.
 * GUID v4 is used.
 * Routine does not accepts parameters.
 *
 * @example
 * _.idWithTimeGuid()
 * // returns '0d796bf0-dc89-4ccd-b751-01430f6ec71f'
 *
 * @return { String } - Returns GUID v4.
 * @function idWithTimeGuid
 * @namespace Tools
 */

function idWithTimeGuid()
{
  let guid = '$$$$$$$$-$$$$-4$$$-y$$$-$$$$$$$$$$$$';
  let date = _.time.now();

  _.assert( arguments.length === 0 );

  return guid.replace( /[$y]/g, replaceSymbol );

  /* */

  function replaceSymbol( sym )
  {
    let r = ( date + Math.random() * 16 ) % 16 | 0;
    date = Math.floor( date / 16 );
    return ( sym === '$' ? r : ( r & 0x3 | 0x8 ) ).toString( 16 );
  }
}

//

var idWithInt = (function()
{

  var counter = 0;

  return function()
  {
    _.assert( arguments.length === 0, 'Expects no arguments' );
    counter += 1;
    return counter;
  }

})();

// --
// declare
// --

const Proto =
{

  // name and symbol

  // nameFielded, /* experimental */
  nameUnfielded, /* xxx : move */
  // namesCoded, /* experimental */

  // id

  idWithOnlyDate,
  idWithDateAndTime,
  idWithTime,
  idWithGuid,
  idWithTimeGuid,
  idWithInt,

}

_.props.extend( _, Proto );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1/NameTools.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, NameTools_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file NameTools_s */ })();

/* */  /* begin of file StrBasic_s */ ( function StrBasic_s() { function StrBasic_s_naked() { (function _StrBasic_s_()
{

'use strict';

/*

qqq : write article "strIsolate* difference"

*/

//

const _global = _global_;
const _ = _global_.wTools;

const _ArraySlice = Array.prototype.slice;
const _FunctionBind = Function.prototype.bind;
const _ObjectToString = Object.prototype.toString;
const _ObjectHasOwnProperty = Object.hasOwnProperty;

const _longSlice = _.longSlice;
const strType = _.entity.strType;

// --
// dichotomy
// --

function strIsHex( src )
{
  _.assert( _.strIs( src ) );
  _.assert( arguments.length === 1 );
  let parsed = parseInt( src, 16 )
  if( isNaN( parsed ) )
  return false;
  return parsed.toString( 16 ).length === src.length;
}

//

function strIsMultilined( src )
{
  if( !_.strIs( src ) )
  return false;
  if( src.indexOf( '\n' ) !== -1 )
  return true;
  return false;
}

//

function strHasAny( src, ins )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.arrayIs( ins ) )
  {
    for( let i = 0 ; i < ins.length ; i++ )
    if( _.strHas( src, ins[ i ] ) )
    return true;
    return false;
  }

  return _.strHas( src, ins );
}

//

function strHasAll( src, ins )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.arrayIs( ins ) )
  {
    for( let i = 0 ; i < ins.length ; i++ )
    if( !_.strHas( src, ins[ i ] ) )
    return false;
    return true;
  }

  return _.strHas( src, ins );
}

//

function strHasNone( src, ins )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.arrayIs( ins ) )
  {
    for( let i = 0 ; i < ins.length ; i++ )
    if( _.strHas( src, ins[ i ] ) )
    return false;
    return true;
  }

  return !_.strHas( src, ins );
}

//

function strHasSeveral( src, ins )
{
  let result = 0;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );

  if( _.arrayIs( ins ) )
  {
    for( let i = 0 ; i < ins.length ; i++ )
    if( _.strHas( src, ins[ i ] ) )
    result += 1;
    return result;
  }

  return _.strHas( src, ins ) ? 1 : 0;
}

//

function strsAnyHas( srcs, ins )
{
  _.assert( _.strIs( srcs ) || _.strsAreAll( srcs ) );
  _.assert( _.strIs( ins ) );

  if( _.strIs( srcs ) )
  return _.strHas( srcs, ins );

  return srcs.some( ( src ) => _.strHas( src, ins ) );
}

//

function strsAllHas( srcs, ins )
{
  _.assert( _.strIs( srcs ) || _.strsAreAll( srcs ) );
  _.assert( _.strIs( ins ) );

  if( _.strIs( srcs ) )
  return _.strHas( srcs, ins );

  return srcs.every( ( src ) => _.strHas( src, ins ) );
}

//

function strsNoneHas( srcs, ins )
{
  _.assert( _.strIs( srcs ) || _.strsAreAll( srcs ) );
  _.assert( _.strIs( ins ) );

  if( _.strIs( srcs ) )
  return !_.strHas( srcs, ins );

  return srcs.every( ( src ) => !_.strHas( src, ins ) );
}

// --
// evaluator
// --

/**
 * Returns number of occurrences of a substring( ins ) in a string( src ),
 * Expects two objects in order: source string, substring.
 * Returns zero if one of arguments is empty string.
 *
 * @param {string} src - Source string.
 * @param {string} ins - Substring.
 * @returns {Number} Returns number of occurrences of a substring in a string.
 *
 * @example
 * _.strCount( 'aabab', 'ab' );
 * // returns 2
 *
 * @example
 * _.strCount( 'aabab', '' );
 * // returns 0
 *
 * @method strCount
 * @throws { Exception } Throw an exception if( src ) is not a String.
 * @throws { Exception } Throw an exception if( ins ) is not a String.
 * @throws { Exception } Throw an exception if( arguments.length ) is not equal 2.
 * @namespace Tools
 *
 */

function strCount( src, ins )
{
  let result = 0;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( src ) );
  _.assert( _.regexpLike( ins ) );

  let i = 0;
  do
  {
    // let found = _.strLeft( src, ins, [ i, src.length ] );
    let found = _.strLeft_( src, ins, [ i, src.length-1 ] );
    if( found.entry === undefined )
    break;
    i = found.index + found.entry.length;
    if( !found.entry.length )
    i += 1;
    result += 1;
    _.assert( i !== -1, 'not tested' );
  }
  while( i !== -1 && i < src.length );

  return result;
}

//

function strStripCount( src, ins )
{
  return _.strCount( _.str.lines.strip( src ), _.str.lines.strip( ins ) );
}

//

function strsShortest( src )
{
  _.assert( arguments.length === 1 );
  _.assert( _.strIs( src ) || _.argumentsArray.like( src ) );
  if( _.strIs( src ) )
  return src;
  return src.sort( ( a, b ) => a.length - b.length )[ 0 ];
}

//

function strsLongest()
{
  _.assert( arguments.length === 1 );
  _.assert( _.strIs( src ) || _.argumentsArray.like( src ) );
  if( _.strIs( src ) )
  return src;
  return src.sort( ( a, b ) => b.length - a.length )[ 0 ];
}

// --
// replacer
// --

function _strRemoved( srcStr, insStr )
{
  let result = srcStr;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( srcStr ), 'Expects string {-src-}' );

  if( _.longIs( insStr ) )
  {
    for( let i = 0; i < insStr.length; i++ )
    result = result.replace( insStr[ i ], '' );
  }
  else
  {
    result = result.replace( insStr, '' );
  }
  // if( !_.longIs( insStr ) )
  // {
  //   result = result.replace( insStr, '' );
  // }
  // else
  // {
  //   for( let i = 0; i < insStr.length; i++ )
  //   {
  //     result = result.replace( insStr[ i ], '' );
  //   }
  // }

  return result;
}

//

/**
* Finds substring or regexp ( insStr ) first occurrence from the source string ( srcStr ) and removes it.
* Returns original string if source( src ) does not have occurrence of ( insStr ).
*
* @param { String } srcStr - Source string to parse.
* @param { String } insStr - String/RegExp that is to be dropped.
* @returns { String } Returns string with result of substring removement.
*
* @example
* _.strRemove( 'source string', 's' );
* // returns ource tring
*
* @example
* _.strRemove( 'example', 's' );
* // returns example
*
* @function strRemove
* @throws { Exception } Throws a exception if( srcStr ) is not a String.
* @throws { Exception } Throws a exception if( insStr ) is not a String or a RegExp.
* @throws { Exception } Throws a exception if( arguments.length ) is not equal 2.
* @namespace Tools
*
*/

/*
aaa : extend coverage of routines strRemove, strReplace, make sure tests cover regexp cases
Dmytro : coverage is extended
*/

function strRemove( srcStr, insStr )
{
  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.longIs( srcStr ) || _.regexpLike( srcStr ), () => 'Expects string or array of strings {-srcStr-}, but got ' + _.entity.strType( srcStr ) );

  if( _.longIs( insStr ) )
  {
    for( let i = 0 ; i < insStr.length ; i++ )
    _.assert( _.strIs( insStr[ i ] ) || _.regexpIs( insStr[ i ] ), () => 'Expects string/regexp or array of strings/regexps' );
  }
  else
  {
    _.assert( _.strIs( insStr ) || _.regexpIs( insStr ), () => 'Expects string/regexp or array of strings/regexps' );
  }
  //_.assert( _.longIs( insStr ) || _.regexpLike( insStr ), () => 'Expects string/regexp or array of strings/regexps {-begin-}' );

  let result = [];

  if( _.strIs( srcStr ) && !_.longIs( srcStr ) )
  return _._strRemoved( srcStr, insStr );

  srcStr = _.array.as( srcStr );

  for( let s = 0; s < srcStr.length; s++ )
  {
    let src = srcStr[ s ];
    result[ s ] = _._strRemoved( src, insStr );
  }

  if( !_.longIs( srcStr ) )
  return result[ 0 ];

  return result;
}

// //
//
// /**
//   * Prepends string( begin ) to the source( src ) if prefix( begin ) is not match with first chars of string( src ),
//   * otherwise returns original string.
//   * @param { String } src - Source string to parse.
//   * @param { String } begin - String to prepend.
//   *
//   * @example
//   * _.strPrependOnce( 'test', 'test' );
//   * // returns 'test'
//   *
//   * @example
//   * _.strPrependOnce( 'abc', 'x' );
//   * // returns 'xabc'
//   *
//   * @returns { String } Returns result of prepending string( begin ) to source( src ) or original string.
//   * @function strPrependOnce
//   * @namespace Tools
//   */
//
// function strPrependOnce( src, begin )
// {
//   _.assert( _.strIs( src ) && _.strIs( begin ), 'Expects {-src-} and {-begin-} as strings' );
//   if( src.lastIndexOf( begin, 0 ) === 0 )
//   return src;
//   else
//   return begin + src;
// }
//
// //
//
// /**
//   * Appends string( end ) to the source( src ) if postfix( end ) is not match with last chars of string( src ),
//   * otherwise returns original string.
//   * @param {string} src - Source string to parse.
//   * @param {string} end - String to append.
//   *
//   * @example
//   * _.strAppendOnce( 'test', 'test' );
//   * // returns 'test'
//   *
//   * @example
//   * _.strAppendOnce( 'abc', 'x' );
//   * // returns 'abcx'
//   *
//   * @returns {string} Returns result of appending string( end ) to source( src ) or original string.
//   * @function strAppendOnce
//   * @namespace Tools
//   */
//
// function strAppendOnce( src, end )
// {
//   _.assert( _.strIs( src ) && _.strIs( end ), 'Expects {-src-} and {-end-} as strings' );
//   if( src.indexOf( end, src.length - end.length ) === -1 )
//   return src + end;
//   else
//   return src;
// }

// --
// etc
// --

/**
 * Replaces occurrence of each word from array( ins ) in string( src ) with word
 * from array( sub ) considering it position.
 * @param {string} src - Source string to parse.
 * @param {array} ins - Array with strings to replace.
 * @param {string} sub - Array with new strings.
 * @returns {string} Returns string with result of replacements.
 *
 * @example
 * _.strReplaceWords( ' my name is', [ 'my', 'name', 'is' ], [ 'your', 'cars', 'are' ] )
 * // returns ' your cars are'
 *
 * @method strReplaceWords
 * @throws { Exception } Throws a exception if( ins ) is not a Array.
 * @throws { Exception } Throws a exception if( sub ) is not a Array.
 * @throws { TypeError } Throws a exception if( src ) is not a String.
 * @throws { Exception } Throws a exception if( arguments.length ) is not equal 3.
 * @namespace Tools
 *
 */

function strReplaceWords( src, ins, sub )
{
  _.assert( arguments.length === 3, 'Expects exactly three arguments' );
  _.assert( _.strIs( src ) );
  _.assert( _.arrayIs( ins ) );
  _.assert( _.arrayIs( sub ) );
  _.assert( ins.length === sub.length );

  let result = src;
  for( let i = 0 ; i < ins.length ; i++ )
  {
    _.assert( _.strIs( ins[ i ] ) );
    let r = new RegExp( '(\\W|^)' + ins[ i ] + '(?=\\W|$)', 'gm' );
    result = result.replace( r, function( original )
    {
      if( original[ 0 ] === sub[ i ][ 0 ] )
      return sub[ i ];
      else
      return original[ 0 ] + sub[ i ];
      // if( original[ 0 ] !== sub[ i ][ 0 ] )
      // return original[ 0 ] + sub[ i ];
      // else
      // return sub[ i ];
    });
  }

  return result;
}

// --
// etc
// --

/**
 * Routine strCommonLeft() finds common symbols from the begining of all strings passed to arguments list.
 * Routine uses first argument {-ins-} as a pattern. If some string doesn`t have the same first symbols
 * as the pattern {-ins-}, the function returns an empty string.
 * Otherwise, it returns the symbol sequence that appears from the start of each string.
 *
 * @param { String } ins - Sequence of possible symbols.
 * @param { String } ... - Another strings to search common sequence of symbols.
 *
 * @example
 * _.strCommonLeft( 'abcd', 'ab', 'abc', 'abd' );
 * // returns 'ab'
 *
 * @example
 * _.strCommonLeft( 'abcd', 'abc', 'abcd' );
 * // returns 'abc'
 *
 * @example
 * _.strCommonLeft( 'abcd', 'abc', 'd' )
 * // returns ''
 *
 * @returns { String } - Returns found common symbols.
 * @function strCommonLeft
 * @throws { Error } If {-ins-} is not a String.
 * @namespace Tools
 *
 */

function strCommonLeft( ins )
{

  if( arguments.length === 0 )
  return '';
  if( arguments.length === 1 )
  return ins;

  _.assert( _.strIs( ins ) );

  let length = +Infinity;

  for( let a = 0 ; a < arguments.length ; a++ )
  {
    let src = arguments[ a ];
    length = Math.min( length, src.length );
  }

  let i = 0;
  for( ; i < length ; i++ )
  for( let a = 1 ; a < arguments.length ; a++ )
  {
    let src = arguments[ a ];
    if( src[ i ] !== ins[ i ] )
    return ins.substring( 0, i );
  }

  return ins.substring( 0, i );
}

//

/**
 * Routine strCommonRight() finds common symbols from the end of all strings passed to arguments list.
 * Routine uses first argument {-ins-} as a pattern. If some string doesn`t have the same end symbols
 * as the pattern {-ins-}, the function returns an empty string.
 * Otherwise, it returns the symbol sequence that appears from the end of each string.
 *
 * @param { String } ins - Sequence of possible symbols.
 * @param { String } ... - Another strings to search common sequence of symbols.
 *
 * @example
 * _.strCommonRight( 'same', 'came', 'me', 'code' );
 * // returns 'e'
 *
 * @example
 * _.strCommonRight( 'add', 'dd'+'d', 'hdd' );
 * // returns 'dd'
 *
 * @example
 * _.strCommonRight( 'abcd', 'abc', 'd' )
 * // returns ''
 *
 * @returns { String } - Returns found common symbols.
 * @function strCommonRight
 * @throws { Error } If {-ins-} is not a String.
 * @namespace Tools
 *
 */

function strCommonRight( ins )
{

  if( arguments.length === 0 )
  return '';
  if( arguments.length === 1 )
  return ins;

  _.assert( _.strIs( ins ) );

  let length = +Infinity;

  for( let a = 0 ; a < arguments.length ; a++ )
  {
    let src = arguments[ a ];
    length = Math.min( length, src.length );
  }

  let i = 0;
  for( ; i < length ; i++ )
  for( let a = 1 ; a < arguments.length ; a++ )
  {
    let src = arguments[ a ];
    if( src[ src.length - i - 1 ] !== ins[ ins.length - i - 1 ] )
    return ins.substring( ins.length-i );
  }

  return ins.substring( ins.length-i );
}

//

/**
 * Routine strRandom() makes string with random length with random symbols defined
 * by option {-o.alphabet-}.
 * Routine accepts two types of parameter. First of them is options map {-o-}, the second
 * is Number (Range) {-length-}.
 *
 * First set of parameters
 * @param { Map } o - Options map.
 * @param { Number|Range } o.length - The length of random string.
 * The generated string may has fixed length if {-o.length-} defined by a number. If {-o.length-}
 * defined by a Range, then length of generated string is variable.
 * @param { String } o.alphabet - String with symbols for generated string.
 * Default range of symbols is 'a' - 'z'.
 *
 * Second set of parameters
 * @param { Number|Range } length - The length of random string.
 * The generated string may has fixed length if {-o.length-} defined by a number. If {-o.length-}
 * defined by a Range, then length of generated string is variable.
 * @param { String } o.alphabet - String with symbols for generated string.
 *
 * @example
 * _.strRandom( 0 );
 * // returns ''
 *
 * @example
 * _.strRandom( 2 );
 * // returns 'vb'
 * // string with 2 random symbols from 'a' to 'z'
 *
 * @example
 * _.strRandom( [ 1, 5 ] )
 * // returns 'soyx'
 * // string with length from 1 to 5 and random symbols from 'a' to 'z'
 *
 * @example
 * _.strRandom( { length : 3, alphabet : 'a' } )
 * // returns 'aaa'
 * // string with length 3 and symbol 'a'
 *
 * @example
 * _.strRandom( { length : [ 1, 5 ], alphabet : 'ab' } )
 * // returns 'aabab'
 * // string with length from 1 to 5 and random symbols 'a' and 'b'
 *
 * @returns { String } - Returns string with random length and symbols.
 * @function strRandom
 * @throws { Error } If arguments.length is less or more then one.
 * @throws { Error } If options map {-o-} has unnacessary fields.
 * @throws { Error } If parameter {-length-} or option {-o.length-} is not a Number and not a Range.
 * @namespace Tools
 *
 */

function strRandom( o )
{
  if( !_.mapIs( o ) )
  o = { length : o }

  o = _.routine.options( strRandom, o );

  if( _.number.is( o.length ) )
  o.length = [ o.length, o.length+1 ];
  if( o.alphabet === null )
  o.alphabet = _.strAlphabetFromRange([ 'a', 'z' ]);

  _.assert( _.intervalIs( o.length ) );
  _.assert( arguments.length === 1 );

  let length = o.length[ 0 ];
  if( o.length[ 0 ]+1 !== o.length[ 1 ] )
  {
    length = _.intRandom( o.length );
  }

  let result = '';
  for( let i = 0 ; i < length ; i++ )
  {
    result += o.alphabet[ _.intRandom( o.alphabet.length ) ];
  }
  return result;
}

strRandom.defaults =
{
  length : null,
  alphabet : null,
}

//

/**
 * Routine strAlphabetFromRange() generates a string with a sequence of symbols started from
 * first element of {-range-} and ended on previous element before last.
 *
 * @param { Range } range - Range of symbols. It is two elements array. Elements of {-range-}
 * should have a String or a Number type.
 *
 * @example
 * _.strAlphabetFromRange( [ 97, 98 ] );
 * // returns 'a'
 *
 * @example
 * _.strAlphabetFromRange( 97, 100 );
 * // returns 'abc'
 *
 * @example
 * _.strAlphabetFromRange( [ 'a', 'b' ] );
 * // returns 'a'
 *
 * @example
 * _.strAlphabetFromRange( 'a', 'd' );
 * // returns 'abc'
 *
 * @example
 * _.strAlphabetFromRange( [ 'a', 98 ] );
 * // returns 'a'
 *
 * @example
 * _.strAlphabetFromRange( 97, 'd' );
 * // returns 'abc'
 *
 * @returns { String } - Returns string with sequence of symbols.
 * @function strAlphabetFromRange
 * @throws { Error } If arguments.length is less then one.
 * @throws { Error } If range.length is less or more then two.
 * @throws { Error } If range[ 0 ] or range[ 1 ] is not a Number and not a String.
 * @namespace Tools
 *
 */

function strAlphabetFromRange( range )
{
  _.assert( _.arrayIs( range ) && range.length === 2 )
  _.assert( _.strIs( range[ 0 ] ) || _.number.is( range[ 0 ] ) );
  _.assert( _.strIs( range[ 1 ] ) || _.number.is( range[ 1 ] ) );
  if( _.strIs( range[ 0 ] ) )
  range[ 0 ] = range[ 0 ].charCodeAt( 0 );
  if( _.strIs( range[ 1 ] ) )
  range[ 1 ] = range[ 1 ].charCodeAt( 0 );
  let result = String.fromCharCode( ... _.longFromRange([ range[ 0 ], range[ 1 ] ]) );
  return result;
}

// --
// formatter
// --

function strForRange( range )
{
  let result;

  _.assert( arguments.length === 1 );
  _.assert( _.arrayIs( range ) );

  result = '[ ' + range[ 0 ] + '..' + range[ 1 ] + ' ]';

  return result;
}

//

function strForCall()
{
  let nameOfRoutine = arguments[ 0 ];
  let args = arguments[ 1 ];
  let ret = arguments[ 2 ];
  let o = arguments[ 3 ];

  let result = nameOfRoutine + '( ';
  let first = true;

  _.assert( _.arrayIs( args ) || _.object.isBasic( args ) );
  _.assert( arguments.length <= 4 );

  _.each( args, function( e, k )
  {

    if( first === false )
    result += ', ';

    if( _.object.isBasic( e ) )
    result += k + ' :' + _.entity.exportString( e, o );
    else
    result += _.entity.exportString( e, o );

    first = false;

  });

  result += ' )';

  if( arguments.length >= 3 )
  result += ' -> ' + _.entity.exportString( ret, o );

  return result;
}

//

function strDifference( src1, src2 )
{
  _.assert( _.strIs( src1 ) );
  _.assert( _.strIs( src2 ) );

  if( src1 === src2 )
  return false;

  let l = Math.min( src1.length, src2.length );
  for( let i = 0 ; i < l ; i++ )
  if( src1[ i ] !== src2[ i ] )
  return src1.substr( 0, i ) + '*';

  return src1.substr( 0, l ) + '*';
}

// --
// transformer
// --

/**
 * Returns string with first letter converted to upper case.
 * Expects one object: the string to be formatted.
 *
 * @param {string} src - Source string.
 * @returns {String} Returns a string with the first letter capitalized.
 *
 * @example
 * _.strCapitalize( 'test string' );
 * // returns Test string
 *
 * @example
 * _.strCapitalize( 'another_test_string' );
 * // returns Another_test_string
 *
 * @method strCapitalize
 * @throws { Exception } Throw an exception if( src ) is not a String.
 * @throws { Exception } Throw an exception if( arguments.length ) is not equal 1.
 * @namespace Tools
 *
 */

function strCapitalize( src )
{
  _.assert( _.strIs( src ) );
  _.assert( arguments.length === 1, 'Expects single argument' );

  /*_.assert( src.length > 0 );*/
  /*_.assert( src.match(/(^\W)/) === null );*/

  if( src.length === 0 )
  return src;

  return src[ 0 ].toUpperCase() + src.substring( 1 );
}

//

/**
 * The routine `strDecapitalize` returns string with first letter converted to lower case.
 * Expects one object: the string to be formatted.
 *
 * @param {string} src - Source string.
 * @returns {String} Returns a string with the first letter lowercased.
 *
 * @example
 * _.strCapitalize( 'Test string' );
 * // returns test string
 *
 * @example
 * _.strCapitalize( 'Another_test_string' );
 * // returns another_test_string
 *
 * @method strDecapitalize
 * @throws { Exception } Throw an exception if( src ) is not a String.
 * @throws { Exception } Throw an exception if( arguments.length ) is not equal 1.
 * @namespace Tools
 *
 */

function strDecapitalize( src )
{
  _.assert( _.strIs( src ) );
  _.assert( arguments.length === 1, 'Expects single argument' );

  if( src.length === 0 )
  return src;

  return src[ 0 ].toLowerCase() + src.substring( 1 );
}

//

/**
 * The routine `strSign` adds {- prefix -} to a source string.
 * @param { String } src - Source string.
 * @param { String } prefix - String to be added.
 * @returns { String } Returns string with added {- prefix -} character.
 *
 * @example
 * _.strSign( 'a' );
 * // returns 'wA'
 *
 * @example
 * _.strSign( 'Tools' );
 * // returns 'wTools'
 *
 * @example
 * _.strSign( 'A', 'q' );
 * // returns 'qA'
 *
 * @method strSign
 * @throws { Exception } If( src ) is not a String.
 * @throws { Exception } If( arguments.length ) is not equal to 1.
 * @throws { Exception } If( {- prefix -}.length ) is not equal to 1.
 * @namespace Tools
 *
 */

function strSign( src, prefix )
{
  _.assert( _.strIs( src ) && src.length > 0, '{- src -} must be non empty string');
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects one or two arguments' );

  if( prefix === undefined )
  prefix = 'w';

  _.assert( prefix.length === 1 );
  _.assert( !_.strIsSigned( src, prefix ), 'Expects not signed string' );

  return prefix + src[ 0 ].toUpperCase() + src.substring( 1 );
}

//

/**
 * The routine `strDesign` removes {- prefix -} character if it's placed before uppercase letter in a source string.
 * @param { String } src - Source string.
 * @param { String } prefix - String to be removed.
 * @returns { String } Returns string with removed {- prefix -} character.
 *
 * @example
 * _.strDesign( 'wA' );
 * // returns 'A'
 *
 * @example
 * _.strDesign( 'wTools' );
 * // returns 'Tools'
 *
 * @example
 * _.strDesign( 'qA', 'q' );
 * // returns 'A'
 *
 * @method strDesign
 * @throws { Exception } If( src ) is not a String.
 * @throws { Exception } If( arguments.length ) is not equal to 1.
 * @throws { Exception } If( {- prefix -}.length ) is not equal to 1.
 * @namespace Tools
 *
 */

function strDesign( src, prefix )
{
  _.assert( _.strIs( src ) && src.length > 0, '{- src -} must be non empty string');
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects one or two arguments' );

  if( prefix === undefined )
  prefix = 'w';

  _.assert( prefix.length === 1 );
  _.assert( _.strIsSigned( src, prefix ), 'Expects signed string' );

  return src.substring( 1 );
}

//

/**
 * The routine `strIsSigned` checks a source string to be signed.
 * @param { String } src - Source string.
 * @param { String } prefix - string to be checked.
 * @returns { String } Returns true if string has {- prefix -} as the first character and a capital letter as the second, otherwise - returns false
 *
 * @example
 * _.strIsSigned( 'wa' );
 * // returns false
 *
 * @example
 * _.strIsSigned( 'wTools' );
 * // returns true
 *
 * @example
 * _.strIsSigned( 'w123' );
 * // returns false
 *
 * @example
 * _.strIsSigned( 'qA', 'q' );
 * // returns true
 *
 * @method strIsSigned
 * @throws { Exception } If( src ) is not a String.
 * @throws { Exception } If( arguments.length ) is not equal to 1.
 * @throws { Exception } If( {- prefix -}.length ) is not equal to 1.
 * @namespace Tools
 *
 */

function strIsSigned( src, prefix )
{
  _.assert( _.strIs( src ) && src.length > 0, '{- src -} must be non empty string');
  _.assert( arguments.length === 1 || arguments.length === 2, 'Expects one or two arguments' );

  if( !prefix )
  prefix = 'w';

  _.assert( prefix.length === 1 );

  return new RegExp( `^${prefix}[A-Z0-9]` ).test( src );

}

//

/**
 * Disables escaped characters in source string( src ).
 * Example: '\n' -> '\\n', '\u001b' -> '\\u001b' etc.
 * Returns string with disabled escaped characters, source string if nothing changed or  empty string if source is zero length.
 * @param {string} src - Source string.
 * @returns {string} Returns string with disabled escaped characters.
 *
 * @example
 * _.strEscape( '\nhello\u001bworld\n' );
 * // returns '\nhello\u001bworld\n'
 *
 * @example
 * _.strEscape( 'string' );
 * // returns 'string'
 *
 * @example
 * _.strEscape( 'str\'' );
 * // returns 'str\''
 *
 * @example
 * _.strEscape( '' );
 * // returns ''
 *
 * @method strEscape
 * @throw { Exception } If( src ) is not a String.
 * @namespace Tools
 *
 */

function strEscape( o )
{

  // 007f : ''
  // . . .
  // 009f : ''

  // 00ad : ''

  // \'   single quote   byte 0x27 in ASCII encoding
  // \'   double quote   byte 0x22 in ASCII encoding
  // \\   backslash   byte 0x5c in ASCII encoding
  // \b   backspace   byte 0x08 in ASCII encoding
  // \f   form feed - new page   byte 0x0c in ASCII encoding
  // \n   line feed - new line   byte 0x0a in ASCII encoding
  // \r   carriage return   byte 0x0d in ASCII encoding
  // \t   horizontal tab   byte 0x09 in ASCII encoding
  // \v   vertical tab   byte 0x0b in ASCII encoding
  // source : http://en.cppreference.com/w/cpp/language/escape

  if( _.strIs( o ) )
  o = { src : o }

  _.assert( _.strIs( o.src ), 'Expects string {-o.src-}, but got', _.entity.strType( o.src ) );
  _.routine.options( strEscape, o );

  let result = '';
  let stringWrapperCode = o.stringWrapper.charCodeAt( 0 );
  for( let s = 0 ; s < o.src.length ; s++ )
  {
    let code = o.src.charCodeAt( s );

    if( o.stringWrapper === '`' && code === 0x24 /* $ */ )
    {
      result += '\\$';
    }
    else if( o.stringWrapper && code === stringWrapperCode )
    {
      result += '\\' + o.stringWrapper;
    }
    else if( 0x007f <= code && code <= 0x009f || code === 0x00ad /*|| code >= 65533*/ )
    {
      result += _.strCodeUnicodeEscape( code );
    }
    else switch( code )
    {

      case 0x5c /* '\\' */ :
        result += '\\\\';
        break;

      case 0x08 /* '\b' */ :
        result += '\\b';
        break;

      case 0x0c /* '\f' */ :
        result += '\\f';
        break;

      case 0x0a /* '\n' */ :
        result += '\\n';
        break;

      case 0x0d /* '\r' */ :
        result += '\\r';
        break;

      case 0x09 /* '\t' */ :
        result += '\\t';
        break;

      // /* xxx : extend coverage of routine _.strEscape. don't forget this test case */
      // case 0x0b /* '\v' */ :
      //   result += '\\v';
      //   break;

      default :
        if( code < 32 )
        {
          result += _.strCodeUnicodeEscape( code );
        }
        else
        {
          result += String.fromCharCode( code );
        }

    }

  }

  return result;
}

strEscape.defaults =
{
  src : null,
  stringWrapper : '\'',
  charsToEscape : null, /* xxx : qqq : implement */
}

//

/**
 * Converts number {-code-} into unicode representation.
 * Returns result of conversion as new string.
 *
 * @param { Number } code - The code to convert into unicode representation.
 *
 * @example
 * _.strCodeUnicodeEscape( 70 );
 * // returns '\\u0046'
 *
 * @example
 * _.strCodeUnicodeEscape( 77 );
 * // returns '\\u004d'
 *
 * @returns { String } - Returns string with result of conversion.
 * @function strCodeUnicodeEscape
 * @throws { Exception } If arguments.length is less or more then one.
 * @throws { Exception } If {-src-} is not a Number.
 * @namespace Tools
 *
 */

function strCodeUnicodeEscape( code )
{
  let result = '';

  _.assert( _.number.is( code ) );
  _.assert( arguments.length === 1, 'Expects single argument' );

  let h = code.toString( 16 );
  let d = _.strDup( '0', 4-h.length ) + h;

  result += '\\u' + d;

  return result;
}

//

/**
 * Converts source string {-str-} into unicode representation by replacing each symbol with its escaped unicode equivalent.
 * Returns result of conversion as new string or empty string if source has zero length.
 *
 * @param { String } str - Source string to parse.
 *
 * @example
 * _.strUnicodeEscape( 'abc' );
 * // returns \u0061\u0062\u0063;
 *
 * @example
 * _.strUnicodeEscape( 'world' );
 * // returns \u0077\u006f\u0072\u006c\u0064
 *
 * @example
 * _.strUnicodeEscape( '//test//' );
 * // returns \u002f\u002f\u0074\u0065\u0073\u0074\u002f\u002f
 *
 * @returns { String } - Returns string with result of conversion.
 * @function strUnicodeEscape
 * @throws { Exception } If arguments.length is less or more then one.
 * @throws { Exception } If {-src-} is not a String.
 * @namespace Tools
 *
 */

function strUnicodeEscape( src )
{
  let result = '';

  _.assert( _.strIs( src ) );
  _.assert( arguments.length === 1, 'Expects single argument' );

  for( let i = 0 ; i < src.length ; i++ )
  {
    let code = src.charCodeAt( i );
    result += _.strCodeUnicodeEscape( code );
  }

  return result;
}

//

function strReverse( srcStr )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  let result = '';
  for( let i = 0 ; i < srcStr.length ; i++ )
  result = srcStr[ i ] + result;
  return result;
}

// --
// splitter
// --

/**
 * Parses a source string( src ) and separates numbers and string values
 * in to object with two properties: 'str' and 'number', example of result: ( { str: 'bd', number: 1 } ).
 *
 * @param {string} src - Source string.
 * @returns {object} Returns the object with two properties:( str ) and ( number ),
 * with values parsed from source string. If a string( src ) doesn't contain number( s ),
 * function returns the object with value of string( src ).
 *
 * @example
 * _.strSplitStrNumber( 'bd1' );
 * // returns { str: 'bd', number: 1 }
 *
 * @example
 * _.strSplitStrNumber( 'bdxf' );
 * // returns { str: 'bdxf' }
 *
 * @method strSplitStrNumber
 * @throws { Exception } Throw an exception if( src ) is not a String.
 * @throws { Exception } Throw an exception if no argument provided.
 * @namespace Tools
 *
 */

function strSplitStrNumber( src )
{
  let result = Object.create( null );

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) );

  let mnumber = src.match(/\d+/);
  if( mnumber && mnumber.length )
  {
    let mstr = src.match(/[^\d]*/);
    result.str = mstr[ 0 ];
    result.number = _.number.from( mnumber[ 0 ] );
  }
  else
  {
    result.str = src;
  }

  return result;
}

//

function strSplitChunks( o )
{
  let result = Object.create( null );
  result.chunks = [];

  if( arguments.length === 2 )
  {
    o = arguments[ 1 ] || Object.create( null );
    o.src = arguments[ 0 ];
  }
  else
  {
    _.assert( arguments.length === 1, 'Expects single argument' );
    if( _.strIs( arguments[ 0 ] ) )
    o = { src : arguments[ 0 ] };
  }

  _.routine.options( strSplitChunks, o );
  _.assert( _.strIs( o.src ), 'Expects string (-o.src-), but got', _.entity.strType( o.src ) );

  if( !_.regexpIs( o.prefix ) )
  o.prefix = RegExp( _.regexpEscape( o.prefix ), 'm' );

  if( !_.regexpIs( o.postfix ) )
  o.postfix = RegExp( _.regexpEscape( o.postfix ), 'm' );

  let src = o.src;

  /* */

  let line = 0;
  let column = 0;
  let chunkIndex = 0;
  let begin = -1;
  let end = -1;
  do
  {

    /* begin */

    begin = src.search( o.prefix );
    if( begin === -1 ) begin = src.length;

    /* text chunk */

    if( begin > 0 )
    makeChunkStatic( begin );

    /* break */

    if( !src )
    {
      if( !result.chunks.length )
      makeChunkStatic( 0 );
      break;
    }

    /* end */

    end = src.search( o.postfix );
    if( end === -1 )
    {
      result.lines = _.str.lines.split( src ).length;
      result.error = _.err( 'Openning prefix', o.prefix, 'of chunk #' + result.chunks.length, 'at'+line, 'line does not have closing tag :', o.postfix );
      return result;
    }

    /* code chunk */

    let chunk = makeChunkDynamic();

    /* wind */

    chunkIndex += 1;
    line += _.strLinesCount( chunk.prefix + chunk.code + chunk.postfix ) - 1;

  }
  while( src );

  return result;

  /* - */

  function colAccount( text )
  {
    let i = text.lastIndexOf( '\n' );

    if( i === -1 )
    {
      column += text.length;
    }
    else
    {
      column = text.length - i;
    }

    _.assert( column >= 0 );
  }

  /* - */

  function makeChunkStatic( begin )
  {
    let chunk = Object.create( null );
    chunk.line = line;
    chunk.text = src.substring( 0, begin );
    chunk.index = chunkIndex;
    chunk.kind = 'static';
    result.chunks.push( chunk );

    src = src.substring( begin );
    line += _.strLinesCount( chunk.text ) - 1;
    chunkIndex += 1;

    colAccount( chunk.text );
  }

  /* - */

  function makeChunkDynamic()
  {
    let chunk = Object.create( null );
    chunk.line = line;
    chunk.column = column;
    chunk.index = chunkIndex;
    chunk.kind = 'dynamic';
    chunk.prefix = src.match( o.prefix )[ 0 ];
    chunk.code = src.substring( chunk.prefix.length, end );
    if( o.investigate )
    {
      chunk.lines = _.str.lines.split( chunk.code );
      chunk.tab = /^\s*/.exec( chunk.lines[ chunk.lines.length-1 ] )[ 0 ];
    }

    /* postfix */

    src = src.substring( chunk.prefix.length + chunk.code.length );
    chunk.postfix = src.match( o.postfix )[ 0 ];
    src = src.substring( chunk.postfix.length );

    result.chunks.push( chunk );
    return chunk;
  }

}

strSplitChunks.defaults =
{
  src : null,
  investigate : 1,
  prefix : '//>-' + '->//',
  postfix : '//<-' + '-<//',
}

//

/*
aaa : cover it by test
Dmytro : covered,

maybe, routine needs assertion
_.assert( arguments.length === 1, 'Expects one argument' );
if assertion will be accepted, then test.case = 'a few arguments' will throw error
*/

function strSplitCamel( src )
{

  let splits = _.strSplitFast( src, /[A-Z]/ );

  for( let s = splits.length-2 ; s >= 0 ; s-- )
  {
    if( s % 2 === 1 )
    splits.splice( s, 2, splits[ s ].toLowerCase() + splits[ s + 1 ] );
  }

  return splits;
}

// --
// extractor
// --

/**
 * Routine _strOnly() gets substring out of source string {-srcStr-} according to a given range {-range-}.
 * The end value of the range is not included in the substring.
 *
 * @param { String } srcStr - Source string.
 * @param { Range } range - Range to get substring.
 * If range[ 0 ] or range[ 1 ] is less then 0, then reference point is length of source string {-srcStr-}.
 *
 * @example
 * _._strOnly( '', [ 0, 2 ] );
 * // returns ''
 *
 * @example
 * _._strOnly( 'first', [ 0, 7 ] );
 * // returns 'first'
 *
 * @example
 * _._strOnly( 'first', [ 0, 2 ] );
 * // returns 'fi'
 *
 * @example
 * _._strOnly( 'first', [ -2, 5 ] );
 * // returns 'st'
 *
 * @example
 * _._strOnly( 'first', [ 2, 2 ] );
 * // returns ''
 *
 * @function _strOnly
 * @returns { String } - Returns substring from source string.
 * @throws { Error } If arguments.length is less or more then two.
 * @throws { Error } If {-srcStr-} is not a String.
 * @throws { Error } If {-range-} is not a Range.
 * @namespace Tools
 */

function _strOnly( srcStr, cinterval )
{

  /*
    _.strOnly( 'abc', [ -2, -1 ] ) => 'b'
    _.strOnly( 'abc', [ 1, 2 ] ) => 'b'

    3-2 = 1
    3-1 = 2
  */

  if( _.number.is( cinterval ) )
  {
    if( cinterval < 0 )
    cinterval = srcStr.length + cinterval;
    cinterval = [ cinterval, cinterval ];
  }
  else
  {
    cinterval = _.long.make( cinterval ); /* Dmytro : vectorized routine should not change original range */

    if( cinterval[ 1 ] < -1 )
    cinterval[ 1 ] = srcStr.length + cinterval[ 1 ];
    if( cinterval[ 0 ] < 0 )
    cinterval[ 0 ] = srcStr.length + cinterval[ 0 ];
  }

  if( cinterval[ 0 ] > cinterval[ 1 ] )
  cinterval[ 1 ] = cinterval[ 0 ] - 1;

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( srcStr ) );
  _.assert( _.cinterval.defined( cinterval ) );

  return srcStr.substring( cinterval[ 0 ], cinterval[ 1 ] + 1 );
}

//

/**
 * Routine strOnly() gets substring out of each string in vector of strings {-srcStr-} according to a given range {-range-}.
 * The end value of the range is not included in the substring.
 *
 * @param { String|Long } srcStr - Source string or array of strings.
 * @param { Range } range - Range to get substring.
 * If range[ 0 ] or range[ 1 ] is less then 0, then reference point is length of source string {-srcStr-}.
 *
 * @example
 * _.strOnly( '', [ 0, 1 ] );
 * // returns ''
 *
 * @example
 * _.strOnly( 'first', [ 0, 6 ] );
 * // returns 'first'
 *
 * @example
 * _.strOnly( 'first', [ 0, 1 ] );
 * // returns 'fi'
 *
 * @example
 * _.strOnly( 'first', [ -2, 4 ] );
 * // returns 'st'
 *
 * @example
 * _.strOnly( 'first', [ 2, 1 ] );
 * // returns ''
 *
 * @example
 * _.strOnly( [ '', 'a', 'ab', 'abcde' ], [ 0, 1 ] );
 * // returns [ '', 'a', 'ab', 'ab' ]
 *
 * @example
 * _.strOnly( [ '', 'a', 'ab', 'abcde' ], [ 0, 6 ] );
 * // returns [ '', 'a', 'ab', 'abcde' ]
 *
 * @example
 * _.strOnly( [ '', 'a', 'ab', 'abcde' ], [ -2, 4 ] );
 * // returns [ '', 'a', 'ab', 'de' ]
 *
 * @example
 * _.strOnly( [ '', 'a', 'ab', 'abcde' ], [ 2, 1 ] );
 * // returns[ '', '', '', '' ]
 *
 * @function strOnly
 * @returns { String|Long } - Returns substrings from source string or array of strings.
 * @throws { Error } If arguments.length is less or more then two.
 * @throws { Error } If {-srcStr-} is not a String, not a Long.
 * @throws { Error } If {-srcStr-} is a Long and includes not a String value.
 * @throws { Error } If {-range-} is not a Range.
 * @namespace Tools
 */

let strOnly = _.vectorize( _strOnly );

//

// srcStr:str ins:str -> str
// srcStr:str ins:[ * str ] -> [ * str ]
// srcStr:[ * str ] ins:[ * str ] -> [ * str ]

/**
 * Routine _strBut() replaces substring from source string {-srcStr-} to new value {-ins-}
 * The ranges of substring defines according to a given range {-cinterval-}.
 * The end value of the range is included in the substring.
 *
 * @example
 * _._strBut( '', [ 0, 2 ] );
 * // returns : ''
 *
 * @example
 * _._strBut( 'first', [ 0, 7 ] );
 * // returns : ''
 *
 * @example
 * _._strBut( 'first', [ 0, 1 ] );
 * // returns : 'rst'
 *
 * @example
 * _._strBut( 'first', [ -2, 4 ] );
 * // returns : 'firt'
 *
 * @example
 * _._strBut( 'first', [ 2, 1 ] );
 * // returns : 'first'
 *
 * @example
 * _._strBut( 'first', [ 0, 1 ], 'abc' );
 * // returns : 'abcrst'
 *
 * @example
 * _._strBut( 'first', [ 0, 1 ], [ 'a', 'b', 'c' ] );
 * // returns : [ 'arst', 'brst', 'crst' ]
 *
 * @example
 * _._strBut( 'first', [ 2, 1 ], 'abc' );
 * // returns : [ 'fiarst', 'fibrst', 'ficrst' ]
 *
 * @param { String } srcStr - Source string.
 * @param { Crange } cinterval - Closed range to get substring.
 * If cinterval[ 0 ] or cinterval[ 1 ] is less then 0, then reference point is length of source string {-srcStr-}.
 * @param { String|Long } ins - Inserted string or array with inserted elements.
 * If {-ins-} is a Long, then routine concatenates string from elements of Long. The delimeter is single space.
 * If {-ins-} is not provided or if it is undefined, then routine removes substring from source string to a given range.
 * @function _strBut
 * @returns { String } - Returns source string, part of which replaced to the new value.
 * @throws { Error } If arguments.length is less then two or more then three.
 * @throws { Error } If {-srcStr-} is not a String.
 * @throws { Error } If {-range-} is not a Range.
 * @throws { Error } If {-ins-} is not a String, not a Long, not undefined.
 * @namespace Tools
 */

function _strBut( srcStr, cinterval, ins )
{


  /*
  aaa : reference point of negative is length. implement and cover please
  Dmytro : implemented a time ago
  */

  if( _.number.is( cinterval ) )
  {
    if( cinterval < 0 )
    cinterval = srcStr.length + cinterval;
    cinterval = [ cinterval, cinterval ];
  }
  else
  {
    cinterval = _.long.make( cinterval ); /* Dmytro : vectorized routine should not change original range */

    if( cinterval[ 1 ] < -1 )
    cinterval[ 1 ] = srcStr.length + cinterval[ 1 ];
    if( cinterval[ 0 ] < 0 )
    cinterval[ 0 ] = srcStr.length + cinterval[ 0 ];
  }

  if( cinterval[ 0 ] > cinterval[ 1 ] )
  cinterval[ 1 ] = cinterval[ 0 ] - 1;

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.strIs( srcStr ) );
  _.assert( _.cinterval.defined( cinterval ) );
  _.assert( ins === undefined || _.strIs( ins ) || _.longIs( ins ) );

  /*
     aaa : implement for case ins is long
     Dmytro : implemented, elements of long joins by spaces
     aaa for Dmytro : no really
     Dmytro : fixed
  */

  let result;
  if( _.longIs( ins ) )
  {
    result = _.array.make( ins.length );
    for( let i = 0 ; i < ins.length ; i++ )
    result[ i ] = _strConcat( srcStr, cinterval, ins[ i ] );
  }
  else
  {
    result = _strConcat( srcStr, cinterval, ins ? ins : '' );
  }

  return result;

  /* */

  function _strConcat( src, range, insertion )
  {
    return src.substring( 0, range[ 0 ] ) + insertion + src.substring( range[ 1 ] + 1, src.length );
  }
}

//

/**
 * Routine strBut() gets substring out of each string in vector of strings {-srcStr-} according to a given range {-range-}
 * and replaces it to new string {-ins-}.
 * The end value of the range is not included in the substring.
 *
 * @param { String|Long } srcStr - Source string or array of strings.
 * @param { Range } range - Range to get substring.
 * If range[ 0 ] or range[ 1 ] is less then 0, then reference point is length of source string {-srcStr-}.
 * @param { String|Long } ins - Inserted string or array with inserted elements.
 * If {-ins-} is a Long, then routine concatenates string from elements of Long. The delimeter is single space.
 * If {-ins-} is not provided or if it is undefined, then routine removes substring from source string to a given range.
 *
 * @example
 * _.strBut( '', [ 0, 2 ] );
 * // returns ''
 *
 * @example
 * _.strBut( 'first', [ 0, 7 ] );
 * // returns ''
 *
 * @example
 * _.strBut( 'first', [ 0, 2 ], 'abc' );
 * // returns 'abcrst'
 *
 * @example
 * _.strBut( 'first', [ -2, 5 ], [ 'a', 'b', 'c' ] );
 * // returns 'fira b c'
 *
 * @example
 * _.strBut( [ '', 'a', 'ab', 'abcde' ], [ 0, 2 ], 'fg' );
 * // returns [ 'fg', 'fg', 'fg', 'fgcde' ]
 *
 * @example
 * _.strBut( [ '', 'a', 'ab', 'abcde' ], [ 0, 7 ], [ 'f', 'g' ] );
 * // returns [ 'f g', 'f g', 'f g', 'f g' ]
 *
 * @example
 * _.strBut( [ '', 'a', 'ab', 'abcde' ], [ -2, 5 ], 'fg' );
 * // returns [ 'fg', 'fg', 'fg', 'abcfg' ]
 *
 * @example
 * _.strBut( [ '', 'a', 'ab', 'abcde' ], [ 2, 2 ], [ 'f', 'g' ] );
 * // returns [ 'f g', 'af g', 'abf g', 'abf gcde' ]
 *
 * @function strBut
 * @returns { String|Long } - Returns source string or vector of strings, part of which replaced to the new value.
 * @throws { Error } If arguments.length is less then two or more then three.
 * @throws { Error } If {-srcStr-} is not a String or not a Long.
 * @throws { Error } If {-srcStr-} is a Long and includes not a String value.
 * @throws { Error } If {-range-} is not a Range.
 * @throws { Error } If {-ins-} is not a String, not a Long, not undefined.
 * @namespace Tools
 */

let strBut = _.vectorize( _strBut );

//

/**
 * Routine strUnjoin() splits string {-srcStr-} into parts using array {-maskArray-} as mask and returns an array with splitted parts.
 * Mask {-maskArray-} contains string(s) separated by marker ( strUnjoin.any ). Mask must starts/ends with first/last letter from source
 * or can be replaced with marker ( strUnjoin.any ). Position of ( strUnjoin.any ) determines which part of source string will be splited:
 * - If ( strUnjoin.any ) is provided before string, it marks everything before that string. Example: ( [ _.strUnjoin.any, 'postfix' ] ).
 * - If ( strUnjoin.any ) is provided after string, it marks everything after that string. Example: ( [ 'prefix', _.strUnjoin.any ] ).
 * - If ( strUnjoin.any ) is provided between two strings, it marks everything between them. Example: ( [ 'prefix', _.strUnjoin.any, 'postfix' ] ).
 * - If ( strUnjoin.any ) is provided before and after string, it marks all except that string. Example: ( [ '_.strUnjoin.any', something, '_.strUnjoin.any' ] ).
 *
 * @param {string} srcStr - Source string.
 * @param {array} maskArray - Contains mask for source string.
 *
 * @example
 * _.strUnjoin( 'prefix_something_postfix', [ 'prefix', _.strUnjoin.any, 'postfix' ] );
 * // returns [ 'prefix', '_something_', 'postfix' ]
 *
 * @example
 * _.strUnjoin( 'prefix_something_postfix', [ _.strUnjoin.any, 'something', _.strUnjoin.any, 'postfix' ] );
 * // returns [ 'prefix_', 'something', '_', 'postfix' ]
 *
 * @example
 * _.strUnjoin( 'prefix_something_postfix', [ _.strUnjoin.any, 'postfix' ] );
 * // returns [ 'prefix_something_', 'postfix' ]
 *
 * @example
 * _.strUnjoin( 'prefix_something_postfix', [ 'prefix', _.strUnjoin.any ] );
 * // returns [ 'prefix', '_something_postfix' ]
 *
 * @example
 * _.strUnjoin( 'prefix_something_postfix', [ _.strUnjoin.any, 'x', _.strUnjoin.any, 'p', _.strUnjoin.any ] );
 * // returns [ 'prefi', 'x', '_something_', 'p', 'ostfix' ]
 *
 * @returns {array} Returns array with unjoined string part.
 * @function strUnjoin
 * @throws { Exception } If arguments.length is less or more then two.
 * @throws { Exception } If {-srcStr-} is not a String.
 * @throws { Exception } If {-maskArray-} is not an Array.
 * @throws { Exception } If {-maskArray-} value is not String or strUnjoin.any.
 * @namespace Tools
 *
 */

function strUnjoin( srcStr, maskArray )
{

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( srcStr ) );
  _.assert( _.arrayIs( maskArray ) );

  let result = [];
  let index = 0;
  let rindex = -1;

  /**/

  for( let m = 0 ; m < maskArray.length ; m++ )
  {

    let mask = maskArray[ m ];

    if( !checkMask( mask ) )
    return;

  }

  if( rindex !== -1 )
  {
    index = srcStr.length;
    if( !checkToken() )
    return;
  }

  if( index !== srcStr.length )
  return;

  /**/

  return result;

  /**/

  function checkToken()
  {

    if( rindex !== -1 )
    {
      _.assert( rindex <= index );
      result.push( srcStr.substring( rindex, index ) );
      rindex = -1;
      return true;
    }

    return false;
  }

  /**/

  function checkMask( mask )
  {

    _.assert( _.strIs( mask ) || mask === strUnjoin.any, 'Expects string or strUnjoin.any, got', _.entity.strType( mask ) );

    if( _.strIs( mask ) )
    {
      index = srcStr.indexOf( mask, index );

      if( index === -1 )
      return false;

      if( rindex === -1 && index !== 0 )
      return false;

      checkToken();

      result.push( mask );
      index += mask.length;

    }
    else if( mask === strUnjoin.any )
    {
      rindex = index;
    }
    else _.assert( 0, 'unexpected mask' );

    return true;
  }

}

strUnjoin.any = _.any;
_.assert( _.routine.is( strUnjoin.any ) );

// --
// joiner
// --

/**
 * Routine _strDup() returns a string with the source string appended to itself n-times.
 * Expects two parameter: source string {-s-} ( or array of strings ) and number of concatenations {-times-}.
 * The string {-s-}  and the number {-times-} remain unchanged.
 *
 * @param { Array/String } s - Source array of strings or source string.
 * @param { Number } times - Number of concatenation cycles.
 *
 * @example
 * _.strDup( 'Word', 5 );
 * // returns WordWordWordWordWord
 *
 * @example
 * _.strDup( '1 '+'2', 2 );
 * // returns 1 21 2
 *
 * @example
 * _.strDup( [ 'ab', 'd', '3 4'], 2 );
 * // returns [ 'abab', 'dd', '3 43 4']
 *
 * @returns { String|Array } - Returns a string or an array of string containing the src string concatenated n-times.
 * @function strDup
 * @throws { Exception } If arguments.length is less or more then two.
 * @throws { Exception } If {-s-} is not a String or an array of strings.
 * @throws { Exception } If {-times-} is not a Number.
 * @namespace Tools
 */

function _strDup( s, times )
{
  let result = '';

  _.assert( arguments.length === 2, 'Expects exactly two arguments' );
  _.assert( _.strIs( s ) );
  _.assert( _.number.is( times ) );

  for( let t = 0 ; t < times ; t++ )
  result += s;

  return result;
}

//

/**
 * Joins objects inside the source array, by concatenating their values in order that they are specified.
 * The source array can contain strings, numbers and arrays. If arrays are provided, they must have same length.
 * Joins arrays by concatenating all elements with same index into one string and puts it into new array at same position.
 * Joins array with other object by concatenating each array element with that object value. Examples: ( [ [ 1, 2 ], 3 ] ) -> ( [ '13', '23' ] ),
 * ( [ [ 1, 2 ], [ 1, 2] ] ) -> ( [ '11', '22' ] ).
 * An optional second string argument can be passed to the function. This argument ( joiner ) defines the string that joins the
 * srcArray objects.  Examples: ( [ [ 1, 2 ], 3 ], '*' ) -> ( [ '1*3', '2*3' ] ),
 * ( [ [ 1, 2 ], [ 1, 2 ] ], ' to ' ) -> ( [ '1 to 1', '2 to 2' ] ).
 *
 * @param { Array-like } srcs - Source array with the provided objects.
 * @param { String } joiner - Optional joiner parameter.
 * @returns { Object } Returns concatenated objects as string or array. Return type depends from arguments type.
 *
 * @example
 * _.strJoin([ 1, 2, 3 ]);
 * // returns '123'
 *
 * @example
 * _.strJoin([ [ 1, 2, 3 ], 2 ]);
 * // returns [ '12', '22', '32' ]
 *
 * @example
 * _.strJoin([ [ 1, 2 ], [ 1, 3 ] ]);
 * // returns [ '11', '23' ]
 *
 * @example
 * _.strJoin([ 1, 2, [ 3, 4, 5 ], [ 6, 7, 8 ] ]);
 * // returns [ '1236', '1247', '1258' ]
 *
 * @example
 * _.strJoin([ 1, 2, [ 3, 4, 5 ], [ 6, 7, 8 ] ], ' ');
 * // returns [ '1 2 3 6', '1 2 4 7', '1 2 5 8' ]
 *
 * @method strJoin
 * @throws { Exception } If ( arguments.length ) is not one or two.
 * @throws { Exception } If some object from( srcs ) is not a Array, String or Number.
 * @throws { Exception } If length of arrays in srcs is different.
 * @throws { Exception } If ( joiner ) is not undefined or a string .
 * @namespace Tools
 *
 */

function strJoin_head( routine, args )
{

  let o = args[ 0 ];
  if( args[ 1 ] !== undefined || _.argumentsArray.like( args[ 0 ] ) )
  o = { srcs : args[ 0 ], join : ( args.length > 1 ? args[ 1 ] : null ) };

  _.routine.options( routine, o );

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2, () => 'Expects an array of string and optional join, but got ' + args.length + ' arguments' );
  _.assert( _.argumentsArray.like( o.srcs ), () => 'Expects an array of strings, but got ' + _.entity.strType( o.srcs ) );
  _.assert( o.join === undefined || o.join === null || _.strIs( o.join ), () => 'Expects optional join, but got ' + _.entity.strType( o.join ) );

  return o;
}

//

/* xxx : review */
// function strJoin_body( srcs, delimeter )
function strJoin_body( o )
{
  // let result = [ '' ];
  // let arrayEncountered = 0;
  let arrayLength;

  _.routine.assertOptions( strJoin_body, arguments );

  let delimeter = o.join || '';
  if( o.join === null || o.join === undefined || _.strIs( o.join ) )
  o.join = join;

  // debugger;

  if( !o.srcs.length )
  return [];

  /* */

  for( let a = 0 ; a < o.srcs.length ; a++ )
  {
    let src = o.srcs[ a ];

    if( _.arrayIs( src ) )
    {
      _.assert( arrayLength === undefined || arrayLength === src.length, 'All arrays should have the same length' );
      arrayLength = src.length;
    }

  }

  if( arrayLength === 0 )
  return [];

  /* */

  if( arrayLength === undefined )
  {
    let result = '';

    for( let a = 0 ; a < o.srcs.length ; a++ )
    {
      let src = o.srcs[ a ];
      let srcStr = o.str( src );
      _.assert( _.strIs( srcStr ), () => 'Expects primitive or array, but got ' + _.entity.strType( src ) );
      result = o.join( result, srcStr, a );
    }

    return result;
  }
  else
  {

    let result = [];
    for( let i = 0 ; i < arrayLength ; i++ )
    result[ i ] = '';

    for( let a = 0 ; a < o.srcs.length ; a++ )
    {
      let src = o.srcs[ a ];

      // _.assert( _.strIs( srcStr ) || _.arrayIs( src ), () => 'Expects primitive or array, but got ' + _.entity.strType( src ) );
      // _.assert( _.strIs( src ) || _.number.is( src ) || _.arrayIs( src ) );

      if( _.arrayIs( src ) )
      {

        // if( arrayEncountered === 0 )
        // for( let s = 1 ; s < src.length ; s++ )
        // result[ s ] = result[ 0 ];

        // _.assert( arrayLength === undefined || arrayLength === src.length, 'All arrays should have the same length' );
        // arrayLength = src.length;

        // arrayEncountered = 1;
        for( let s = 0 ; s < result.length ; s++ )
        result[ s ] = o.join( result[ s ], src[ s ], a );

      }
      else
      {

        let srcStr = o.str( src );
        _.assert( _.strIs( srcStr ), () => 'Expects primitive or array, but got ' + _.entity.strType( src ) );
        for( let s = 0 ; s < result.length ; s++ )
        result[ s ] = o.join( result[ s ], srcStr, a );

      }

    }

    return result;
  }

  /* */

  /* qqq : investigate */

  if( arrayEncountered )
  return result;
  else
  return result[ 0 ];

  /* */

  function join( result, src, a )
  {
    if( delimeter && a > 0 )
    return result + delimeter + src;
    else
    return result + src;
  }

}

strJoin_body.defaults =
{
  srcs : null,
  join : null,
  str : _.entity.strPrimitive,
}

let strJoin = _.routine.unite( strJoin_head, strJoin_body );

//

/**
 * Routine strJoinPath() joins objects inside the source array, by concatenating their values in order that they are specified.
 * The source array can contain strings, numbers and arrays. If arrays are provided, they must have same length.
 * Joins arrays by concatenating all elements with same index into one string and puts it into new array at same position.
 * Joins array with other object by concatenating each array element with that object value.
 * Examples: ( [ [ 1, 2 ], 3 ], '' ) -> ( [ '13', '23' ] ), ( [ [ 1, 2 ], [ 1, 2] ] ) -> ( [ '11', '22' ], '' ).
 * Second argument should be string type. This argument ( joiner ) defines the string that joins the
 * srcArray objects.  Examples: ( [ [ 1, 2 ], 3 ], '*' ) -> ( [ '1*3', '2*3' ] ),
 * ( [ [ 1, 2 ], [ 1, 2 ] ], ' to ' ) -> ( [ '1 to 1', '2 to 2' ] ).
 * If the ( srcs ) objects has ( joiner ) at begin or end, ( joiner ) will be replaced. ( joiner ) replaced only between joined objects.
 * Example: ( [ '/11/', '//22//', '/3//' ], '/' ) --> '/11//22//3//'
 *
 * @param { Array-like } srcs - Source array with the provided objects.
 * @param { String } joiner - Joiner parameter.
 *
 * @example
 * _.strJoinPath( [ 1, 2, 3 ], '' );
 * // returns '123'
 *
 * @example
 * _.strJoinPath( [ [ '/a//', 'b', '//c//' ], 2 ], '/' );
 * // returns '/a//b//c//'
 *
 * @example
 * _.strJoinPath( [ [ 1, 2 ], [ 1, 3 ] ], '.');
 * // returns [ '1.1', '2.3' ]
 *
 * @example
 * _.strJoinPath( [ 1, 2, [ 3, 4, 5 ], [ 6, 7, 8 ] ], ',');
 * // returns [ '1,2,3,6', '1,2,4,7', '1,2,5,8' ]
 *
 * @method strJoinPath
 * @returns { String|Array-like } Returns concatenated objects as string or array. Return type depends from arguments type.
 * @throws { Exception } If ( arguments.length ) is less or more than two.
 * @throws { Exception } If some object from ( srcs ) is not a Array, String or Number.
 * @throws { Exception } If length of arrays in ( srcs ) is different.
 * @throws { Exception } If ( joiner ) is not a string.
 * @namespace Tools
 *
 */

function strJoinPath( srcs, joiner )
{
  let result = [ '' ];
  let arrayEncountered = 0;
  let arrayLength;

  _.assert( arguments.length === 2, () => 'Expects an array of string and joiner, but got ' + arguments.length + ' arguments' );
  _.assert( _.argumentsArray.like( srcs ), () => 'Expects an array of strings, but got ' + _.entity.strType( srcs ) );
  _.assert( _.strIs( joiner ), () => 'Expects joiner, but got ' + _.entity.strType( joiner ) );

  /* xxx : investigate */

  for( let a = 0 ; a < srcs.length ; a++ )
  {
    let src = srcs[ a ];

    _.assert( _.strIs( src ) || _.number.is( src ) || _.arrayIs( src ) );

    if( _.arrayIs( src ) )
    {

      if( arrayEncountered === 0 )
      {
        for( let s = 1 ; s < src.length ; s++ )
        result[ s ] = result[ 0 ];
      }

      _.assert( arrayLength === undefined || arrayLength === src.length, 'All arrays should have the same length' );
      arrayLength = src.length;

      arrayEncountered = 1;
      for( let s = 0 ; s < src.length ; s++ )
      join( src[ s ], s, a );

    }
    else
    {

      for( let s = 0 ; s < result.length ; s++ )
      join( src, s, a );

    }

  }

  if( arrayEncountered )
  return result;
  else
  return result[ 0 ];

  /* */

  function join( src, s, a )
  {
    if( _.number.is( src ) )
    src = src.toString();

    if( a > 0 && joiner )
    {
      let ends = _.strEnds( result[ s ], joiner );
      let begins = _.strBegins( src, joiner );
      if( begins && ends )
      result[ s ] = _.strRemoveEnd( result[ s ], joiner ) + src;
      else if( begins || ends )
      result[ s ] += src;
      else
      result[ s ] += joiner + src;
    }
    else
    {
      result[ s ] += src;
    }
  }
}

// --
// liner
// --

/**
 * Adds indentation character(s) to passed string.
 * If( src ) is a multiline string, function puts indentation character( tab ) before first
 * and every next new line in a source string( src ).
 * If( src ) represents single line, function puts indentation at the begining of the string.
 * If( src ) is a Array, function prepends indentation character( tab ) to each line( element ) of passed array.
 *
 * @param { String/Array } src - Source string to parse or array of lines( not array of texts ).
 * With line we mean it does not have eol. Otherwise please join the array to let the routine to resplit the text,
 * like that: _.strLinesIndentation( array.join( '\n' ), '_' ).
 * @param { String } tab - Indentation character.
 * @returns { String } Returns indented string.
 *
 * @example
 *  _.strLinesIndentation( 'abc', '_' )
 * // returns '_abc'
 *
 * @example
 * _.strLinesIndentation( 'a\nb\nc', '_' )
 * // returns
 * // _a
 * // _b
 * // _c
 *
 * @example
 * _.strLinesIndentation( [ 'a', 'b', 'c' ], '_' )
 * // returns
 * // _a
 * // _b
 * // _c
 *
 * @example
 * let array = [ 'a\nb', 'c\nd' ];
 * _.strLinesIndentation( array.join( '\n' ), '_' )
 * // returns
 * // _a
 * // _b
 * // _c
 * // _d
 *
 * @method strLinesIndentation
 * @throws { Exception } Throw an exception if( src ) is not a String or Array.
 * @throws { Exception } Throw an exception if( tab ) is not a String.
 * @throws { Exception } Throw an exception if( arguments.length ) is not a equal 2.
 * @namespace Tools
 *
 */

function strLinesIndentation( src, tab, every )
{

  if( every === undefined )
  every = true;

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.strIs( src ) || _.arrayIs( src ), 'Expects src as string or array' );
  _.assert( _.strIs( tab ) || _.number.is( tab ), 'Expects tab as string or number' );
  _.assert( every === undefined || _.bool.like( every ) );

  if( _.number.is( tab ) )
  tab = _.strDup( ' ', tab );

  if( _.strIs( src ) )
  {
    if( src.indexOf( '\n' ) === -1 )
    return src;
    src = _.str.lines.split( src );
  }

  /*
    should be no tab in prolog
  */

  if( every === true )
  {
    let result = src.join( '\n' + tab );
    return result;
  }
  else
  {
    let result = '';
    src.forEach( ( e, c ) =>
    {
      if( c > 0 )
      result += '\n';
      result += e.length > 0 && c > 0 ? tab + e : e;
    });
    return result;
  }
}

//

/**
 * Routine strLinesBut() replaces a range {-range-} of lines in source string {-src-} to new
 * values in {-ins-} parameter.
 *
 * @param { String|Long } src - Source string or array of strings.
 * If {-src-} is a String, then it split to parts using delimeter '\n'.
 * @param { Range|Number } range - Range of lines to be replaced.
 * If {-range-} is a Number, then routine replace only one line defined by value of {-range-}.
 * @param { String|Long } ins - String or array of strings to be inserted in source string.
 * If {-ins-} is a Long, then elements of Long concatenates using delimeter '\n'.
 * If range[ 0 ] or range[ 1 ] is less than zero, then routine count lines from the end of {-src-}.
 *
 * @example
 * _.strLinesBut( 'ab \n bc \n cd \n de', 1 );
 * // returns 'ab \n cd \n de'
 *
 * @example
 * _.strLinesBut( 'ab \n bc \n cd \n de', -1 );
 * // returns 'ab \n bc \n cd '
 *
 * @example
 * _.strLinesBut( 'ab \n bc \n cd \n de', [ 1, 4 ], '' );
 * // returns 'ab '
 *
 * @example
 * _.strLinesBut( 'ab \n bc \n cd \n de', [ 1, -1 ], '' );
 * // returns 'ab \n de'
 *
 * @example
 * _.strLinesBut( 'ab \n bc \n cd \n de', 1, ' some \n string ' );
 * // returns 'ab \n some \n string \n cd \n de'
 *
 * @example
 * _.strLinesBut( 'ab \n bc \n cd \n de', -1, ' some \n string ' );
 * // returns 'ab \n bc \n cd \n some \n string '
 *
 * @example
 * _.strLinesBut( 'ab \n bc \n cd \n de', [ 1, 4 ], [ ' some ', ' string' ] );
 * // returns 'ab \n some \n string'
 *
 * @example
 * _.strLinesBut( 'ab \n bc \n cd \n de', [ 1, -1 ], [ ' some ', ' string' ] );
 * // returns 'ab \n some \n string\n de'
 *
 * @example
 * _.strLinesBut( [ 'ab ', ' bc ', ' cd ', ' de' ], 1, ' some \n string ' );
 * // returns 'ab \n some \n string \n cd \n de'
 *
 * @example
 * _.strLinesBut( [ 'ab ', ' bc ', ' cd ', ' de' ], -1, ' some \n string ' );
 * // returns 'ab \n bc \n cd \n some \n string '
 *
 * @example
 * _.strLinesBut( [ 'ab ', ' bc ', ' cd ', ' de' ], [ 1, 4 ], [ ' some ', ' string' ] );
 * // returns 'ab \n some \n string'
 *
 * @example
 * _.strLinesBut( [ 'ab ', ' bc ', ' cd ', ' de' ], [ 1, -1 ], [ ' some ', ' string' ] );
 * // returns 'ab \n some \n string\n de'
 *
 * @returns { String } - Returns string concatenated from original source string and inserted values.
 * @function strLinesBut
 * @throws { Exception } If arguments.length is less then two or more then three.
 * @throws { Exception } If {-src-} is not a String or a Long.
 * @throws { Exception } If {-ins-} is not a String, not a Long, not undefined.
 * @namespace Tools
 */

function strLinesBut( src, range, ins )
{

  if( _.strIs( src ) )
  src = _.str.lines.split( src );

  _.assert( arguments.length === 2 || arguments.length === 3 );
  _.assert( _.longIs( src ) );
  _.assert( ins === undefined || _.strIs( ins ) || _.longIs( ins ) );
  // _.assert( !_.longIs( ins ), 'not implemented' );

  if( _.number.is( range ) )
  {
    if( range < 0 )
    range = src.length + range;
    range = [ range, range + 1 ];
  }

  if( range[ 1 ] < 0 )
  range[ 1 ] = src.length + range[ 1 ];

  _.assert( _.intervalIs( range ) );

  /*
    aaa : should work
    _.strLinesBut( _.strLinesBut( got1, 0 ), -1 )

    Dmytro : works
  */

  /*
    aaa : implement not implemented
    Dmytro : implemented
  */

  let range2 = [ range[ 0 ], range[ 1 ] - 1 ]
  /* qqq for Dmtro : check and improve code */

  if( _.longIs( ins ) )
  return _.longBut_( null, src, range2, ins ).join( '\n' );
  else if( _.strIs( ins ) )
  return _.longBut_( null, src, range2, [ ins ] ).join( '\n' );
  else
  return _.longBut_( null, src, range2 ).join( '\n' );

  // if( _.longIs( ins ) )
  // return _.longBut( src, range, ins ).join( '\n' );
  // else if( _.strIs( ins ) )
  // return _.longBut( src, range, [ ins ] ).join( '\n' );
  // else
  // return _.longBut( src, range ).join( '\n' );

  // if( ins )
  // {
  //   _.assert( _.strIs( ins ) );
  //   return _.longBut( src, range, [ ins ] ).join( '\n' );
  // }
  // else
  // {
  //   return _.longBut( src, range ).join( '\n' );
  // }

}

//

/**
 * Routine strLinesOnly() selects a range {-range-} of lines in source string {-src-} and returns
 * new string joined from it.
 *
 * @param { String|Long } src - Source string or array of strings.
 * If {-src-} is a String, then it split to parts using delimeter '\n'.
 * @param { Range|Number } range - Range of lines to be selected.
 * If {-range-} is a Number, then routine selects only one line defined by value of {-range-}.
 * If range[ 0 ] or range[ 1 ] is less than zero, then routine count lines from the end of {-src-}.
 *
 * @example
 * _.strLinesOnly( 'ab \n bc \n cd \n de', 1 );
 * // returns ' bc '
 *
 * @example
 * _.strLinesOnly( 'ab \n bc \n cd \n de', -1 );
 * // returns ' de'
 *
 * @example
 * _.strLinesOnly( 'ab \n bc \n cd \n de', [ 1, 4 ] );
 * // returns ' bc \n cd \n de'
 *
 * @example
 * _.strLinesOnly( 'ab \n bc \n cd \n de', [ 1, -1 ] );
 * // returns ' bc \n cd '
 *
 * @example
 * _.strLinesOnly( [ 'ab ', ' bc ', ' cd ', ' de' ], 1 );
 * // returns ' bc '
 *
 * @example
 * _.strLinesOnly( [ 'ab ', ' bc ', ' cd ', ' de' ], -1 );
 * // returns ' de'
 *
 * @example
 * _.strLinesOnly( [ 'ab ', ' bc ', ' cd ', ' de' ], [ 1, 4 ] );
 * // returns ' bc \n cd \n de'
 *
 * @example
 * _.strLinesOnly( [ 'ab ', ' bc ', ' cd ', ' de' ], [ 1, -1 ] );
 * // returns ' bc \n cd '
 *
 * @returns { String } - Returns a range of lines from source string concatenated by new line symbol.
 * @function strLinesOnly
 * @throws { Exception } If arguments.length is less then two or more then three.
 * @throws { Exception } If {-src-} is not a String or a Long.
 * @namespace Tools
 */

function strLinesOnly( src, range )
{

  if( _.strIs( src ) )
  src = _.str.lines.split( src );

  _.assert( arguments.length === 2 );
  _.assert( _.longIs( src ) );

  if( _.number.is( range ) )
  range = [ range, range + 1 ];
  if( range[ 0 ] < 0 )
  range[ 0 ] = src.length >= -range[ 0 ] ? src.length + range[ 0 ] : 0
  if( range[ 1 ] < 0 )
  range[ 1 ] = src.length + range[ 1 ];

  _.assert( _.intervalIs( range ) );

  let result = [];
  for( let i = range[ 0 ]; i < range[ 1 ] && i < src.length; i++ )
  result[ i - range[ 0 ] ] = src[ i ];

  return result.join( '\n' );

}

//

/**
 * Puts line counter before each line/element of provided source( o.src ).
 * If( o.src ) is a string, function splits it into array using new line as splitter, then puts line counter at the beginning of each line( element ).
 * If( o.src ) is a array, function puts line counter at the beginning of each line( element ).
 * Initial value of a counter can be changed by defining( o.first ) options( o ) property.
 * Can be called in two ways:
 * - First by passing all options in one object;
 * - Second by passing source only and using default value of( first ).
 *
 * @param { Object } o - options.
 * @param { String/Array } [ o.src=null ] - Source string or array of lines( not array of texts ).
 * With line we mean it does not have EOF. Otherwise please join the array to let the routine to resplit the text,
 * like that: _.strLinesNumber( array.join( '\n' ) ).
 * @param { Number} [ o.first=1 ] - Sets initial value of a counter.
 * @returns { String } Returns string with line enumeration.
 *
 * @example
 * _.strLinesNumber( 'line' );
 * // returns '1 : line'
 *
 * @example
 * _.strLinesNumber( 'line1\nline2\nline3' );
 * // returns
 * // 1: line1
 * // 2: line2
 * // 3: line3
 *
 * @example
 * _.strLinesNumber( [ 'line', 'line', 'line' ] );
 * // returns
 * // 1: line1
 * // 2: line2
 * // 3: line3
 *
 * @example
 * _.strLinesNumber( { src:'line1\nline2\nline3', zeroLine : 2 } );
 * // returns
 * // 2: line1
 * // 3: line2
 * // 4: line3
 *
 * @method strLinesNumber
 * @throws { Exception } Throw an exception if no argument provided.
 * @throws { Exception } Throw an exception if( o.src ) is not a String or Array.
 * @namespace Tools
 */

function strLinesNumber( o )
{

  if( !_.object.isBasic( o ) )
  o = { src : arguments[ 0 ], zeroLine : ( arguments.length > 1 ? arguments[ 1 ] : null ) };

  _.routine.options( strLinesNumber, o );
  _.assert( arguments.length === 1 || arguments.length === 2 );
  _.assert( _.strIs( o.src ) || _.strsAreAll( o.src ), 'Expects string or strings {-o.src-}' );

  /* */

  if( o.zeroLine === null )
  {
    if( o.zeroChar === null )
    {
      o.zeroLine = 1;
    }
    else if( _.number.is( o.zeroChar ) )
    {
      let src = _.arrayIs( o.src ) ? o.src.join( '\n' ) : o.src;
      o.zeroLine = _.strLinesCount( src.substring( 0, o.zeroChar+1 ) );
    }
  }

  /* */

  let lines = _.strIs( o.src ) ? _.str.lines.split( o.src ) : o.src;

  /* */

  let maxNumberLength = String( lines.length - 1 + o.zeroLine ).length;
  let zeroLineLength = String( o.zeroLine ).length;
  let maxNumLength = maxNumberLength > zeroLineLength ? maxNumberLength : zeroLineLength;

  if( o.onLine )
  for( let l = 0; l < lines.length; l += 1 )
  {
    let numLength = String( l + o.zeroLine ).length;

    lines[ l ] = o.onLine( [ ' '.repeat( maxNumLength - numLength ), ( l + o.zeroLine ), ' : ', lines[ l ] ], o.zeroLine + l, o );
    if( lines[ l ] === undefined )
    {
      lines.splice( l, 1 );
      l -= 1;
    }
    _.assert( _.strIs( lines[ l ] ) );
  }
  else
  for( let l = 0; l < lines.length; l += 1 )
  {
    let numLength = String( l + o.zeroLine ).length;
    lines[ l ] = ' '.repeat( maxNumLength - numLength ) + ( l + o.zeroLine ) + ' : ' + lines[ l ];
  }
  if( o.highlightingToken && o.highlighting )
  {
    let results;

    _.assert( o.highlighting === null || _.number.is( o.highlighting ) || _.longIs( o.highlighting ), 'Expects number or array of numbers {-o.highlighting-}' );

    if( !_.arrayIs( o.highlighting ) )
    {
      if( o.highlighting > o.zeroLine + lines.length - 1 || o.highlighting < o.zeroLine )
      return lines.join( '\n' );
    }

    results = lines.map( ( el ) =>
    {
      if( _.arrayIs( o.highlighting ) )
      return o.highlighting.includes( parseInt( el, 10 ) ) ? '' + o.highlightingToken + ' ' + el : '' + ' '.repeat( o.highlightingToken.length + 1 ) + el;
      else
      return ( '' + o.highlighting ).includes( parseInt( el, 10 ) ) ? '' + o.highlightingToken + ' ' + el : '' + ' '.repeat( o.highlightingToken.length + 1 ) + el;
    } )

    if( JSON.stringify( lines ) === JSON.stringify( results.map( ( el ) => el.trim() ) ) )
    return lines.join( '\n' );

    return results.join( '\n' );

  }

  return lines.join( '\n' );
}

strLinesNumber.defaults =
{
  src : null,
  zeroLine : null,
  zeroChar : null,
  onLine : null,
  highlighting : null,
  highlightingToken : '*', /* qqq : if null then highlighting is off */
}

/* qqq2 : implement and cover option o.highlighting

_.strLinesNumber({ src, highlighting : 867 });

//   863 : 7 : Last one
//   864 : + replace 5 in ${ a.abs( 'before/File2.js' ) }
//   865 : Done 1 action(s). Thrown 0 error(s).
//   866 : `
// * 867 :     test.equivalent( op.output, exp );

_.strLinesNumber({ src, highlighting : 867, highlightingToken : '-->' });

//     863 : 7 : Last one
//     864 : + replace 5 in ${ a.abs( 'before/File2.js' ) }
//     865 : Done 1 action(s). Thrown 0 error(s).
//     866 : `
// --> 867 :     test.equivalent( op.output, exp );

_.strLinesNumber({ src, highlighting : [ 865, 867 ] });

//   863 : 7 : Last one
//   864 : + replace 5 in ${ a.abs( 'before/File2.js' ) }
// * 865 : Done 1 action(s). Thrown 0 error(s).
//   866 : `
// * 867 :     test.equivalent( op.output, exp );

*/

//

/**
 * Selects range( o.range ) of lines from source string( o.src ).
 * If( o.range ) is not specified and ( o.line ) is provided function uses it with ( o.selectMode ) option to generate new range.
 * If( o.range ) and ( o.line ) are both not provided function generates range by formula: [ 0, n + 1 ], where n: number of ( o.delimteter ) in source( o.src ).
 * Returns selected lines range as string or empty string if nothing selected.
 * Can be called in three ways:
 * - First by passing all parameters in one options map( o ) ;
 * - Second by passing source string( o.src ) and range( o.range ) as array or number;
 * - Third by passing source string( o.src ), range start and end position.
 *
 * @param {Object} o - Options.
 * @param {String} [ o.src=null ] - Source string.
 * @param {Array|Number} [ o.range=null ] - Sets range of lines to select from( o.src ) or single line number.
 * @param {Number} [ o.zero=1 ] - Sets base value for a line counter.
 * @param {Number} [ o.number=0 ] - If true, puts line counter before each line by using o.range[ 0 ] as initial value of a counter.
 * @param {String} [ o.delimteter='\n' ] - Sets new line character.
 * @param {String} [ o.line=null ] - Sets line number from which to start selecting, is used only if ( o.range ) is null.
 * @param {Number} [ o.nearestLines=3 ] - Sets maximal number of lines to select, is used only if ( o.range ) is null and ( o.line ) option is specified.
 * @param {String} [ o.selectMode='center' ] - Determines in what way funtion must select lines, works only if ( o.range ) is null and ( o.line ) option is specified.
 * Possible values:
 * - 'center' - uses ( o.line ) index as center point and selects ( o.nearestLines ) lines in both directions.
 * - 'begin' - selects ( o.nearestLines ) lines from start point ( o.line ) in forward direction;
 * - 'end' - selects ( o.nearestLines ) lines from start point ( o.line ) in backward direction.
 * @returns {string} Returns selected lines as new string or empty if nothing selected.
 *
 * @example
 * // selecting single line
 * _.strLinesSelect( 'a\nb\nc', 1 );
 * // returns 'a'
 *
 * @example
 * // selecting first two lines
 * _.strLinesSelect( 'a\nb\nc', [ 1, 3 ] );
 * // returns
 * // 'a
 * // b'
 *
 * @example
 * // selecting first two lines, second way
 * _.strLinesSelect( 'a\nb\nc', 1, 3 );
 * // returns
 * // 'a
 * // b'
 *
 * @example
 * // custom new line character
 * _.strLinesSelect({ src : 'a b c', range : [ 1, 3 ], delimteter : ' ' });
 * // returns 'a b'
 *
 * @example
 * // setting preferred number of lines to select, line option must be specified
 * _.strLinesSelect({ src : 'a\nb\nc', line : 2, nearestLines : 1 });
 * // returns 'b'
 *
 * @example
 * // selecting 2 two next lines starting from second
 * _.strLinesSelect({ src : 'a\nb\nc', line : 2, nearestLines : 2, selectMode : 'begin' });
 * // returns
 * // 'b
 * // c'
 *
 * @example
 * // selecting 2 two lines starting from second in backward direction
 * _.strLinesSelect({ src : 'a\nb\nc', line : 2, nearestLines : 2, selectMode : 'end' });
 * // returns
 * // 'a
 * // b'
 *
 * @method strLinesSelect
 * @throws { Exception } Throw an exception if no argument provided.
 * @throws { Exception } Throw an exception if( o.src ) is not a String.
 * @throws { Exception } Throw an exception if( o.range ) is not a Array or Number.
 * @throws { Exception } Throw an exception if( o ) is extended by unknown property.
 * @namespace Tools
 */

function strLinesSelect( o )
{

  if( arguments.length === 2 )
  {

    if( _.arrayIs( arguments[ 1 ] ) )
    o = { src : arguments[ 0 ], range : arguments[ 1 ] };
    else if( _.number.is( arguments[ 1 ] ) )
    o = { src : arguments[ 0 ], range : [ arguments[ 1 ], arguments[ 1 ]+1 ] };
    else _.assert( 0, 'unexpected argument', _.entity.strType( range ) );

  }
  else if( arguments.length === 3 )
  {
    o = { src : arguments[ 0 ], range : [ arguments[ 1 ], arguments[ 2 ] ] };
  }

  _.routine.options( strLinesSelect, o );
  _.assert( arguments.length <= 3 );
  _.assert( _.strIs( o.src ) );
  _.assert( _.bool.like( o.highlighting ) || _.longHas( [ '*' ], o.highlighting ) );

  if( _.bool.like( o.highlighting ) && o.highlighting )
  o.highlighting = '*';

  /* range */

  if( !o.range )
  {
    if( o.line === null )
    {
      o.range = [ 0, _.strCount( o.src, o.delimteter )+1 ];
    }
    else
    {
      if( o.selectMode === 'center' )
      o.range = [ o.line - Math.ceil( ( o.nearestLines + 1 ) / 2 ) + 1, o.line + Math.floor( ( o.nearestLines - 1 ) / 2 ) + 1 ];
      else if( o.selectMode === 'begin' )
      o.range = [ o.line, o.line + o.nearestLines ];
      else if( o.selectMode === 'end' )
      o.range = [ o.line - o.nearestLines+1, o.line+1 ];
    }
    // if( o.line !== null )
    // {
    //   if( o.selectMode === 'center' )
    //   o.range = [ o.line - Math.ceil( ( o.nearestLines + 1 ) / 2 ) + 1, o.line + Math.floor( ( o.nearestLines - 1 ) / 2 ) + 1 ];
    //   else if( o.selectMode === 'begin' )
    //   o.range = [ o.line, o.line + o.nearestLines ];
    //   else if( o.selectMode === 'end' )
    //   o.range = [ o.line - o.nearestLines+1, o.line+1 ];
    // }
    // else
    // {
    //   o.range = [ 0, _.strCount( o.src, o.delimteter )+1 ];
    // }
  }

  if( o.line === null )
  {
    if( o.selectMode === 'center' )
    o.line = Math.floor( ( o.range[ 0 ] + o.range[ 1 ] ) / 2 );
    else if( o.selectMode === 'begin' )
    o.line = o.range[ 0 ];
    else if( o.selectMode === 'end' )
    o.line = o.range[ 1 ] - 1;

    o.line = o.line > 0 ? o.line : 1;
  }

  _.assert( _.longIs( o.range ) );
  _.assert( _.intIs( o.line ) && o.line >= 0, 'Expects positive integer {-o.line-}.' );

  /* */

  let f = 0;
  let counter = o.zeroLine;
  while( counter < o.range[ 0 ] )
  {
    f = o.src.indexOf( o.delimteter, f );
    if( f === -1 )
    return '';
    f += o.delimteter.length;
    counter += 1;
  }

  /* */

  let l = f-1;
  while( counter < o.range[ 1 ] )
  {
    l += 1;
    l = o.src.indexOf( o.delimteter, l );
    if( l === -1 )
    {
      l = o.src.length;
      break;
    }
    counter += 1;
  }

  /* */

  let result = f < l ? o.src.substring( f, l ) : '';

  /* numbering */

  let zeroLine = o.range[ 0 ] <= 0 ? o.zeroLine : o.range[ 0 ];

  if( o.numbering && result.length )
  result = _.strLinesNumber
  ({
    src : result,
    zeroLine,
    onLine : lineHighlight,
  });

  return result;

  /* */

  function lineHighlight( line, l )
  {
    if( !o.highlighting )
    return line.join( '' );
    if( l === o.line )
    line[ 0 ] = '* ' + line[ 0 ];
    else
    line[ 0 ] = '  ' + line[ 0 ];
    // line[ 1 ] = _.strBut( line[ 1 ], 0, '*' );
    return line.join( '' );
  }

  /* */

}

strLinesSelect.defaults =
{

  src : null,
  range : null,

  line : null,
  nearestLines : 3,
  selectMode : 'center',
  highlighting : '*',

  numbering : 0,
  zeroLine : 1,
  delimteter : '\n',

}

/* aaa :
- cover option highlighting
Dmytro : covered
- cover option zeroLine
Dmytro : covered
*/

//

/**
 *
 * Get the nearest ( o.nearestLines ) lines to the range ( o.charsRangeLeft ) from source string( o.src ).
 * Returns object with two elements: .
 * Can be called in two ways:
 * - First by passing all parameters in one options map( o ) ;
 * - Second by passing source string( o.src ) and range( o.range ) as array or number;

 * The routine strLinesNearest returns the nearest {-o.numberOfLines-} lines to the range {-o.charsRangeLeft-} from source string {-o.src-}.
 * Returns object with two elements: splits - array with a substring & the nearest lines and spans - array of indexes of the nearest lines.
 * Can be called in two ways:
 * - First by passing all parameters in one options map {-o-} ;
 * - Second by passing source string {-o.src-} and range {-o.range-} as array or number;

 *
 * @example
 * // selecting single line
 * _.strLinesNearest
 * ({
 *   src : `\na\nbc\ndef\nghij\n\n`,
 *   charsRangeLeft : [ 2, 4 ],
 *   nearestLines : 1,
 * });
 * // returns o.splits = [ 'a', '\nb', 'c' ];
 * // returns o.spans = [ 1, 2, 4, 5 ];
 *
 * @example
 * // selecting single line
 * _.strLinesNearest
 * ({
 *   src : `\na\nbc\ndef\nghij\n\n`,
 *   charsRangeLeft : 3,
 *   nearestLines : 2,
 * });
 * // returns o.splits = [ 'a\n', 'b', 'c' ];
 * // returns o.spans = [ 1, 3, 4, 5 ];
 *
 * @returns { Aux } - Returns object with next fields:
 * splits - Array with three entries:
 * splits[ 0 ] and splits[ 2 ] contains a string with the nearest lines,
 * and splits[ 1 ] contains the substring corresponding to the range.
 * spans - Array with indexes of begin and end of nearest lines.
 * @param { Aux } o - Options.
 * @param { String } o.src - Source string.
 * @param { Array|Number } o.range - Sets range of lines to select from {-o.src-} or single line number.
 * @param { Number } o.numberOfLines - Sets number of lines to select.
 * @throws { Exception } Throw an exception if no argument provided.
 * @throws { Exception } Throw an exception if {-o.src-} is not a String.
 * @throws { Exception } Throw an exception if {-o.charsRangeLeft-} is not a Array or Number.
 * @throws { Exception } Throw an exception if {-o-} is extended by unknown property.
 * @function strLinesNearest
 * @namespace Tools
 */

function strLinesNearest_head( routine, args )
{

  let o = args[ 0 ];
  if( args[ 1 ] !== undefined )
  o = { src : args[ 0 ], charsRangeLeft : args[ 1 ] };

  _.routine.options( routine, o );

  if( _.number.is( o.charsRangeLeft ) )
  o.charsRangeLeft = [ o.charsRangeLeft, o.charsRangeLeft+1 ];

  _.assert( _.intervalIs( o.charsRangeLeft ) );
  _.assert( _.numberIs( o.nearestLines ) );

  return o;
}

//

function strLinesNearest_body( o )
{
  let result = Object.create( null );
  // let resultCharRange = [];
  let i, nearestLines;

  result.splits = [];
  result.spans = [ o.charsRangeLeft[ 0 ], o.charsRangeLeft[ 0 ], o.charsRangeLeft[ 1 ], o.charsRangeLeft[ 1 ] ];

  // logger.log( 'Result', result )
  // logger.log( )
  // /* */

  if( o.nearestLines === 0 )
  {
    // result = [];
    result.splits = [];
    result.splits[ 0 ] = '';
    result.splits[ 1 ] = o.src.substring( o.charsRangeLeft[ 0 ], o.charsRangeLeft[ 1 ] );
    result.splits[ 2 ] = '';
    return result;
  }

  /* */

  let nearestLinesLeft = Math.ceil( ( o.nearestLines+1 ) / 2 );
  nearestLines = nearestLinesLeft;
  if( nearestLines > 0 )
  {
    for( i = o.charsRangeLeft[ 0 ]-1 ; i >= 0 ; i-- )
    {
      if( o.src[ i ] === '\n' )
      nearestLines -= 1;
      if( nearestLines <= 0 )
      break;
    }
    i = i+1;
  }
  result.spans[ 0 ] = i;

  /*
    // 0 -> 0 + 0 = 0
    // 1 -> 1 + 1 = 2
    // 2 -> 2 + 1 = 3
    // 3 -> 2 + 2 = 4
  */

  /* */

  let nearestLinesRight = o.nearestLines + 1 - nearestLinesLeft;
  nearestLines = nearestLinesRight;
  if( nearestLines > 0 )
  {
    for( i = o.charsRangeLeft[ 1 ] ; i < o.src.length ; i++ )
    {
      if( o.src[ i ] === '\n' )
      nearestLines -= 1;
      if( nearestLines <= 0 )
      break;
    }
  }
  result.spans[ 3 ] = i;

  /* */

  result.splits[ 0 ] = o.src.substring( result.spans[ 0 ], result.spans[ 1 ] );
  result.splits[ 1 ] = o.src.substring( result.spans[ 1 ], result.spans[ 2 ] );
  result.splits[ 2 ] = o.src.substring( result.spans[ 2 ], result.spans[ 3 ] );

  // result.splits[ 0 ] = o.src.substring( resultCharRange[ 0 ], o.charsRangeLeft[ 0 ] );
  // result.splits[ 1 ] = o.src.substring( o.charsRangeLeft[ 0 ], o.charsRangeLeft[ 1 ] );
  // result.splits[ 2 ] = o.src.substring( o.charsRangeLeft[ 1 ], resultCharRange[ 1 ] );

  return result;
}

strLinesNearest_body.defaults =
{
  src : null,
  charsRangeLeft : null,
  nearestLines : 3,
  // outputFormat : 'map',
}

let strLinesNearest = _.routine.unite( strLinesNearest_head, strLinesNearest_body );

//

/**
 * The routine strLinesNearestLog returns a report about found string from the source string {-o.src-}.
 * Returns object with 2 elements: nearest - array with a substring & the nearest lines around, report - string with the found substring & surrounding lines.
 *
 * @example
 * // selecting first 5 letters, next 3 letters and rest letters
 * _.strLinesNearestLog
 * ({
 *   src : 'function add( x,y ) { return x + y }',
 *   charsRangeLeft : [ 5, 8 ],
 *   gray : 1,
 *   numberOfLines : 1
 * });
 * // returns {
 * //           nearest : [ 'funct', 'ion', ' add( x,y ) { return x + y }' ],
 * //           report : '1 : function add( x,y ) { return x + y }'
 * //         }
 *
 * @returns { Aux } - Returns object with next fileds:
 *    nearest { Array } - 3 elements: 1 - lines to the left of charsRangeLeft if {-numberOfLines-} allows, 2 - chars in range {-o.charsRangeLeft-}, 3 - lines to the right of {-o.charsRangeLeft-} if {-numberOfLines-} allows.
 *    report { String } - report about found string along with surrounding lines {-numberOfLines-}
 * @param { Aux } o - Options.
 * @param { String } o.src - Source string.
 * @param { Array|Number } o.charsRangeLeft - Sets range of lines to select from {-o.src-} or single line number.
 * @param { Number } o.numberOfLines - Sets number of lines to select.
 * @param { Number } o.gray - 0: Paints searched text in yellow, everything else in gray, 1: No highlighting
 * @throws { Exception } Throw an exception if no argument provided.
 * @throws { Exception } Throw an exception if {-o.src-} is not a String.
 * @throws { Exception } Throw an exception if {-o.charsRangeLeft-} is not a Array or Number.
 * @throws { Exception } Throw an exception if {-o-} is extended by unknown property.
 * @function strLinesNearestLog
 * @namespace Tools
*/

function strLinesNearestLog_body( o )
{
  let result = o;

  _.assert( o.charsRangeLeft[ 0 ] >= 0 && o.charsRangeLeft[ 1 ] >= 0, 'Expects positive ranges' );
  _.assert
  (
    o.charsRangeLeft[ 0 ] <= o.src.length && o.charsRangeLeft[ 1 ] <= o.src.length,
    'Expects valid range for source string {-o.src-}'
  );
  _.assert( o.sub === null || _.strIs( o.sub ) );

  if( o.charsRangeLeft[ 0 ] > o.charsRangeLeft[ 1 ] )
  o.charsRangeLeft[ 1 ] = o.charsRangeLeft[ 0 ];

  if( !result.nearest )
  result.nearest = _.strLinesNearest.body( o ).splits;

  result.log = result.nearest.slice();
  if( o.gray )
  {
    if( o.sub !== null )
    result.log[ 1 ] = `{- ${result.log[ 1 ]} -} -> {- ${o.sub} -}`;
  }
  else
  {
    let str;
    if( o.sub === null )
    str = _.color.strFormat( result.log[ 1 ], { fg : 'yellow' } );
    else
    str = _.color.strFormat( result.log[ 1 ], { fg : 'red' } ) + _.color.strFormat( o.sub, { fg : 'green' } );
    result.log[ 1 ] = _.color.strUnescape( str );
  }
  result.log = result.log.join( '' );

  result.log = _.strLinesSplit( result.log );
  if( !o.gray )
  result.log = _.color.strEscape( result.log );

  let left = o.src.substring( 0, o.charsRangeLeft[ 0 ] );
  // ---- BUG
  // let zeroLine = left ? _.strLinesCount( left ) : 1;
  // ----

  // ---- FIX (Yevhen S.)
  let zeroLine;
  if( left )
  {
    let linesNum = _.strLinesCount( left )
    if( linesNum <= 1 )
    zeroLine = 1;
    else
    zeroLine = linesNum - ( Math.floor( o.nearestLines / 2 ) ) <= 0 ? 1 : linesNum - ( Math.floor( o.nearestLines / 2 ) );
  }
  else
  {
    zeroLine = 1
  }
  // ----

  result.log = _.strLinesNumber
  ({
    src : result.log,
    zeroLine,
    onLine : ( line ) =>
    {
      if( !o.gray )
      {
        line[ 0 ] = _.color.strFormat( line[ 0 ], { fg : 'bright black' } );
        line[ 1 ] = _.color.strFormat( line[ 1 ], { fg : 'bright black' } );
      }
      return line.join( '' );
    }
  });

  return result;
}

strLinesNearestLog_body.defaults =
{
  src : null,
  sub : null,
  nearest : null, /* qqq2 : cover the option */
  charsRangeLeft : null,
  nearestLines : 3,
  gray : 0,
}

let strLinesNearestLog = _.routine.unite( strLinesNearest_head, strLinesNearestLog_body );

//

/**
 * Returns a count of lines in a string.
 * Expects one object: the string( src ) to be processed.
 *
 * @param {string} src - Source string.
 * @returns {number} Returns a number of lines in string.
 *
 * @example
 * _.strLinesCount( 'first\nsecond' );
 * // returns 2
 *
 * @example
 * _.strLinesCount( 'first\nsecond\nthird\n' );
 * // returns 4
 *
 * @method strLinesCount
 * @throws { Exception } Throw an exception if( src ) is not a String.
 * @throws { Exception } Throw an exception if no argument provided.
 * @namespace Tools
 *
*/

function strLinesCount( src )
{
  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( src ) );
  let result = src.indexOf( '\n' ) === -1 ? 1 : _.str.lines.split( src ).length;
  return result;
}

//

function strLinesSize( o )
{
  let lines;

  if( !_.mapIs( o ) )
  o = { src : arguments[ 0 ] }

  _.assert( arguments.length === 1, 'Expects single argument' );
  _.assert( _.strIs( o.src ) || _.argumentsArray.like( o.src ) );
  _.routine.options( strLinesSize, o );
  if( o.onLength === null )
  o.onLength = ( src ) => src.length;

  if( _.strIs( o.src ) )
  {
    if( o.onLength( o.src ) === '' )
    return [ 0, 0 ];
    if( o.src.indexOf( '\n' ) === -1 )
    return [ 1, o.onLength( o.src ) ];
    lines = _.str.lines.split( o.src );
  }
  else
  {
    lines = o.src;
    if( lines.length === 0 )
    return [ 0, 0 ];
    else if( lines.length === 1 && lines[ 0 ] === '' )
    return [ 0, 0 ];
  }

  let w = lines.reduce( ( a, e ) => Math.max( a, o.onLength( e ) ), 0 );

  return [ lines.length, w ];
}

strLinesSize.defaults =
{
  src : null,
  onLength : null,
}

//

function strLinesRangeWithCharRange_head( routine, args )
{

  let o = args[ 0 ];
  if( args[ 1 ] !== undefined )
  o = { src : args[ 0 ], charsRangeLeft : args[ 1 ] }

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 );
  _.assert( _.intervalIs( o.charsRangeLeft ) );
  _.assert( _.strIs( o.src ) );
  _.routine.options( routine, o );

  return o;
}

//

function strLinesRangeWithCharRange_body( o )
{

  let head = o.src.substring( 0, o.charsRangeLeft[ 0 ] );
  let mid = o.src.substring( o.charsRangeLeft[ 0 ], o.charsRangeLeft[ 1 ] + 1 );
  let result = []

  result[ 0 ] = _.strLinesCount( head )-1;
  result[ 1 ] = result[ 0 ] + _.strLinesCount( mid );

  return result;
}

strLinesRangeWithCharRange_body.defaults =
{
  src : null,
  charsRangeLeft : null,
}

let strLinesRangeWithCharRange = _.routine.unite( strLinesRangeWithCharRange_head, strLinesRangeWithCharRange_body );

// --
// declare
// --

let Proto =
{

  // dichotomy

  strIsHex,
  strIsMultilined,

  strHasAny,
  strHasAll,
  strHasNone,
  strHasSeveral,

  strsAnyHas,
  strsAllHas,
  strsNoneHas,

  // evaluator

  strCount,
  strStripCount,
  strsShortest,
  strsLongest,

  // replacer

  _strRemoved,
  strRemove,

  // strPrependOnce,
  // strAppendOnce,

  strReplaceWords,

  // etc

  strCommonLeft,
  strCommonRight,
  strRandom,
  strAlphabetFromRange,

  // formatter

  strForRange, /* xxx : investigate */
  strForCall, /* xxx : investigate */
  strDifference,

  // transformer

  strCapitalize,
  strDecapitalize,
  strSign,
  strDesign,
  strIsSigned,

  strEscape,
  strCodeUnicodeEscape,
  strUnicodeEscape,
  strReverse,

  // splitter

  strSplitStrNumber, /* experimental */
  strSplitChunks, /* experimental */

  strSplitCamel,

  // extractor

  _strOnly,
  strOnly,
  _strBut,
  strBut,
  strUnjoin,

  // joiner

  _strDup,
  strDup : _.vectorize( _strDup ),
  strJoin,
  strJoinPath,

  // liner

  strLinesIndentation,
  strLinesBut,
  strLinesOnly,

  // strLinesSplit,
  // strLinesJoin,
  // strLinesStrip,

  strLinesNumber,
  strLinesSelect,
  strLinesNearest,
  strLinesNearestLog,
  strLinesCount,
  strLinesSize, /* qqq2 : cover */
  strLinesRangeWithCharRange,

}

_.props.extend( _, Proto );

})();

/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1/StrBasic.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, StrBasic_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file StrBasic_s */ })();

/* */  /* begin of file TreeMap_s */ ( function TreeMap_s() { function TreeMap_s_naked() { ( function _TreeMap_s_()
{

'use strict';

/**
 * Modest implementation of treeMap.
 * @module Tools/base/TreeMap
*/

const _ = _global_.wTools;
_.treeMap = _.treeMap || Object.create( null );

// --
// dichotomy
// --

function is( node )
{
  if( !_.aux.is( node ) )
  return false;
  if( !node.ups )
  return false;
  return true;
}

//

function make()
{
  _.assert( arguments.length === 0 );
  let node = Object.create( null );
  node.vals = new Set();
  node.ups = Object.create( null );
  return node;
}

// --
// declare
// --

let NamespaceExtension =
{

  // dichotomy

  is,
  make,

}

//

/* _.props.extend */Object.assign( _.treeMap, NamespaceExtension );

// _.class.declareBasic
// ({
//   constructor : fo.class,
//   iterate,
//   equalAre : equalAre_functor( fo ),
//   exportString,
//   cloneShallow, /* xxx : implement */
//   cloneDeep, /* xxx : implement */
// });

// --
// export
// --

if( typeof module !== 'undefined' )
module[ 'exports' ] = _;

})();


/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1/TreeMap.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, TreeMap_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file TreeMap_s */ })();

/* */  /* begin of file Trie_s */ ( function Trie_s() { function Trie_s_naked() { ( function _Trie_s_()
{

'use strict';

/**
 * Modest implementation of trie.
 * @module Tools/base/Trie
*/

const _ = _global_.wTools;
_.trie = _.trie || Object.create( null );

// --
// dichotomy
// --

function is( node )
{
  if( !_.aux.is( node ) )
  return false;
  if( !node.ups )
  return false;
  return true;
}

//

function make()
{
  _.assert( arguments.length === 0 );
  let node = Object.create( null );
  node.vals = new Set();
  node.ups = Object.create( null );
  return node;
}

// --
// writer
// --

function makeWithPath_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 );

  let o = args[ 0 ]
  if( args.length === 2 )
  {
    o = { root : args[ 0 ], path : args[ 1 ] }
  }

  _.routine.options( routine, o );
  _.assert( _.longIs( o.path ) );
  _.assert( o.root === null || self.is( o.root ), () => `Expects node of trie or null, but got ${_.strType( o.root )}` );

  return o;
}

//

function makeWithPath_body( o )
{
  let self = this;

  if( o.root === null )
  o.root = self.make();

  let trace = o.trace = [];

  trace.push([ o.root, 0, o.path.length ]);

  for( let i = 0 ; i < trace.length ; i++ )
  act( ... trace[ i ] );

  return o;

  function act( node, f, l )
  {
    if( f === l )
    {
      o.child = node;
      return;
    }
    let node2 = node.ups[ o.path[ f ] ];
    if( !node2 )
    node2 = node.ups[ o.path[ f ] ] = self.make();
    trace.push([ node2, f+1, l ]);
  }

}

makeWithPath_body.defaults =
{
  root : null,
  path : null,
}

let makeWithPath = _.routine.unite( makeWithPath_head, makeWithPath_body );

//

function addSingle_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 3 );

  let o = args[ 0 ]
  if( args.length === 3 )
  {
    if( args.length === 3 )
    o = { root : args[ 0 ], path : args[ 1 ], val : args[ 2 ] }
    else
    o = { root : args[ 0 ] };
  }

  _.routine.options( routine, o );
  _.assert( _.longIs( o.path ) );
  _.assert( o.root === null || self.is( o.root ), () => `Expects node of trie or null, but got ${_.strType( o.root )}` );

  return o;
}

//

function addSingle_body( o )
{
  let self = this;
  self.makeWithPath.body.call( self, o );
  o.child.vals.add( o.val );
  return o;
}

addSingle_body.defaults =
{
  root : null,
  path : null,
  val : null,
}

let addSingle = _.routine.unite( addSingle_head, addSingle_body );

//

function addMultiple_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 3 );

  let o = args[ 0 ]
  if( args.length === 3 )
  {
    if( args.length === 3 )
    o = { root : args[ 0 ], path : args[ 1 ], vals : args[ 2 ] }
    else
    o = { root : args[ 0 ] };
  }

  _.routine.options( routine, o );
  _.assert( _.longIs( o.path ) );
  _.assert( o.root === null || self.is( o.root ), () => `Expects node of trie or null, but got ${_.strType( o.root )}` );
  _.assert( _.countable.is( o.vals ) );

  return o;
}

//

function addMultiple_body( o )
{
  let self = this;
  self.makeWithPath.body.call( self, o );
  if( o.onVal )
  {
    for( let val of o.vals )
    o.child.vals.add( o.onVal( val, o ) );
  }
  else
  {
    for( let val of o.vals )
    o.child.vals.add( val );
  }
  return o;
}

addMultiple_body.defaults =
{
  root : null,
  path : null,
  vals : null,
  onVal : null,
}

let addMultiple = _.routine.unite( addMultiple_head, addMultiple_body );

//

function addDeep_body( o )
{
  let self = this;
  let path = o.path;
  let l = o.path.length;

  for( let i = 0 ; i <= l ; i++ )
  {
    o.path = path.slice( i, l );
    self.addMultiple.body.call( self, o );
  }

  o.path = path;
  return o;
}

addDeep_body.defaults =
{
  ... addMultiple.defaults,
}

let addDeep = _.routine.unite( addMultiple_head, addDeep_body );

//

function delete_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 );

  let o = args[ 0 ];

  _.routine.options( routine, o );
  _.assert( self.is( o.root ), () => `Expects node of trie, but got ${_.strType( o.root )}` );
  _.assert( self.is( o.node ), () => `Expects node of trie, but got ${_.strType( o.node )}` );
  _.assert
  (
    o.vals === null || _.countableIs( o.vals ), () => `Vals should countable if specified, but it is ${_.strType( o.vals )}`
  );

  return o;
}

//

function delete_body( o )
{
  let self = this;

  if( o.vals === null )
  for( let val of o.node.vals )
  {
    o.node.vals.delete( val );
  }
  else
  for( let val of o.vals )
  {
    o.node.vals.delete( val );
  }

  return o;
}

delete_body.defaults =
{
  node : null,
  vals : null,
}

let _delete = _.routine.unite( delete_head, delete_body );

//

function deleteWithPath_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 || args.length === 3 );

  let o = args[ 0 ]
  if( args.length == 2 )
  {
    o = { root : args[ 0 ], path : args[ 1 ] }
  }
  else if( args.length == 3 )
  {
    if( args.length === 3 )
    o = { root : args[ 0 ], path : args[ 1 ], vals : args[ 2 ] }
    else
    o = { root : args[ 0 ] };
  }

  _.routine.options( routine, o );
  _.assert( self.is( o.root ), () => `Expects node of trie, but got ${_.strType( o.root )}` );
  _.assert( _.longIs( o.path ) );
  _.assert
  (
    o.vals === null || _.countableIs( o.vals ), () => `Vals should countable if specified, but it is ${_.strType( o.vals )}`
  );

  return o;
}

//

function deleteWithPath_body( o )
{
  let self = this;

  self.withPath.body.call( self, o );
  if( !o.child )
  return o;

  o.node = o.child;
  self.delete.body.call( self, o );

  if( o.child.vals.size === 0 && Object.keys( o.child.ups ).length === 0 && o.shrinking )
  self.shrinkWithPath.body.call( self, o );

  return o;
}

deleteWithPath_body.defaults =
{
  root : null,
  path : null,
  vals : null,
  shrinking : true,
}

let deleteWithPath = _.routine.unite( deleteWithPath_head, deleteWithPath_body );

//

function shrinkWithPath_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 || args.length === 3 );

  let o = args[ 0 ]
  if( args.length == 2 )
  {
    o = { root : args[ 0 ], path : args[ 1 ] }
  }
  else if( args.length == 3 )
  {
    if( args.length === 3 )
    o = { root : args[ 0 ], path : args[ 1 ], vals : args[ 2 ] }
    else
    o = { root : args[ 0 ] };
  }

  _.routine.options( routine, o );
  _.assert( self.is( o.root ), () => `Expects node of trie, but got ${_.strType( o.root )}` );
  _.assert( o.path === null || _.longIs( o.path ) );
  _.assert( o.trace === null || _.longIs( o.trace ) );

  return o;
}

//

function shrinkWithPath_body( o )
{
  let self = this;

  if( !o.trace )
  {
    self.withPath.body.call( self, o );
    if( !o.child )
    return o;
  }

  let node = o.trace[ o.trace.length - 1 ][ 0 ];
  if( node.vals.size !== 0 || Object.keys( node.ups ).length !== 0 )
  {
    o.child = undefined;
    return o;
  }

  for( let i = o.trace.length - 1 ; i >= 0 ; i-- )
  if( o.trace[ i ][ 0 ].vals.size > 0 )
  {
    o.childLevel = i + 1;
    o.child = o.trace[ o.childLevel ];
    if( !o.child )
    return;
    o.child = o.child[ 0 ];
    o.parent = o.trace[ i ][ 0 ];
    _.assert( o.parent.ups[ o.path[ i ] ] === o.child );
    delete o.parent.ups[ o.path[ i ] ];
    return o;
  }
  o.child = o.root;

  return o;
}

shrinkWithPath_body.defaults =
{
  root : null,
  path : null,
  trace : null,
}

let shrinkWithPath = _.routine.unite( shrinkWithPath_head, shrinkWithPath_body );

//

function shrink_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 );

  let o = args[ 0 ]
  if( self.is( o ) )
  o = { root : o }

  _.routine.options( routine, o );
  _.assert( self.is( o.root ), () => `Expects node of trie, but got ${_.strType( o.root )}` );

  return o;
}

//

function shrink_body( o )
{
  let self = this;

  let stack = [];
  stack.push([ o.root, null, null ]);

  debugger;

  for( let i = 0 ; i < stack.length ; i++ )
  actUp( ... stack[ i ] );

  for( let i = stack.length - 1 ; i >= 0 ; i-- )
  actDown( ... stack[ i ] );

  debugger;

  return o;

  function actUp( node )
  {
    for( let k in node.ups )
    {
      let node2 = node.ups[ k ];
      stack.push([ node2, k, node ]);
    }
  }

  function actDown( child, key, parent )
  {
    debugger;
    if( parent !== null )
    if( child.vals.size === 0 && Object.keys( child.ups ).length === 0 )
    {
      debugger;
      _.assert( parent.ups[ key ] === child );
      delete parent.ups[ key ];
      o.counter += 1;
    }

  }

}

shrink_body.defaults =
{
  counter : 0,
  root : null,
}

let shrink = _.routine.unite( shrink_head, shrink_body );

// --
// reader
// --

function withPath_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 );

  let o = args[ 0 ]
  if( args.length === 2 )
  {
    o = { root : args[ 0 ], path : args[ 1 ] }
  }

  _.routine.options( routine, o );
  _.assert( _.longIs( o.path ) );
  _.assert( self.is( o.root ), () => `Expects node of trie, but got ${_.strType( o.root )}` );

  return o;
}

//

function withPath_body( o )
{
  let self = this;
  let trace = o.trace = [];

  trace.push([ o.root, 0, o.path.length ]); /* xxx : remove 3rd argument */

  for( let i = 0 ; i < trace.length ; i++ )
  act( ... trace[ i ] );

  return o;

  function act( node, f, l )
  {
    if( f === l )
    {
      o.child = node;
      return;
    }
    let node2 = node.ups[ o.path[ f ] ];
    if( !node2 )
    return;
    trace.push([ node2, f+1, l ]);
  }

}

withPath_body.defaults =
{
  root : null,
  path : null,
}

let withPath = _.routine.unite( withPath_head, withPath_body );

//

function valEach_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 );

  let o = args[ 0 ]
  if( self.is( o ) )
  {
    o = { root : args[ 0 ] }
  }

  _.routine.options( routine, o );
  _.assert( self.is( o.root ), () => `Expects node of trie, but got ${_.strType( o.root )}` );

  return o;
}

//

function valEach_body( o )
{
  let self = this;

  o.vals = o.vals || new Set;

  let stack = [];
  stack.push([ o.root ]);

  if( _.setIs( o.vals ) )
  {
    while( stack.length )
    actSet( ... stack.pop() );
  }
  else
  {
    while( stack.length )
    actArray( ... stack.pop() );
  }

  return o;

  function actSet( node )
  {
    for( let k in node.ups )
    {
      let node2 = node.ups[ k ];
      stack.push([ node2 ]);
    }
    for( let val of node.vals )
    {
      o.vals.add( val );
    }
  }

  function actArray( node )
  {
    for( let k in node.ups )
    {
      let node2 = node.ups[ k ];
      stack.push([ node2 ]);
    }
    for( let val of node.vals )
    {
      _.arrayAppendOnce( o.vals, val );
    }
  }

}

valEach_body.defaults =
{
  root : null,
  vals : null,
}

let valEach = _.routine.unite( valEach_head, valEach_body );

//

function valEachAbove_head( routine, args )
{
  let self = this;

  _.assert( arguments.length === 2 );
  _.assert( args.length === 1 || args.length === 2 );

  let o = args[ 0 ]
  if( args.length === 2 )
  {
    o = { root : args[ 0 ], path : args[ 1 ] }
  }

  _.routine.options( routine, o );
  _.assert( self.is( o.root ), () => `Expects node of trie, but got ${_.strType( o.root )}` );

  return o;
}

//

function valEachAbove_body( o )
{
  let self = this;

  o.vals = o.vals || [];

  self.withPath.body.call( self, o );
  if( !o.child )
  return o;

  o.root = o.child;
  self.valEach.body.call( self, o );

  return o;
}

valEachAbove_body.defaults =
{
  root : null,
  path : null,
  vals : null,
}

let valEachAbove = _.routine.unite( withPath_head, valEachAbove_body );

// --
// declare
// --

let Proto =
{

  // dichotomy

  is,
  make,

  // writer

  makeWithPath,
  addSingle,
  addMultiple,
  add : addMultiple,
  addDeep,
  delete : _delete,
  deleteWithPath,
  shrinkWithPath,
  shrink,

  // reader

  withPath,
  valEach,
  valEachAbove,

}

//

/* _.props.extend */Object.assign( _.trie, Proto );

// --
// export
// --

if( typeof module !== 'undefined' )
module[ 'exports' ] = _;

})();


/* */    };
/* */  let _filePath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1/Trie.s' );
/* */  let _dirPath_ = _starter_._pathResolveLocal( null, _libraryFilePath_, './wtools/abase/l1/l1' );
/* */  let __filename = _filePath_;
/* */  let __dirname = _dirPath_;
/* */  let module = _starter_._sourceMake( _filePath_, _dirPath_, Trie_s_naked );
/* */  let exports = module.exports;
/* */  let require = module.include;
/* */  let include = module.include;

/* */  /* end of file Trie_s */ })();


/* */  module.exports = _starter_._sourceInclude( null, _libraryFilePath_, './wtools/abase/l1/Include.s' );


/* */  /* end of library Main_s */ })()
