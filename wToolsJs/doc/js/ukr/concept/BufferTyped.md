# Тип <code>BufferTyped</code>

Стандартні типізовані буфери.

[Тип `BufferTyped`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/TypedArray) - представляє бінарні дані із `BufferRaw` у вигляді числових примітивів, як наприклад `Int8`, `Ui32`, `Float64` та інших. Типізовані буфери не містять реальних даних, а є представленням даних в `BufferRaw`, де і знаходяться реальні дані. Типізовані буфери реалізують стратегії доступу до `BufferRaw`.

Перелік типізованих буферів:

- `I8x` ( `Int8Array` );
- `U8x` ( `Ui8Array` );
- `U8ClampedX` ( `Ui8ClampedArray` );
- `I16x` ( `Int16Array` );
- `U16x` ( `Ui16Array` );
- `I32x`, аналогічна назва `Ix` ( `Int32Array` );
- `U32x`, аналогічна назва `Ux` ( `Ui32Array` );
- `F32x`, аналогічна назва `Fx` ( `Float32Array` );
- `F64x` ( `Float64Array` );
- `I64x` ( `BigInt64Array` );
- `U64x` ( `BigUint64Array` ).

Тип `BufferTyped` на відміну від [`BufferView`](./BufferView.md) типізує елементи статично.

### Приклади

```js
var u8 = new U8x();
console.log( u8.length ) // log 0
console.log( u8.byteLength ) // log 0
```

Для створення екземпляру типізованого буфера потрібно викликати конструктор відповідного класу та передати аргумент для створення буферу. Якщо конструктор викликати без аргументів, тоді буде створено порожній типізований буфер.
Змінна `u8` містить екземпляр буферу `U8x`. Оскільки конструктор викликано без аргументів його довжина рівна нулю.

```js
var i8 = new I8x( 20 );
console.log( i8.length ); // log 20
console.log( i8.byteLength ); // log 20
```

У випадку передачі довжини буферу, створюється типізований буфер з заданою кількістю елементів. Числовий тип `Int8` являє собою однобайтові числа зі знаком, тому розмір відповідає довжині буферу.

```js
var i16 = new I16x( [ 1, 2, 10 ] );
console.log( i16.length ); // log 3
console.log( i16.byteLength ); // log 6
```

При передачі масиву з даними, конструктор створює типізований буфер рівний довжині переданого буферу. Кожен елемент масиву перетворюється до типу і розміру вказаного в конструкторі. Для буфера `i16` кожен елемент вхідного масиву перетворено в число зі знаком розміром в два байти кожен.

```js
var raw = new BufferRaw( 32 );

var float32 = new F32x( raw );
console.log( float32.length ); // log 8
console.log( float32.byteLength ); // log 32

var ui64 = new U64x( raw );
console.log( ui64.length ); // log 4
console.log( ui64.byteLength ); // log 32
```

При створенні представлення `raw` буферу з допомогою типізованого, послідовність байтів `raw` буферу ділиться на частини згідно розміру елементу типізованого буфера. Таким чином, типізований буфер `float32` має 8 елементів. А при використанні представлення в `ui64` типізований буфер має вдвічі меншу довжину тому, що розмір одного елемента типу `U64x` складає вісім однобайтних чисел.

```js
var raw = new BufferRaw( 32 );
var u8 = new U8x( raw );
u8[ 0 ] = 20;
console.log( u8[ 5 ] ); // log 20
```

В прикладі з `raw` буферу створено представлення - `u8`. Для доступу до окремих елементів типізованого буфера використовуються індекси, як в звичайному масиві.

```js
var raw = new BufferRaw( 32 );

var u8First = new U8x( raw );
var u8Second = new U8x( raw );

u8First[ 0 ] = 20;
u8Second[ 5 ] = 3;

console.log( u8First[ 5 ] ); // log 3
console.log( u8Second[ 0 ] ); // log 20
```

При створенні типізованого буфера з буфера типу `BufferRaw`, типізованому буферу передається `BufferRaw`. Ніякого копіювання буфера `BufferRaw` при створенні представлення фактично не виконується. Насправді представлення не володіє даними, а є свого роду лінком на дані. Тому, при зміні елемента одного типізованого буфера змінюється й елемент в іншому типізованому буфера.

### Підсумок

- Типізовані буфери представляють двійкові дані у вигляді числових примітивів.
- Доступ до елементів типізованих буферів здійснюється за індексом.
- Довжина типізованого буфера визначається кількістю елементів.
- Розмір типізованого буфера визначається кількістю байт, що займають всі елементи.
- Типізовані буфери не володіють даними.
- Типізовані буфери є представленням буферів типу `BufferRaw` в котрих і знаходятсья реальні дані.
- Тому зміна даних в одному з представлень відображається в інших `BufferTyped` з тим же `BufferRaw`.

[Повернутись до змісту](../README.md#Концепції)
