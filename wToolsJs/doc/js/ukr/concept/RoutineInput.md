## Масив аргументів

Це сукупність параметрів рутини, котрі сформовано в псевдомасив <code>arguments</code>.

В JavaScript усі передані у функцію аргументи записуються у псевдомасив `arguments`, який є значенням властивості `arguments` цієї функції.
Псевдомасив - це об'єкт, який структурно подібний до масиву. Тобто ключем властивості у нього виступає число ( індекс ).
Також у нього є властивість `lenght`. Проте Array не є його функцією-конструктором. А значить у псевдомасива немає методів масиву, таких як `indexOf`, `join`, `map` та ін.

Приклад псевдомасива:

```js
var arguments = { 0 : 'value 1', 1 : 'value 2', 2 : 'value 3', length : 3 };
```

Приведена мапа `arguments` є псевдомасивом, бо містить числові ключі та поле `lenght`.

За необхідності, із псевдомасиву `arguments` можна створити звичайний масив:

```js
function arrayFromArguments()
{
  console.log( arguments );
  /* log : [Arguments] { '0': 'hello', '1': 'world' } */
  console.log( arguments instanceof Array );
  /* log : false */

  let argumentsArr = Array.from( arguments );
  console.log( argumentsArr );
  /* log : [ 'hello', 'world' ] */
  console.log( argumentsArr instanceof Array );
  /* log : true */
}
arrayFromArguments( 'hello', 'world' );
```

Метод `from` класа `Array` перетворив псевдомасив `arguments` в звичайний масив.

Кожну рутину в `JavaScript` можна викликати з необмеженою кількістю аргументів. До аргументів, оголошених в параметрах рутини можна звернутись за іменем і за порядковим індексом в `arguments`. До аргументів, що не оголошені в параметрах рутини - тільки за індексом.

```js
function logMsgs( msg1, msg2 )
{
  if( msg1 && !msg2 )
  console.log( msg1 );

  if( !msg1 && msg2 )
  console.log( msg2, arguments[ 1 ] );  // two variants of calls of signed parameter

  if( arguments[ 2 ] )
  console.log( arguments[ 2 ] );
}

logMsgs( 'one' );
/* log : one */
logMsgs( null, 'two' );
/* log : two two */
logMsgs( null, undefined, 'three' );
/* log : three */
logMsgs( 'one', 'two', 'three', 'four', 'five' );
/* log : three */
```

Для коректної роботи рутини, аргументи повинні передаватись у правильній послідовності. Це створює незручності для розробника, змушує щоразу дізнаватись ( навіть запам'ятовувати ) правильний порядок аргументів для кожної рутини. Ця проблема вирішується з допомогою [мапи опцій](#мапа-опцій).

## Мапа опцій

Це контейнер, що призначений для передачі даних у рутину та управління її поведінкою.

Працювати із мапою опцій зручніше ніж із [масивом аргументів](#масив-аргументів), оскільки кожна з опцій має своє ім'я та їх послідовність може бути будь-якою.

```js
function someFunction1( optionsMap )
{
  if( optionsMap.option1 >= 0 )
  console.log( 'option1' );

  if( optionsMap.option2 < 0 )
  console.log( 'option2' );
}
someFunction1( { option1 : 1, option2 : 2 } );
/* log : option1 */
```

В приведеному вище спрощеному прикладі рутина `someFunction1` приймає як аргумент мапу опцій. Цей спосіб передачі вхідних даних
має ряд переваг в порівнянні з масивом аргументів:

- послідовність опцій може бути будь-якою, це не впливає на коректність виконання коду рутини;
- можливість використання мапи опцій, що згенеровані іншими рутинами;
- можливість перевірки коректності значень мапи опцій при її створенні, до виконання рутини;
- можливість створення нових рутин перевикористанням коду початкової рутини. Для цього необхідно створити нову рутину з викликом у ній першої, та передати їй вхідну мапу опцій ( змінивши її або ж без змін ):

```js
function someFunction2( mapOptions )
{
  let result = someFunction1( mapOptions );
  // some code
}
```

Рутина `someFunction2` поміщає в змінну `result` результат виконання рутини `someFunction1`. В виклик рутини `someFunction1` передано оригінальну мапу опцій без змін.

## Мапа дефолтних значень

Це мапа, яка містить у собі опції, що визначають поведінку рутини за замовчуванням.

Значення із мапи дефолтних значень можна використати при перевірці опцій вхідної [мапи опцій](#мапа-опцій) - їх значення чи наявності. Наприклад, якщо не вказати одну з опцій у вхідній мапі опцій, а вона є необхідною для коректної роботи рутини, то її значення можна взяти із мапи дефолтних значень.

```js
function arrayOfRandomInts( o )
{
  if( !o.times )
  o.times = arrayOfRandomInts.defaults.times;

  let result = [];
  for( let i = 0; i < o.times; i++ )
  result.push( _.intRandom([ -100, 100 ]) );

  return result;
}
arrayOfRandomInts.defaults =
{
  times : 1
}

console.log( arrayOfRandomInts( {} ) );
/* log array with 1 random integer : [ 23 ] */
console.log( arrayOfRandomInts({ times : 2 }) );
/* log array with 2 random integers : [ -57, 93 ] */
```

У приведеному вище спрощеному прикладі рутина `arrayOfRandomInts` за замовчуванням повертає масив із одним випадковим цілим числом. Якщо потрібен масив із `times` випадкових цілих чисел, можна вказати опцію `times` котра за це відповідає.

Очевидно, що вказавши значення опцій в мапі дефолтних значень, можна не вказувати їх у вхідній мапі опцій, якщо поведінка рутини за замовчуванням відповідає задачі.

[Повернутись до змісту](../README.md#Концепції)

