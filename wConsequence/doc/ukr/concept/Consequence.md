# Наслідок

Це об'єкт синхронізації, який надає ширші можливості при роботі із асинхронним кодом порівняно із нативними засобами JavaScript.

Клас `Consequence` створює об'єкти, які використовуються для асинхронних обчислень. Ці об'єкти представляють чергу
результатів, які можна обчислити асинхронно, і мають широкий спектр інструментів для виконання цього процесу.
`Наслідок` є сумісним із нативним об'єктом синхронізації `Promise`.

Розглянемо простий приклад використання `наслідку` в асинхронному коді.
```js
// here would be the `async fynction` syntax if using Promise
function foo()
{
  var con = new _.Consequence();

  _.time.out( 1000, () => con.take( 'my resource' ) );

  con.deasync(); // delay execution of .sync() till resource is passed into consequence
  return con.sync(); // .sync() retrieves the resource just passed into consequence
}

// here would be the `await foo()` syntax if using Promise
var result = foo();

// after 1 sec we get result
console.log( result ); // my resource
```

Структурно `наслідок` складається із двох черг(масивів):
- [ресурсів](./Resource.md#ресурс);
- [конкурентів](./Competitor.md#конкурент).

Тобто, `наслідок` - це контейнер для даних, якими є `ресурси` та `конкуренти`, що їх обробляють.

```js
var con = new _.Consequence();

console.log( con ); // logs: Consequence:: 0 / 0
```

При конвертації об'єкта `Consequence` в рядок ми побачимо вивід у форматі - `Consequence:: ресурси / конкуренти`.
Кожне із цих двох чисел - це величина черги(довжина масиву) `ресурсів` та `конкурентів`. А значить, число вказує на їхню кількість у черзі.

`Ресурси` і `конкуренти` є об'єктами, що містять у своїх властивостях:
- значення ресурсу, якщо у наслідок додається ресурс;
- тіло рутини-обробника ресурса, якщо у наслідок додається конкурент;
- інші значення.

Детальніше про дослідження вмісту `наслідку` та його зміну описано в туторіалі - [Інспектування наслідку](../tutorial/InspectingConsequence.md#інспектування-наслідку).

Детальніше про `ресурси` та `конкуренти` описано в концепціях - [Ресурс](./Resource.md#ресурс) та [Конкурент](./Competitor.md#конкурент).

Можна спершу додати в чергу ресурси, а потім конкуренти, що їх оброблятимуть, або навпаки. Проте між цими способами є 
принципова відмінність в обробці ресурсів.

Перший спосіб - спершу ресурс потім конкурент.
```js
// The `capacity` option indicates the maximum number of resources in the resource queue at a time. By default 1, if 0 - not limited
var con = new _.Consequence({ capacity : 0 });

// .take(resource) - pass resource to the queue
con.take( 'my resource1' );
con.take( 'my resource2' );

console.log( con ); // Consequence:: 2 / 0

// .then(callback), thenGive(callback) - pass competitor to the queue
con.then( ( arg ) =>
{
  console.log( 'then: ', arg ); // then:  my resource1
  return 'new arg from then';
} );

con.thenGive( ( arg ) => console.log( 'thenGive: ', arg ) ); // thenGive:  my resource2

console.log( con ); // Consequence:: 1 / 0
```

Приклад вище показує, що:
- додані в `наслідок` ресурси потрапляють у чергу ресурсів та очікують на появу `конкурентів`, що їх оброблятимуть;
- як тільки в чергу конкурентів додається новий `конкурент`, він викликається із передачею в нього першого в черзі ресурса;
- порядок ресурсів у черзі, в ході їх обробки, змінюється.

Другий спосіб - спершу конкурент потім ресурс.
```js
var con = new _.Consequence();

con.then( ( arg ) =>
{
  console.log( 'then logs: ', arg );
  return 'new arg from then';
} );

con.thenGive( ( arg ) => console.log( 'thenGive logs: ', arg ) );

console.log( con ); // Consequence:: 0 / 2

con.take( 'my resource1' ); // then:  my resource1
con.take( 'my resource2' ); // thenGive:  new arg from then

console.log( con ); // Consequence:: 1 / 0
```

Приклад вище показує, що:
- додані в `наслідок` конкуренти потрапляють у чергу конкурентів та очікують на появу `ресурсів` для їх обробки;
- як тільки в чергу ресурсів передається новий `ресурс`, викликається перший в черзі `конкурент` із передачею в нього цього ресурса;
- після завершення роботи першого `конкурента` викликається наступний із передачею в нього поверненного результату роботи;
- наступний доданий `ресурс` не був оброблений.

Щоб краще зрозуміти особливості поведінки `конкурентів` та їх види, рекомендуємо прочитати туторіал - [Різниця між 'give' та 'keep' конкурентами](../tutorial/GiveKeepDifference.md).

Наслідок може використовуватись як заміна функції-`callback` в синхронних чи асинхронних рутинах.

Детальніше з цим можна ознайомитись у туторіалі - [Заміна callback функції на наслідок](../tutorial/ReplacingCallbackByConsequence.md).

**Підсумок**
- `наслідок` це об'єкт синхронізації;
- `наслідок` є контейнером данних - `ресурсів` та `конкурентів` за ресурси;
- `конкурент` це рутина, у яку передається ресурс;
- можна у будь-якому порядку додавати ресурси та конкуренти, проте поведінка наслідку від цього змінюється;
- різні види `конкурентів` по різному поводяться із чергою ресурсів.

[Повернутись до змісту](../README.md#концепції)
